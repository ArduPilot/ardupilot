#!/usr/bin/env python3
"""
LQR Gain Calculator for ArduSub Position Control (12-state system)

This script calculates optimal LQR gains for the full 12-state position controller:
States: [x, y, z, vx, vy, vz, roll, pitch, yaw, p, q, r]
Controls: [Tz, τ_roll, τ_pitch, τ_yaw]

Usage:
    python3 lqr_position_gain_calculator.py --output gains_position.param
"""

import numpy as np
import scipy.linalg
import argparse
import sys

# Default vehicle parameters (BlueROV2 Heavy)
DEFAULT_VEHICLE = {
    'mass': 12.0,              # kg
    'Ixx': 0.15,               # kg·m²
    'Iyy': 0.15,               # kg·m²
    'Izz': 0.25,               # kg·m²
    'Dx': 5.0,                 # N/(m/s) - X-axis damping
    'Dy': 5.0,                 # N/(m/s) - Y-axis damping
    'Dz': 5.0,                 # N/(m/s) - Z-axis damping
    'Drx': 0.5,                # Nm/(rad/s) - Roll damping
    'Dry': 0.5,                # Nm/(rad/s) - Pitch damping
    'Drz': 0.3,                # Nm/(rad/s) - Yaw damping
}

def create_system_matrices(vehicle):
    """
    Create the continuous-time state-space matrices for the underwater vehicle.

    State vector x = [x, y, z, vx, vy, vz, φ, θ, ψ, p, q, r]
    Control vector u = [Tz, τ_roll, τ_pitch, τ_yaw]

    Returns:
        A: 12×12 state matrix
        B: 12×4 control matrix
    """
    m = vehicle['mass']
    Ixx = vehicle['Ixx']
    Iyy = vehicle['Iyy']
    Izz = vehicle['Izz']
    Dx = vehicle['Dx']
    Dy = vehicle['Dy']
    Dz = vehicle['Dz']
    Drx = vehicle['Drx']
    Dry = vehicle['Dry']
    Drz = vehicle['Drz']

    g = 9.81  # m/s²

    # Initialize matrices
    A = np.zeros((12, 12))
    B = np.zeros((12, 4))

    # Position derivatives (ẋ = vx, ẏ = vy, ż = vz)
    A[0, 3] = 1.0  # ẋ = vx
    A[1, 4] = 1.0  # ẏ = vy
    A[2, 5] = 1.0  # ż = vz

    # Velocity derivatives (linearized around hover)
    # v̇x = -Dx*vx/m + g*θ + Fx/m (Fx from attitude, approximated by coupling)
    A[3, 3] = -Dx / m       # Damping
    A[3, 7] = g             # Pitch creates forward acceleration

    # v̇y = -Dy*vy/m - g*φ + Fy/m (Fy from attitude, approximated by coupling)
    A[4, 4] = -Dy / m       # Damping
    A[4, 6] = -g            # Roll creates lateral acceleration

    # v̇z = -Dz*vz/m + Fz/m (vertical thrust control)
    A[5, 5] = -Dz / m       # Damping
    # Vertical thrust is a direct control input (in B matrix)

    # Attitude derivatives (φ̇ = p, θ̇ = q, ψ̇ = r)
    A[6, 9] = 1.0   # φ̇ = p
    A[7, 10] = 1.0  # θ̇ = q
    A[8, 11] = 1.0  # ψ̇ = r

    # Angular rate derivatives (simplified decoupled model)
    # ṗ = -Drx*p/Ixx + τ_roll/Ixx
    A[9, 9] = -Drx / Ixx

    # q̇ = -Dry*q/Iyy + τ_pitch/Iyy
    A[10, 10] = -Dry / Iyy

    # ṙ = -Drz*r/Izz + τ_yaw/Izz
    A[11, 11] = -Drz / Izz

    # Control matrix B
    # Vertical thrust affects vz
    B[5, 0] = 1.0 / m

    # Roll torque affects p
    B[9, 1] = 1.0 / Ixx

    # Pitch torque affects q
    B[10, 2] = 1.0 / Iyy

    # Yaw torque affects r
    B[11, 3] = 1.0 / Izz

    return A, B

def calculate_lqr_gains(A, B, Q, R):
    """
    Calculate LQR gains by solving the continuous-time algebraic Riccati equation.

    Returns:
        K: 4×12 feedback gain matrix
        P: 12×12 solution to the Riccati equation
    """
    # Solve continuous-time algebraic Riccati equation
    try:
        P = scipy.linalg.solve_continuous_are(A, B, Q, R)
    except Exception as e:
        print(f"Error solving Riccati equation: {e}")
        print("Try adjusting Q and R matrices.")
        return None, None

    # Calculate feedback gain K = R^(-1) * B^T * P
    K = np.linalg.inv(R) @ B.T @ P

    return K, P

def discretize_system(A, B, dt):
    """
    Discretize continuous-time system using zero-order hold.

    Returns:
        Ad: Discrete-time state matrix
        Bd: Discrete-time control matrix
    """
    n = A.shape[0]
    m = B.shape[1]

    # Create augmented matrix
    M = np.zeros((n + m, n + m))
    M[:n, :n] = A * dt
    M[:n, n:] = B * dt

    # Matrix exponential
    eMdt = scipy.linalg.expm(M)

    Ad = eMdt[:n, :n]
    Bd = eMdt[:n, n:]

    return Ad, Bd

def generate_param_file(K, vehicle, filename):
    """
    Generate ArduPilot parameter file with calculated gains.
    """
    with open(filename, 'w') as f:
        f.write("# ArduSub State Feedback Position Control Parameters\n")
        f.write("# Generated by lqr_position_gain_calculator.py\n")
        f.write("#\n")
        f.write("# Gain matrix K (4×12):\n")
        f.write("# Row 0: Vertical thrust control\n")
        f.write("# Row 1: Roll torque control\n")
        f.write("# Row 2: Pitch torque control\n")
        f.write("# Row 3: Yaw torque control\n")
        f.write("#\n")
        f.write("# States: [x, y, z, vx, vy, vz, roll, pitch, yaw, p, q, r]\n\n")

        # Enable position control
        f.write("# Enable full position control (SF_ENABLE = 3)\n")
        f.write("SF_ENABLE,3\n\n")

        # Vehicle dynamics parameters
        f.write("# Vehicle dynamics parameters\n")
        f.write(f"SF_P_MASS,{vehicle['mass']:.3f}\n")
        f.write(f"SF_P_DX,{vehicle['Dx']:.3f}\n")
        f.write(f"SF_P_DY,{vehicle['Dy']:.3f}\n")
        f.write(f"SF_P_DZ,{vehicle['Dz']:.3f}\n\n")

        # Also set rate loop dynamics (used when SF_ENABLE < 3)
        f.write("# Rate loop dynamics\n")
        f.write(f"SF_R_IXX,{vehicle['Ixx']:.3f}\n")
        f.write(f"SF_R_IYY,{vehicle['Iyy']:.3f}\n")
        f.write(f"SF_R_IZZ,{vehicle['Izz']:.3f}\n")
        f.write(f"SF_R_DX,{vehicle['Drx']:.3f}\n")
        f.write(f"SF_R_DY,{vehicle['Dry']:.3f}\n")
        f.write(f"SF_R_DZ,{vehicle['Drz']:.3f}\n\n")

        # Gain matrix (stored row-major in parameters)
        f.write("# Gain matrix K (row-major)\n")
        param_idx = 1
        for i in range(4):  # 4 control outputs
            for j in range(12):  # 12 states
                f.write(f"SF_P_K{param_idx},{K[i, j]:.6f}\n")
                param_idx += 1

        f.write("\n# End of parameter file\n")

    print(f"\n✓ Parameter file written to: {filename}")
    print(f"  Total parameters: {48 + 6} (48 gains + 6 dynamics)")

def print_gain_matrix(K):
    """
    Print the gain matrix in a readable format.
    """
    print("\nLQR Gain Matrix K (4×12):")
    print("=" * 100)
    state_names = ['x', 'y', 'z', 'vx', 'vy', 'vz', 'φ', 'θ', 'ψ', 'p', 'q', 'r']
    control_names = ['Tz', 'τ_roll', 'τ_pitch', 'τ_yaw']

    # Print header
    print(f"{'Control':>12s} | ", end='')
    for name in state_names:
        print(f"{name:>8s}", end=' ')
    print()
    print("-" * 100)

    # Print each row
    for i, ctrl_name in enumerate(control_names):
        print(f"{ctrl_name:>12s} | ", end='')
        for j in range(12):
            print(f"{K[i, j]:>8.4f}", end=' ')
        print()
    print("=" * 100)

def analyze_system(A, B, K):
    """
    Analyze closed-loop system stability and performance.
    """
    print("\nSystem Analysis:")
    print("=" * 60)

    # Open-loop eigenvalues
    eig_open = np.linalg.eigvals(A)
    print("\nOpen-loop eigenvalues (A):")
    for i, eig in enumerate(eig_open):
        stability = "STABLE" if eig.real < 0 else "UNSTABLE"
        print(f"  λ{i+1} = {eig.real:>8.4f} + {eig.imag:>8.4f}j  [{stability}]")

    # Closed-loop eigenvalues
    A_cl = A - B @ K
    eig_closed = np.linalg.eigvals(A_cl)
    print("\nClosed-loop eigenvalues (A - BK):")
    max_real = -np.inf
    for i, eig in enumerate(eig_closed):
        stability = "STABLE" if eig.real < 0 else "UNSTABLE"
        print(f"  λ{i+1} = {eig.real:>8.4f} + {eig.imag:>8.4f}j  [{stability}]")
        max_real = max(max_real, eig.real)

    if max_real < 0:
        print("\n✓ Closed-loop system is STABLE")
    else:
        print("\n✗ WARNING: Closed-loop system is UNSTABLE!")
        print("   Adjust Q and R matrices to improve stability.")

    print("=" * 60)

def main():
    parser = argparse.ArgumentParser(description='Calculate LQR gains for ArduSub position control')
    parser.add_argument('--output', '-o', default='gains_position.param',
                       help='Output parameter file (default: gains_position.param)')
    parser.add_argument('--mass', type=float, default=DEFAULT_VEHICLE['mass'],
                       help=f"Vehicle mass in kg (default: {DEFAULT_VEHICLE['mass']})")
    parser.add_argument('--Ixx', type=float, default=DEFAULT_VEHICLE['Ixx'],
                       help=f"Roll inertia in kg·m² (default: {DEFAULT_VEHICLE['Ixx']})")
    parser.add_argument('--Iyy', type=float, default=DEFAULT_VEHICLE['Iyy'],
                       help=f"Pitch inertia in kg·m² (default: {DEFAULT_VEHICLE['Iyy']})")
    parser.add_argument('--Izz', type=float, default=DEFAULT_VEHICLE['Izz'],
                       help=f"Yaw inertia in kg·m² (default: {DEFAULT_VEHICLE['Izz']})")
    parser.add_argument('--dt', type=float, default=0.01,
                       help='Control loop time step in seconds (default: 0.01 = 100Hz)')

    args = parser.parse_args()

    # Vehicle parameters
    vehicle = DEFAULT_VEHICLE.copy()
    vehicle['mass'] = args.mass
    vehicle['Ixx'] = args.Ixx
    vehicle['Iyy'] = args.Iyy
    vehicle['Izz'] = args.Izz

    print("ArduSub LQR Position Controller Gain Calculator")
    print("=" * 60)
    print("\nVehicle Parameters:")
    print(f"  Mass:        {vehicle['mass']:.2f} kg")
    print(f"  Inertia:     Ixx={vehicle['Ixx']:.3f}, Iyy={vehicle['Iyy']:.3f}, Izz={vehicle['Izz']:.3f} kg·m²")
    print(f"  Damping (T): Dx={vehicle['Dx']:.1f}, Dy={vehicle['Dy']:.1f}, Dz={vehicle['Dz']:.1f} N/(m/s)")
    print(f"  Damping (R): Drx={vehicle['Drx']:.2f}, Dry={vehicle['Dry']:.2f}, Drz={vehicle['Drz']:.2f} Nm/(rad/s)")

    # Create system matrices
    print("\nCreating state-space model...")
    A, B = create_system_matrices(vehicle)

    # LQR weight matrices
    # Q: State weights (penalize state deviations)
    # Higher values = tighter control of that state
    Q = np.diag([
        10.0,   # x position (m)
        10.0,   # y position (m)
        10.0,   # z position (m)
        1.0,    # vx velocity (m/s)
        1.0,    # vy velocity (m/s)
        1.0,    # vz velocity (m/s)
        100.0,  # roll angle (rad)
        100.0,  # pitch angle (rad)
        100.0,  # yaw angle (rad)
        10.0,   # p (rad/s)
        10.0,   # q (rad/s)
        10.0,   # r (rad/s)
    ])

    # R: Control effort weights (penalize control usage)
    # Higher values = less aggressive control
    R = np.diag([
        1.0,    # Vertical thrust
        1.0,    # Roll torque
        1.0,    # Pitch torque
        2.0,    # Yaw torque (usually less responsive)
    ])

    print("\nCalculating LQR gains...")
    K, P = calculate_lqr_gains(A, B, Q, R)

    if K is None:
        print("\n✗ Failed to calculate gains. Exiting.")
        return 1

    # Print results
    print_gain_matrix(K)

    # Analyze system
    analyze_system(A, B, K)

    # Generate parameter file
    generate_param_file(K, vehicle, args.output)

    print("\n" + "=" * 60)
    print("Next Steps:")
    print("  1. Load parameters: param load", args.output)
    print("  2. Set SF_ENABLE = 3 to enable position control")
    print("  3. Test in POSHOLD or GUIDED mode")
    print("  4. Tune Q/R matrices if needed for better performance")
    print("=" * 60)

    return 0

if __name__ == '__main__':
    sys.exit(main())
