# encoding: utf-8

# flake8: noqa

"""
Waf tool for RP2350 build
"""

from waflib import Build, ConfigSet, Configure, Context, Task, Utils
from waflib import Errors, Logs
from waflib.TaskGen import before, after_method, before_method, feature
from waflib.Configure import conf
from collections import OrderedDict

import os
import shutil
import sys
import traceback
import re
import pickle
import subprocess
import argparse
import textwrap
from pathlib import Path

import hal_common

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../libraries/AP_HAL_RP/hwdef/scripts'))
import rp_hwdef

# Ensure PICO_SDK_PATH is set in your environment variables before running this script
PICO_SDK_PATH = os.environ.get('PICO_SDK_PATH')
FREERTOS_KERNEL_PATH = os.environ.get('FREERTOS_KERNEL_PATH')

if not PICO_SDK_PATH or not os.path.exists(PICO_SDK_PATH):
    print("Error: The environment variable PICO_SDK_PATH is not set or the path is invalid.")
    print("Please set it, for example:")
    print("export PICO_SDK_PATH=/path/to/your/pico-sdk")
    sys.exit(1)

if not FREERTOS_KERNEL_PATH or not os.path.exists(FREERTOS_KERNEL_PATH):
    print("Error: The environment variable FREERTOS_KERNEL_PATH is not set or the path is invalid.")
    print("Please set it, for example:")
    print("export FREERTOS_KERNEL_PATH=/path/to/your/FreeRTOS-Kernel")
    sys.exit(1)

FREERTOS_KERNEL_CMAKE = os.path.join(FREERTOS_KERNEL_PATH, "portable", "ThirdParty", "GCC", "RP2040", "FreeRTOS_Kernel_import.cmake")
PICO_SDK_IMPORT_CMAKE = os.path.join(PICO_SDK_PATH, "external", "pico_sdk_import.cmake")

def generate_pico_project(env):
    """Generates the Pico project directory structure and files."""

    sources = ["main.c"]
    mcu_name = env.RP_TARGET
    # Validate MCU name to set board variant
    if mcu_name.upper() == 'RP2350A':
        board_variant = 'RP2350A'
        gpio_count = 30
    elif mcu_name.upper() == 'RP2350B':
        board_variant = 'RP2350B'
        gpio_count = 48
    else:
        print(f"Error: Unsupported MCU '{mcu_name}'. Use RP2350A or RP2350B.")
        sys.exit(1)

    project_dir = env.AP_HAL_RP2350
    project_name = "ardupilot"
    # Create project directory
    if os.path.exists(project_dir):
        print(f"Warning: Directory '{project_dir}' already exists.")
        # Optionally prompt user for overwrite or exit
    os.makedirs(project_dir, exist_ok=True)
    os.chdir(project_dir)

    print(f"Creating project '{project_name}' for {mcu_name.upper()} with FreeRTOS support...")

    # Copy necessary CMake support files
    try:
        shutil.copy(PICO_SDK_IMPORT_CMAKE, "pico_sdk_import.cmake")
        shutil.copy(FREERTOS_KERNEL_CMAKE, "FreeRTOS_Kernel_import.cmake")
        print("Copied SDK/FreeRTOS CMake support files.")
    except IOError as e:
        print(f"Fat error copying SDK files: {e}")
        sys.exit(1)

    # Copy and configure FreeRTOSConfig.h (using template from SDK)
    try:
        # The template needs minor edits for a standard Pico LED pin config, 
        # but copying the raw template is usually sufficient for a basic start.
        shutil.copy(env.FREERTOS_CONFIG_H_TEMPLATE, "FreeRTOSConfig.h")
        print("Copied FreeRTOSConfig.h.template as FreeRTOSConfig.h.")
    except IOError as e:
        print(f"Fat error while copying FreeRTOSConfig.h: {e}")
        sys.exit(1)

    # Create placeholder source files and copy user-specified sources
    source_files_cmake_list = []
    for src in sources:
        if os.path.exists(os.path.join("..", src)):
            shutil.copy(os.path.join("..", src), src)
            print(f"Copied source file: {src}")
            source_files_cmake_list.append(src)
        else:
            # If the user specified a name that doesn't exist, create a basic placeholder
            if not os.path.exists(src):
                with open(src, "w") as f:
                    f.write(f"// Placeholder for {src} generated by script\n#include <stdio.h>\n#include \"pico/stdlib.h\"\n\n")
                print(f"Stub file created: {src}")
            source_files_cmake_list.append(src)
            
    # Join source list for CMake file format
    source_list_str = "\n    ".join(source_files_cmake_list)

    # Generate CMakeLists.txt
    with open(env.CMAKE_LISTS_TXT_TEMPLATE, 'r', encoding='utf-8') as f:
        template_content = f.read()

    try:
        cmake_content = template_content.replace("{project_name}", project_name)
        cmake_content = cmake_content.replace("{mcu_name_upper}", mcu_name.upper())
        cmake_content = cmake_content.replace("{source_list_str}", source_list_str)
    except Exception as e:
        print(f"Error formatting CMakeLists.txt: {e}")
        cmake_content = template_content # Fallback

    with open('CMakeLists.txt', 'w', encoding='utf-8') as f:
        f.write(cmake_content)
    print("Generated CMakeLists.txt.")

    # Copy pioasm
    hwdef_dir = os.path.join(env.SRCROOT, 'libraries/AP_HAL_RP/hwdef')
    env.PIOASM = os.path.join(hwdef_dir, env.BOARD, 'pioasm')
    src_pioasm = env.PIOASM
    dst_pioasm = os.path.join(env.AP_HAL_RP2350, 'pioasm')
    if os.path.exists(src_pioasm):
        try:
            if os.path.exists(dst_pioasm):
                shutil.rmtree(dst_pioasm)
            shutil.copytree(src_pioasm, dst_pioasm)
            print(f"Copied pioasm to {dst_pioasm}")
        except Exception as e:
            print(f"Error copying pioasm: {e}")
            sys.exit(1)

    # Generate a basic header file for GPIO defines
    gpio_header_filename = f"{mcu_name.lower()}_gpio_defines.h"
    gpio_header_content = textwrap.dedent(f"""\
        /**
         * @file {gpio_header_filename}
         * @brief Universal GPIO macro definitions for the {mcu_name.upper()}.
         * This file was automatically generated by the project generator script.
         */
        #ifndef {mcu_name.upper()}_GPIO_DEFINES_H
        #define {mcu_name.upper()}_GPIO_DEFINES_H
        // --- Universal GPIO Numbers ---
        """)
    for i in range(gpio_count):
         gpio_header_content += f"#define GPIO_{i:<4} {i}\n"
    gpio_header_content += f"\n\n#{'endif':<7} // {mcu_name.upper()}_GPIO_DEFINES_H\n"
    
    with open(gpio_header_filename, "w") as f:
        f.write(gpio_header_content)
    print(f"Generated GPIO header file: {gpio_header_filename}")
    print(f"\nProject '{project_name}' successfully generated.")

def get_target_mcu(cfg):
    """Read MCU variable from hwdef file."""

    hwdef_file = cfg.srcnode.find_resource(f'libraries/AP_HAL_RP/hwdef/{cfg.variant}/hwdef.dat')
    if not hwdef_file:
        cfg.fatal(f"hwdef.dat not found for board {cfg.variant}")

    target_mcu = None
    with open(hwdef_file.abspath(), 'r') as f:
        for line in f:
            line = line.split('#')[0].strip()
            if line.startswith('MCU '):
                target_mcu = line.split()[1].lower() # getting "rp2350a"
                break

    if not target_mcu:
        cfg.fatal(f"The MCU parameter is not specified in the hwdef.dat file for {cfg.variant}")

    supported_mcus = {"rp2350a", "rp2350b"}
    if target_mcu not in supported_mcus:
        cfg.fatal(f"Unsupported MCU '{target_mcu}' in hwdef.dat. Expected: rp2350a or rp2350b")

    cfg.env.RP_TARGET = target_mcu
    print(f"Board: {cfg.variant}, MCU read from hwdef: {target_mcu.upper()}")
    return target_mcu

def configure(cfg):
    target=get_target_mcu(cfg)

    bldnode = cfg.bldnode.make_node(cfg.variant)
    def srcpath(path):
        return cfg.srcnode.make_node(path).abspath()
    def bldpath(path):
        return bldnode.make_node(path).abspath()

    cfg.env.HAVE_ENDIAN_H = True
    cfg.env.HAVE_BYTESWAP_H = True
    cfg.env.HAVE_MEMRCHR = True

    cfg.env.HAL_OS_POSIX_IO = False
    cfg.define('HAL_OS_POSIX_IO', 0)

    cfg.env.prepend_value('CPPPATH', [
        cfg.srcnode.find_dir('libraries/AP_Common').abspath(),
        cfg.srcnode.find_dir('libraries/AP_HAL').abspath(),
        cfg.srcnode.find_dir('libraries/AP_HAL_RP').abspath(),
    ])
    cfg.env.prepend_value('CPPPATH', [
        cfg.srcnode.find_dir('libraries/AP_Common/missing').abspath()
    ])

    #Load cmake builder and make
    cfg.load('cmake')

    #define env and location for the cmake rp2350 file
    env = cfg.env
    target_dir = 'targets/%s/pico-sdk' % target
    env.AP_HAL_RP2350 = bldpath(target_dir)
    env.FREERTOS_CONFIG_H_TEMPLATE = srcpath('libraries/AP_HAL_RP/template/FreeRTOSConfig.h.template')
    env.CMAKE_LISTS_TXT_TEMPLATE = srcpath('libraries/AP_HAL_RP/template/CMakeLists.txt.template')
    env.PICO_SDK_PREFIX_REL = 'pico-sdk'

    env.RP_TARGET = target
    env.BUILDROOT = bldpath('')
    env.SRCROOT = srcpath('')
    env.APJ_TOOL = srcpath('Tools/scripts/apj_tool.py')

    try:
        generate_pico_project(env)
    except:
        cfg.fatal("Failed to generate Pico C/C++ SDK project")

    try:
        env.PICO_SDK = os.environ['PICO_SDK_PATH']
    except:
        env.PICO_SDK = cfg.srcnode.abspath()+"/modules/pico/pico-sdk"
    print("USING PICO C/C++ SDK:"+str(env.PICO_SDK))

    # build pioasm
    pico_sdk_path = env.PICO_SDK
    pioasm_path = os.path.join(pico_sdk_path, 'tools/pioasm')
    build_path = os.path.join(pioasm_path, 'build')

    if not os.path.exists(os.path.join(build_path, 'pioasm')):
        try:
            os.makedirs(build_path, exist_ok=True)
            subprocess.run(['cmake', '-DPIOASM_VERSION_STRING=1.0', '..'], cwd=build_path)
            subprocess.run(['make', '-j4'], cwd=build_path)
            print("pioasm built")
        except:
            cfg.fatal("Failed to build pioasm")

    try:
        hwdef_obj = generate_hwdef_h(env)
    except Exception:
        traceback.print_exc()
        cfg.fatal("Failed to process hwdef.dat")
    hal_common.process_hwdef_results(cfg, hwdef_obj)

def generate_hwdef_h(env):
    '''run rp_hwdef.py'''
    hwdef_dir = os.path.join(env.SRCROOT, 'libraries/AP_HAL_RP/hwdef')

    if len(env.HWDEF) == 0:
        env.HWDEF = os.path.join(hwdef_dir, env.BOARD, 'hwdef.dat')
    hwdef_out = env.BUILDROOT
    if not os.path.exists(hwdef_out):
        os.mkdir(hwdef_out)
    hwdef = [env.HWDEF]
    if env.HWDEF_EXTRA:
        hwdef.append(env.HWDEF_EXTRA)

    hwdef_obj = rp_hwdef.RP2350HWDef(
        outdir=hwdef_out,
        hwdef=hwdef,
        quiet=False,
    )
    hwdef_obj.run()

    return hwdef_obj

def pre_build(self):
    """Configure Pico C/C++ SDK as lib target"""
    lib_vars = OrderedDict()
    lib_vars['ARDUPILOT_CMD'] = self.cmd
    lib_vars['WAF_BUILD_TARGET'] = self.targets
    lib_vars['ARDUPILOT_LIB'] = self.bldnode.find_or_declare('lib/').abspath()
    lib_vars['ARDUPILOT_BIN'] = self.bldnode.find_or_declare('lib/bin').abspath()
    lib_vars['PICO_SDK_PATH'] = self.env.PICO_SDK
    target = self.env.RP_TARGET

    relative_path = 'targets/%s/pico-sdk' % target
    cmake_node = self.bldnode.make_node(relative_path)
    cmake_node.mkdir()

    pico_sdk = self.cmake(
            name='pico-sdk',
            cmake_vars=lib_vars,
            cmake_src=cmake_node,
            cmake_bld='pico-sdk_build',
            )

    pico_sdk_showinc = pico_sdk.build('showinc', target='pico-sdk_build/includes.list')
    pico_sdk_showinc.post()

    from waflib import Task
    class load_generated_includes(Task.Task):
        """After includes.list generated include it in env"""
        always_run = True
        def run(tsk):
            bld = tsk.generator.bld
            includes = bld.bldnode.find_or_declare('pico-sdk_build/includes.list').read().split()
            #print(includes)
            bld.env.prepend_value('INCLUDES', includes)

    tsk = load_generated_includes(env=self.env)
    tsk.set_inputs(self.path.find_resource('pico-sdk_build/includes.list'))
    self.add_to_group(tsk)
