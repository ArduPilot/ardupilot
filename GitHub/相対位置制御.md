# ArduCopter 相対位置制御システム

## 座標系について

### NEU座標系 (North-East-Up)
- **N (North)**: 北方向を正とする
- **E (East)**: 東方向を正とする  
- **U (Up)**: 上方向（天頂方向）を正とする
- ArduCopterの内部処理で主に使用される座標系
- 高度が正の値で上昇を表現

### NED座標系 (North-East-Down)
- **N (North)**: 北方向を正とする
- **E (East)**: 東方向を正とする
- **D (Down)**: 下方向を正とする
- 航空業界で一般的に使用される座標系
- MAVLinkプロトコルでも使用
- 高度が負の値で上昇を表現

### 座標系変換
```cpp
// NED → NEU変換
Vector3f ned_to_neu(const Vector3f& ned) {
    return Vector3f(ned.x, ned.y, -ned.z);
}

// NEU → NED変換  
Vector3f neu_to_ned(const Vector3f& neu) {
    return Vector3f(neu.x, neu.y, -neu.z);
}
```

## 非GPS環境下での相対位置制御

### 概要
ArduCopterでは、GPS無しでも以下のセンサーを使用して相対位置制御が可能：
- 光学フローセンサー (Optical Flow)
- ビジュアルオドメトリ (Visual Odometry)
- デッドレコニング (Dead Reckoning)
- レンジファインダー（高度制御）

### 主要ライブラリとファイル

#### 1. AC_WPNav (Waypoint Navigation)
**ファイル**: `libraries/AC_WPNav/AC_WPNav.cpp`, `libraries/AC_WPNav/AC_WPNav.h`

**主要関数**:
```cpp
// EKF原点からの相対位置（cm）で目標設定
bool set_wp_destination_NEU_cm(const Vector3f& destination_neu_cm, bool terrain_alt = false);

// NED座標系での相対位置設定
bool set_wp_destination_NED_cm(const Vector3f& destination_NED_cm);

// Location クラスでの目標設定
bool set_wp_destination_loc(const Location& destination);

// 次の目標点も同時設定（スムーズなコーナリング用）
bool set_wp_destination_next_NEU_cm(const Vector3f& destination_neu_cm, bool terrain_alt = false);
```

#### 2. AC_PosControl (Position Control)
**ファイル**: `libraries/AC_AttitudeControl/AC_PosControl.cpp`, `libraries/AC_AttitudeControl/AC_PosControl.h`

**主要関数**:
```cpp
// 位置、速度、加速度の同時設定
void set_pos_vel_accel_NEU_cm(const Vector3p& pos_neu_cm, const Vector3f& vel_neu_cms, const Vector3f& accel_neu_cmss);

// 水平面での位置・速度・加速度制御
void input_pos_vel_accel_NE_cm(Vector2p& pos_ne_cm, Vector2f& vel_ne_cms, const Vector2f& accel_ne_cmss, bool limit_output = true);

// 現在位置の取得
const Vector3p& get_pos_estimate_NEU_cm() const;

// 停止点の計算
void get_stopping_point_NE_cm(Vector2p &stopping_point_neu_cm) const;
```

#### 3. ModeGuided (Guidedモード)
**ファイル**: `ArduCopter/mode_guided.cpp`, `ArduCopter/mode_guided.h`

**主要関数**:
```cpp
// 相対位置での目標設定
bool set_destination(const Vector3f& destination, bool use_yaw = false, float yaw_cd = 0.0, 
                    bool use_yaw_rate = false, float yaw_rate_cds = 0.0, bool yaw_relative = false, bool terrain_alt = false);

// 位置と速度の同時設定
bool set_destination_posvel(const Vector3f& destination, const Vector3f& velocity, bool use_yaw = false, float yaw_cd = 0.0, 
                           bool use_yaw_rate = false, float yaw_rate_cds = 0.0, bool yaw_relative = false);

// 位置、速度、加速度の同時設定
bool set_destination_posvelaccel(const Vector3f& destination, const Vector3f& velocity, const Vector3f& acceleration, 
                                bool use_yaw = false, float yaw_cd = 0.0, bool use_yaw_rate = false, float yaw_rate_cds = 0.0, bool yaw_relative = false);
```

## VIO/LIO対応の相対位置制御モード

### 1. FlowHold モード
**ファイル**: `ArduCopter/mode_flowhold.cpp`, `ArduCopter/mode_flowhold.h`

**概要**: 光学フローセンサーを使用した位置保持モード。レンジファインダー無しでも動作可能。

**特徴**:
- GPS不要の相対位置制御
- 光学フローセンサーによる水平位置推定
- 高度推定は慣性航法とフロー情報を組み合わせ
- 地面のテクスチャに依存

**主要パラメータ**:
```cpp
// FlowHoldモードのパラメータ
FHLD_XY_P        // 水平位置制御のP gain
FHLD_XY_I        // 水平位置制御のI gain  
FHLD_FLOW_MAX    // 最大フロー率制限
FHLD_FILT_HZ     // フローデータのフィルタ周波数
FHLD_QUAL_MIN    // 最小フロー品質閾値
FHLD_BRAKE_RATE  // スティック離し時の減速率
```

**動作原理**:
```cpp
void ModeFlowHold::flowhold_flow_to_angle(Vector2f &bf_angles, bool stick_input) {
    // 光学フローレートを取得
    Vector2f raw_flow = copter.optflow.flowRate() - copter.optflow.bodyRate();
    
    // 高度で補正してm/s単位に変換
    Vector2f sensor_flow = flow_filter.apply(raw_flow);
    sensor_flow *= constrain_float(height_estimate, height_min, height_max);
    
    // 地球座標系に変換
    Vector2f input_ef = copter.ahrs.body_to_earth2D(sensor_flow);
    
    // PI制御器で目標角度計算
    flow_pi_xy.set_input(input_ef);
    Vector2f ef_output = flow_pi_xy.get_pi();
    
    // 機体座標系に変換
    bf_angles += copter.ahrs.earth_to_body2D(ef_output);
}
```

### 2. VIO (Visual Inertial Odometry) 対応

#### AP_VisualOdom ライブラリ
**ファイル**: `libraries/AP_VisualOdom/AP_VisualOdom.cpp`, `libraries/AP_VisualOdom/AP_VisualOdom.h`

**対応センサー**:
```cpp
enum class VisualOdom_Type {
    None         = 0,
    MAV          = 1,  // MAVLink経由のVIO
    IntelT265    = 2,  // Intel RealSense T265
    VOXL         = 3,  // ModalAI VOXL
};
```

**設定パラメータ**:
```cpp
VISO_TYPE = 1    // MAVLink VIO
VISO_TYPE = 2    // Intel RealSense T265  
VISO_TYPE = 3    // ModalAI VOXL
```

#### Intel RealSense T265 対応
**ファイル**: `libraries/AP_VisualOdom/AP_VisualOdom_IntelT265.cpp`

**機能**:
- 6DOF位置・姿勢推定
- 速度推定
- リセットカウンター対応
- AHRS/EKFとの位置・姿勢アライメント

```cpp
void AP_VisualOdom_IntelT265::handle_pose_estimate(uint64_t remote_time_us, uint32_t time_ms, 
                                                   float x, float y, float z, const Quaternion &attitude, 
                                                   float posErr, float angErr, uint8_t reset_counter, int8_t quality) {
    // スケール補正
    const float scale_factor = _frontend.get_pos_scale();
    Vector3f pos{x * scale_factor, y * scale_factor, z * scale_factor};
    
    // 姿勢・位置の回転補正
    rotate_and_correct_position(pos);
    rotate_attitude(att);
    
    // EKFに送信
    if (consume) {
        AP::ahrs().writeExtNavData(pos, att, posErr, angErr, time_ms, 
                                  _frontend.get_delay_ms(), get_reset_timestamp_ms(reset_counter));
    }
}
```

#### ModalAI VOXL 対応
**設定**: `VISO_TYPE = 3`
- ODOMETRY MAVLinkメッセージを使用
- 非GPS環境での自律飛行対応
- 位置・速度・姿勢の統合推定

### 3. EKF統合による相対位置制御

#### EKF2/EKF3での相対位置推定
**ファイル**: `libraries/AP_NavEKF2/AP_NavEKF2_Control.cpp`, `libraries/AP_NavEKF3/AP_NavEKF3_Control.cpp`

**動作モード**:
```cpp
enum AidingMode {
    AID_NONE,      // 支援無し（IMUのみ）
    AID_RELATIVE,  // 相対位置支援（フロー、VIO等）
    AID_ABSOLUTE   // 絶対位置支援（GPS等）
};
```

**相対位置モードの条件**:
```cpp
// EKF3での相対位置モード判定
bool NavEKF3_core::readyToUseOptFlow() const {
    return (optFlowDataPresent() && 
            (frontend->_flowUse == FLOW_USE_NAV) && 
            filterIsStable);
}

bool NavEKF3_core::readyToUseBodyOdm() const {
    return (bodyOdmDataPresent() && filterIsStable);
}
```

**モード遷移**:
```cpp
switch (PV_AidingMode) {
    case AID_NONE:
        if (readyToUseGPS() || readyToUseRangeBeacon() || readyToUseExtNav()) {
            PV_AidingMode = AID_ABSOLUTE;
        } else if (readyToUseOptFlow() || readyToUseBodyOdm()) {
            PV_AidingMode = AID_RELATIVE;  // 相対位置モードに移行
        }
        break;
        
    case AID_RELATIVE:
        // フロー/VIOタイムアウト時はAID_NONEに戻る
        if (flowFusionTimeout && bodyOdmFusionTimeout) {
            PV_AidingMode = AID_NONE;
        }
        break;
}
```

### 4. 各モードからの使用例

#### mode_auto.cpp での使用例
```cpp
void ModeAuto::wp_run() {
    // 相対位置目標の設定
    Vector3f relative_pos_cm(100.0f, 200.0f, -50.0f); // North 1m, East 2m, Up 0.5m
    bool terrain_alt = false; // EKF原点からの相対高度
    
    // WPNavを使用
    wp_nav->set_wp_destination_NEU_cm(relative_pos_cm, terrain_alt);
    
    // 制御更新
    wp_nav->update_wpnav();
    pos_control->update_NE_controller();
    pos_control->update_U_controller();
}
```

#### mode_guided.cpp での使用例
```cpp
bool ModeGuided::set_relative_destination(const Vector3f& offset_neu_m) {
    // 現在位置を取得
    Vector3f current_pos_neu_cm;
    if (!AP::ahrs().get_relative_position_NED_origin_float(current_pos_neu_cm)) {
        return false;
    }
    
    // オフセットを加算（mからcmに変換）
    Vector3f target_pos_neu_cm = current_pos_neu_cm + (offset_neu_m * 100.0f);
    
    // 目標設定
    return set_destination(target_pos_neu_cm);
}
```

### 相対位置取得関数

#### AHRS (Attitude and Heading Reference System)
**ファイル**: `libraries/AP_AHRS/AP_AHRS.cpp`

```cpp
// EKF原点からの相対位置取得（NEU座標系）
bool get_relative_position_NED_origin(Vector3p &vec) const;
bool get_relative_position_NED_origin_float(Vector3f &vec) const;

// 水平面のみの相対位置取得
bool get_relative_position_NE_origin(Vector2p &posNE) const;
bool get_relative_position_NE_origin_float(Vector2f &posNE) const;

// 高度のみの相対位置取得
bool get_relative_position_D_origin(postype_t &posD) const;
bool get_relative_position_D_origin_float(float &posD) const;

// ホーム位置からの相対位置取得
bool get_relative_position_NED_home(Vector3f &vec) const;
bool get_relative_position_NE_home(Vector2f &posNE) const;
```

### 動作条件と要件

#### 必要条件
1. **EKF（Extended Kalman Filter）が有効**
   - EKF2またはEKF3が動作していること
   - `AHRS_EKF_TYPE` パラメータで設定

2. **相対位置推定が可能**
   - 光学フローセンサー: `FLOW_TYPE` パラメータで有効化
   - ビジュアルオドメトリ: `VISO_TYPE` パラメータで設定
   - デッドレコニング: 一時的な位置推定

3. **センサー健全性**
   - IMU（慣性測定装置）が正常動作
   - 気圧計による高度推定
   - 必要に応じてレンジファインダー

#### 制限事項
- GPS無しでは絶対位置は不明
- 時間経過とともに位置誤差が蓄積
- 光学フローは地面のテクスチャに依存
- 屋内環境では磁気コンパスの精度低下

### EKFの位置推定階層

```cpp
// ArduCopter/system.cpp より
bool Copter::ekf_has_relative_position() const {
    // EKFが使用可能かチェック
    if (!ahrs.have_inertial_nav()) {
        return false;
    }
    
    // 有効なセンサーがあるかチェック
    bool enabled = false;
    #if AP_OPTICALFLOW_ENABLED
    if (optflow.enabled()) {
        enabled = true;
    }
    #endif
    #if HAL_VISUALODOM_ENABLED
    if (visual_odom.enabled()) {
        enabled = true;
    }
    #endif
    if (dead_reckoning.active && !dead_reckoning.timeout) {
        enabled = true;
    }
    
    return enabled && ahrs.has_status(AP_AHRS::Status::HORIZ_POS_REL);
}
```

### VIO/LIO設定例

#### Intel RealSense T265設定
```cpp
// パラメータ設定例
VISO_TYPE = 2           // Intel T265を選択
VISO_POS_X = 0.05       // カメラのX軸オフセット（m）
VISO_POS_Y = 0.0        // カメラのY軸オフセット（m）  
VISO_POS_Z = -0.02      // カメラのZ軸オフセット（m）
VISO_ORIENT = 0         // カメラの向き
VISO_SCALE = 1.0        // 位置スケール補正
VISO_DELAY_MS = 30      // センサー遅延（ms）

// EKF3設定
EK3_SRC1_POSXY = 6      // 水平位置ソースをVIOに設定
EK3_SRC1_VELXY = 6      // 水平速度ソースをVIOに設定  
EK3_SRC1_POSZ = 6       // 垂直位置ソースをVIOに設定
EK3_SRC1_VELZ = 6       // 垂直速度ソースをVIOに設定
```

#### ModalAI VOXL設定
```cpp
// パラメータ設定例
VISO_TYPE = 3           // VOXL VIOを選択
SERIAL5_PROTOCOL = 1    // MAVLink v1
SERIAL5_BAUD = 921600   // 通信速度

// EKF3設定（T265と同様）
EK3_SRC1_POSXY = 6
EK3_SRC1_VELXY = 6
EK3_SRC1_POSZ = 6  
EK3_SRC1_VELZ = 6
```

### 実装時の注意点

1. **単位の統一**
   - 位置: cm単位
   - 速度: cm/s単位
   - 加速度: cm/s²単位

2. **座標系の確認**
   - 内部処理はNEU座標系
   - 外部インターフェースはNED座標系の場合もあり

3. **エラーハンドリング**
   - 位置推定の有効性チェック
   - センサー故障時のフォールバック

4. **パフォーマンス**
   - 制御ループは通常100Hz以上で実行
   - 重い計算は適切な頻度で実行

### スクリプティングでの使用

```cpp
// ArduCopter/Copter.cpp より（スクリプト用API）
bool Copter::set_target_pos_NED(const Vector3f& target_pos, bool use_yaw, float yaw_deg, 
                                bool use_yaw_rate, float yaw_rate_degs, bool yaw_relative, bool terrain_alt) {
    if (!flightmode->in_guided_mode()) {
        return false;
    }
    
    // NED → NEU変換（mからcmへ）
    const Vector3f pos_neu_cm(target_pos.x * 100.0f, target_pos.y * 100.0f, -target_pos.z * 100.0f);
    
    return mode_guided.set_destination(pos_neu_cm, use_yaw, yaw_deg * 100.0, use_yaw_rate, 
                                      yaw_rate_degs * 100.0, yaw_relative, terrain_alt);
}
```

## LIO (Lidar Inertial Odometry) について

現在のArduCopterコードベースでは、専用のLIOモードは実装されていませんが、以下の方法でLidar情報を活用できます：

### 1. レンジファインダーとの組み合わせ
- 高度制御にLidarレンジファインダーを使用
- 水平位置制御は光学フローやVIOと組み合わせ

### 2. 外部LIOシステムとの連携
- 外部コンピューターでLIO処理を実行
- MAVLinkのODOMETRYメッセージで位置・速度情報を送信
- `VISO_TYPE = 1`（MAVLink VIO）として受信

### 3. 将来の拡張可能性
- AP_VisualOdomライブラリの拡張でLIO対応可能
- 新しいVISO_TYPEとしてLIOセンサー追加の余地あり

この相対位置制御システムにより、ArduCopterはGPS無しでも安定した自律飛行が可能になっています。
