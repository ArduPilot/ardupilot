cmake_minimum_required(VERSION 3.13...3.27)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)


#set(CMAKE_TOOLCHAIN_FILE $ENV{IDF_PATH}/tools/cmake/toolchain-esp32.cmake CACHE STRING "")

#set(FREERTOS_KERNEL_PATH "../../")

set(PICO_SDK_FETCH_FROM_GIT TRUE)
set(PICO_PLATFORM "rp2350")

#set(PICO_BOARD "pimoroni_tiny2350")
set(PICO_BOARD "pimoroni_pico_plus2_rp2350")
#set(PICO_BOARD "pico2")

# set(PICO_CXX_ENABLE_NEW_DELETE 0)  # prevents new_delete.cpp
set(PICO_CXX_ENABLE_EXCEPTIONS 0)
set(PICO_CXX_ENABLE_RTTI 0)
# # fixme disable wrap malloc
# set(PICO_CXX_ENABLE_MALLOC 0)
set(PICO_CXX_DISABLE_ALLOCATION_OVERRIDES 1)


# PICO_SDK_PATH can be set to the path to the pico-sdk
include(pico_sdk_import.cmake)


project(ardupilot)

# Include for ESP-IDF build system functions
#include($ENV{IDF_PATH}/tools/cmake/idf.cmake)
include(FetchContent)

add_library(freertos_config INTERFACE)

target_include_directories(freertos_config SYSTEM
    INTERFACE include
)

# FetchContent_Declare( freertos_kernel
#   GIT_REPOSITORY https://github.com/raspberrypi/FreeRTOS-Kernel.git
#   GIT_TAG        main #Note: Best practice to use specific git-hash or tagged version
# )

# mostly following this
# https://github.com/raspberrypi/pico-sdk/issues/1659#issuecomment-2886559548
# FIXME - now its updated
FetchContent_Populate(freertos_kernel
    GIT_REPOSITORY     "https://github.com/FreeRTOS/FreeRTOS-Kernel.git"
    GIT_TAG            "V11.2.0"
)
set(FREERTOS_KERNEL_PATH "${CMAKE_CURRENT_BINARY_DIR}/freertos_kernel-src" CACHE STRING "FreeRTOS Location" FORCE)

add_subdirectory(
    ${FREERTOS_KERNEL_PATH}/portable/ThirdParty/Community-Supported-Ports/GCC/RP2350_ARM_NTZ
    ${CMAKE_BINARY_DIR}/freertos_kernel-build
)


pico_sdk_init()




target_compile_definitions(freertos_config
  INTERFACE
    projCOVERAGE_TEST=0
)

# In case you installed FreeRTOS-Kernel as a submodule, you will have to add it as a subdirectory:
# add_subdirectory(${FREERTOS_PATH})


# set( FREERTOS_HEAP "4" CACHE STRING "" FORCE)
# # Select the native compile PORT
# # RP2350_ARM_NTZ
# # GCC_RP2040 -> RP2350_ARM_NTZ
# set( FREERTOS_PORT "GCC_RP2040" CACHE STRING "" FORCE)
# # Select the cross-compile PORT
# if (CMAKE_CROSSCOMPILING)
#     # GCC_ARM_CA9 -> GCC_RP2350_ARM_NTZ
#   set(FREERTOS_PORT "GCC_RP2040" CACHE STRING "" FORCE)
#   set(FREERTOS_KERNEL_PORT "ThirdParty_GCC_RP2350_ARM_NTZ" CACHE STRING "" FORCE)
# endif()

#FetchContent_MakeAvailable(freertos_kernel)

# In case of cross compilation, you should also add the following to freertos_config:
#target_compile_definitions(freertos_config INTERFACE ${definitions})
# target_compile_options(freertos_config INTERFACE ${options})






# Create idf::esp32 and idf::freertos static libraries
#idf_build_process(esp32
    # try and trim the build; additional components
    # will be included as needed based on dependency tree
    #
    # although esptool_py does not generate static library,
    # processing the component is needed for flashing related
    # targets and file generation
    # COMPONENTS  freertos
    #             fatfs
    #             nvs_flash
    #             #esptool_py
    #             app_update
    #             #esp_adc
    #             #esp_driver_mcpwm
    #             driver
    #             lwip

    # treat sdkconfig as build product generated by the defaults
#    SDKCONFIG ${CMAKE_BINARY_DIR}/sdkconfig
#    SDKCONFIG_DEFAULTS ${CMAKE_CURRENT_LIST_DIR}/sdkconfig.defaults
#    BUILD_DIR ${CMAKE_BINARY_DIR})

set(elf_file ardupilot)


add_executable(${elf_file} main.c)

# just compile
#target_compile_definitions(${elf_file}  __RAMFUNC__=)

# target_compile_definitions(${elf_file} PRIVATE
#   AP_FILESYSTEM_ENABLED=0
#   AP_SCRIPTING_ENABLED=0
#   #AP_LOGGING_ENABLED=0
# )

target_compile_definitions(${elf_file} PUBLIC
    CYW43_LWIP=0
    WANT_HCI_DUMP=1
    AP_FILESYSTEM_ENABLED=0
  AP_SCRIPTING_ENABLED=0
)

# enable stdout (printf) via USB serial
pico_enable_stdio_usb(${elf_file} 1)

# enable stdout (printf) via UART
pico_enable_stdio_uart(${elf_file}  0)

pico_add_extra_outputs(${elf_file})



# or place in RAM (if you have that section in your linker script)
# target_compile_definitions(${elf_file} PRIVATE __RAMFUNC__=__attribute__\(\(section\(\".time_critical\"\)\)\))


if(NOT DEFINED ARDUPILOT_CMD)
    set(ARDUPILOT_CMD "none")
endif()

message("ARDUPILOT_CMD=${ARDUPILOT_CMD}")
message("WAF_BUILD_TARGET=${WAF_BUILD_TARGET}")

string(REGEX MATCH "^(examples|tool)/" IS_EXAMPLE "${WAF_BUILD_TARGET}")

if (IS_EXAMPLE)
    string(REPLACE "/" ";" A ${WAF_BUILD_TARGET})
    list(GET A 0 EXAMPLE_BASE)
    list(GET A 1 EXAMPLE_NAME)
    message("Building ${EXAMPLE_BASE} ${EXAMPLE_NAME}")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/${EXAMPLE_BASE}/lib${EXAMPLE_NAME}.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libap.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "plane")
    message("Building for plane")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libarduplane.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduPlane_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "copter")
    message("Building for copter")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libarducopter.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduCopter_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "rover")
    message("Building for rover")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libardurover.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libRover_libs.a")
ELSEIF(${ARDUPILOT_CMD} STREQUAL "sub")
    message("Building for submarine")
    target_link_libraries(${elf_file} "${ARDUPILOT_BIN}/libardusub.a")
    target_link_libraries(${elf_file} "${ARDUPILOT_LIB}/libArduSub_libs.a")
ENDIF()

target_link_libraries(${elf_file}  
  #freertos_kernel
  freertos_config
  pico_stdlib
  FreeRTOS-Kernel
  FreeRTOS-Kernel-Heap4
  hardware_pwm
  #hardware_usb
  hardware_uart
  hardware_clocks
  pico_runtime
  )

#   target_link_libraries(${elf_file}
#     #PRIVATE
#     FreeRTOS-Kernel-Heap4
#     #freertos_kernel
#     FreeRTOS-Kernel
#     freertos_config
#     pico_stdlib_headers         # headers only; no new/delete, no malloc.c
#     hardware_sync
#     hardware_gpio
#     hardware_timer
#     hardware_uart
#     hardware_clocks
#     pico_platform
#     pico_runtime
# )


add_custom_target(showinc ALL
        COMMAND echo -e
        "$<TARGET_PROPERTY:${elf_file},INCLUDE_DIRECTORIES>"
        > includes.list
    VERBATIM
    BYPRODUCTS includes.list
    COMMAND_EXPAND_LISTS
)

#Find files name lib to link
#function(SUBLINK target curdir)
#  FILE(GLOB children RELATIVE ${curdir} ${curdir}/*)
#  FOREACH(child ${children})
#    IF(NOT IS_DIRECTORY ${curdir}/${child})
#      SET(PATH "${curdir}/${child}")
#      message("Linking ${PATH}")
#      target_link_libraries(${target} "${PATH}")
#    ENDIF()
#  ENDFOREACH()
#endfunction()

#IF (DEFINED ARDUPILOT_BIN)
#    SUBLINK(${elf_file} ${ARDUPILOT_BIN})
#ENDIF()
#IF (DEFINED ARDUPILOT_LIB)
#    SUBLINK(${elf_file} ${ARDUPILOT_LIB})
#ENDIF()

# Link the static libraries to the executable
# FIXME !!!

# Link your firmware/library target to FreeRTOS so its headers are visible

# target_link_libraries(${elf_file}
#                 idf::freertos
#                 idf::fatfs
#                 idf::nvs_flash
#                 idf::spi_flash
#                 idf::app_update
#                 idf::esp_adc
#                 idf::esp_driver_mcpwm
#                 idf::driver
#                 idf::lwip
#                 idf::esp_wifi
#                 idf::esp_system
#                 idf::esp_rom
#                 idf::esp_timer
#                 )

# Attach additional targets to the executable file for flashing,
# linker script generation, partition_table generation, etc.
# FIXME !!!
#idf_build_executable(${elf_file})

# wrap malloc to ensure memory is zeroed
target_link_options(${elf_file} PRIVATE "-Wl,--wrap,malloc")

set(CMAKE_EXPORT_COMPILE_COMMANDS 1)

# Additional targets for measuring RAM use: size, size-components, size-files
#   - Adapted from ${IDF_PATH}/tools/cmake/project.cmake
#
# Reference:
#   - https://docs.espressif.com/projects/esp-idf/en/v5.0/esp32s3/api-guides/performance/size.html#minimizing-binary-size
#
# Usage:
#   cd ./build/esp32s3xxx/esp-idf_build
#   ninja -v -v size
#
set(mapfile "${CMAKE_BINARY_DIR}/${CMAKE_PROJECT_NAME}.map")
# Add cross-reference table to the map file
target_link_options(${elf_file} PRIVATE "-Wl,--cref")
# Add this symbol as a hint for esp_idf_size to guess the target name
target_link_options(${elf_file} PRIVATE "-Wl,--defsym=IDF_TARGET_${idf_target}=0")
# Enable map file output
target_link_options(${elf_file} PRIVATE "-Wl,--Map=${mapfile}")
# Check if linker supports --no-warn-rwx-segments
execute_process(COMMAND ${CMAKE_LINKER} "--no-warn-rwx-segments" "--version"
    RESULT_VARIABLE result
    OUTPUT_QUIET
    ERROR_QUIET)
if(${result} EQUAL 0)
    # Do not print RWX segment warnings
    target_link_options(${elf_file} PRIVATE "-Wl,--no-warn-rwx-segments")
endif()
if(CONFIG_ESP_ORPHAN_SECTION_WARNING)
    # Print warnings if orphan sections are found
    target_link_options(${elf_file} PRIVATE "-Wl,--orphan-handling=warn")
endif()

# FIXME
#idf_build_get_property(idf_path IDF_PATH)
#idf_build_get_property(python PYTHON)

set(idf_size ${python} -m esp_idf_size)

# Add size targets, depend on map file, run esp_idf_size
# OUTPUT_JSON is passed for compatibility reasons, SIZE_OUTPUT_FORMAT
# environment variable is recommended and has higher priority
add_custom_target(size
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)

add_custom_target(size-files
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "IDF_SIZE_MODE=--files"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)

add_custom_target(size-components
    COMMAND ${CMAKE_COMMAND}
    -D "IDF_SIZE_TOOL=${idf_size}"
    -D "IDF_SIZE_MODE=--archives"
    -D "MAP_FILE=${mapfile}"
    -D "OUTPUT_JSON=${OUTPUT_JSON}"
    -P "${idf_path}/tools/cmake/run_size_tool.cmake"
    DEPENDS ${mapfile}
    USES_TERMINAL
    VERBATIM
)
