Directory structure:
└── AP_Scripting/
    ├── README.md
    ├── wscript
    ├── ai/
    │   ├── README.md
    │   ├── AI_GIT_FORMAT_PATCH_PLAYBOOK.md
    │   ├── AI_PAIR_PROGRAMMING_PLAYBOOK.md
    │   └── AI_VEHICLE_CONTROL_PLAYBOOK.md
    ├── applets/
    │   ├── README.md
    │   ├── BattEstimate.lua
    │   ├── BattEstimate.md
    │   ├── BatteryTag.lua
    │   ├── BatteryTag.md
    │   ├── Gimbal_Camera_Mode.lua
    │   ├── Gimbal_Camera_Mode.md
    │   ├── Heli_IM_COL_Tune.lua
    │   ├── Heli_IM_Col_Tune.md
    │   ├── Heli_idle_control.lua
    │   ├── Heli_idle_control.md
    │   ├── Hexsoon LEDs.lua
    │   ├── Hexsoon LEDs.md
    │   ├── MissionSelector.lua
    │   ├── MissionSelector.md
    │   ├── ONVIF_Camera_Control.lua
    │   ├── ONVIF_Camera_Control.md
    │   ├── Param_Controller.lua
    │   ├── Param_Controller.md
    │   ├── QuadPlane_Low_Alt_FW_mode_prevention.lua
    │   ├── QuadPlane_Low_Alt_FW_mode_prevention.md
    │   ├── RockBlock.lua
    │   ├── RockBlock.md
    │   ├── Script_Controller.lua
    │   ├── Script_Controller.md
    │   ├── SmartAudio.lua
    │   ├── SmartAudio.md
    │   ├── UniversalAutoLand.lua
    │   ├── UniversalAutoLand.md
    │   ├── VTOL-quicktune.lua
    │   ├── VTOL-quicktune.md
    │   ├── advance-wp.lua
    │   ├── advance-wp.md
    │   ├── ahrs-set-origin.lua
    │   ├── ahrs-set-origin.md
    │   ├── ahrs-source-extnav-optflow.lua
    │   ├── ahrs-source-extnav-optflow.md
    │   ├── camera-change-setting.lua
    │   ├── camera-change-settings.md
    │   ├── copter-deadreckon-home.lua
    │   ├── copter-deadreckon-home.md
    │   ├── copter-slung-payload.lua
    │   ├── copter-slung-payload.md
    │   ├── copter_box_pattern.lua
    │   ├── copter_box_pattern.md
    │   ├── copter_terrain_brake.lua
    │   ├── copter_terrain_brake.md
    │   ├── crsf-calibrate.lua
    │   ├── crsf-calibrate.md
    │   ├── figure-eight.lua
    │   ├── figure-eight.md
    │   ├── flip_on_a_switch.lua
    │   ├── flip_on_a_switch.md
    │   ├── follow-target-send.lua
    │   ├── follow-target-send.md
    │   ├── forward_flight_motor_shutdown.lua
    │   ├── forward_flight_motor_shutdown.md
    │   ├── leds_on_a_switch.lua
    │   ├── leds_on_a_switch.md
    │   ├── motor_failure_test.lua
    │   ├── motor_failure_test.md
    │   ├── mount-poi.lua
    │   ├── mount-poi.md
    │   ├── net_webserver.lua
    │   ├── net_webserver.md
    │   ├── param-set.lua
    │   ├── param-set.md
    │   ├── pelco_d_antennatracker.lua
    │   ├── pelco_d_antennatracker.md
    │   ├── plane_package_place.lua
    │   ├── plane_package_place.md
    │   ├── plane_precland.lua
    │   ├── plane_precland.md
    │   ├── plane_ship_landing.lua
    │   ├── repl.lua
    │   ├── repl.md
    │   ├── revert_param.lua
    │   ├── revert_param.md
    │   ├── rover-quicktune.lua
    │   ├── rover-quicktune.md
    │   ├── runcam_on_arm.lua
    │   ├── runcam_on_arm.md
    │   ├── video-stream-information.lua
    │   ├── video-stream-information.md
    │   ├── winch-control.lua
    │   ├── winch-control.md
    │   ├── x-quad-cg-allocation.lua
    │   ├── x-quad-cg-allocation.md
    │   ├── Aerobatics/
    │   │   └── FixedWing/
    │   │       ├── README.md
    │   │       ├── dual_log.py
    │   │       ├── dual_plane.sh
    │   │       ├── plane_aerobatics.lua
    │   │       ├── view_paths.py
    │   │       ├── RateBased/
    │   │       │   ├── README.md
    │   │       │   └── sport_aerobatics.lua
    │   │       └── Schedules/
    │   │           └── README.md
    │   └── WebExamples/
    │       ├── test.lua
    │       └── test.shtml
    ├── docs/
    │   └── docs.lua
    ├── drivers/
    │   ├── BattMon_ANX.lua
    │   ├── BattMon_ANX.md
    │   ├── EFI_DLA.lua
    │   ├── EFI_DLA.md
    │   ├── EFI_HFE.lua
    │   ├── EFI_HFE.md
    │   ├── EFI_Halo6000.lua
    │   ├── EFI_Halo6000.md
    │   ├── EFI_NMEA2k.lua
    │   ├── EFI_NMEA2k.md
    │   ├── EFI_SkyPower.lua
    │   ├── EFI_SkyPower.md
    │   ├── Generator_SVFFI.lua
    │   ├── Generator_SVFFI.md
    │   ├── Hobbywing_DataLink.lua
    │   ├── Hobbywing_DataLink.md
    │   ├── INF_Inject.lua
    │   ├── INF_Inject.md
    │   ├── LTE_modem.lua
    │   ├── LTE_modem.md
    │   ├── UltraMotion.lua
    │   ├── UltraMotion.md
    │   ├── mount-djirs2-driver.lua
    │   ├── mount-djirs2-driver.md
    │   ├── mount-viewpro-driver.lua
    │   ├── mount-viewpro-driver.md
    │   ├── torqeedo-torqlink.lua
    │   ├── torqeedo-torqlink.md
    │   └── TOFSense-M/
    │       ├── TOFSense-M_CAN.lua
    │       ├── TOFSense-M_CAN.md
    │       ├── TOFSense-M_Serial.lua
    │       └── TOFSense-M_Serial.md
    ├── examples/
    │   ├── README.md
    │   ├── 6DoF_roll_pitch.lua
    │   ├── AHRS_switch.lua
    │   ├── BQ40Z_bms_shutdown.lua
    │   ├── CAN_MiniCheetah_drive.lua
    │   ├── CAN_logger.lua
    │   ├── CAN_read.lua
    │   ├── CAN_write.lua
    │   ├── DroneCAN_test.lua
    │   ├── EFI_tester.lua
    │   ├── ESC_slew_rate.lua
    │   ├── FenceBreach.lua
    │   ├── FlexDebug.lua
    │   ├── Flip_Mode.lua
    │   ├── LED_matrix_image.lua
    │   ├── LED_matrix_text.lua
    │   ├── LED_poslight.lua
    │   ├── LED_roll.lua
    │   ├── MAVLinkHL.lua
    │   ├── MAVLink_Commands.lua
    │   ├── Mission_test.lua
    │   ├── MotorMatrix_dotriaconta_octaquad_x.lua
    │   ├── MotorMatrix_fault_tolerant_hex.lua
    │   ├── MotorMatrix_hexadeca_octa.lua
    │   ├── MotorMatrix_hexadeca_octa_cw_x.lua
    │   ├── MotorMatrix_setup.lua
    │   ├── Motor_mixer_dynamic_setup.lua
    │   ├── Motors_6DoF.lua
    │   ├── NMEA-decode.lua
    │   ├── OOP_example.lua
    │   ├── RCIN_test.lua
    │   ├── RC_override.lua
    │   ├── RM3100_self_test.lua
    │   ├── SN-GCJA5-particle-sensor.lua
    │   ├── Safety_States.lua
    │   ├── Serial_Dump.lua
    │   ├── UART_log.lua
    │   ├── active_source_set.lua
    │   ├── ahrs-print-angle-and-rates.lua
    │   ├── ahrs-print-home-and-origin.lua
    │   ├── ahrs-print-variances.lua
    │   ├── ahrs-set-home-to-vehicle-location.lua
    │   ├── ahrs-source-gps-optflow.lua
    │   ├── ahrs-source-gps-wheelencoders.lua
    │   ├── ahrs-source.lua
    │   ├── analog_input_and_GPIO.lua
    │   ├── arming-check-batt-temp.lua
    │   ├── arming-check-wp1-takeoff.lua
    │   ├── aux_cached.lua
    │   ├── battery_internal_resistance_check.lua
    │   ├── benewakeH30_can_rangefinder.lua
    │   ├── button_test.lua
    │   ├── camera-test.lua
    │   ├── cell_balance_check.lua
    │   ├── command_int.lua
    │   ├── copter-circle-speed.lua
    │   ├── copter-fast-descent.lua
    │   ├── copter-fly-vertical-circle.lua
    │   ├── copter-nav-script-time.lua
    │   ├── copter-posoffset.lua
    │   ├── copter-wall-climber.lua
    │   ├── copter_alt_offset.lua
    │   ├── copter_deploy.lua
    │   ├── copter_pingpong.lua
    │   ├── copter_pingpong.md
    │   ├── copy_userdata.lua
    │   ├── crosstrack_restore.lua
    │   ├── crsf-menu.lua
    │   ├── easter-egg.lua
    │   ├── efi_speed_check.lua
    │   ├── esc_rpm_scale.lua
    │   ├── fault_handling.lua
    │   ├── frsky_battery.lua
    │   ├── frsky_rpm.lua
    │   ├── frsky_wp.lua
    │   ├── fw_vtol_failsafe.lua
    │   ├── gen_control.lua
    │   ├── get_notify_RGB.lua
    │   ├── glide_into_wind.lua
    │   ├── gps_synth.lua
    │   ├── hello_world.lua
    │   ├── hello_world_display.lua
    │   ├── i2c_scan.lua
    │   ├── jump_tags_calibrate_agl.lua
    │   ├── jump_tags_calibrate_agl.waypoints
    │   ├── jump_tags_into_wind_landing.lua
    │   ├── jump_tags_into_wind_landing.waypoints
    │   ├── land_hagl.lua
    │   ├── lidar_control.lua
    │   ├── logging.lua
    │   ├── mag_heading.lua
    │   ├── message_interval.lua
    │   ├── mission-edit-demo.lua
    │   ├── mission-load.lua
    │   ├── mission-save.lua
    │   ├── mission_spiral.lua
    │   ├── motor_lost.lua
    │   ├── mount-test.lua
    │   ├── net_test.lua
    │   ├── notch_switch.lua
    │   ├── opendog_demo.lua
    │   ├── orbit_follow.lua
    │   ├── param_add.lua
    │   ├── param_get_set_test.lua
    │   ├── plane-callout-alt.lua
    │   ├── plane-doublets.lua
    │   ├── plane-wind-failsafe.lua
    │   ├── plane-wind-fs.lua
    │   ├── plane_guided_follow.lua
    │   ├── plane_guided_terrain.lua
    │   ├── protected_call.lua
    │   ├── proximity_test.lua
    │   ├── qnh_alt.lua
    │   ├── quadruped.lua
    │   ├── rangefinder_quality_test.lua
    │   ├── rangefinder_test.lua
    │   ├── readstring_test.lua
    │   ├── relay_control.lua
    │   ├── rgb_led_test.lua
    │   ├── rgb_notify_patterns.lua
    │   ├── rover-MinFixType.lua
    │   ├── rover-SaveTurns.lua
    │   ├── rover-TerrainDetector.lua
    │   ├── rover-motor-driver.lua
    │   ├── rover-set-steering-and-throttle.lua
    │   ├── rover-set-turn-rate.lua
    │   ├── serial_test.lua
    │   ├── servo_scan.lua
    │   ├── servo_set_get.lua
    │   ├── servo_slew.lua
    │   ├── set-angle.lua
    │   ├── set-target-location.lua
    │   ├── set-target-velocity.lua
    │   ├── set_CAMERA_INFORMATION.lua
    │   ├── set_target_posvel_circle.lua
    │   ├── ship_vel_match.lua
    │   ├── sim_arming_pos.lua
    │   ├── simple_loop.lua
    │   ├── sitl_standby_sim.lua
    │   ├── smbus-check-cycles.lua
    │   ├── sub_test_synthetic_seafloor.lua
    │   ├── temperature_sensor.lua
    │   ├── terrain_warning.lua
    │   ├── test_get_target_location.lua
    │   ├── test_load.lua
    │   ├── test_script_button.lua
    │   ├── test_update_target_location.lua
    │   ├── trisonica-mini.lua
    │   ├── trisonicia-mini.md
    │   ├── wp_test.lua
    │   └── wrap32_test.lua
    ├── generator/
    │   ├── description/
    │   │   └── bindings.desc
    │   └── src/
    ├── lua/
    │   ├── Makefile
    │   ├── README
    │   ├── doc/
    │   │   ├── contents.html
    │   │   ├── index.css
    │   │   ├── lua.1
    │   │   ├── lua.css
    │   │   ├── luac.1
    │   │   ├── manual.css
    │   │   ├── manual.html
    │   │   └── readme.html
    │   └── src/
    │       ├── Makefile
    │       └── lua.hpp
    ├── modules/
    │   ├── NMEA_2000.lua
    │   ├── mavport.lua
    │   ├── vehicle_control.lua
    │   └── MAVLink/
    │       ├── Readme.md
    │       ├── mavlink_msg_COMMAND_ACK.lua
    │       ├── mavlink_msg_COMMAND_LONG.lua
    │       ├── mavlink_msg_FOLLOW_TARGET.lua
    │       ├── mavlink_msg_GLOBAL_POSITION_INT.lua
    │       ├── mavlink_msg_HEARTBEAT.lua
    │       ├── mavlink_msg_SERIAL_CONTROL.lua
    │       └── mavlink_msgs.lua
    └── tests/
        ├── check.json
        ├── docs.json
        ├── docs_check.py
        ├── luacheck.lua
        ├── math.lua
        ├── mavlink_test.lua
        ├── scripting_require_test_2.lua
        ├── scripting_test.lua
        ├── serial_loopback.lua
        ├── strings.lua
        └── modules/
            └── test/
                ├── nested.lua
                └── top.lua

================================================
File: README.md
================================================
# AP_Scripting

## Enabling Scripting Support in Builds

Scripting is automatically enabled on all boards with at least 1MB of flash space.
The following example enables scripting, builds the ArduPlane firmware for the Cube, and uploads it.

```
$ waf configure --board=CubeBlack

$ waf plane

$ waf plane --upload
```

To run SITL you can simply use the `sim_vehicle.py` script which will wrap the configuration, compilation,
and launching of the simulation into one command for you.


```
$ Tools/autotest/sim_vehicle.py -v ArduPlane
```

Once you have a vehicle flashed with scripting you need to set the `SCR_ENABLE` parameter to 1 to enable scripting and reboot.

## Adding Scripts

The vehicle will automatically look for and launch any scripts that are contained in the `scripts` folder when it starts.
On real hardware this should be inside of the `APM` folder of the SD card. In SITL this should be in the working directory (typically the main `ardupilot` directory).

An example script is given below:

```lua
function update () -- periodic function that will be called
  local current_pos = ahrs:get_location() -- fetch the current position of the vehicle
  local home = ahrs:get_home()            -- fetch the home position of the vehicle
  if current_pos and home then            -- check that both a vehicle location, and home location are available
    local distance = current_pos:get_distance(home) -- calculate the distance from home in meters
    if distance > 1000 then -- if more then 1000 meters away
      distance = 1000;      -- clamp the distance to 1000 meters
    end
    SRV_Channels:set_output_pwm(96, 1000 + distance) -- set the servo assigned function 96 (scripting3) to a proportional value
  end

  return update, 1000 -- request "update" to be rerun again 1000 milliseconds (1 second) from now
end

return update, 1000   -- request "update" to be the first time 1000 milliseconds (1 second) after script is loaded
```

## Examples
See the [code examples folder](https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Scripting/examples)

## Working with bindings

Edit bindings.desc and rebuild. The waf build will automatically
re-run the code generator.

## Lua Source Code

The Lua 5.3.6 source code is vendored in `lua/`. This is a customized
version of the [official
distribution](https://www.lua.org/ftp/lua-5.3.6.tar.gz). Where possible,
differences have been marked of the code.

Lua (not including modifications) is distributed under the terms of the
MIT license.



================================================
File: wscript
================================================
#!/usr/bin/env python
# encoding: utf-8
'''
build generated bindings from bindings.desc for AP_Scripting
'''

from waflib.TaskGen import after_method, before_method, feature
import os

# these are only used for binding generation, not compilation of the library
BINDING_CFLAGS="-std=c99 -Wno-error=missing-field-initializers -Wall -Werror -Wextra"
BINDING_CC="gcc"

def configure(cfg):
    cfg.env.AP_LIB_EXTRA_SOURCES['AP_Scripting'] = ['lua_generated_bindings.cpp']

def relpath(bld, node):
    '''make a build relative path. This is needed for CI to pass on azure'''
    blddir = bld.bldnode.make_node(".").abspath()
    return os.path.relpath(node.abspath(), blddir)

def build(bld):
    main_c = bld.srcnode.make_node('libraries/AP_Scripting/generator/src/main.c')
    gen_bindings = bld.bldnode.find_or_declare('gen-bindings')

    main_c_rel = relpath(bld, main_c)
    gen_bindings_rel = relpath(bld, gen_bindings)

    bld(
        # build gen-bindings compiler
        source=main_c,
        target=[gen_bindings],
        # we should have configure tests for finding the native compiler
        rule="%s %s -o %s %s" % (BINDING_CC, BINDING_CFLAGS, gen_bindings_rel, main_c_rel),
        group='dynamic_sources',
    )

    bindings = bld.srcnode.make_node('libraries/AP_Scripting/generator/description/bindings.desc')
    bindings_rel = relpath(bld, bindings)
    gen_bindings = bld.bldnode.find_or_declare('gen-bindings')
    generated_cpp = bld.bldnode.find_or_declare('libraries/AP_Scripting/lua_generated_bindings.cpp')
    generated_h = bld.bldnode.find_or_declare('libraries/AP_Scripting/lua_generated_bindings.h')

    docs_command = ""
    if bld.options.scripting_docs:
        docs = bld.srcnode.make_node('libraries/AP_Scripting/docs/docs.lua')
        docs_rel = relpath(bld,docs)
        docs_command = "-d %s" % docs_rel

    bld(
        # build the bindings
        source=[bindings, gen_bindings],
        rule="./gen-bindings -o libraries/AP_Scripting/lua_generated_bindings -i %s %s" % (bindings_rel, docs_command),
        target=[generated_cpp, generated_h],
        group='dynamic_sources',
    )



================================================
File: ai/README.md
================================================
# **AI Drone Scripting**

## **Overview**

This project uses a Large Language Model (LLM) to generate Lua scripts for the ArduPilot autopilot platform.

The generation process is guided by a document called the **AI Playbook**. This playbook contains a set of rules and constraints that ensures the generated scripts are safe, testable, and consistent with ArduPilot development standards.

## **Key Components**

To generate a script, the LLM requires the following context:

* **API Documentation (docs.lua):** This file is the definitive source for all ArduPilot-specific Lua function signatures and is the final authority on correct API usage.  
* **Code Digest (digest.txt):** This file contains the AI Playbook and a snapshot of all existing scripts and tests within the ArduPilot repository. It provides the LLM with the necessary rules and real-world examples to create new scripts.

## **Generating the digests**

1. Install [gitingest](https://github.com/cyclotruc/gitingest)
2. Run ```gitingest libraries/AP_Scripting -e '*.cpp' -e '*.c' -e '*.h' -e '*.txt'```
3. LUA Digest will be in digest.txt
4. Run ```gitingest Tools/autotest -i arducopter.py -i vehicle_test_suite.py```
5. Autotest digest will be in digest.txt

## **How to Use This System**

The process for generating a script is as follows:

1. **Write a Prompt:** Clearly describe the required functionality. Focus on what the script should do, not the implementation details.  
   * *Example Prompt:* \"Create a script to control the brightness of my drone's NeoPixel LEDs using an RC switch. It should support three levels: off, medium, and high.\"
2. **Provide Context:** Give the LLM your prompt and the digest-lua.txt file. The digest contains the AI Playbook and all necessary examples for the LLM to learn from.  
3. **Generate Artifacts:** The LLM will generate a complete ArduPilot Applet, which includes:  
   * A .lua script file.  
   * A .md documentation file explaining how to set up and use the script.  
4. **Generate Autotest:** For every applet, the LLM will offer to generate a corresponding SITL autotest file. This allows you to verify the script's functionality in a safe, simulated environment.

## **The leds\_on\_a\_switch Example**

The development of the leds\_on\_a\_switch applet demonstrates the intended workflow. A simple prompt was used to generate an initial script. Through an iterative process of critiquing the output against the playbook's rules, the final script was refined to be:

* **Correct:** Adheres strictly to the documented APIs.  
* **Safe:** Includes error handling and fails gracefully if misconfigured.  
* **Testable:** Provides GCS feedback for verification in an autotest.  
* **User-Friendly:** Follows standard ArduPilot conventions and is accompanied by clear documentation.


================================================
File: ai/AI_GIT_FORMAT_PATCH_PLAYBOOK.md
================================================
# **Playbook: Generating git format-patch Diffs (v4)**

## **1\. Objective**

To generate a precise, machine-readable, and human-understandable diff for a file change, formatted in the style of a git format-patch output. This ensures the change is encapsulated with its metadata, the exact code modifications, and is structurally valid for use with Git tools.

## **2\. Core Principles**

* **Verifiability:** The original file content must be present in my context. I will **never** generate a patch based on an assumed or hallucinated file state.  
* **Path Integrity:** The patch must target the correct file path. I will **never** generate a patch without knowing the file path. If the path is not provided, I must ask for it.  
* **Hunk Integrity:** Each non-contiguous block of changes in a file **must** be represented by its own separate hunk (@@ ... @@ section). Combining separate changes into a single hunk will corrupt the patch.  
* **Accuracy:** The diff must represent the change perfectly. Line numbers, context lines, additions, and deletions must be exact.  
* **Format Purity:** The final output must be a raw text block, using Unix-style line endings (\\n), without any surrounding text or formatting.  
* **Structural Integrity:** The patch must be complete, including the header, body, diff stats, and the mandatory patch terminator.

## **3\. Anatomy of a format-patch File**

A patch file contains a header, a commit message, diff statistics, one or more hunks, and a terminator.

From \<commit\_hash\> \<timestamp\>  
From: Gemini \<gemini@google.com\>  
Date: \<current\_date\>  
Subject: \[PATCH\] \<Short, imperative summary of the change\>

\<Detailed explanation of the change.\>  
\---  
 path/to/the/file.ext | 4 \++--  
 1 file changed, 2 insertions(+), 2 deletions(-)

diff \--git a/path/to/the/file.ext b/path/to/the/file.ext  
index \<hash1\>..\<hash2\> \<file\_mode\>  
\--- a/path/to/the/file.ext  
\+++ b/path/to/the/file.ext  
@@ \-\<hunk\_1\_old\> \+\<hunk\_1\_new\> @@  
 ... content for the first hunk ...  
@@ \-\<hunk\_2\_old\> \+\<hunk\_2\_new\> @@  
 ... content for the second hunk ...  
\--   
2.43.0

## **4\. Step-by-Step Generation Process**

### **Step 1: Gather and Verify Information**

**Prerequisites:** Before proceeding, I must have:

1. The complete **Original File Content**.  
2. The full **File Path**.  
3. The complete **Modified File Content**.

If any information is missing, I will stop and request it.

### **Step 2-4: Header, Message, and Stats**

I will generate the metadata headers, the commit message, and the diff statistics as previously defined.

### **Step 5: Generate the Technical Diff Hunks**

This process is critical for ensuring patch integrity.

1. **Write File Headers:** I will write the diff \--git, index, \--- a/..., and \+++ b/... lines.  
2. **Identify All Change Blocks:** I will scan both files and identify every separate, non-contiguous block of added (+) and/or removed (-) lines.  
3. **Iterate Through Each Block:** For each block of changes identified in the previous step, I will perform the following procedure to generate a distinct hunk:  
   * **Establish Context:** I will select up to **3 lines** of unchanged code directly before the block and up to **3 lines** directly after it.  
   * **Calculate Hunk Header (@@ ... @@):** I will precisely calculate the start line and line count for both the original (-old,old\_count) and new (+new,new\_count) versions of the file for this specific block.  
   * **Assemble the Hunk:** I will print the calculated @@ ... @@ header, followed by the context and change lines for this block, each prefixed with the correct character ( , \-, or \+).  
4. I will repeat this process until a separate, valid hunk has been generated for every block of changes.

### **Step 6: Terminate the Patch**

1. After the last line of the final hunk, I will add a line containing only \-- .  
2. On the next line, I will add a placeholder Git version (e.g., 2.43.0).

## **6\. Self-Correction Checklist**

* \[ \] Do I have the full, original file content and path?  
* \[ \] Is the metadata and commit message correctly formatted?  
* \[ \] **(Crucial)** Have I identified all non-contiguous change blocks and created a separate, correctly calculated hunk for **each one**?  
* \[ \] Does the patch end with the correct \-- \\n\<version\> terminator?  
* \[ \] Is the final output a single, raw text block, ready for direct use?


================================================
File: ai/AI_PAIR_PROGRAMMING_PLAYBOOK.md
================================================
# AI Playbook for Drone Control LUA Script Generation

<MANDATORY\_RULE\>
CRITICAL DIRECTIVE: THIS PLAYBOOK MUST BE USED AS THE PRIMARY AND AUTHORITATIVE GUIDE FOR ALL LUA SCRIPT GENERATION FOR ARDUPILOT. ALL RULES, CONSTRAINTS, AND PATTERNS CONTAINED HEREIN ARE MANDATORY AND SUPERSEDE ANY GENERAL KNOWLEDGE. ADHERENCE IS NOT OPTIONAL.  
</MANDATORY\_RULE\>
<MANDATORY\_RULE\>
CRITICAL DIRECTIVE: THE docs.lua FILE IS THE ABSOLUTE SOURCE OF TRUTH FOR ALL ARDUPILOT-SPECIFIC FUNCTION SIGNATURES. ANY DEVIATION FROM THE FUNCTION SIGNATURES IN THIS FILE IS A VIOLATION OF THE PLAYBOOK.  
</MANDATORY\_RULE\>

## 1\. Core Concepts

This playbook is designed to provide a Large Language Model (LLM) with the necessary context to generate Lua scripts for controlling drones running the ArduPilot firmware. Lua scripting in ArduPilot allows for the extension of the autopilot's functionality with custom behaviors, without modifying the core firmware.

**Key Principles:**

* **Sandboxed Environment:** Scripts run in a sandboxed environment, meaning they have limited access to the system's resources and cannot crash the main flight controller.  
* **Event-Driven:** Scripts are typically event-driven, reacting to changes in the drone's state, sensor data, or RC controller inputs.  
* **ArduPilot API:** Scripts interact with the drone through a specific ArduPilot Lua API, which provides functions for controlling the vehicle, reading sensors, and more.

## 2\. Environment Setup

For a Lua script to be used, the drone's flight controller must be configured to support scripting.

* **Enable Scripting:** In the ArduPilot parameters, SCR\_ENABLE must be set to 1\.  
* **Upload Scripts:** Scripts are uploaded to the APM/scripts directory on the flight controller's SD card.  
* **Reboot:** The flight controller must be rebooted after enabling scripting or uploading new scripts.

## 3\. ArduPilot LUA API Reference

This section details the most common functions and libraries available in the ArduPilot Lua API.

For a definitive list of all available function signatures, the `docs.lua` file is the absolute source of truth.

For a task-oriented guide on how to use these functions to accomplish common drone behaviors (e.g., controlling movement, reading sensors, managing missions), please refer to the **AI_VEHICLE_CONTROL_PLAYBOOK.md**. The `AI_VEHICLE_CONTROL_PLAYBOOK.md` organizes the API by function rather than by library.


### 3.1. Vehicle Control

* **vehicle:get\_location()**: Returns a Location object with the current position of the drone.  
* **vehicle:set\_target\_location(Location)**: Commands the drone to fly to a specific Location.  
* **vehicle:set\_target\_velocity\_NED(Vector3f)**: Sets the drone's target velocity in a North-East-Down (NED) frame.  
* **vehicle:arm()**: Arms the drone.  
* **vehicle:disarm()**: Disarms the drone.  
* **vehicle:get\_mode()**: Returns the current flight mode of the drone.  
* **vehicle:set\_mode(mode)**: Sets the drone's flight mode (e.g., GUIDED, LOITER, RTL).  
* **vehicle:start\_takeoff(altitude)**: Initiates an auto-takeoff to the specified altitude.

**Example:**

\-- Fly to a GPS coordinate  
local target\_location \= Location()  
target\_location:lat(47.397742)  
target\_location:lng(8.545594)  
target\_location:alt(10) \-- 10 meters altitude  
vehicle:set\_target\_location(target\_location)

### 3.2. GPS

* **gps:num\_sensors()**: Returns the number of connected GPS sensors.  
* **gps:status(instance)**: Returns the fix status of a specific GPS sensor.  
* **gps:location(instance)**: Returns a Location object with the position from a specific GPS sensor.  
* **gps:primary\_sensor()**: Returns the index of the primary GPS sensor.

### 3.3. Sensors

* **rangefinder:num\_sensors()**: Returns the number of connected rangefinders.  
* **rangefinder:distance(instance)**: Returns the distance measured by a specific rangefinder.  
* **battery:num\_instances()**: Returns the number of connected batteries.  
* **battery:voltage(instance)**: Returns the voltage of a specific battery.  
* **battery:remaining\_capacity(instance)**: Returns the remaining capacity of a specific battery.

### 3.4. RC Channels

* **rc:get\_channel(channel\_num)**: Returns the current PWM value of a specific RC channel.  
* **rc:get\_aux\_cached(aux\_channel)**: Returns the cached value of an auxiliary channel.

## 4\. Available Scripts

The ArduPilot repository contains a wide variety of pre-written Lua scripts that can be used as-is or adapted for specific needs. These scripts are categorized into applets, drivers, examples, and tests.

### 4.1. Applets

Applets are complete, ready-to-use scripts that require no user editing. They often provide high-level functionality and can be enabled through parameters. Each applet is accompanied by a markdown file (.md) that details its operation.

* BattEstimate  
* BatteryTag  
* Gimbal\_Camera\_Mode  
* Heli\_IM\_COL\_Tune  
* Heli\_idle\_control  
* Hexsoon LEDs  
* MissionSelector  
* ONVIF\_Camera\_Control  
* Param\_Controller  
* QuadPlane\_Low\_Alt\_FW\_mode\_prevention  
* RockBlock  
* Script\_Controller  
* SmartAudio  
* UniversalAutoLand  
* VTOL-quicktune  
* advance-wp  
* ahrs-set-origin  
* ahrs-source-extnav-optflow  
* camera-change-setting  
* copter-deadreckon-home  
* copter-slung-payload  
* copter\_terrain\_brake  
* crsf-calibrate  
* follow-target-send  
* forward\_flight\_motor\_shutdown  
* leds\_on\_a\_switch  
* motor\_failure\_test  
* mount-poi  
* net\_webserver  
* param-set  
* pelco\_d\_antennatracker  
* plane\_package\_place  
* plane\_precland  
* plane\_ship\_landing  
* repl  
* revert\_param  
* rover-quicktune  
* runcam\_on\_arm  
* video-stream-information  
* winch-control  
* x-quad-cg-allocation  
* **Aerobatics:**  
  * plane\_aerobatics  
  * sport\_aerobatics  
* **WebExamples:**  
  * test.lua  
  * test.shtml

### 4.2. Drivers

Drivers provide support for specific hardware or protocols.

* BattMon\_ANX  
* EFI\_DLA  
* EFI\_HFE  
* EFI\_Halo6000  
* EFI\_NMEA2k  
* EFI\_SkyPower  
* Generator\_SVFFI  
* Hobbywing\_DataLink  
* INF\_Inject  
* LTE\_modem  
* UltraMotion  
* mount-djirs2-driver  
* mount-viewpro-driver  
* torqeedo-torqlink  
* **TOFSense-M:**  
  * TOFSENSE-M\_CAN  
  * TOFSENSE-M\_Serial

### 4.3. Examples

Examples provide demonstrations of specific functionalities and can be used as a starting point for custom scripts.

* 6DoF\_roll\_pitch  
* AHRS\_switch  
* BQ40Z\_bms\_shutdown  
* CAN\_MiniCheetah\_drive  
* CAN\_logger  
* CAN\_read  
* CAN\_write  
* DroneCAN\_test  
* EFI\_tester  
* ESC\_slew\_rate  
* FenceBreach  
* FlexDebug  
* Flip\_Mode  
* LED\_matrix\_image  
* LED\_matrix\_text  
* LED\_poslight  
* LED\_roll  
* MAVLinkHL  
* MAVLink\_Commands  
* Mission\_test  
* MotorMatrix\_dotriaconta\_octaquad\_x  
* MotorMatrix\_fault\_tolerant\_hex  
* MotorMatrix\_hexadeca\_octa  
* MotorMatrix\_hexadeca\_octa\_cw\_x  
* MotorMatrix\_setup  
* Motor\_mixer\_dynamic\_setup  
* Motors\_6DoF  
* NMEA-decode  
* OOP\_example  
* RCIN\_test  
* RC\_override  
* RM3100\_self\_test  
* SN-GCJA5-particle-sensor  
* Safety\_States  
* Serial\_Dump  
* UART\_log  
* active\_source\_set  
* ahrs-print-angle-and-rates  
* ahrs-print-home-and-origin  
* ahrs-print-variances  
* ahrs-set-home-to-vehicle-location  
* ahrs-source-gps-optflow  
* ahrs-source-gps-wheelencoders  
* ahrs-source  
* analog\_input\_and\_GPIO  
* arming-check-batt-temp  
* arming-check-wp1-takeoff  
* aux\_cached  
* battery\_internal\_resistance\_check  
* benewakeH30\_can\_rangefinder  
* button\_test  
* camera-test  
* cell\_balance\_check  
* command\_int  
* copter-circle-speed  
* copter-fast-descent  
* copter-fly-vertical-circle  
* copter-nav-script-time  
* copter-posoffset  
* copter-wall-climber  
* copter\_alt\_offset  
* copter\_deploy  
* copter\_pingpong  
* copy\_userdata  
* crosstrack\_restore  
* crsf-menu  
* easter-egg  
* efi\_speed\_check  
* esc\_rpm\_scale  
* fault\_handling  
* frsky\_battery  
* frsky\_rpm  
* frsky\_wp  
* fw\_vtol\_failsafe  
* gen\_control  
* get\_notify\_RGB  
* glide\_into\_wind  
* gps\_synth  
* hello\_world  
* hello\_world\_display  
* i2c\_scan  
* jump\_tags\_calibrate\_agl  
* jump\_tags\_into\_wind\_landing  
* land\_hagl  
* lidar\_control  
* logging  
* mag\_heading  
* message\_interval  
* mission-edit-demo  
* mission-load  
* mission-save  
* mission\_spiral  
* motor\_lost  
* mount-test  
* net\_test  
* notch\_switch  
* opendog\_demo  
* orbit\_follow  
* param\_add  
* param\_get\_set\_test  
* plane-callout-alt  
* plane-doublets  
* plane-wind-failsafe  
* plane-wind-fs  
* plane\_guided\_follow  
* plane\_guided\_terrain  
* protected\_call  
* proximity\_test  
* qnh\_alt  
* quadruped  
* rangefinder\_quality\_test  
* rangefinder\_test  
* readstring\_test  
* relay\_control  
* rgb\_led\_test  
* rgb\_notify\_patterns  
* rover-MinFixType  
* rover-SaveTurns  
* rover-TerrainDetector  
* rover-motor-driver  
* rover-set-steering-and-throttle  
* rover-set-turn-rate  
* serial\_test  
* servo\_scan  
* servo\_set\_get  
* servo\_slew  
* set-angle  
* set-target-location  
* set-target-velocity  
* set\_CAMERA\_INFORMATION  
* set\_target\_posvel\_circle  
* ship\_vel\_match  
* sim\_arming\_pos  
* simple\_loop  
* sitl\_standby\_sim  
* smbus-check-cycles  
* sub\_test\_synthetic\_seafloor  
* temperature\_sensor  
* terrain\_warning  
* test\_get\_target\_location  
* test\_load  
* test\_script\_button  
* test\_update\_target\_location  
* trisonica-mini  
* wp\_test  
* wrap32\_test

## 5\. Code Generation Constraints

The following constraints apply to all Lua code generation:

### 5.1. Lua Version and Libraries

* **Lua Version:** All generated code must be compatible with Lua 5.3.  
* **API Source of Truth:** The docs.lua file is the **definitive source of truth** for all ArduPilot-specific function signatures. In cases of discrepancy between examples and this documentation, the docs.lua file takes precedence.  
* **Allowed Functions:** Functions are limited to:  
  * Standard Lua 5.3 language features.  
  * Functions documented in the provided docs.lua file.  
  * The standard io library for file operations.  
  * The require() function, for loading modules from the script's local APM/scripts directory.

### 5.2. Script Structure and Execution

* **No Threads:** Scripts must not create or manage their own threads. The ArduPilot environment handles script execution in a single-threaded manner.  
* **Non-Blocking:** Scripts must not contain any blocking calls or long-running loops. Each execution of the script's main function should complete within a few milliseconds.  
* **Update Function Pattern:** The required structure depends on the script's purpose:  
  * **Applets (Continuous Tasks):** Must use a main update() function that performs its tasks and then reschedules itself to run again at a regular interval.  
  * **One-Shot Scripts:** Can execute logic sequentially and terminate without an update() loop.  
  * **Test Scripts:** Typically run a series of assert() checks and may optionally enter a simple loop to report a "tests passed" message.  
* **Error Handling:** A protected\_wrapper using pcall() is mandatory for all applets. It is also required for any example or test script where a runtime error is possible (e.g., interacting with hardware, complex calculations). For very simple, infallible example scripts (like hello\_world.lua), the wrapper can be omitted for clarity.  
  **Example protected\_wrapper:**
```lua
  function protected_wrapper()
    local success, err = pcall(update)
    if not success then
       gcs:send_text(MAV\_SEVERITY.ERROR, "Internal Error: " .. err)
       -- Reschedule with a longer delay after an error
       return protected_wrapper, 1000
    end
    -- Reschedule with the normal update interval
    return protected_wrapper, 100
  end
```

### 5.3. Initial Condition Checks

* **Use assert():** Scripts should use the assert() function at the beginning to validate essential preconditions. This ensures the script fails early and clearly if the environment is not correctly configured.  
  **Example assert() check:**  
```lua
  -- Check that a required parameter is set
  local my_param = assert(param:get('MYAPL_ENABLE'), 'MYAPL_ENABLE not set')

  -- Check that the vehicle is the correct type
  assert(vehicle:get_frame_class() == 1, 'Script requires a Quad frame')
```

### 5.4. Default Applet Behavior

  1. **Activation:** By default, all applets **must** be activatable via an RC switch.
  2. **RC Function Constant:** The Auxiliary Function number for the switch **must** be defined as a local constant in the script (e.g., `local SCRIPTING_AUX_FUNC = 300`). It **must not** be a user-configurable script parameter (e.g., `FIG8_LAND_SWITCH`). This simplifies user setup.
  3. Use rc:get\_aux\_cached(SCRIPTING\_AUX\_FUNC) to read the switch position (0=low, 1=middle, 2=high).  
  4. The documentation (.md file) must instruct the user to set their desired RCx\_OPTION to this number (e.g., "Set RC9\_OPTION to 300"). This removes a parameter from the script and simplifies user setup.
  5. **User Prompt Precedence:** If the user's prompt explicitly requests an activation method that differs from this default (e.g., "take off automatically on arm"), the user's request shall take precedence. However, the generated `.md` documentation **must** include a section explicitly noting this deviation from the standard applet pattern and explaining the custom activation logic.

**Example 3-Position Switch Logic (for `.lua` file):**

```lua
-- Define a constant for the auxiliary function
local SCRIPTING_AUX_FUNC = 300 -- Corresponds to "Scripting1"

-- In the script's main logic
function update()
    -- Directly use the hardcoded aux function number
    local switch\_pos = rc:get_aux_cached(SCRIPTING_AUX_FUNC)
    if switch_pos == 0 then
        -- Handle LOW position
    elseif switch_pos == 1 then
        -- Handle MIDDLE position
    elseif switch_pos == 2 then
        -- Handle HIGH position
    end
    return update, 200 -- reschedule
end
```

### **5.4.1 Applet Configuration Mandate**

**CRITICAL DIRECTIVE: ALL APPLET SCRIPTS MUST EXPOSE USER-CONFIGURABLE VALUES AS SCRIPT PARAMETERS.** Any value that a user might reasonably want to tune (e.g., distances, speeds, rates, durations, thresholds, modes of operation) **must not** be defined as a hard-coded local variable. Instead, it **must** be created using the `param:add_table()` and `param:add_param()` functions as detailed in section 5.7. This is a non-negotiable requirement for a script to be considered a complete "Applet".

**Violation Example (Incorrect):**

```lua
-- A local variable is used for a key configuration value.
local RADIUS = 20
```
**Compliance Example (Correct):**

```lua
-- The radius is exposed as a proper, user-configurable parameter.
local PARAM_TABLE_KEY = 105
local PARAM_TABLE_PREFIX = "FIG8_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 1), '...')

local FIG8_RADIUS = assert(param:add_param(PARAM_TABLE_KEY, 1, 'RADIUS', 20), '...')
```

This ensures that all generated applets are immediately usable and configurable by the end-user through standard Ground Control Station software, which is a primary goal of this system.

### 5.5. Deliverable Format and Autotest Generation

* **Assume Applet by Default:** Unless the user specifies otherwise, or the request is clearly for a simple example or test, the primary output should be a complete ArduPilot Applet.  
* **Applet Format:** An applet must include two files:  
  1. The Lua script file (.lua).  
  2. A corresponding Markdown documentation file (.md) that explains the applet's purpose, parameters, and usage.  
* **Example/Test Format:** If generating an example or test, follow the simpler structure observed in the repository (e.g., may omit headers, pcall wrappers, and documentation).  
* **Autotest Generation:** For every new applet, offer to generate a corresponding SITL autotest. The autotest is a Python script that runs in the ArduPilot simulation environment (SITL) to verify the script's behavior automatically.  
  **Mandatory Autotest Structure:**  
  1. **Test Location and Structure**: Autotests **must not be new files**. They must be added as new, self-contained methods to the appropriate existing vehicle-specific test suite. For example, a Copter-related script test must be a new method within a class in Tools/autotest/arducopter.py. If the script is not vehicle-specific, the test should be written for Copter by default. The test method must not introduce new global state but may use the existing test framework's helper functions and self object.  
  2. **install\_applet\_script\_context**: Use the self.install\_applet\_script\_context("my\_script.lua") context manager. This command handles copying the script into the correct SITL directory and ensures it's cleaned up after the test.  
  3. **Two-Stage Parameter Setup**:  
     * **Stage 1**: Set SCR\_ENABLE to 1\. If required, also enable any necessary hardware simulations (like RNGFND1\_TYPE). Then, **must** call self.reboot\_sitl(). This first reboot allows ArduPilot to recognize that scripting is enabled and to generate the parameters defined by the script.  
     * **Stage 2**: Now that the script's parameters exist, set them to the values required for the test (e.g., MYAPL\_ENABLE to 1, RC9\_OPTION to 300). Then, **must** call self.reboot\_sitl() a second time. This reboot ensures the script starts up with the correct parameter values.  
  4. **Test Logic**:  
     * Arm the vehicle (self.arm\_vehicle()) and change to the desired flight mode (self.change\_mode("LOITER")).  
     * Use self.context\_collect('STATUSTEXT') before performing an action that should generate a GCS message.  
     * Trigger the script's conditions. This may involve changing altitude (self.change\_alt(10)), flying to a location (self.fly\_to\_pos(...)), or setting an RC channel input (self.set\_rc(9, 2000)).  
     * Verify the outcome. The primary method for this is self.wait\_statustext("Expected message text", check\_context=True). You can also check for mode changes (self.wait\_mode("BRAKE")) or other vehicle state changes.  
  5. **Cleanup**: Disarm the vehicle (self.disarm\_vehicle()).

**Annotated Autotest Example (to be inserted into arducopter.py):**\# NOTE: This is an example of a method to be added to an existing class  
\# like 'class AutoTestCopter(vehicle\_test\_suite.TestSuite):'  
def do\_lua\_mynewapplet\_test(self):  
    '''Tests the my\_new\_applet.lua script'''  
    self.start\_subtest("Test MyNewApplet functionality")

    \# 2\. Install Script  
    with self.install\_applet\_script\_context("my\_new\_applet.lua"):

        \# 3\. Two-Stage Parameter Setup  
        self.set\_parameters({  
            "SCR\_ENABLE": 1,  
            "RNGFND1\_TYPE": 10, \# Enable SITL rangefinder for testing  
        })  
        self.reboot\_sitl()

        self.set\_parameters({  
            "MYAPL\_ENABLE": 1,  
            "RC9\_OPTION": 300, \# Corresponds to Scripting1 aux function  
            "MYAPL\_ALT": 15,  
        })  
        self.reboot\_sitl()

        \# 4\. Test Logic  
        self.wait\_ready\_to\_arm()  
        self.arm\_vehicle()  
        self.change\_mode("LOITER")  
        self.user\_takeoff(alt\_min=20)

        self.context\_collect('STATUSTEXT')  
        self.set\_rc(9, 2000\) \# Set RC9 high to trigger script  
        self.wait\_statustext("MyNewApplet: State changed to HIGH", check\_context=True, timeout=10)

        \# 5\. Cleanup  
        self.set\_rc(9, 1000\) \# Return RC switch to low  
        self.disarm\_vehicle()

### 5.6. Code Quality

* **Header Comments (Applets Only):** Every applet script must start with a comment block that briefly describes its purpose and functionality. The style should be concise and consistent with other applets in the ArduPilot repository. This is not required for examples or tests.  
* **State Change Feedback:** Applets must provide brief, clear feedback via gcs:send\_text(severity, text) when significant state changes occur (e.g., activation, mode change, action completed). These messages are the primary mechanism for verification in autotests.  
* **Use Enums for Constants:** Avoid using hardcoded integers ("magic numbers") for values like modes, states, or options. Instead, define a local table at the start of the script to act as an enumeration.  
  **Example Enum for gcs:send\_text:**
```lua
  -- Enum for MAV_SEVERITY levels. Using this is mandatory
  -- for gcs:send_text() instead of hardcoded numbers.
  local MAV_SEVERITY = {
      EMERGENCY = 0,
      ALERT = 1,
      CRITICAL = 2,
      ERROR = 3,
      WARNING = 4,
      NOTICE = 5,
      INFO = 6,
      DEBUG = 7
  }

  -- Usage:
  gcs:send_text(MAV_SEVERITY.INFO, "Script initialized")
```

* **luacheck Compliance:** All generated Lua code must be free of errors and warnings when analyzed with the luacheck tool, using the standard ArduPilot configuration.

### 5.7. Parameter Creation

* **Strict Syntax:** Parameter creation is a strict two-step process that must be followed exactly as documented in docs.lua.  
  1. **Declare Table:** Use param:add\_table(table\_key, prefix, num\_params) to declare the parameter group. The prefix must **NOT** have a trailing underscore.  
  2. **Add Parameters:** Iterate through a local table of parameter definitions and add each one using param:add\_param(table\_key, param\_num, name, default\_value).  
* **Naming Convention:**  
  * The prefix should be a short, uppercase string (e.g., MYAPL).  
  * The name in the parameter definition should be the suffix (e.g., ENABLE).  
  * The final parameter name seen by the user is PREFIX\_NAME (e.g., MYAPL\_ENABLE).  
  * The total length of this full name **must not exceed 16 characters**.  
  * The full name must be used when getting/setting the parameter in Lua and in autotests.  
* **Unique Table Key:** The table\_key must be an integer between 1 and 200 and must be unique across all existing scripts in the ArduPilot repository. Do not reuse any of the following keys: 7, 8, 9, 10, 11, 12, 14, 15, 16, 31, 36, 37, 39, 40, 41, 42, 43, 44, 45, 48, 49, 70, 71, 72, 73, 75, 76, 78, 79, 80, 81, 82, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 102, 104, 106, 109, 110, 111, 117, 136, 138, 139, 193\.  
  **Correct Parameter Creation Example:**
```lua
  -- This local table is for script organization only.  
  local parameter_definitions = {
      { name = "ENABLE", default = 0 },
      { name = "VALUE", default = 12.3 }
  }
  local PARAM_TABLE_KEY = 101
  local PARAM_TABLE_PREFIX = "MYAPL" -- Note: NO trailing underscore

  -- Step 1: Declare the table with its key, prefix, and the number of parameters.  
  assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, \#parameter_definitions), "Could not add param table")

  -- Step 2: Add each parameter individually using the correct signature.  
  for i, p_def in ipairs(parameter_definitions) do  
      assert(param:add_param(PARAM_TABLE_KEY, i, p_def.name, p_def.default), "Could not add param "..p_def.name)  
  end

  -- Usage in code: use the full, concatenated name.  
  local my_val \= param:get('MYAPL_VALUE')
```

### 5.8. Surgical Modification

<MANDATORY\_RULE\>
When asked to modify an existing file, you must strictly limit your changes to the scope of the user's explicit request. Do not perform any unrelated "tidy-up", refactoring, or tylistic changes. The goal is to produce the smallest possible diff that correctly implements the user's request, respecting the original author's coding style and structure.
</MANDATORY\_RULE\>
**Prohibited Tangential Changes Include:**

* **Reformatting:** Do not change indentation, line breaks, or spacing in code that is unrelated to the direct change. 
* **Variable Renaming:** Do not rename variables or functions for clarity unless that is part of the specific request. 
* **Comment Removal/Alteration:** Do not remove existing comments, even if they appear obsolete or incorrect. Preserve them exactly as they are.
* **Unrelated Refactoring:** Do not restructure or "improve" the logic of functions or sections of code that are not the direct subject of the modification request.

By adhering to this, you ensure that the user can easily review the changes and trust that no unintended side effects have been introduced.

## 6\. Operational Constraints and Safety

When generating Lua scripts, the following constraints must be strictly adhered to, to ensure the safety and stability of the drone.

* **Flight Mode Awareness:** Scripts must be aware of the vehicle's current flight mode. Actions should only be executed if the current flight mode is appropriate. For example, a script that controls the drone's position should only run in modes like GUIDED or AUTO.  
* **Arming Status:** Scripts must always check if the vehicle is armed before executing any commands that could result in motor activation or movement.  
* **Failsafe Integrity:** Scripts must not interfere with critical failsafe mechanisms, such as RC failsafe, battery failsafe, or geofence breaches.  
* **Resource Limits:** Scripts should be mindful of the flight controller's processing and memory limits. Avoid long-running, blocking operations and excessive memory allocation. Use short, efficient functions and schedule them to run periodically.  
* **Parameter Modification:** Scripts should exercise extreme caution when modifying parameters. Critical flight parameters should not be changed without a clear understanding of the consequences. If a script does modify parameters, it should restore them to their original values when the script is disabled or completes its task.  
* **User Control Priority:** The pilot's RC input should always have the highest priority. Scripts should be designed to relinquish control immediately if the pilot provides any input on the sticks or changes the flight mode.

## 7\. Best Practices for Prompting

When requesting a Lua script, provide clear and concise instructions. Referencing the available scripts in the repository can help to improve the clarity and specificity of your requests.

**Prompting Template:**

"Create a Lua script that \[**action**\] when \[**trigger**\]. The script should \[**specific behavior**\]."

**Examples:**

* "Create a Lua script that **makes the drone fly in a 20-meter square pattern** when **the pilot flips RC channel 7 high**. The script should **return the drone to its original position after completing the pattern**."  
* "Create a Lua script that **logs the drone's altitude and battery voltage to a file every 5 seconds** when **the drone is armed**. The script should **stop logging when the drone is disarmed**."  
* "Create a Lua script that **activates a servo connected to output 10** when **the drone's altitude is above 50 meters**. The script should **deactivate the servo when the altitude is below 50 meters**."

## 8\. Example Use Cases

Here are some common drone behaviors with their corresponding text prompts and expected Lua script outputs.

### 8.1. Simple Box Mission

* **Prompt:** "Create a Lua script that makes the drone fly in a 15-meter box pattern when the pilot flips RC channel 8 to high."  
* **Expected Lua Script:**
```lua
  -- This script demonstrates a simple state machine to fly a box pattern.
  
  local BOX_SIZE = 15 -- meters
  local state = {
      active = false,
      stage = 0,
      start_location = nil
  }
  
  -- Define waypoint offsets from the start location (North, East)
  local waypoints = {
      {BOX_SIZE, 0},
      {BOX_SIZE, BOX_SIZE},
      {0, BOX_SIZE},
      {0, 0}
  }
  
  function update()
      -- Use rc:get_pwm() which is the correct function
      if rc:get_pwm(8) > 1800 then
          if not state.active then
              -- Start the pattern
              state.active = true
              state.stage = 1
              state.start_location = ahrs:get_location()
              if state.start_location then
                  local target = state.start_location:copy()
                  target:offset(waypoints[state.stage][1], waypoints[state.stage][2])
                  vehicle:set_target_location(target)
              end
          end
      else
          -- Reset the pattern if the switch is low
          state.active = false
          state.stage = 0
          state.start_location = nil
      end
  
      if state.active and state.start_location then
          local current_pos = ahrs:get_location()
          if current_pos then
              local target = state.start_location:copy()
              target:offset(waypoints[state.stage][1], waypoints[state.stage][2])
              if current_pos:get_distance(target) < 2 then -- 2 meter arrival radius
                  state.stage = state.stage + 1
                  if state.stage > #waypoints then
                      -- Pattern complete, reset
                      state.active = false
                      state.stage = 0
                  else
                      local next_target = state.start_location:copy()
                      next_target:offset(waypoints[state.stage][1], waypoints[state.stage][2])
                      vehicle:set_target_location(next_target)
                  end
              end
          end
      end
      return update, 200
  end
  
  return update()
```

### 8.2. Battery Failsafe

* **Prompt:** "Create a Lua script that triggers a Return-to-Launch (RTL) when the battery voltage drops below 14.8 volts."  
* **Expected Lua Script:**  
```lua
  local LOW_VOLTAGE = 14.8
  local RTL_MODE = 6 -- Mode number for RTL in Copter
  
  function update()
      -- Use instance 1 (1-indexed) and check if it's healthy
      if battery:healthy(1) then
          if battery:voltage(1) < LOW_VOLTAGE then
              -- Use the correct integer mode number for set_mode()
              if vehicle:get_mode() ~= RTL_MODE then
                  vehicle:set_mode(RTL_MODE)
                  gcs:send_text(6, "Battery low, initiating RTL")
              end
          end
      end
      return update, 1000
  end
  
  return update()
```

### 8.3. Landing Gear Control

* **Prompt:** "Create a Lua script that deploys the landing gear (servo on output 9\) when the drone's altitude is below 10 meters and retracts it above 10 meters."  
* **Expected Lua Script:**
```lua
  local LANDING_GEAR_ALTITUDE_M = 10 -- meters
  local SERVO_OUTPUT_CHAN = 8 -- 0-indexed channel for SERVO9
  local DEPLOYED_PWM = 1900
  local RETRACTED_PWM = 1100
  
  local gear_deployed = false
  
  function update()
      local loc = ahrs:get_location()
      if loc and loc:relative_alt() then
          -- get_location():alt() is in CM and is AMSL.
          -- We must get relative altitude and convert it to meters.
          local current_alt_m = loc:alt() / 100.0
  
          if current_alt_m < LANDING_GEAR_ALTITUDE_M then
              if not gear_deployed then
                  -- Use SRV_Channels object and set_output_pwm_chan (0-indexed)
                  SRV_Channels:set_output_pwm_chan(SERVO_OUTPUT_CHAN, DEPLOYED_PWM)
                  gear_deployed = true
              end
          else
              if gear_deployed then
                  SRV_Channels:set_output_pwm_chan(SERVO_OUTPUT_CHAN, RETRACTED_PWM)
                  gear_deployed = false
              end
          end
      end
      return update, 500
  end
  
  return update()
```

## 9\. Working with Aider and a Local ArduPilot Codebase

This section provides a guide for using a tool like aider to directly modify a local clone of the ArduPilot git repository. This workflow is ideal for making changes to existing scripts or autotests.

### 9.1. File Locations

To work with existing scripts, you need to know where they are located within the ArduPilot source tree. When creating new scripts, they should be placed in the appropriate subdirectory based on their function.

* **Lua Scripts**: The source for all Lua scripts is located in the libraries/AP\_Scripting/ directory. They are organized into subdirectories based on their type:  
  * applets/  
  * drivers/  
  * examples/  
* **Autotests**: The Python-based SITL autotests for Lua scripts are located in Tools/autotest/. The tests are vehicle-specific and should be added to the appropriate file (e.g., arducopter.py).

### 9.2. Aider Workflow

The workflow is a two-step conversation between the primary LLM and the user operating aider. The primary LLM generates the code and instructions, and the user applies them via aider.

**Example Workflow:**

Let's say you want to modify the copter\_terrain\_brake.lua applet and add a corresponding autotest.

1. **LLM Requests Files**: The primary LLM first determines wqhich files need to be modified and asks the user to add them to the aider chat.  
   **LLM Output (Step 1):**"I have the requested changes. Please add the following files to the aider chat so I can provide the edits: libraries/AP\_Scripting/applets/copter\_terrain\_brake.lua and Tools/autotest/arducopter.py."  
2. **User Adds Files**: The user adds the requested files to their local aider instance.  
   /add libraries/AP\_Scripting/applets/copter\_terrain\_brake.lua Tools/autotest/arducopter.py

3. **LLM Provides Edits**: Once the files are in the chat context, the primary LLM provides the edits in the required diff format.  
   **LLM Output (Step 2):**"Thank you. Please apply the following changes."  
   (The diff blocks containing the code changes would follow here.)  
4. **User Approves Edits**: The user then approves the changes within aider to apply them to the local files.

By following this process, the primary LLM can handle the creative/logic-based tasks, while aider acts as a tool to execute the changes.

### 9.3. Aider Output Format

<MANDATORY\_RULE\>
When generating changes for existing files, the output must be a set of edits in a diff-style format, using Unix-style line endings (\\n). Do not provide the entire file content unless the file is new. The edits should be clear and easy to apply.  
</MANDATORY\_RULE\>

### 9.4. Commit Message Conventions

<MANDATORY\_RULE\>
When committing changes to the ArduPilot repository, all commits must follow the standard ArduPilot conventions.  
</MANDATORY\_RULE\>

* **Atomic Commits**: Each commit should represent a single, logical change. For example, a change to a Lua applet and the addition of its corresponding autotest should be in two separate commits. Do not bundle unrelated changes into a single commit.  
* **Commit Message Prefix**: The subject line of every commit message **must** be prefixed with the name of the top-level module being changed, followed by a colon. The module is typically the subdirectory within the libraries/ or Tools/ directory where the file is located.  
  * **Example for a Lua script change:**  
    AP\_Scripting: Add new terrain brake applet

  * **Example for an autotest change:**  
    Tools: Add autotest for the terrain brake applet  


## 10. Final Deliverable Checklist

Before concluding a script generation task, the following checklist **must** be completed. All three components are required for a complete Applet deliverable.

1.  **[ ] Lua Script File (`.lua`):**
    * Does the script include a descriptive header comment?
    * Does it include all mandatory precondition `assert()` checks (Rule 5.3)?
    * Does it provide GCS feedback for significant state changes?
    * Is it free of `luacheck` errors and warnings?

2.  **[ ] Markdown Documentation File (`.md`):**
    * Has a complete `.md` file been generated?
    * Does it clearly explain the script's purpose?
    * Does it document all script-specific parameters (`*_ENABLE`, `*_RADIUS`, etc.)?
    * Does it provide clear setup instructions, including the required `RCx_OPTION` for the activation switch?

3.  **[ ] SITL Autotest Offer:**
    * Have you explicitly offered to generate a SITL autotest to verify the script's functionality?
    * Are you prepared to add the test as a new method to the appropriate vehicle test suite (e.g., `arducopter.py`) as per the playbook rules?



================================================
File: ai/AI_VEHICLE_CONTROL_PLAYBOOK.md
================================================
# **ArduPilot Lua Scripting: Functional Guides**

Welcome to the functional guides for ArduPilot Lua scripting. This resource organizes the scripting API by the *task you want to accomplish*, helping you discover the right functions for your needs. For complete details on each function, including all parameters and return values, please refer to the full **API Reference**.

### **1\. Reading Vehicle State & Telemetry**

This guide covers the essential functions for accessing the vehicle's real-time data, such as its position, attitude, and sensor readings. This is the foundation for any script that needs to be aware of the vehicle's status.

* **Primary Objects:** ahrs, gps, baro, battery

| Function/Method | Description |
| :---- | :---- |
| **ahrs:get\_location()** | Retrieves the vehicle's best-estimate position as a Location object. |
| **ahrs:get\_velocity\_NED()** | Gets the vehicle's current velocity in the North-East-Down frame. |
| **ahrs:get\_roll\_rad()** | Returns the current roll angle in radians. |
| **ahrs:get\_pitch\_rad()** | Returns the current pitch angle in radians. |
| **ahrs:get\_yaw\_rad()** | Returns the current yaw angle in radians. |
| **ahrs:healthy()** | Checks if the main attitude and heading reference system is providing reliable data. |
| **gps:status(instance)** | Gets the fix status for a specific GPS instance (e.g., 3D Fix, RTK Fixed). |
| **gps:num\_sats(instance)** | Returns the number of satellites being tracked by a specific GPS. |
| **baro:get\_altitude()** | Gets the current barometric altitude in meters. |
| **battery:voltage(instance)** | Gets the voltage of a specific battery. |
| **battery:capacity\_remaining\_pct(instance)** | Gets the remaining capacity of a battery as a percentage. |

### **2\. Controlling Vehicle Movement**

This guide focuses on functions that actively control the vehicle's movement. These commands are only effective when the vehicle is in a mode that accepts external guidance, such as **Guided** or **Auto** (during a NAV\_SCRIPT\_TIME command). The underlying implementation for these commands is the ModeGuided controller, and its behavior can be fine-tuned using the GUID\_OPTIONS parameter.

#### **Movement Control Types**

There are three main types of movement control, each with different levels of abstraction:

* **Position Control:** The safest method. You command a target position or velocity, and the autopilot's internal controllers manage the attitude and rates required to get there. The autopilot will not allow the vehicle to become inverted.  
* **Angle Control:** More direct than position control. You command a target attitude (roll, pitch, yaw), and the autopilot works to maintain it. The autopilot will still prevent the vehicle from becoming inverted.  
* **Rate Control:** The most direct method. You command specific rotational rates. This gives the script full control but also full responsibility. The script **must** monitor the vehicle's attitude and stop the rotation to achieve a desired outcome. This mode *can* allow the vehicle to go inverted if not managed carefully. If new rate commands are not received within a timeout period (set by GUID\_TIMEOUT), the vehicle will automatically stop rotating as a safety measure.

#### **Position Control**

* **Primary Object:** vehicle

| Function/Method | Description |
| :---- | :---- |
| **vehicle:set\_target\_location(Location\_ud)** | Commands the vehicle to fly to a specific geographic location. |
| **vehicle:set\_target\_velocity\_NED(Vector3f\_ud)** | Commands the vehicle to fly at a specific velocity in the North-East-Down frame. |
| **vehicle:set\_target\_pos\_NED(...)** | Commands the vehicle to fly to a position relative to the EKF origin, with optional yaw control. |

#### **Angle Control**

* **Primary Object:** vehicle

| Function/Method | Description |
| :---- | :---- |
| **vehicle:set\_target\_angle\_and\_climbrate(...)** | Sets a target roll, pitch, and yaw angle, along with a target climb rate. |

#### **Rate Control**

* **Primary Object:** vehicle

| Function/Method | Description |
| :---- | :---- |
| **vehicle:set\_target\_rate\_and\_throttle(...)** | Sets target roll, pitch, and yaw rates in degrees/second, along with a collective throttle value. |

#### **Combined Control (Advanced)**

These functions provide more granular control by allowing you to specify position, velocity, and acceleration targets simultaneously. This is useful for creating complex, smooth trajectories.

* **Primary Object:** vehicle

| Function/Method | Description |
| :---- | :---- |
| **vehicle:set\_target\_velaccel\_NED(...)** | Sets a target velocity and a feed-forward acceleration. Use this to command a smooth change in velocity. |
| **vehicle:set\_target\_posvel\_NED(...)** | Sets a target position and a target velocity. Use this to command the vehicle to arrive at a point with a specific speed and direction. |
| **vehicle:set\_target\_posvelaccel\_NED(...)** | Sets a target position, velocity, and acceleration. This provides the most complete control over the trajectory for advanced applications. The postion, velocity and acceleration define the instantaneous state of the target trajectory. This is interpolated forward in time until the next update is provided.The position controller will adjust it's own target trajectory to match.

#### **Controlling Yaw**

When using position or angle control methods, you can specify how the vehicle's yaw (heading) should behave.

| Control Type | Description |
| :---- | :---- |
| **Set Point Yaw** | Command a specific compass heading (e.g., 90 for East). The yaw\_relative flag determines if this is an absolute heading or relative to the vehicle's current direction. |
| **Rate-Controlled Yaw** | Command a specific rate of turn in degrees per second. The vehicle will continue to turn at this rate until a new command is issued. |

#### **Braking, Landing, and Other Actions**

These are fundamental actions for managing the flight lifecycle.

| Function/Method | Description |
| :---- | :---- |
| **Brake / Hold Position** | To stop the vehicle and hold its current position, send a zero-velocity command: vehicle:set\_target\_velocity\_NED(Vector3f()). |
| **Land** | The standard procedure to land is to command a mode change to the LAND flight mode using vehicle:set\_mode(). The vehicle will then perform an autonomous landing at its current location. |
| vehicle:start\_takeoff(altitude) | Initiates an autonomous takeoff to a specified altitude. |

#### **Querying the Current Target**

These functions allow your script to be aware of the vehicle's current navigation objective.

| Function/Method | Description |
| :---- | :---- |
| vehicle:get\_target\_location() | Gets the geographic location the vehicle is currently flying towards. |
| vehicle:get\_wp\_distance\_m() | Gets the distance in meters to the current waypoint target. |
| vehicle:get\_wp\_bearing\_deg() | Gets the bearing in degrees to the current waypoint target. |

#### **Advanced Control & Tuning**

The behavior of Guided mode can be modified with the GUID\_OPTIONS parameter. This is a bitmask, so you can combine options by adding their values together.

* **DoNotStabilizePositionXY (Bit 0, Value 1):** In velocity control mode, the autopilot will normally still try to hold its position and prevent drift. Setting this option disables that behavior, resulting in a "purer" velocity control where the vehicle may drift with wind.  
* **DoNotStabilizeVelocityXY (Bit 1, Value 2):** In acceleration control mode, the autopilot will normally try to hold velocity. Setting this option disables that behavior.  
* **WPNavUsedForPosControl (Bit 3, Value 8):** Changes the position controller from the simple pos\_control to the full wp\_nav controller. This allows for smoother pathing around corners but requires that set\_target\_location commands be sent at a lower rate.

### **3\. Managing Autonomous Missions**

This guide covers interaction with the onboard mission planner, allowing scripts to read, modify, and control the flow of pre-defined missions.

* **Primary Object:** mission

| Function/Method | Description |
| :---- | :---- |
| **mission:num\_commands()** | Returns the total number of commands in the current mission. |
| **mission:get\_item(index)** | Retrieves a single mission command at a specific index. |
| **mission:set\_item(index, item)** | Sets or updates a single mission command at a specific index. |
| **mission:set\_current\_cmd(index)** | Jumps the mission execution to the command at the specified index. |
| **mission:state()** | Returns the current status of the mission (e.g., Running, Complete, Stopped). |
| **mission:clear()** | Clears all commands from the current mission. |

### **4\. GCS Communication & Logging**

This guide explains how to send information back to the Ground Control Station (GCS) and how to write custom data to the vehicle's onboard logs for post-flight analysis.

* **Primary Objects:** gcs, logger

| Function/Method | Description |
| :---- | :---- |
| **gcs:send\_text(severity, text)** | Sends a text message to the GCS message console. |
| **gcs:send\_named\_float(name, value)** | Sends a named floating-point value for real-time graphing or display in the GCS. |
| **logger:write(name, labels, format, ...)** | Writes a custom entry to the onboard dataflash log. |

### **5\. Interacting with Parameters**

This guide covers how to read and write ArduPilot's configuration parameters from within a script.

* **Primary Objects:** param, Parameter()

| Function/Method | Description |
| :---- | :---- |
| **param:get(name)** | Gets a parameter's current value by its name. |
| **param:set(name, value)** | Sets a parameter's value for the current session only (does not persist). |
| **param:set\_and\_save(name, value)** | Sets a parameter's value and saves it to permanent storage. |
| **Parameter(name)** | Creates a more efficient helper object for a parameter that will be accessed frequently. |

### **6\. Controlling Peripherals & I/O**

This guide details how to control physical outputs like servos, relays, and GPIO pins, and how to read from inputs.

* **Primary Objects:** SRV\_Channels, relay, gpio

| Function/Method | Description |
| :---- | :---- |
| **SRV\_Channels:set\_output\_pwm\_chan(chan, pwm)** | Sets the raw PWM value for a specific servo output channel. |
| **SRV\_Channels:set\_output\_scaled(function, value)** | Sets a normalized output value (-1 to 1\) for a channel assigned a specific function. |
| **relay:on(instance)** | Turns a specific relay on. |
| **relay:toggle(instance)** | Toggles the state of a specific relay. |
| **gpio:write(pin\_number, value)** | Writes a high (1) or low (0) value to a GPIO pin configured as an output. |
| **gpio:read(pin\_number)** | Reads the state of a GPIO pin configured as an input. |

### **7\. Dealing with Radio Control (RC) Input**

This guide covers how to read the pilot's stick inputs from the RC transmitter and how to respond to auxiliary switch changes. This is essential for scripts that allow for manual override or mode changes based on pilot input.

Note: The specific channel numbers for the primary flight controls (roll, pitch, throttle, yaw) are mapped by the user. Your script should read the RCMAP\_ROLL, RCMAP\_PITCH, RCMAP\_THROTTLE, and RCMAP\_YAW parameters to determine the correct channels to use.

* **Primary Objects:** rc, RC\_Channel\_ud, param

| Function/Method | Description |
| :---- | :---- |
| **param:get("RCMAP\_PITCH")** | Reads a parameter's value; use this to find the correct channel for each flight control. |
| **rc:get\_channel(chan\_num)** | Gets an object representing a single RC channel (e.g., channel 3 for throttle). |
| **rc:has\_valid\_input()** | Checks if the RC receiver has a valid signal and is not in failsafe. |
| **RC\_Channel\_ud:get\_pwm()** | Returns the raw PWM value (typically 1000-2000) of a specific channel. |
| **RC\_Channel\_ud:norm\_input()** | Returns the normalized input (-1 to 1\) of a channel, centered on the trim. |
| **RC\_Channel\_ud:norm\_input\_dz()** | Returns the normalized input (-1 to 1), but returns exactly 0 when the stick is within the deadzone. |
| **rc:find\_channel\_for\_option(aux\_fun)** | Finds which RC channel is assigned to a specific auxiliary function (e.g., RCx\_OPTION). |
| **RC\_Channel\_ud:get\_aux\_switch\_pos()** | For a channel assigned to a switch, this returns the current switch position (0, 1, or 2). |




================================================
File: applets/README.md
================================================
# LUA Applets

Unlike the code in the examples directory, these are complete applets that required no user editing of the file for use. Each one has an .md file describing its operation and any switches or parameters in ArduPilot that are required for operation. The user only has to copy the applet to APM/scripts directory on their SD card, in order to install. Of course, scripting must be enabled via SCR_ENABLE =1 and the autopilot be capable of running scripts. See the Wiki for Lua Scripting under Advanced Configuration.

Each will have a Wiki entry mirroring the .md file'd contents with a link back to this directory.


================================================
File: applets/BattEstimate.lua
================================================
--[[
   battery state of charge (SOC) estimator based on resting voltage

   See Tools/scripts/battery_fit.py for a tool to calculate the coefficients from a log
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 14
local PARAM_TABLE_PREFIX = "BATT_SOC"

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup quicktune specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 32), 'could not add param table')

--[[
  // @Param: BATT_SOC_COUNT
  // @DisplayName: Count of SOC estimators
  // @Description: Number of battery SOC estimators
  // @Range: 0 4
  // @User: Standard
--]]
local BATT_SOC_COUNT     = bind_add_param('_COUNT', 1, 0)

if BATT_SOC_COUNT:get() <= 0 then
   return
end

--[[
  // @Param: BATT_SOC1_IDX
  // @DisplayName: Battery estimator index
  // @Description: Battery estimator index
  // @Range: 0 4
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC1_NCELL
  // @DisplayName: Battery estimator cell count
  // @Description: Battery estimator cell count
  // @Range: 0 48
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC1_C1
  // @DisplayName: Battery estimator coefficient1
  // @Description: Battery estimator coefficient1
  // @Range: 100 200
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC1_C2
  // @DisplayName: Battery estimator coefficient2
  // @Description: Battery estimator coefficient2
  // @Range: 2 5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC1_C3
  // @DisplayName: Battery estimator coefficient3
  // @Description: Battery estimator coefficient3
  // @Range: 0.01 0.5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC1_C4
  // @DisplayName: Battery estimator coefficient4
  // @Description: Battery estimator coefficient4
  // @Range: 5 100
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_IDX
  // @DisplayName: Battery estimator index
  // @Description: Battery estimator index
  // @Range: 0 4
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_NCELL
  // @DisplayName: Battery estimator cell count
  // @Description: Battery estimator cell count
  // @Range: 0 48
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_C1
  // @DisplayName: Battery estimator coefficient1
  // @Description: Battery estimator coefficient1
  // @Range: 100 200
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_C2
  // @DisplayName: Battery estimator coefficient2
  // @Description: Battery estimator coefficient2
  // @Range: 2 5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_C3
  // @DisplayName: Battery estimator coefficient3
  // @Description: Battery estimator coefficient3
  // @Range: 0.01 0.5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC2_C4
  // @DisplayName: Battery estimator coefficient4
  // @Description: Battery estimator coefficient4
  // @Range: 5 100
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_IDX
  // @DisplayName: Battery estimator index
  // @Description: Battery estimator index
  // @Range: 0 4
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_NCELL
  // @DisplayName: Battery estimator cell count
  // @Description: Battery estimator cell count
  // @Range: 0 48
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_C1
  // @DisplayName: Battery estimator coefficient1
  // @Description: Battery estimator coefficient1
  // @Range: 100 200
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_C2
  // @DisplayName: Battery estimator coefficient2
  // @Description: Battery estimator coefficient2
  // @Range: 2 5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_C3
  // @DisplayName: Battery estimator coefficient3
  // @Description: Battery estimator coefficient3
  // @Range: 0.01 0.5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC3_C4
  // @DisplayName: Battery estimator coefficient4
  // @Description: Battery estimator coefficient4
  // @Range: 5 100
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_IDX
  // @DisplayName: Battery estimator index
  // @Description: Battery estimator index
  // @Range: 0 4
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_NCELL
  // @DisplayName: Battery estimator cell count
  // @Description: Battery estimator cell count
  // @Range: 0 48
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_C1
  // @DisplayName: Battery estimator coefficient1
  // @Description: Battery estimator coefficient1
  // @Range: 100 200
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_C2
  // @DisplayName: Battery estimator coefficient2
  // @Description: Battery estimator coefficient2
  // @Range: 2 5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_C3
  // @DisplayName: Battery estimator coefficient3
  // @Description: Battery estimator coefficient3
  // @Range: 0.01 0.5
  // @User: Standard
--]]

--[[
  // @Param: BATT_SOC4_C4
  // @DisplayName: Battery estimator coefficient4
  // @Description: Battery estimator coefficient4
  // @Range: 5 100
  // @User: Standard
--]]

local params = {}
local last_armed_ms = uint32_t(0)

--[[
   add parameters for an estimator
--]]
function add_estimator(i)
   id = string.format("%u_", i)
   pidx = 2+(i-1)*5
   params[i] = {}
   params[i]['IDX']   = bind_add_param(id .. "IDX",     pidx+0, 0)
   params[i]['NCELL'] = bind_add_param(id .. "NCELL", pidx+1, 0)
   params[i]['C1']    = bind_add_param(id .. "C1", pidx+2, 111.56)
   params[i]['C2']    = bind_add_param(id .. "C2", pidx+3, 3.65)
   params[i]['C3']    = bind_add_param(id .. "C3", pidx+4, 0.205)

   -- place the 4th coefficients at the end for backwards compatibility
   c4_pidx = 2+4*5+(i-1)
   params[i]['C4']    = bind_add_param(id .. "C4", c4_pidx, 80.0)
end

-- limit to 4 estimators even if the parameter specifies more
local count = math.min(math.floor(BATT_SOC_COUNT:get() or 0), 4)
for i = 1, count do
   add_estimator(i)
end

local function constrain(v, vmin, vmax)
   return math.max(math.min(v, vmax), vmin)
end

--[[
   simple model of state of charge versus resting voltage.
   With thanks to Roho for the form of the equation
   https://electronics.stackexchange.com/questions/435837/calculate-battery-percentage-on-lipo-battery

   Adjusted to also fit other battery chemistries such as Li-ion.
--]]
local function SOC_model(cell_volt, c1, c2, c3, c4)
    local soc = c1*(1.0-1.0/(1+(cell_volt/c2)^c4)^c3)
    return constrain(soc, 0, 100)
end

--[[
   update one estimator
--]]
local function update_estimator(i)
   local idx = math.floor(params[i]['IDX']:get())
   local ncell = math.floor(params[i]['NCELL']:get())
   if idx <= 0 or ncell <= 0 then
      return
   end
   local C1 = params[i]['C1']:get()
   local C2 = params[i]['C2']:get()
   local C3 = params[i]['C3']:get()
   local C4 = params[i]['C4']:get()
   local num_batts = battery:num_instances()
   if idx > num_batts then
      return
   end
   local voltR = battery:voltage_resting_estimate(idx-1)
   local soc = SOC_model(voltR/ncell, C1, C2, C3, C4)
   battery:reset_remaining(idx-1, soc)
end

--[[
   main update function, called at 1Hz
--]]
function update()
   local now_ms = millis()
   if arming:is_armed() then
      last_armed_ms = now_ms
      return update, 1000
   end
   -- don't update for 10s after disarm, to get logging of charge recovery
   if now_ms - last_armed_ms < 10000 then
      return update, 1000
   end
   for i = 1, #params do
      update_estimator(i)
   end
   return update, 1000
end

gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded BattEstimate for %u batteries", #params))

-- start running update loop
return update, 1000




================================================
File: applets/BattEstimate.md
================================================
# Battery State of Charge Estimator

This script implements a battery state of charge estimator based on
resting voltage and a simple cell model.

This allows the remaining battery percentage to be automatically set
based on the resting voltage when disarmed.

# Parameters

You will need to start by setting BATT_SOC_COUNT to the number of
estimators you want (how many batteries you want to do SoC estimation
for).

Then you should restart scripting or reboot and set the following
parameters per SoC estimator.

## BATT_SOCn_IDX

The IDX is the battery index, starting at 1.

## BATT_SOCn_NCELL

Set the number of cells in your battery in the NCELL parameter

## BATT_SOCn_C1

C1 is the first coefficient from your fit of your battery

## BATT_SOCn_C2

C2 is the second coefficient from your fit of your battery

## BATT_SOCn_C3

C3 is the third coefficient from your fit of your battery

## BATT_SOCn_C4

C4 is the fourth coefficient from your fit of your battery

# Usage

You need to start by working out the coefficients C1, C2, C3 and C4 for
your battery. You can do this by starting with a fully charged battery
and slowly discharging it with LOG_DISARMED set to 1. Alternatively you
can provide a CSV file with battery percentage in the first column and
voltage in the 2nd column.

Then run the resulting log or csv file through the script at
Tools/scripts/battery_fit.py. The fitting process is designed to work
reliably with LiPo and Li-ion batteries and is generally effective for
other battery chemistries as well, but users should verify that the fit
is accurate for their specific case.

You will need to tell the script the following:

 - the number of cells
 - the final percentage charge your log stops at
 - the battery index you want to fit to (1 is the first battery)

That will produce a graph and a set of coefficients like this:
 - Coefficients C1=111.5629 C2=3.6577 C3=0.2048 C4=80.0000

Use the C1, C2, C3 and C4 parameters in the parameters for this script.

The remaining battery percentage is only set when disarmed, and won't
be set till 10 seconds after you disarm from a flight.





================================================
File: applets/BatteryTag.lua
================================================
--[[
    update and log battery tag information from BatteryTag periph nodes
--]]

local GLOBALTIME_ID = 344
local GLOBALTIME_SIGNATURE = uint64_t(0xA5517744, 0x8A490F33)

local BATTERYTAG_ID = 20500
local BATTERYTAG_SIGNATURE = uint64_t(0x4A5A9B42, 0x099F73E1)

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

PARAM_TABLE_KEY = 49
PARAM_TABLE_PREFIX = "BTAG_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Setup Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'BatteryTag: could not add param table')

--[[
  // @Param: BTAG_ENABLE
  // @DisplayName: enable battery info support
  // @Description: enable battery info support
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local BTAG_ENABLE = bind_add_param('ENABLE',  1, 1)

--[[
  // @Param: BTAG_MAX_CYCLES
  // @DisplayName: max battery cycles
  // @Description: max battery cycles for arming
  // @Range: 0 10000
  // @User: Standard
--]]
local BTAG_MAX_CYCLES = bind_add_param('MAX_CYCLES',  2, 400)

if BTAG_ENABLE:get() == 0 then
    return
end

-- a handle for receiving BatteryTag messages
local batterytag_handle = DroneCAN_Handle(0, BATTERYTAG_SIGNATURE, BATTERYTAG_ID)
batterytag_handle:subscribe()

-- a handle for sending GlobalTime messages
local globaltime_handle = DroneCAN_Handle(0, GLOBALTIME_SIGNATURE, GLOBALTIME_ID)

-- ID for an arming check
local auth_id = arming:get_aux_auth_id()

local highest_cycles = 0

--[[
    check for BatteryTag messages
--]]
local function check_batterytag()
    local payload, nodeid = batterytag_handle:check_message()
    if not payload then
        return
    end
    local serial_num, num_cycles, arm_hours, capacity, first_use, last_arm = string.unpack("IIfIII", payload)
    if not serial_num then
        return
    end

    highest_cycles = math.max(num_cycles, highest_cycles)

    -- log battery information
    logger:write("BTAG",
                 'Node,Ser,NCycle,ArmHr,Cap,FirstUse,LastArm',
                 'BIIfIII',
                 '#------',
                 '-------',
                 nodeid,
                 serial_num, num_cycles, arm_hours,
                 capacity, first_use, last_arm)

    if auth_id then
        if highest_cycles > BTAG_MAX_CYCLES:get() then
            arming:set_aux_auth_failed(auth_id, string.format("Battery cycles too high: %d", highest_cycles))
        else
            arming:set_aux_auth_passed(auth_id)
        end
    end
end

local last_globaltime_send = millis()

--[[
    see if we should send GlobalTime message
--]]
local function check_globaltime()
    local now = millis()
    if now - last_globaltime_send < 1000 then
        return
    end
    if gps:num_sensors() < 1 or gps:status(0) < 3 then
        return
    end
    last_globaltime_send = now

    -- create 56 bit UTC microsecond timestamp
    local utc_usec = gps:time_epoch_usec(0)
    if utc_usec == 0 then
        return
    end
    local usec_hi,usec_lo = utc_usec:split()
    local payload8 = string.pack("II", usec_lo:toint(), usec_hi:toint())
    local payload7 = string.sub(payload8, 1, 7)
    globaltime_handle:broadcast(payload7)
end

local function update()
    if BTAG_ENABLE:get() ~= 0 then
        check_batterytag()
        check_globaltime()
    end
    return update, 200
end

gcs:send_text(MAV_SEVERITY.INFO, "BatteryTag loaded")

return update, 1000



================================================
File: applets/BatteryTag.md
================================================
# Battery Tag Support

This script implements logging of DroneCAN BatteryTag messages. It is
used in combination with a BatteryTag AP_Periph node to log
information about number of cycles a battery has been through along
with the serial number and number of hours in an armed state.

The data for each battery is logged in the BTAG log message

# Parameters

## BTAG_ENABLE

Allow for enable/disable of the script

## BTAG_MAX_CYCLES

Maximum number of battery cycles to allow arming




================================================
File: applets/Gimbal_Camera_Mode.lua
================================================
-- This script is a useful tool when using gimbal and camera. You can use it to switch between manual
-- and auto control for mission mode. It is meant for use with a transmitter that has a free switch
-- available.
-- The camera is setup for picture trigger during auto but can do other things e.g. video during
-- manual mode also. The script changes parameters but does not store them.
-- Setup Gimbal and Camera incl. manual control channels, then setting SCR_USER1 to 1 enables this script.

-- (known issue is that manual and auto mode do not have same travel as SERVOn_ settings are ignored
-- for "pass-through" RCINn channels - a scaled and bounded variant must be introduced and used here)

-- Tested and working as of 25th Aug 2020 (Copter Dev)
-- Derived from Heli_IM_COL_Tune.lua in https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Scripting/applets
-- Tested and working as of 9th and 24th of Oct 2021 (drtrigon)


function update()
    -- read switch input from designated scripting RCx_OPTION
    local rcin_select = select_switch_ch:get_aux_switch_pos()

    -- Save params only if switch changed
    if rcin_select ~= rcin_select_pre then
        if rcin_select == 0 then
             -- low: set gimbal and cam to manual mode (RCIN9, RCIN10, RCIN12)
            set_save_param('SERVO8_FUNCTION',59,false)
            set_save_param('SERVO9_FUNCTION',60,false)
            set_save_param('SERVO10_FUNCTION',62,false)

            gcs:send_text(6, 'LUA: Gimbal-Cam mode manual')  -- MAV_SEVERITY_INFO
        elseif rcin_select == 1 then
             -- middle: set gimbal to auto and cam to manual mode (mount_tilt, mount_roll, RCIN12)
            set_save_param('SERVO8_FUNCTION',7,false)
            set_save_param('SERVO9_FUNCTION',8,false)
            set_save_param('SERVO10_FUNCTION',62,false)

            gcs:send_text(6, 'LUA: Gimbal-Cam mode auto/manual')  -- MAV_SEVERITY_INFO
        else
             -- high: set gimbal and cam to auto mode (mount_tilt, mount_roll, camera_trigger)
            set_save_param('SERVO8_FUNCTION',7,false)
            set_save_param('SERVO9_FUNCTION',8,false)
            set_save_param('SERVO10_FUNCTION',10,false)

            gcs:send_text(6, 'LUA: Gimbal-Cam mode auto')  -- MAV_SEVERITY_INFO

            -- No script exit condition (runs always)
        end

        rcin_select_pre = rcin_select
    end

    -- Reschedule
    return script_cont_stop()
end


-- Standardised function for stopping or continuing
function script_cont_stop()
    -- Get SCR_USER1 parameter value and check whether to run or not
    if param:get('SCR_USER1') ~= 1 then  -- DISABLED (any number) or FAULT (nil)
--        gcs:send_text(6, string.format('LUA: %s = %i',param_name,value))  -- MAV_SEVERITY_INFO
--        gcs:send_text(6, 'LUA: Gimbal-Cam mode disabled')  -- MAV_SEVERITY_INFO

        rcin_select_pre = -1

--        return  -- stop running until reboot of FC
        return script_cont_stop, 10000  -- stop running until change of param +10s
    end

    -- Set RC channels to use to control gimbal and cam servo params
    -- SERVOn_FUNCTION = 7 (mount_tilt)      -> SERVO8_FUNCTION   and   MNT_RC_IN_TILT -> RC9  -> RCIN9  (59)
    -- SERVOn_FUNCTION = 8 (mount_roll)      -> SERVO9_FUNCTION   and   MNT_RC_IN_ROLL -> RC10 -> RCIN10 (60)
    -- SERVOn_FUNCTION = ? (mount_pan)       -> ...
    -- SERVOn_FUNCTION = 10 (camera_trigger) -> SERVO10_FUNCTION  and   RCn_OPTION = 9 (Camera Trigger) -> RC12_OPTION -> RCIN12 (62)

    -- Set RC channels to use to control gimbal and cam servo params
    select_switch_ch = rc:find_channel_for_option(300) --scripting ch 1
    if (select_switch_ch == nil) then  -- NORC
        gcs:send_text(3, 'LUA: RC channels not set')  -- MAV_SEVERITY_ERROR

        return script_cont_stop, 10000  -- stop running until valid param +10s
    end

    -- Script is HEALTHY, continue running update() (in fast loop)
--    return update, 500
    return update, 1000
end


-- function for setting and saving parameter
function set_save_param(str,val,save)
    if save then
        -- Set and save
        if param:set_and_save(str,val) then
            gcs:send_text(2, 'LUA: params saved')  -- MAV_SEVERITY_CRITICAL
        else
            gcs:send_text(2, 'LUA: param set failed')  -- MAV_SEVERITY_CRITICAL
        end
    else
        -- Just set
        if not(param:set(str,val)) then
            gcs:send_text(2, 'LUA: param set failed')  -- MAV_SEVERITY_CRITICAL
        end
    end
end


--- -- -- Initial Setup --- --- ---
-- Script status buffers
rcin_select_pre = -1

gcs:send_text(6, 'LUA: Gimbal-Cam mode started')  -- MAV_SEVERITY_INFO

-- Only continue running script if healthy
return script_cont_stop()



================================================
File: applets/Gimbal_Camera_Mode.md
================================================
# Gimbal_Camera_Mode Lua Script

This script is a useful tool when using gimbal and camera. You can use it to switch between manual
and auto control for mission mode. It is meant for use with a transmitter that has a free switch
available (3-pos).

## How it works

The camera is setup for picture trigger during auto but can do other things e.g. video during
manual mode also. The script changes parameters but does not store them.
It changes the `SERVO<X>_FUNCTION`s and switches between `RCIN<X>` (pass-through) and `mount_tilt`,
`mount_roll` and `camera_trigger`.
In order to see the stored parameter values, disable the script (SCR_USER1) and reboot the FC.

## Modes

The control modes set by the 3-pos switch are as follows:

- Gimbal-Cam mode manual: Gimbal and Camera in manual control mode (pass-through)

- Gimbal-Cam mode auto/manual: Gimbal auto and Camera in manual control mode

- Gimbal-Cam mode auto: Gimbal and Camera in auto control mode (controlled by ArduPilot and mission)

## Setup and Use

- If you have not done so already, follow the instructions on ArduPilot's wiki page to enable auto camera and gimbal control.

- Also configure channels for manual control.
 
- For example I then have (to convert the values use https://ardupilot.org/copter/docs/parameters.html):

  - SERVO8_FUNCTION = 7 (mount_tilt)   leads to   MNT_RC_IN_TILT = 9 (RC9)     and to   RCIN9  (59)

  - SERVO9_FUNCTION = 8 (mount_roll)   leads to   MNT_RC_IN_ROLL = 10 (RC10)   and to   RCIN10 (60)

  - SERVOn_FUNCTION = ? (mount_pan)   is not used in this example

  - SERVO10_FUNCTION = 10 (camera_trigger)   leads to   RC12_OPTION = 9 (Camera Trigger)   and to   RCIN12 (62)

- Now fill these into the script Gimbal_Camera_Mode.lua:

- - -
     -- low: set gimbal and cam to manual mode (RCIN9, RCIN10, RCIN12)
    set_save_param('SERVO8_FUNCTION',59,false)
    set_save_param('SERVO9_FUNCTION',60,false)
    set_save_param('SERVO10_FUNCTION',62,false)
- - -
     -- middle: set gimbal to auto and cam to manual mode (mount_tilt, mount_roll, RCIN12)
    set_save_param('SERVO8_FUNCTION',7,false)
    set_save_param('SERVO9_FUNCTION',8,false)
    set_save_param('SERVO10_FUNCTION',62,false)
- - -
     -- high: set gimbal and cam to auto mode (mount_tilt, mount_roll, camera_trigger)
    set_save_param('SERVO8_FUNCTION',7,false)
    set_save_param('SERVO9_FUNCTION',8,false)
    set_save_param('SERVO10_FUNCTION',10,false)
- - -
   (these settings in 'update()' could be automatically derived if Gimbal and Camera are fully setup, but
   that would cause a bigger memory footprint of the script and increase the chance of faulty behaviour also)
- - -

- To get appropriate feedback from the script it is advised to set `SCR_DEBUG_LVL` to 3 during setup.

- Load the modified Gimbal_Camera_Mode.lua to the 'scripts' folder on your flight controller.

- Reboot your flight controller.

- Set `RC<X>_OPTION` to 300 for the RC input channel that corresponds to the switch that you would like to control the mode.

- Set `SCR_USER1` to 1 in order to enable the script and allow it to run.

- Test the script by moving the switch and checking the log messages output.

## Output Messages

### "LUA: Gimbal-Cam mode started"

The script has been started and runs now.

This message is usually immediately followed by "LUA: Gimbal-Cam mode < X >". If NOT, it might be disabled, check `SCR_USER1`. The script should run as soon as setting `SCR_USER1` to 1 (if not, there is a major error with lua scripting in general as the parameter `SCR_USER1` cannot be read).

### "LUA: RC channels not set"

The RC channel is not set to the scripting channel (300). Set it!

### "LUA: Gimbal-Cam mode < X >"

Mode chosen, confer 'Modes' above.

### "LUA: param set failed"

Failed to set parameter.  Script will persist to try and set parameters without exiting.  If this message continues to show, consider landing and investigating the underlying issue.

## Known Issues

Manual and auto modes do not have same travel as SERVOn_ settings are ignored for "pass-through" RCINn channels - a scaled and bounded variant must be introduced and used here.



================================================
File: applets/Heli_IM_COL_Tune.lua
================================================
-- This script is a useful tool when first setting up a heli.  You can use it to dial in the IM_STB_COL_2 and 
-- IM_STAB_COL_3 parameters in a more intuative way.  It is meant for use with a transmitter that has two pots
-- available.  1 Pot can be used to control the gradient of the line between the 40% and 60% curve points.  Use 
-- this pot to adjust the sensitivity of the collective about the collective midstick.  The 2nd Pot then controls
-- the value of the 50% point on the curve.  This can be used to set the collective position to aid with hovering 
-- at the midstick.

-- Tested and working as of 25th Aug 2020 (Copter Dev)

function update()
    local rcin_50 = col50_val_ch:norm_input_ignore_trim()
    local rcin_grad = col_grad_ch:norm_input_ignore_trim()
    rcin_save = save_switch_ch:get_aux_switch_pos()

    -- Offset starting midstick curve value to get new value
    -- Max = +30% , Min = -30%
    local im_50 = (value_im_3 + value_im_2) * 0.5 --(%)
    local delta_50 = rcin_50*30
    im_50 = im_50 + delta_50

    -- Scale rcin_grad to be between 0 and 1
    rcin_grad = (rcin_grad+1)*0.5

    -- Calculate delta due to gradient
    local grad_40 = rcin_grad * -10 --(%)
    local grad_60 = rcin_grad * 10 --(%)

    -- Calculate param values
    local im_40_pct = im_50+grad_40
    local im_60_pct = im_50+grad_60

    -- Ensure IM_STB_COL_2 < IM_STB_COL_3
    if im_40_pct >= im_60_pct then
        im_40_pct = im_60_pct - 1
    end

    -- Ensure IM_STB_COL_2 and IM_STB_COL_3 are withing appropriate ranges
    im_40_pct = min_max(math.floor(im_40_pct),1,98)
    im_60_pct = min_max(math.floor(im_60_pct),2,99)

    -- Enforce that IM_STB_COL_1 < IM_STB_COL_2
    local im_0_pct = get_im_val('IM_STB_COL_1',false)
    if im_0_pct >= im_40_pct then
        -- Correct within parameter limits
        im_0_pct = min_max(im_40_pct - 1,0,97)

        -- Set correct value to prevent pre-arm warnings
        set_save_param('IM_STB_COL_1',im_0_pct,false)
    end

    -- Enforce that IM_STB_COL_4 > IM_STB_COL_3
    im_100_pct = get_im_val('IM_STB_COL_4',false)
    if im_100_pct <= im_60_pct then
        -- Correct within parameter limits
        im_100_pct = min_max(im_60_pct + 1,3,100)

        -- Set correct value to prevent pre-arm warnings
        set_save_param('IM_STB_COL_4',im_100_pct,false)
    end

    -- Save params only if switch active
    if rcin_save < 1 then
         -- just set 40% and 60% parameter values
        set_save_param('IM_STB_COL_2',im_40_pct,false)
        set_save_param('IM_STB_COL_3',im_60_pct,false)
    else
        set_save_param('IM_STB_COL_1',im_0_pct,true)
        set_save_param('IM_STB_COL_2',im_40_pct,true)
        set_save_param('IM_STB_COL_3',im_60_pct,true)
        set_save_param('IM_STB_COL_4',im_100_pct,true)

        -- Set script exit condition
        script_status = COMPLETE
    end

    -- Reschedule
    foo, sched = script_cont_stop()
    return foo, sched
end


-- Get parameter value and perform checks to ensure successful
function get_im_val(param_name,disp)
    local value = param:get(param_name)

    if value >= 0 then
        if disp then
            gcs:send_text(3, string.format('LUA: %s = %i',param_name,value))
        end
    else
        gcs:send_text(3, string.format('LUA: Failed get %s',param_name))
        script_status = false
    end

    return value
end


-- Prevent parameters from being set out of range
function min_max(value,min,max)
    if value < min then
        value = min
    end

    if value > max then
        value = max
    end

    return value
end


-- Standardised function for stopping or continuing
function script_cont_stop()
    if script_status == HEALTHY then
        return update, 500

    elseif script_status == COMPLETE then
        gcs:send_text(2, 'LUA: IM_COL tune complete')

    elseif script_status == NORC then
        gcs:send_text(2, 'LUA: RC channels not set')

    else --FAULT
        gcs:send_text(2, 'LUA: IM_COL setter stopped')
    end
end


-- function for setting and saving parameter
function set_save_param(str,val,save)
    if save then
        -- Set and save
        if param:set_and_save(str,val) then
            gcs:send_text(2, 'LUA: params saved')
        else
            gcs:send_text(2, 'LUA: param set failed')
        end
    else
        -- Just set
        if not(param:set(str,val)) then
            gcs:send_text(2, 'LUA: param set failed')
        end
    end
end

--- -- -- Initial Setup --- --- ---
-- Script status levels
FAULT = 0
NORC = 1
HEALTHY = 2
COMPLETE = 3

script_status = HEALTHY

-- Set RC channels to use to control im_stb_col params
col50_val_ch = rc:find_channel_for_option(300) --scripting ch 1
col_grad_ch = rc:find_channel_for_option(301) --scripting ch 2
save_switch_ch = rc:find_channel_for_option(302) --scripting ch 3

if (col50_val_ch == nil or col_grad_ch == nil or save_switch_ch == nil) then
    script_status = NORC
end

-- Get im_stb_col parameter values and store
value_im_2 = get_im_val('IM_STB_COL_2',true)
value_im_3 = get_im_val('IM_STB_COL_3',true)

-- Only continue running script if healthy
foo, sched = script_cont_stop()
return foo, sched



================================================
File: applets/Heli_IM_Col_Tune.md
================================================
# Heli_IM_Col_Tune Lua Script

This is a useful tool when setting up a traditional heli.  It is used to tune the `IM_STAB_COL_<X>` input curve.  Typically, it is awkward to tune the `IM_STAB_COL_2` and `IM_STAB_COL_3` parameters to get the heli hovering around mid-stick with the desired finesse to maintain the hover, unless you have someone working on the GCS for you.  This tool provides a more intuitive approach using two pots on your RC transmitter.

## How it works

One pot controls the output value that correlates to the 50% input (i.e. mid-stick position).  The other pot will control the sensitivity of the collective from the 40% to the 60% input values (i.e. the gradient of the curve between 40% and 60%).  It then converts the 50% value and the gradient to appropriate values for `IM_STAB_COL_2` and `IM_STAB_COL_3`.  Once you are happy with the tune, flick the save switch on the transmitter and script will save the parameter values and exit the script.

The script updates the parameters every 0.5 seconds based on the position of the pots, allowing for easy tuning until the desired 'feel' is achieved.

It is worth noting that this script preserves the constraints set by ArduPilot:

0 <= `IM_STAB_COL_1` < `IM_STAB_COL_2` < `IM_STAB_COL_3` < `IM_STAB_COL_4` <= 100

As a result, if `IM_STAB_COL_1` or `IM_STAB_COL_4` are set to values that would violate the above constraint, after either `IM_STAB_COL_2` or `IM_STAB_COL_3` are changed by the script, then this script will modify the values of COL_1 and COL_4 to ensure this rule is met.

## Limits

The limits imposed on the values controlled by the pots are as follows:

- The mid-stick output value can be changed +/- 30%, centered on the initial mid-stick output value when the script is initialised.

- The maximum gradient is +100%

- The minimum gradient is +5%.

## Setup and Use

 - If you have not done so already, follow the instructions on ArduPilot's wiki page to enable scripting.

 - To get appropriate feedback from the script it is advised to set `SCR_DEBUG_LVL` to 3.

 - Load Heli_IM_Col_Tune.lua to the 'scripts' folder on your flight controller.

 - Set `RC<X>_OPTION` to 300 for the RC input channel that corresponds to the pot that you would like to control the mid-stick output value.

 - Set `RC<X>_OPTION` to 301 for the RC input channel that corresponds to the pot that you would like to use to set the collective's sensitivity, around the mid-stick value.

 - Set `RC<X>_OPTION` to 302 for the RC input channel that corresponds to the switch that you would like to use to save the parameters and exit the script.

 - Note that the script will only register the assigned RC functions when first booting up the flight controller.  Any changes to the RC allocations will require a reboot.

 - Note that `RC<X>_TRIM` values are ignored.

 - It is advisable to start with your `IM_STAB_COL_<X>` curve set to defaults to start (0/40/60/100 respectively).  Similarly, it is advisable to start with the 50% input pot set to the half-way point and your gradient pot set to maximum.  This way, you will start with your parameter values at their default values.

 - Ensure your save switch is set to low.

 - Reboot your flight controller.

 - Fly in stabilize and tune to get your desired collective 'feel' by adjusting the two pots.  If you plan to use higher automated modes than stabilize, it is sensible to get your heli hovering at mid-stick to ensure a smoother mode change into and out of 'auto-collective' modes (e.g. AltHold and Loiter).  Once happy with your tune set the save switch to high.  The script will save the parameters and exit the script.  If you do not save the params they will not persist after a reboot.

 - Once you have tuned your `IM_STAB_COL_2` and `IM_STAB_COL_3` values using the script, remove the script from your flight controller and reset the `RC<X>_OPTION` parameters.

 - If you wish to make any adjustments to `IM_STAB_COL_1` and `IM_STAB_COL_4` you can now do so using the normal parameters.

## Output Messages

### "LUA: IM_COL tune complete"

The script has finished and will not run again without a reboot.

### "LUA: RC channels not set"

One or more RC channels are not set to the scripting channels (300,301, or 302).  Set them and reboot flight controller.

### "LUA: IM_COL setter stopped"

There has been a fault and the script has exited.  This is caused by the script being unable to read the `IM_STB_VOL_<X>` parameter values.  Another message will precede this one, stating which parameter could not be retrieved.

### "LUA: params saved"

Parameters successfully saved.

### "LUA: param set failed"

Failed to set parameter.  Script will persist to try and set parameters without exiting.  If this message continues to show, consider landing and investigating the underlying issue.


================================================
File: applets/Heli_idle_control.lua
================================================
-- idle_control.lua: a closed loop control throttle control while on ground idle (trad-heli)
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil

local PARAM_TABLE_KEY = 73
local PARAM_TABLE_PREFIX = 'IDLE_'
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 30), 'could not add param table')

function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- parameters for idle control

IDLE_GAIN_I = bind_add_param('GAIN_I', 1, 0.05)
IDLE_GAIN_P = bind_add_param('GAIN_P', 2, 0.25)
IDLE_GAIN_MAX = bind_add_param('GAIN_MAX', 3, 1)
IDLE_MAX = bind_add_param('MAX', 4, 17)
IDLE_RANGE = bind_add_param('RANGE', 5, 300)
IDLE_SETPOINT = bind_add_param('SETPOINT', 6, 600)
IDLE_RPM_ENABLE = bind_add_param('RPM_ENABLE', 7, 0)

-- internal variables

local thr_out = nil
local idle_control_active = false
local idle_control_active_last = false
local last_scaled_output = nil
local idle_default = nil
local ramp_up_complete = false
local idle_adjusted = false
local last_idc_time = nil
local time_now = nil
local pv = nil
local thr_ctl = nil
local thr_out_last = nil
local pot_input = rc:find_channel_for_option(301)
local switch_rsc = rc:find_channel_for_option(32)
local rsc_output = SRV_Channels:find_channel(31)
local SERVO_MAX = Parameter('SERVO' .. (rsc_output+1) .. '_MAX')
local SERVO_MIN = Parameter('SERVO' .. (rsc_output+1) .. '_MIN')
local SERVO_REV = Parameter('SERVO' .. (rsc_output+1) .. '_REVERSED')
local servo_range = SERVO_MAX:get() - SERVO_MIN:get()
local H_RSC_IDLE = Parameter('H_RSC_IDLE')
local H_RSC_RUNUP_TIME = Parameter('H_RSC_RUNUP_TIME')

-- map function

function map(x, in_min, in_max, out_min, out_max)
   return out_min + (x - in_min)*(out_max - out_min)/(in_max - in_min)
end

-- constrain function

local function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end

-- PI controller function
local function PI_controller(kP,kI,iMax,min,max)

   local self = {}

   local _kP = kP
   local _kI = kI
   local _iMax = iMax
   local _min = min
   local _max = max
   local _last_t = nil
   local _I = 0
   local _total = 0
   local _counter = 0

   function self.update(target, current)
      local now = millis()
      if not _last_t then
         _last_t = now
      end
      local dt = (now - _last_t):tofloat()*0.001
      _last_t = now
      local err = target - current
      _counter = _counter + 1
      local P = _kP:get() * err
      if ((_total < _max and _total > _min) or (_total >= _max and err < 0) or (_total <= _min and err > 0)) then
         _I = _I + _kI:get() * err * dt
      end
      if _iMax:get() > 0 then
         _I = constrain(_I, -_iMax:get(), iMax:get())
      end
      local ret = P + _I
      _total = ret
      return ret
   end

   function self.reset(integrator)
      _I = integrator
   end

   return self
end

local thr_PI = PI_controller(IDLE_GAIN_P, IDLE_GAIN_I, IDLE_GAIN_MAX, 0, 1)

-- main update function

function update()  

   local armed = arming:is_armed()

  -- aux potentiometer for manual adjusting of idle

   local pot_pos = pot_input:norm_input()
   local thr_man = map(pot_pos,-1,1,0,1)

   if armed == false then
      idle_default = H_RSC_IDLE:get()
      idle_control_active = false
      ramp_up_complete = false
      idle_adjusted = false
      thr_PI.reset(0)
   else 
      if switch_rsc:get_aux_switch_pos() == 0 and vehicle:get_likely_flying() == false then
         if H_RSC_IDLE:get()~= idle_default then
            H_RSC_IDLE:set(idle_default)
            gcs:send_text(5, "H_RSC_IDLE set to:".. tostring(H_RSC_IDLE:get()))
         end
         if IDLE_RPM_ENABLE:get() == 0 then
            ramp_up_complete = false
            idle_adjusted = false
            thr_out = H_RSC_IDLE:get() + thr_man*(IDLE_MAX:get() - H_RSC_IDLE:get())
         else
            if thr_man == 0 then
              idle_control_active = false
              if idle_control_active_last ~= idle_control_active then
                 gcs:send_text(5, "idle control: OFF")
              end
               thr_out = H_RSC_IDLE:get()
               thr_ctl = 0
               thr_PI.reset(0)
            else
               local rpm_current = RPM:get_rpm((IDLE_RPM_ENABLE:get())-1)
               ramp_up_complete = false
               idle_adjusted = false
               if rpm_current < (IDLE_SETPOINT:get() - IDLE_RANGE:get()) then
                  thr_out = H_RSC_IDLE:get() + thr_man*(IDLE_MAX:get() - H_RSC_IDLE:get())
                  thr_out_last = thr_out
               elseif rpm_current > (IDLE_SETPOINT:get() + IDLE_RANGE:get()) then 
                  thr_out = H_RSC_IDLE:get()
                  thr_out_last = thr_out
               else
                  -- throttle output set from the PI controller
                  pv = rpm_current/(IDLE_SETPOINT:get())
                  thr_ctl = thr_PI.update(1, pv)
                  thr_ctl = constrain(thr_ctl,0,1)
                  thr_out = H_RSC_IDLE:get() + thr_ctl*(IDLE_MAX:get() - H_RSC_IDLE:get())
                  if thr_out_last == nil then
                     thr_out_last = 0
                  end
                  thr_out = constrain(thr_out, thr_out_last-0.05, thr_out_last+0.05)
                  thr_out_last = thr_out
                  idle_control_active = true
               end
               if idle_control_active_last ~= idle_control_active then
                  gcs:send_text(5, "idle control: ON")
               end
             end
         end
         last_idc_time = millis()
         last_scaled_output = thr_out/100
         if SERVO_REV:get() == 0 then
            SRV_Channels:set_output_pwm_chan_timeout(rsc_output, math.floor((last_scaled_output*servo_range)+SERVO_MIN:get()), 150)
         else
            SRV_Channels:set_output_pwm_chan_timeout(rsc_output, math.floor(SERVO_MAX:get()-(last_scaled_output*servo_range)), 150)
         end
      else
         -- motor interlock disabled, armed state, flight
         idle_control_active = false
         if idle_control_active_last ~= idle_control_active then
            gcs:send_text(5, "idle control: deactivated")
         end
         if ramp_up_complete ~= true then
            time_now = millis()
            if ((time_now-last_idc_time):tofloat()*0.001) < H_RSC_RUNUP_TIME:get() then
               if idle_adjusted ~= true then
                  H_RSC_IDLE:set(last_scaled_output*100)
                  idle_adjusted = true
                  gcs:send_text(5, "H_RSC_IDLE updated for ramp up:".. tostring(H_RSC_IDLE:get()))
               end
            else
               if H_RSC_IDLE:get()~= idle_default then
                  H_RSC_IDLE:set(idle_default)
                  gcs:send_text(5, "H_RSC_IDLE default restored:".. tostring(H_RSC_IDLE:get()))
               end
               ramp_up_complete = true
            end
         end
      end
  -- update notify variable
  idle_control_active_last = idle_control_active
   end

   return update, 100 -- 10Hz rate
end

gcs:send_text(5, "idle_control_running")

return update()



================================================
File: applets/Heli_idle_control.md
================================================
# Idle Control

Allows manual or automatic rpm control for heli while on ground idle condition

# Parameters

IDLE_GAIN_I = integrative gain of the controller
IDLE_GAIN_P = proportional gain of the controller
IDLE_GAIN_MAX = IMAX for integrative
IDLE_MAX = maximum throttle position, shall be set low enough to prevent clutch engagement/slipping or lower than first point of throttle curve
IDLE_RANGE = rpm range of operation for the idle control
IDLE_SETPOINT = desired rpm setpoint
IDLE_RPM_ENABLE = 0 for manual throttle control // 1 for RPM1 targeting // 2 for RPM2 targeting

# How To Use

set RCx_OPTION to 301 to enable idle control from an auxiliary potentiometer



================================================
File: applets/Hexsoon LEDs.lua
================================================
-- Hexsoon EDU 450 LED script
-- LEDs will be fixed colour when disarmed, when armed LEDs will also strobe

--[[ INSTRUCTIONS:
LEDs have two servo headers, plug into AUX 5 and 6 on cube.
Note white is ground, black and brown are signal
black into AUX 5 and brown into AUX 6
Other aux pins could be used but 5 and 6 make best use of the available groups
    BRD_PWM_COUNT must be 6
Aux 5 and 6 are servo outs 13 and 14
    SERVO13_FUNCITON 132 Profi LED Clock
    SERVO14_FUNCTION 94 Script 1
setup scripting:
    SCR_ENABLE 1
    SCR_HEAP_SIZE 88032
Reboot
Use MP config tab -> MAVFtp to place this script in 'APM/scripts' folder
Reboot
Check messages tab should see:
LEDs strip left: chan=14
RCOut: PWM:1-12 ProfiLED:13-14
Note that 1-12 might not be PWM, all than matters is: ProfiLED:13-14
If not check for scripting error messages.
LEDs should now work!, if not try swapping AUX 5 and 6, either by physically swapping or by swapping the servo functions and rebooting
To get colours to match either change the ordering in "local led_map ="  below or swap headers round on the LED distribution board
If using 6 les add two extra colours to "local led_map =" e.g:  "local led_map = {red, red, red, green, green, green}"
--]]

-- helper colours, red, green, blue values from 0 to 255
local red   = {255, 0,   0}
local green = {0,   255, 0}
-- local blue =  {0,   0,   255}

-- led map giving the colour for the LEDs plugged in
local led_map = {red, red, green, green}

-- number of ms to strobe white, can be 0 for no strobe
-- strobe only active when armed
local strobe_on_time = 100

-- number of ms to hold colour set in led_map
local colour_map_time = 900

local led_chan = assert(SRV_Channels:find_channel(94),"LED: channel not set") + 1
gcs:send_text(6, "LED strip: chan=" .. tostring(led_chan))
assert(serialLED:set_num_profiled(led_chan, 8),"Failed LED setup")

local timer = false
function update_LEDs()
  local armed = arming:is_armed()
  if armed and timer and strobe_on_time > 0 then
    timer = false
    -- all white
    serialLED:set_RGB(led_chan, -1, 255, 255, 255)
    serialLED:send(led_chan)
    return update_LEDs, strobe_on_time
  else
    timer = armed
    for led_num = 1,#led_map do
      -- each LED module has two LEDs, set both to colour map colour
      serialLED:set_RGB(led_chan, ((led_num-1)*2)+0, led_map[led_num][1], led_map[led_num][2], led_map[led_num][3])
      serialLED:set_RGB(led_chan, ((led_num-1)*2)+1, led_map[led_num][1], led_map[led_num][2], led_map[led_num][3])
    end
    serialLED:send(led_chan)
    return update_LEDs, colour_map_time
  end
end

return update_LEDs()



================================================
File: applets/Hexsoon LEDs.md
================================================
# Hexsoon EDU 450 LED script
LEDs will be fixed colour when disarmed, when armed LEDs will also strobe

# INSTRUCTIONS
LEDs have two servo headers, plug into AUX 5 and 6 on cube.

Note white is ground, black and brown are signal

black into AUX 5 and brown into AUX 6

Other aux pins could be used but 5 and 6 make best use of the available groups
    BRD_PWM_COUNT must be 6

Aux 5 and 6 are servo outs 13 and 14
```
SERVO13_FUNCITON 132 (Profi LED Clock)
SERVO14_FUNCTION 94 (Script 1)
```

-setup scripting:
```
SCR_ENABLE 1
SCR_HEAP_SIZE 88032
```
- Reboot

- Use MP config tab -> MAVFtp to place this script in 'APM/scripts' folder

- Reboot

- Check messages tab should see:
```
LEDs strip left: chan=14
RCOut: PWM:1-12 ProfiLED:13-14
```

Note that 1-12 might not be PWM, all than matters is: ProfiLED:13-14

If not check for scripting error messages.

LEDs should now work!, if not try swapping AUX 5 and 6, either by physically swapping or by swapping the servo functions and rebooting

To get colours to match either change the ordering in "local led_map ="  below or swap headers round on the LED distribution board

If using 6 les add two extra colours to "local led_map =" e.g:  "local led_map = {red, red, red, green, green, green}"



================================================
File: applets/MissionSelector.lua
================================================
-- Loads one of three mission files to autopilot on each arm, depending on position of the Mission Reset AUX FUNC switch
-- Must have Mission Reset switch assigned, it will function normally when armed or disarmed
-- but also on the disarm to arm transition, it will load (if file exists) a file in the root named
-- missionH.txt, missionM.txt, or missionH.txt corresponding to the the Mission Reset switch position of High/Mid/Low

local mission_loaded = false
local rc_switch = rc:find_channel_for_option(24)  --AUX FUNC sw for mission restart

if not rc_switch then  -- requires the switch to be assigned in order to run script
  return
end

local function read_mission(file_name)

  -- Open file try and read header
  local file = io.open(file_name,"r")
  if not file then
    return update, 1000 --could not read, file probably does not exist
  end
  local header = file:read('l')

  -- check header
  assert(string.find(header,'QGC WPL 110') == 1, file_name .. ': incorrect format')

  -- clear any existing mission
  assert(mission:clear(), 'Could not clear current mission')

  -- read each line and write to mission
  local item = mavlink_mission_item_int_t()
  local index = 0
  while true do
    local data = {}
    for i = 1, 12 do
      data[i] = file:read('n')
      if data[i] == nil then
        if i == 1 then
          gcs:send_text(6, 'loaded mission: ' .. file_name)
          file:close()
          return -- got to the end of the file
        else
          mission:clear() -- clear part loaded mission
          error('failed to read file')
        end
      end
    end

    item:seq(data[1])
    item:frame(data[3])
    item:command(data[4])
    item:param1(data[5])
    item:param2(data[6])
    item:param3(data[7])
    item:param4(data[8])
    item:x(data[9]*10^7)
    item:y(data[10]*10^7)
    item:z(data[11])

    if not mission:set_item(index,item) then
      mission:clear() -- clear part loaded mission
      error(string.format('failed to set mission item %i',index))
    end
    index = index + 1
  end
end

function update()
  if not arming:is_armed() then --if disarmed, wait until armed
    mission_loaded = false
    return update,1000
  end
  if not mission_loaded then --if first time after arm and switch is valid then try to load based on switch position
    local filename
    local sw_pos = rc_switch:get_aux_switch_pos()
    if sw_pos == 0 then
        filename = 'missionL.txt'
    elseif sw_pos == 1 then
        filename = 'missionM.txt'
    else
        filename = 'missionH.txt'
    end
    mission_loaded = true
    read_mission(filename)
  end
  return update, 1000
end

gcs:send_text(5,"Loaded MissionSelector.lua")

return update, 5000



================================================
File: applets/MissionSelector.md
================================================
# MissionSelector LUA script

This script will select and load one of three mission files upon every arm depending on the state of the AUX FUNCTION switch for Mission Reset (24). This allows easy, at the field selection of missions, particulary useful for changing autoland/RTL_AUTOLAND directions based on prevailing wing conditions. MissionH.txt, MissionM.txt, or MissionL.txt mission files in the SD card root will be loaded based on that switch position on a disarmed to armed transition.

The basic AUX function of resetting the mission pointer to the first waypoint is unaltered when the switch is moved to the high position, as previous.

If the AUX FUNCTION rc switch is not configured, the script is not active.

If the file selected by the switch position is not in the root SD directory, nothing happens, otherwise the current mission will be cleared and the designated mission file will be loaded and the user notified of the mission change.

If the file is available but is not the correct format , the script will abort.

So a user can install the script and if the switch is configured and a file exists for selection it will function, but either can be missing without causing messaging to the user.


================================================
File: applets/ONVIF_Camera_Control.lua
================================================

local counter = 0
local running = 0
local last_pan_cmd = 0.0
local last_tilt_cmd = 0.0

function update()
  if onvif and onvif.start and counter >= 100 and running == 0 then
    gcs:send_text(0, "onvif starting")
    if onvif:start("user","123456","http://10.211.55.3:10000") then
        gcs:send_text(0, "onvif started")
        running = 1
    end
    counter = 0
  end
  counter = counter + 1

  if running == 1 then
    pan_norm, tilt_norm = vehicle:get_pan_tilt_norm()
    pan_tilt_limit_max = onvif:get_pan_tilt_limit_max()
    pan_tilt_limit_min = onvif:get_pan_tilt_limit_min()
    pan_norm = ((pan_norm + 1) * (pan_tilt_limit_max:x() - pan_tilt_limit_min:x())/2.0) + pan_tilt_limit_min:x()
    tilt_norm = ((tilt_norm + 1) * (pan_tilt_limit_max:y() - pan_tilt_limit_min:y())/2.0) + pan_tilt_limit_min:y()
    gcs:send_text(0, string.format("PAN: %f TILT: %f", pan_norm, tilt_norm))
    if math.floor(pan_norm*100.0) ~= math.floor(last_pan_cmd*100.0) or
        math.floor(tilt_norm*100.0) ~= math.floor(last_tilt_cmd*100.0) then
      -- actually send the command
      if not onvif:set_absolutemove(pan_norm, tilt_norm, 0.0) then
        gcs:send_text(0, "onvif failed to send absolutemove command")
      end
      last_pan_cmd = pan_norm;
      last_tilt_cmd = tilt_norm;
    end
  end
  return update, 20
end
gcs:send_text(0, "Starting ONVIF Control")

return update() -- run immediately before starting to reschedule


================================================
File: applets/ONVIF_Camera_Control.md
================================================
# ONVIF_Camera_Control Lua Script

This is a script that converts AntennaTracker into a Drone Tracking Camera using ONVIF capable Camera. The Camera needs to support  PTZ AbsoluteMove method. The camera is sent absolute Pan Tilt commands based on requirement from Antenna Tracker lib.

User just needs to edit the script to set string username, password and IP address:port of the camera. Currently we only support running as part of SITL/Linux instance. Which can simply be done by adding `--enable-onvif` the rest including adding this script will be taken care of by build system. Also you will need to set `PITCH_MAX` `PITCH_MIN` and `YAW_RANGE` parameters per camera specifications.

Following steps are required before doing ONVIF build:
```
cd modules/gsoap
autoreconf -f -i
./configure
make
make install #add sudo if needed
```



================================================
File: applets/Param_Controller.lua
================================================
--[[
   a script to select other parameters using an auxillary switch
   from subdirectories in scripts directory labeled /1,/2, or /3
--]]

local SEL_CH = 302
local PARAM_FILENAME = "params.param"

--[[
   check that directory exists
--]]
function check_subdir_exists(n)
  return dirlist(get_scripts_dir() .. "/" .. n )
end

--[[
   get the path to the scripts directory. This will be scripts/ on SITL
   and APM/scripts on a ChibiOS board
--]]
function get_scripts_dir()
   local dlist1 = dirlist("APM/scripts")
   if dlist1 and #dlist1 > 0 then
      return "APM/scripts"
   end
   -- otherwise assume scripts/
   return "scripts"
end

--[[
load parameters from a file PARAM_FILENAME from directory n
--]]
function param_load(n)
   count = 0
   failed = false
   file_name = get_scripts_dir() .. "/" .. n .."/" .. PARAM_FILENAME
  -- Open file
  file = io.open(file_name)
  if not file then
     gcs:send_text(0,string.format("%s not present",file_name))
     return
  end
   while true do
      local line = file:read()
      if not line then
         break
      end
      -- trim trailing spaces
      line = string.gsub(line, '^(.-)%s*$', '%1')
      local _, _, parm, value = string.find(line, "^([%w_]+)%s*([%d]*.[%d]*)")
      if parm then
         if not param:set(parm,value) then
            failed = true
         else
            count = count +1
         end
      end
   end 
   if not failed then
      gcs:send_text(6,string.format("Loaded %u parameters",count)) 
   else
      gcs:send_text(6,string.format("Loaded %u parameters but some params did not exist to set",count)) 
   end
end   
 
local sw_last = -1
local load_param = true

function update()
   local sw_current = rc:get_aux_cached(SEL_CH)
   if (sw_current == sw_last) or (sw_current == nil) then
      return update, 500
   end
   if sw_current == 0 then 
        subdir = 1
      elseif sw_current == 2 then
        subdir = 3
      else
        subdir = 2
   end
   sw_last = sw_current
   if not check_subdir_exists(subdir) then
      gcs:send_text(0,string.format("Scripts subdirectory /%s does not exist!",subdir))
      return update, 500
   end
   if load_param then
      param_load(subdir)
      load_param = false
   end
   
   return update, 500
end

gcs:send_text(5,"Loaded Parameter_Controller.lua")
return update, 500



================================================
File: applets/Param_Controller.md
================================================
# Param_Controller LUA script

This script allows the user to have different parameters (in files named "params.parm") in three subdirectories of the main scripting directory and load them based on the position of a switch with the auxiliary function of "302". This allows easy, at the field selection of parameter sets. It uses the same switch function and directories as the Scripting_Controller.lua script selector and the two may be used together, if desired.

# Setup and Operation

The user must setup an RCx_OPTION to function 302 to determine which of the three scripts subdirectories will be used: LOW:scripts/1, MIDDLE:scripts/2, or HIGH:scripts/3. If no RC has been established during ground start, it will behave as if subdirectory 1 is selected. Changing this switch position either prior to ground start or after, will load a "params.param" file from the desginated subdirectory (if it and its subdirectory exists). Mission Planner also provides a means of executing the same function as an RC switch assigned to 302 in its AUX Function tab, so a transmitter switch does not necessarily need to be used.

Note that loaded parameter changes are not saved across reboots, that must be done manually.



================================================
File: applets/QuadPlane_Low_Alt_FW_mode_prevention.lua
================================================
-- This is a script overrides a forward flight mode at low altitude and within radius of home
-- configured with Q_LOW_ALT_* params

-- maker sure on a quadplane
assert(quadplane, "Quadplane not setup")

-- add new params
local PARAM_TABLE_KEY = 76
assert(param:add_table(PARAM_TABLE_KEY, "Q_LOW_ALT_", 3), "could not add param table")
assert(param:add_param(PARAM_TABLE_KEY, 1, "ENABLE", 0), "could not add param") -- enable low alt mode change, 1: Switch to QLAND, 2: Switch back to previous mode
assert(param:add_param(PARAM_TABLE_KEY, 2, "ALT", 15), "could not add param") -- threshold altitude
assert(param:add_param(PARAM_TABLE_KEY, 3, "RADIUS", 50), "could not add param") -- threshold radius

local enabled = Parameter()
local alt = Parameter()
local radius = Parameter()

assert(enabled:init("Q_LOW_ALT_ENABLE"), "could not find param")
assert(alt:init("Q_LOW_ALT_ALT"), "could not find param")
assert(radius:init("Q_LOW_ALT_RADIUS"), "could not find param")

-- all plane mode numbers
local MODE_MANUAL        = 0
local MODE_CIRCLE        = 1
local MODE_STABILIZE     = 2
local MODE_TRAINING      = 3
local MODE_ACRO          = 4
local MODE_FLY_BY_WIRE_A = 5
local MODE_FLY_BY_WIRE_B = 6
local MODE_CRUISE        = 7
local MODE_AUTOTUNE      = 8
local MODE_AUTO          = 10
local MODE_RTL           = 11
local MODE_LOITER        = 12
local MODE_TAKEOFF       = 13
local MODE_AVOID_ADSB    = 14
local MODE_GUIDED        = 15
local MODE_INITIALISING  = 16
local MODE_QSTABILIZE    = 17
local MODE_QHOVER        = 18
local MODE_QLOITER       = 19
local MODE_QLAND         = 20
local MODE_QRTL          = 21
local MODE_QAUTOTUNE     = 22
local MODE_QACRO         = 23
local MODE_THERMAL       = 24
local MODE_LOITER_ALT_QLAND = 25

local FS_enabled_in_mode = {}

-- enable in all FW modes except auto and guided
FS_enabled_in_mode[MODE_MANUAL] = true
FS_enabled_in_mode[MODE_CIRCLE] = true
FS_enabled_in_mode[MODE_STABILIZE] = true
FS_enabled_in_mode[MODE_TRAINING] = true
FS_enabled_in_mode[MODE_ACRO] = true
FS_enabled_in_mode[MODE_FLY_BY_WIRE_A] = true
FS_enabled_in_mode[MODE_FLY_BY_WIRE_B] = true
FS_enabled_in_mode[MODE_CRUISE] = true
FS_enabled_in_mode[MODE_AUTOTUNE] = true
FS_enabled_in_mode[MODE_AUTO] = false
FS_enabled_in_mode[MODE_RTL] = true
FS_enabled_in_mode[MODE_LOITER] = true
FS_enabled_in_mode[MODE_TAKEOFF] = true
FS_enabled_in_mode[MODE_AVOID_ADSB] = true
FS_enabled_in_mode[MODE_GUIDED] = false
FS_enabled_in_mode[MODE_INITIALISING] = true
FS_enabled_in_mode[MODE_QSTABILIZE] = false
FS_enabled_in_mode[MODE_QHOVER] = false
FS_enabled_in_mode[MODE_QLOITER] = false
FS_enabled_in_mode[MODE_QLAND] = false
FS_enabled_in_mode[MODE_QRTL] = false
FS_enabled_in_mode[MODE_QAUTOTUNE] = false
FS_enabled_in_mode[MODE_QACRO] = false
FS_enabled_in_mode[MODE_THERMAL] = true
FS_enabled_in_mode[MODE_LOITER_ALT_QLAND] = true

local last_mode = vehicle:get_mode()
function update()

  local mode = vehicle:get_mode()
  local previous_mode = last_mode
  if mode == last_mode then
    -- no mode change
    return update, 100
  end
  last_mode = mode

  if enabled:get() <= 0 or not arming:is_armed() then
    -- not enabled or not armed
    return update, 100
  end

  if not FS_enabled_in_mode[mode] then
    -- not enabled in this mode
    return update, 100
  end

  if FS_enabled_in_mode[previous_mode] then
    -- fail safe is enabled in this mode, but it was also enabled in the last mode
    -- Don't stop switch from one FW flight mode to another
    return update, 100
  end

  local pos = ahrs:get_relative_position_NED_home()
  if not pos then
    -- no position
    return update, 100
  end

  if pos:xy():length() > radius:get() or -pos:z() > alt:get() then
    -- outside threshold radius or above altitude
    return update, 100
  end

  -- Enabled, armed and in enabled mode, switching out of disabled mode
  -- Within radius and below altitude threshold
  -- switch to Qland or back to previous mode

  local new_mode = MODE_QLAND
  if enabled:get() == 2 then
    new_mode = previous_mode
    gcs:send_text(5, 'Too low for fixedwing flight')
  else
    gcs:send_text(5, 'Too low for fixedwing flight, mode set to QLand')
  end

  vehicle:set_mode(new_mode)

  -- update last mode to prevent trigger on this mode change
  last_mode = new_mode

  return update, 100
end

return update()



================================================
File: applets/QuadPlane_Low_Alt_FW_mode_prevention.md
================================================
# Quadplane low altitude forward flight mode prevention

This script prevents inadvertent switching into a fixed wing flight mode at low altitude. Its behaviour is controlled by Q_LOW_ALT_* parameters.

- Q_LOW_ALT_ENABLE: Enable script. 1: switch to Qland instead of fixed wing mode. 2: Switch back to previous mode instead of fixed wing mode.

- Q_LOW_ALT_ALT: Altitude threshold in meters above home. If vehicle is above this altitude the script will not take action

- Q_LOT_ALT_RADIUS: Radius threshold in meters from home. If vehicle is outside this radius the script wil not take action

Note: vehicle is always allowed to switch into auto mode or guided mode.



================================================
File: applets/RockBlock.lua
================================================
--[[ Lua script to send a recieve very basic MAVLink telemetry over a
Rockblock SBD satellite modem
Requires https://github.com/stephendade/rockblock2mav at the GCS end

Setup:
This script requires 1 serial port:
A "Script" to connect the RockBlock modem

Usage:
Use the MAVLink High Latency Control ("link hl on|off" in MAVProxy) to control
whether to send or not (or use "force_hl_enable")
Use the RCK_DEBUG param to view debugging statustexts at the GCS
Use the RCK_FORCEHL param to control the mode of operation: 0=Disabled, 1=Enabled, 2=Enabled on 5000ms telemetry loss

Caveats:
This will *only* send HIGH_LATENCY2 packets via the SBD modem. No heartbeats,
no command acknowledgements, no statustexts, no parameters, etc
A single HIGH_LATENCY2 packet will be send every RCK_PERIOD seconds
MAVLink 1 will be used, as it's slightly more efficient (50 vs 52 bytes for a HL2 message)
Any incoming packets on the first mailbox check will be ignored (as these may be from a long time in the past)
Only 1 command can be sent at a time from the GCS. Any subsequent commands will overwrite the previous command
The param SCR_VM_I_COUNT may need to be increased in some circumstances

Written by Stephen Dade (stephen_dade@hotmail.com)
]]--

local PARAM_TABLE_KEY = 10
local PARAM_TABLE_PREFIX = "RCK_"

local port = serial:find_serial(0)

if not port then
    gcs:send_text(0, "Rockblock: No Scripting Serial Port")
    return
end

port:begin(19200)
port:set_flow_control(0)

-- number of millsec that GCS telemetry has been lost for
local link_lost_for = 0

-- bind a parameter to a variable
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
 end
 
 -- add a parameter and bind it to a variable
 function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
 end

 -- setup RCK specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 5), 'could not add param table')
--[[
  // @Param: RCK_FORCEHL
  // @DisplayName: Force enable High Latency mode
  // @Description: Automatically enables High Latency mode if not already enabled
  // @Values: 0:Disabled,1:Enabled,2:Enabled on telemetry loss
  // @User: Standard
--]]
RCK_FORCEHL     = bind_add_param('FORCEHL', 1, 0)

--[[
  // @Param: RCK_PERIOD
  // @DisplayName: Update rate
  // @Description: When in High Latency mode, send Rockblock updates every N seconds
  // @Range: 0 600
  // @Units: s
  // @User: Standard
--]]
RCK_PERIOD     = bind_add_param('PERIOD', 2, 30)

--[[
  // @Param: RCK_DEBUG
  // @DisplayName: Display Rockblock debugging text
  // @Description: Sends Rockblock debug text to GCS via statustexts
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
RCK_DEBUG     = bind_add_param('DEBUG', 3, 0)

--[[
  // @Param: RCK_ENABLE
  // @DisplayName: Enable Message transmission
  // @Description: Enables the Rockblock sending and recieving
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
RCK_ENABLE     = bind_add_param('ENABLE', 4, 1)

--[[
  // @Param: RCK_TIMEOUT
  // @DisplayName: GCS timeout to start sendin Rockblock messages
  // @Description: If RCK_FORCEHL=2, this is the number of seconds of GCS timeout until High Latency mode is auto-enabled
  // @Range: 0 600
  // @Units: s
  // @User: Standard
--]]
RCK_TIMEOUT     = bind_add_param('TIMEOUT', 5, 5)

--[[
Returns true if the value is NaN, false otherwise
--]]
local function isNaN (x)
    return (x ~= x)
  end

--[[
Lua Object for decoding and encoding MAVLink (V1 only) messages
--]]
local function MAVLinkProcessor()
    -- public fields
    local self = {
        -- define MAVLink message id's
        COMMAND_LONG = 76,
        COMMAND_INT = 75,
        HIGH_LATENCY2 = 235,
        MISSION_ITEM_INT = 73,
        SET_MODE = 11,
        MISSION_SET_CURRENT = 41
    }

    -- private fields
    local _mavbuffer = ""
    local _mavresult = {}
    local _payload_len = 0
    local _mavdecodestate = 0 -- 0=looking for marker, 1=getting header,2=getting payload,3=getting crc
    PROTOCOL_MARKER_V1 = 0xFE
    HEADER_LEN_V1 = 6
    local _txseqid = 0

    -- AUTOGEN from MAVLink generator
    local _crc_extra = {}
    _crc_extra[75] = 0x9e
    _crc_extra[76] = 0x98
    _crc_extra[235] = 0xb3
    _crc_extra[73] = 0x26
    _crc_extra[11] = 0x59
    _crc_extra[41] = 0x1c
    
    local _messages = {}
    _messages[75] = { -- COMMAND_INT
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"x", "<i4"}, {"y", "<i4"}, {"z", "<f"}, {"command", "<I2"},
        {"target_system", "<B"}, {"target_component", "<B"}, {"frame", "<B"},
        {"current", "<B"}, {"autocontinue", "<B"}
    }
    _messages[76] = { -- COMMAND_LONG
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"param5", "<f"}, {"param6", "<f"}, {"param7", "<f"},
        {"command", "<I2"}, {"target_system", "<B"}, {"target_component", "<B"},
        {"confirmation", "<B"}
    }
    _messages[235] = { -- HIGH_LATENCY2
        {"timestamp", "<I4"}, {"latitude", "<i4"}, {"longitude", "<i4"},
        {"custom_mode", "<I2"}, {"altitude", "<i2"}, {"target_altitude", "<i2"},
        {"target_distance", "<I2"}, {"wp_num", "<I2"}, {"failure_flags", "<I2"},
        {"type", "<B"}, {"autopilot", "<B"}, {"heading", "<B"},
        {"target_heading", "<B"}, {"throttle", "<B"}, {"airspeed", "<B"},
        {"airspeed_sp", "<B"}, {"groundspeed", "<B"}, {"windspeed", "<B"},
        {"wind_heading", "<B"}, {"eph", "<B"}, {"epv", "<B"},
        {"temperature_air", "<b"}, {"climb_rate", "<b"}, {"battery", "<b"},
        {"custom0", "<B"}, -- should be <b (int8), but we're hacking this into a uint8 instead
        {"custom1", "<b"}, {"custom2", "<b"}
    }
    _messages[73] = { -- MISSION_ITEM_INT
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"x", "<i4"}, {"y", "<i4"}, {"z", "<f"}, {"seq", "<I2"},
        {"command", "<I2"}, {"target_system", "<B"}, {"target_component", "<B"},
        {"frame", "<B"}, {"current", "<B"}, {"autocontinue", "<B"}
    }
    _messages[11] = { -- SET_MODE
        { "custom_mode", "<I4" }, { "target_system", "<B" }, { "base_mode", "<B" },
    }
    _messages[41] = { -- MISSION_SET_CURRENT
        { "seq", "<I2" }, { "target_system", "<B" }, { "target_component", "<B" },
    }
    function self.getSeqID() return _txseqid end

    function self.generateCRC(buffer)
        -- generate the x25crc for a given buffer. Make sure to include crc_extra!
        local crc = 0xFFFF
        for i = 1, #buffer do
            local tmp = string.byte(buffer, i, i) ~ (crc & 0xFF)
            tmp = (tmp ~ (tmp << 4)) & 0xFF
            crc = (crc >> 8) ~ (tmp << 8) ~ (tmp << 3) ~ (tmp >> 4)
            crc = crc & 0xFFFF
        end
        return string.pack("<H", crc)
    end

    function self.parseMAVLink(byte)
        -- parse a new byte and see if we've got MAVLink message
        -- returns true if a packet was decoded, false otherwise
        _mavbuffer = _mavbuffer .. string.char(byte)

        -- check if this is a start of packet
        if _mavdecodestate == 0 and byte == PROTOCOL_MARKER_V1 then
            -- we have a packet start, discard the buffer before this byte
            _mavbuffer = string.char(byte)
            _mavdecodestate = 1
            return
        end

        -- if we have a full header, try parsing
        if #_mavbuffer == HEADER_LEN_V1 and _mavdecodestate == 1 then
            local read_marker = 1
            _, read_marker = string.unpack("<B", _mavbuffer, read_marker)
            _payload_len, read_marker = string.unpack("<B", _mavbuffer,
                                                      read_marker) -- payload is always the second byte
            -- fetch seq/sysid/compid
            _mavresult.seq, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            _mavresult.sysid, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            _mavresult.compid, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            -- fetch the message id
            _mavresult.msgid, _ = string.unpack("<B", _mavbuffer, read_marker)

            _mavdecodestate = 2
            return
        end

        -- get payload
        if _mavdecodestate == 2 and #_mavbuffer ==
            (_payload_len + HEADER_LEN_V1) then
            _mavdecodestate = 3
            _mavresult.payload = string.sub(_mavbuffer, HEADER_LEN_V1 + 1)
            return
        end

        -- get crc, then process if CRC ok
        if _mavdecodestate == 3 and #_mavbuffer ==
            (_payload_len + HEADER_LEN_V1 + 2) then
            _mavdecodestate = 0
            _mavresult.crc = string.sub(_mavbuffer, -2, -1)

            local message_map = _messages[_mavresult.msgid]
            if not message_map then
                -- we don't know how to decode this message, bail on it
                _mavbuffer = ""
                return true
            end

            -- check CRC, if message defined
            local crc_extra_msg = _crc_extra[_mavresult.msgid]
            if crc_extra_msg ~= nil then
                local calccrc = self.generateCRC(
                                    string.sub(_mavbuffer, 2, -3) ..
                                        string.char(crc_extra_msg))
                if _mavresult.crc ~= calccrc then
                    gcs:send_text(3,
                                  "Rockblock: Bad Mavlink CRC: " ..
                                      self.bytesToString(_mavbuffer, -2, -1) ..
                                      ", " .. self.bytesToString(calccrc, 1, 2))
                    _mavbuffer = ""
                    return
                end
            end

            -- map all the fields out
            local offset = 1
            for _, v in ipairs(message_map) do
                if v[3] then
                    _mavresult[v[1]] = {}
                    for j = 1, v[3] do
                        _mavresult[v[1]][j], offset = string.unpack(v[2],
                                                                    _mavresult.payload,
                                                                    offset)
                    end
                else
                    _mavresult[v[1]], offset = string.unpack(v[2],
                                                             _mavresult.payload,
                                                             offset)
                end
            end
            -- only process COMMAND_LONG and COMMAND_INT and  MISSION_ITEM_INT messages
            if _mavresult.msgid == self.MISSION_ITEM_INT then
                -- goto somewhere (guided mode target)
                if _mavresult.command == 16 then -- MAV_CMD_NAV_WAYPOINT
                    local loc = Location()
                    loc:lat(_mavresult.x)
                    loc:lng(_mavresult.y)
                    loc:alt(_mavresult.z * 100)
                    if _mavresult.frame == 10 then -- MAV_FRAME_GLOBAL_TERRAIN_ALT
                        loc:terrain_alt(true)
                        loc:relative_alt(true)
                    elseif _mavresult.frame == 3 then -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                        loc:relative_alt(true)
                    end
                    vehicle:set_target_location(loc)
                end
            elseif _mavresult.msgid == self.SET_MODE then
                vehicle:set_mode(_mavresult.custom_mode)
            elseif _mavresult.msgid == self.COMMAND_LONG then
                --- need to do a little conversion here. Taken from convert_COMMAND_LONG_to_COMMAND_INT()
                local command_long_stores_location = 0
                if (_mavresult.command == 179 or       -- MAV_CMD_DO_SET_HOME
                    _mavresult.command ==  201 or      -- MAV_CMD_DO_SET_ROI
                    _mavresult.command ==  195 or      -- MAV_CMD_DO_SET_ROI_LOCATION
                    _mavresult.command ==  192 or      -- MAV_CMD_DO_REPOSITION
                    _mavresult.command ==  43003) then -- MAV_CMD_EXTERNAL_POSITION_ESTIMATE
                    command_long_stores_location = 1
                end
                local int_frame_conv = 0       -- MAV_FRAME_GLOBAL
                if (_mavresult.command ==  195) then       -- MAV_CMD_DO_SET_ROI_LOCATION
                    int_frame_conv = 3         -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                elseif (_mavresult.command ==  179) then   -- MAV_CMD_DO_SET_HOME
                    int_frame_conv = 0        -- MAV_FRAME_GLOBAL
                elseif (_mavresult.command ==  201) then   -- MAV_CMD_DO_SET_ROI
                    int_frame_conv = 3        -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                elseif (_mavresult.command ==  42006) then   -- MAV_CMD_FIXED_MAG_CAL_YAW
                    int_frame_conv = 3        -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                end
                local int_x = _mavresult.param5
                local int_y = _mavresult.param6
                if isNaN(int_x) then
                    int_x = 0
                end
                if isNaN(int_y) then
                    int_y = 0
                end
                if command_long_stores_location == 1 then
                    int_x = 1E7 * int_x
                    int_y = 1E7 * int_y
                end
                gcs:run_command_int(_mavresult.command, { p1 = _mavresult.param1,
                                                          p2 = _mavresult.param2,
                                                          p3 = _mavresult.param3,
                                                          p4 = _mavresult.param4,
                                                          x = int_x,
                                                          y = int_y,
                                                          z = _mavresult.param7,
                                                          int_frame = int_frame_conv,
                                                          current = 0,
                                                          autocontinue = 0 })
            elseif _mavresult.msgid == self.COMMAND_INT then
                gcs:run_command_int(_mavresult.command, { p1 = _mavresult.param1,
                                                          p2 = _mavresult.param2,
                                                          p3 = _mavresult.param3,
                                                          p4 = _mavresult.param4,
                                                          x = _mavresult.x,
                                                          y = _mavresult.y,
                                                          z = _mavresult.z,
                                                          frame = _mavresult.frame })
            elseif _mavresult.msgid == self.MISSION_SET_CURRENT then
                mission:set_current_cmd(_mavresult.seq)
            end
            _mavbuffer = ""
            return true
        end

        -- packet too big ... start again
        if #_mavbuffer > 263 then 
            _mavbuffer = ""
            _mavdecodestate = 0
        end
        return false
    end

    function self.bytesToString(buf, start, stop)
        local ret = ""
        for idx = start, stop do
            ret = ret .. string.format("0x%x ", buf:byte(idx), 1, -1) .. " "
        end
        return ret
    end

    function self.createMAVLink(message, msgid)
        -- generate a mavlink message (V1 only)

        -- create the payload
        local message_map = _messages[msgid]
        if not message_map then
            -- we don't know how to encode this message, bail on it
            gcs:send_text(3, "Rockblock: Unknown MAVLink message " .. msgid)
            return nil
        end

        local packString = "<"
        local packedTable = {}
        local packedIndex = 1
        for i, v in ipairs(message_map) do
            if v[3] then
                packString = (packString ..
                                 string.rep(string.sub(v[2], 2), v[3]))
                for j = 1, v[3] do
                    packedTable[packedIndex] = message[message_map[i][1]][j]
                    packedIndex = packedIndex + 1
                end
            else
                packString = (packString .. string.sub(v[2], 2))
                packedTable[packedIndex] = message[message_map[i][1]]
                packedIndex = packedIndex + 1
            end
        end

        local payload = string.pack(packString, table.unpack(packedTable))

        -- create the header. Assume componentid of 1
        local header = string.pack('<BBBBBB', PROTOCOL_MARKER_V1, #payload,
                                   _txseqid, param:get('MAV_SYSID'), 1,
                                   msgid)

        -- generate the CRC
        local crc_extra_msg = _crc_extra[msgid]
        local crc = self.generateCRC(string.sub(header, 2) .. payload ..
                                         string.char(crc_extra_msg))

        -- iterate sequence id
        _txseqid = (_txseqid + 1) % 255

        return header .. payload .. crc
    end

    -- return the instance
    return self
end


--[[
Lua Object for managing the RockBlock modem
--]]
local function RockblockModem()
    -- public fields
    local self = {
        is_transmitting = false,
        first_sucessful_mailbox_check = false,
        time_last_tx = millis():tofloat() * 0.001,
        last_modem_status_check = 0,
        modem_detected = false,
        in_read_cycle = false,
        rx_len = 0
    }

    -- private fields
    local _AT_query = "AT+CGMM\r"
    local _AT_mailbox_check = "AT+SBDIXA\r"
    local _AT_load_tx_buffer = "AT+SBDWB="
    local _AT_read_rx_buffer = "AT+SBDRB\r"
    local _AT_clear_tx_buffer = "AT+SBDD0\r"
    local _AT_clear_rx_buffer = "AT+SBDD1\r"
    
    local _modem_history = {}
    local _modem_to_send = {}
    local _str_recieved = ""
    
    -- Get any incoming data
    function self.rxdata(inchar)
        read = string.char(inchar)
        local maybepkt = nil
        if _modem_history[#_modem_history] == 'AT+SBDRB' and self.in_read_cycle == false and self.rx_len > 0 then
            -- read buffer may include /r and /n, so need a special cycle to capture all up to the self.rx_len
            self.in_read_cycle = true
            _str_recieved = _str_recieved .. read
        elseif self.in_read_cycle and #_str_recieved == self.rx_len + 3 then
            -- get last byte in read cycle
            _str_recieved = _str_recieved .. read
            self.in_read_cycle = false
            self.rx_len = 0
            table.insert(_modem_history, _str_recieved)
            _str_recieved = ""
            if RCK_DEBUG:get() == 1 then
                gcs:send_text(3, "Rockblock: Modem rx msg: " ..
                                  self.nicestring(_modem_history[#_modem_history]))
            end
        elseif (read == '\r' or read == '\n') and not self.in_read_cycle then
            if #_str_recieved > 0 then
                table.insert(_modem_history, _str_recieved)
                if RCK_DEBUG:get() == 1 then
                    gcs:send_text(3, "Rockblock: Modem response: " ..
                                      self.nicestring(_modem_history[#_modem_history]))
                end
                maybepkt = self.check_cmd_return()
            end
            _str_recieved = ""
        else
            _str_recieved = _str_recieved .. read
        end
        return maybepkt
    end

    -- Parse any incoming text from the modem
    -- returns any payload data, nil otherwise
    function self.check_cmd_return()
        -- modem detection (response to AT_query)
        if #_modem_history == 3 and _modem_history[1] == 'AT+CGMM' and
            _modem_history[3] == 'OK' then
            gcs:send_text(3, "Rockblock modem detected - " ..
                              self.nicestring(_modem_history[2]))
            _modem_history = nil
            _modem_history = {}
            self.modem_detected = true
            table.insert(_modem_to_send, _AT_clear_rx_buffer)
            table.insert(_modem_to_send, _AT_clear_tx_buffer)

            -- enable high latency mode, if desired
            if RCK_FORCEHL:get() == 1 then gcs:enable_high_latency_connections(true) end
            return nil
        end

        if self.modem_detected then
            -- TX Buffer clear (response to AT_query)
            if #_modem_history >= 3 and _modem_history[#_modem_history - 2] ==
                'AT+SBDD0' and _modem_history[#_modem_history] == 'OK' then
                if RCK_DEBUG:get() == 1 then
                    gcs:send_text(3, "Rockblock cleared modem TX buffer")
                end
                _modem_history = nil
                _modem_history = {}
                return nil
            end

            -- RX buffer clear (response to AT_query)
            if #_modem_history >= 3 and _modem_history[#_modem_history - 2] ==
                'AT+SBDD1' and _modem_history[#_modem_history] == 'OK' then
                if RCK_DEBUG:get() == 1 then
                    gcs:send_text(3, "Rockblock cleared modem RX buffer")
                end
                _modem_history = nil
                _modem_history = {}
                return nil
            end

            -- Tx buffer loaded (response to AT command)
            if #_modem_history >= 4 and
                string.find(_modem_history[#_modem_history - 3], _AT_load_tx_buffer, 1,
                            true) and _modem_history[#_modem_history] == 'OK' then
                if RCK_DEBUG:get() == 1 then
                    gcs:send_text(3, "Rockblock loaded packet into tx buffer, " ..
                                      tostring(_modem_history[#_modem_history - 3]))
                end
                if _modem_history[#_modem_history - 1] ~= '0' then
                    gcs:send_text(3, "Rockblock Error loading packet into buffer")
                end
                _modem_history = nil
                _modem_history = {}
                return nil
            end

            -- Got received data (response to AT command)
            if _modem_history[#_modem_history - 2] == 'AT+SBDRB' and
                _modem_history[#_modem_history] == 'OK' then
                -- Message format is { 2 byte msg length} + {message} + {2 byte checksum}
                local totallen = #(_modem_history[#_modem_history - 1])
                local len = string.unpack(">i2", _modem_history[#_modem_history - 1])
                local msg = string.sub(_modem_history[#_modem_history - 1], 3,
                                       totallen - 2)
                local checksumrx = string.sub(_modem_history[#_modem_history - 1],
                                              totallen - 1, totallen)
                local highByte, lowByte = self.checksum(msg)

                -- check that received message is OK, then send to MAVLink processor
                if len ~= #msg then
                    gcs:send_text(3,
                                  "Rockblock: Bad RX message length " .. tostring(len) ..
                                      " vs actual " .. tostring(#msg))
                elseif checksumrx ~= (tostring(highByte) .. tostring(lowByte)) then
                    gcs:send_text(3,
                                  "Rockblock: Bad RX CRC " .. checksumrx .. " vs " ..
                                      tostring(highByte) .. tostring(lowByte))
                else
                    if RCK_DEBUG:get() == 1 then
                        gcs:send_text(3, "totmsg=" ..
                                          self.nicestring(
                                              _modem_history[#_modem_history - 1]))
                    end
                end

                _modem_history = nil
                _modem_history = {}
                return msg
            end

            -- Mailbox check  (response to AT command) (can be a fail or success)
            if _modem_history[#_modem_history - 2] == 'AT+SBDIXA' and
                _modem_history[#_modem_history] == 'OK' then

                -- Parse response (comma and : delimited, trimming whitespace)
                local statusReponse = {}
                for w in _modem_history[#_modem_history - 1]:gmatch("[^,:]+") do
                    table.insert(statusReponse, w)
                end

                if #statusReponse == 7 then
                    if tonumber(statusReponse[2]) < 5 then
                        gcs:send_text(3, "Rockblock Packet Transmitted successfully")
                        -- check for rx packet
                        if tonumber(statusReponse[4]) == 1 and self.first_sucessful_mailbox_check then
                            self.rx_len = tonumber(statusReponse[6])
                            gcs:send_text(3, "Rockblock Packet Received of len " .. tostring(self.rx_len))
                            -- read messages, if not first mailbox check
                            table.insert(_modem_to_send, _AT_read_rx_buffer)
                        elseif RCK_DEBUG:get() == 1 then
                            gcs:send_text(3, "Rockblock: No message to receive")
                        end
                        self.first_sucessful_mailbox_check = true
                    elseif tonumber(statusReponse[2]) == 32 then
                        gcs:send_text(3, "Rockblock Error: No network service")
                    else
                        gcs:send_text(3, "Rockblock Error: Unable to send")
                    end
                end
                _modem_history = nil
                _modem_history = {}
                self.is_transmitting = false
                return nil
            end
        end
    end

    function self.checksum(bytes)
        -- Checksum calculation for SBDWB
        -- The checksum is the least significant 2-bytes of the summation of the entire SBD message
        local SUM = 0

        for idx = 1, #bytes do SUM = SUM + bytes:byte(idx) end

        local SUM_H = (SUM & 0xFF << 8) >> 8
        local SUM_L = SUM & 0xFF

        if RCK_DEBUG:get() == 1 then
            gcs:send_text(3, "Rockblock: Modem CRC: " .. string.char(SUM_H) .. " " ..
                              string.char(SUM_L))
        end

        return string.char(SUM_H), string.char(SUM_L)
    end

    function self.nicestring(instr)
        -- make any strings printable to GCS (constrain to ASCII range)
        local retstr = ""
        for i = 1, #instr do
            local c = string.byte(instr:sub(i, i))
            if c < 0x20 or c > 0x7E then c = 0x5F end
            retstr = retstr .. string.char(c)
        end

        return tostring(retstr)
    end
    
    function self.checkmodem()
        --- send detect command to modem every 10 sec if not detected
        if (millis():tofloat() * 0.001) - self.last_modem_status_check > 10 then
            table.insert(_modem_to_send, _AT_query)
            self.last_modem_status_check = millis():tofloat() * 0.001
        end
    end
    
    function self.getnextcommandtosend()
        --- get the next string to send to the modem
        if #_modem_to_send == 0 then
            return nil
        end
        
        local ret = _modem_to_send[1]
        if RCK_DEBUG:get() == 1 then
            gcs:send_text(3, "Rockblock: Sent to modem: " .. self.nicestring(_modem_to_send[1]))
        end
        table.remove(_modem_to_send, 1)
        
        return ret
    end
    
    function self.loadtxbuffer(pkt)
        -- Load the transmit buffer of the modem
        -- Send as binary data, plus checksum
        local highByte, lowByte = self.checksum(pkt)
        table.insert(_modem_to_send, _AT_load_tx_buffer .. tostring(#pkt) .. '\r')
        table.insert(_modem_to_send, pkt)
        table.insert(_modem_to_send, highByte .. lowByte .. "\r")

        self.time_last_tx = millis():tofloat() * 0.001
        if RCK_ENABLE:get()  == 1 then
            table.insert(_modem_to_send, _AT_mailbox_check)
            self.is_transmitting = true
        end
    end
    
    -- return the instance
    return self
end

-- Transmitted HIGH_LATENCY2 packet
local hl2 = {}
hl2.timestamp = 0
hl2.latitude = 0
hl2.longitude = 0
hl2.custom_mode = 0
hl2.altitude = 0
hl2.target_altitude = 0
hl2.target_distance = 0
hl2.wp_num = 0
hl2.failure_flags = 0
hl2.type = gcs:frame_type()
hl2.autopilot = 3 -- MAV_AUTOPILOT_ARDUPILOTMEGA
hl2.heading = 0
hl2.target_heading = 0
hl2.throttle = 0
hl2.airspeed = 0
hl2.airspeed_sp = 0
hl2.groundspeed = 0
hl2.windspeed = 0
hl2.wind_heading = 0
hl2.eph = 0
hl2.epv = 0
hl2.temperature_air = 0
hl2.climb_rate = 0
hl2.battery = 0
hl2.custom0 = 1 -- MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
hl2.custom1 = 0
hl2.custom2 = 0

function wrap_360(angle)
    local res = angle % 360
    if res < 0 then res = res + 360 end
    return res
end

-- Define the MAVLink processor
local mavlink = MAVLinkProcessor()

-- Define the RockBlock interface
local rockblock = RockblockModem()

function HLSatcom()
    -- read in any bytes from rockblock and form into received commands
    local n_bytes = port:available()
    while n_bytes > 0 do
        read = port:read()
        pkt = rockblock.rxdata(read)
        n_bytes = n_bytes - 1
        -- we've got a MAVLink message from the GCS, parse
        if pkt ~= nil then
            for idx = 1, #pkt do
                mavlink.parseMAVLink(pkt:byte(idx))
            end
        end
    end

    -- write out commands from send list. one cmd per loop
    local cmd = rockblock.getnextcommandtosend()
    if cmd ~= nil then
        for idx = 1, #cmd do
            port:write(cmd:byte(idx))
        end
    end

    --- check if modem is there
    if not rockblock.modem_detected then
        gcs:send_text(3, "Rockblock: Trying to detect modem")
        rockblock.checkmodem()
    end

    --- check if GCS telemetry has been lost for RCK_TIMEOUT sec (if param enabled)
    if RCK_FORCEHL:get() == 2 then
        -- link lost time = boot time - GCS last seen time
        link_lost_for = (millis()- gcs:last_seen()):toint()
        -- gcs:last_seen() is set to millis() during boot (on plane). 0 on rover/copter
        -- So if it's less than 10000 assume no GCS packet received since boot
        if link_lost_for > (RCK_TIMEOUT:get() * 1000) and not gcs:get_high_latency_status() and gcs:last_seen() > 10000 then
            gcs:enable_high_latency_connections(true)
        elseif link_lost_for < (RCK_TIMEOUT:get() * 1000) and gcs:get_high_latency_status() then
            gcs:enable_high_latency_connections(false)
        end
    end
    
    -- send HL2 packet every RCK_PERIOD sec, if not aleady in a mailbox check
    if rockblock.modem_detected and gcs:get_high_latency_status() and
        (millis():tofloat() * 0.001) - rockblock.time_last_tx > RCK_PERIOD:get() and not rockblock.is_transmitting then

        -- update HL2 packet
        hl2.timestamp = millis():tofloat()
        local position = ahrs:get_location()
        local wind = ahrs:wind_estimate()

        if position then
            hl2.latitude = tonumber(position:lat())
            hl2.longitude = tonumber(position:lng())
            hl2.altitude = math.floor(tonumber(position:alt()) * 0.01)
        end
        if wind then
            wind_xy = Vector2f()
            wind_xy:x(wind:x())
            wind_xy:y(wind:y())
            hl2.windspeed = math.abs(math.floor(wind_xy:length() * 5))
            hl2.wind_heading = math.floor(wrap_360(wind_xy:angle()) / 2)
        end
        hl2.custom_mode = vehicle:get_mode()

        if vehicle:get_wp_distance_m() ~= nil then
            hl2.target_distance = math.floor(vehicle:get_wp_distance_m() / 10)
        end
        if mission:get_current_nav_index() ~= nil then
            hl2.wp_num = mission:get_current_nav_index()
        end
        if vehicle:get_wp_bearing_deg() ~= nil then
            hl2.target_heading = math.floor(wrap_360(
                                                vehicle:get_wp_bearing_deg()) /
                                                2)
        end

        -- failure flags
        hl2.failure_flags = 0
        if not ahrs:healthy() then
            hl2.failure_flags = hl2.failure_flags + 4096 -- HL_FAILURE_FLAG_ESTIMATOR
        end
        if battery:num_instances() > 0 and not battery:healthy(0) then
            hl2.failure_flags = hl2.failure_flags + 128 -- HL_FAILURE_FLAG_BATTERY
        end
        if gps:num_sensors() > 0 and gps:status(0) <= gps.NO_FIX then
            hl2.failure_flags = hl2.failure_flags + 1 -- HL_FAILURE_FLAG_GPS
        end
        if (FWVersion:type() == 2 or FWVersion:type() == 3) and terrain:status() ==
            terrain.TerrainStatusUnhealthy then
            -- only for copter and plane
            hl2.failure_flags = hl2.failure_flags + 64 -- HL_FAILURE_FLAG_TERRAIN
        end
        if not rc:has_valid_input() then
            hl2.failure_flags = hl2.failure_flags + 256 -- HL_FAILURE_FLAG_RC_RECEIVER
        end

        hl2.heading = math.floor(wrap_360(math.deg(ahrs:get_yaw_rad())) / 2)
        hl2.throttle = math.floor(gcs:get_hud_throttle())
        if ahrs:airspeed_estimate() ~= nil then
            hl2.airspeed = math.abs(math.floor(ahrs:airspeed_estimate() * 5))
        end
        -- hl2.airspeed_sp = 0
        hl2.groundspeed = math.abs(math.floor(
                                       ahrs:groundspeed_vector():length() * 5))

        hl2.temperature_air = math.floor(baro:get_external_temperature())
        
        if battery:num_instances() > 0 and battery:capacity_remaining_pct(0) ~= nil then
            hl2.battery = battery:capacity_remaining_pct(0)
        else
            hl2.battery = 0
        end

        -- just sending armed state here for simplicity. Flight mode is in the custom_mode field
        if arming:is_armed() then
            hl2.custom0 = 129 -- MAV_MODE_FLAG_SAFETY_ARMED + MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        else
            hl2.custom0 = 1 -- MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        end

        local newpkt = mavlink.createMAVLink(hl2, mavlink.HIGH_LATENCY2)
        if #newpkt > 50 then
            gcs:send_text(3, "Rockblock: Tx packet > 50 bytes: " .. tostring(#newpkt))
        end

        -- send packet
        rockblock.loadtxbuffer(newpkt)
        
    end
end

-- wrapper around HLSatcom(). This calls HLSatcom() and if HLSatcom faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(HLSatcom)
    if not success then
        gcs:send_text(3, "Internal Error: " .. err)
        -- when we fault we run the HLSatcom function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, math.floor(1000 / 10)
end

-- start running HLSatcom loop
return protected_wrapper()



================================================
File: applets/RockBlock.md
================================================
# RockBlock Lua Script

Lua script to send a recieve very basic MAVLink telemetry over a
Rockblock SBD satellite modem
Requires https://github.com/stephendade/rockblock2mav at the GCS end

Note that this uses MAVLink1 messaging, due to it's smaller message size compared
to MAVLink2.

Messages will only be send or received if High Latency Mode is enabled.

Setup:
This script requires 1 serial port:
- A "Script" port to connect the modem to

Caveats:
- This will *only* send HIGH_LATENCY2 packets via the SBD modem. No heartbeats, no command acknowledgements, no statustexts, no parameters, etc
- A single HIGH_LATENCY2 packet will be sent every RCK_PERIOD sec, in addition to receiving 
   a single MAVLink packet from the GCS. This is known as a mailbox check.
- Any incoming packets on the first mailbox check will be ignored (as these may be from a long time in the past)
- Only 1 command can be sent per mailbox check from the GCS. Any additional commands will overwrite the previous command

# Parameters

The script adds the following parameters:

## RCK_FORCEHL

Mode of operation:
- 0 = start disabled, can be enabled via MAV_CMD_CONTROL_HIGH_LATENCY
- 1 = start enabled, can be disabled via MAV_CMD_CONTROL_HIGH_LATENCY
- 2 = enabled on loss of telemetry (GCS) link for RCK_TIMEOUT seconds

## RCK_PERIOD

When in High Latency mode, send Rockblock updates every RCK_PERIOD seconds

## RCK_DEBUG

Sends Rockblock debug text to GCS via statustexts

## RCK_ENABLE

Enables the modem transmission

## RCK_TIMEOUT

If RCK_FORCEHL=2, this is the number of seconds of no-messages from the GCS until High Latency mode is auto-enabled

When GCS messages are recieved again, High Latency mode is auto-disabled.


================================================
File: applets/Script_Controller.lua
================================================
--[[
   a script to select other lua scripts using an auxillary switch from
    /1 /2 or /3 subdirectories of the scripts directory
--]]
---@diagnostic disable: param-type-mismatch


local THIS_SCRIPT = "Script_Controller.lua"
local sel_ch = Parameter("SCR_USER6")
SEL_CH = sel_ch:get()
if SEL_CH == 0 then
   SEL_CH = 302
end

MISSION_FILENAME = "mission.txt"
--[[
   check that directory exists
--]]
function check_subdir_exists(n)
  return dirlist(get_scripts_dir() .. "/" .. n )
end

--[[
   copy file src to dest, return true on success
--]]
function file_copy(src, dest)
   local block_size = 256
   local file1 = io.open(src, "rb")
   if not file1 then
      return false
   end
   local file2 = io.open(dest, "wb")
   if not file2 then
      file1:close()
      return false
   end
   while true do
      local block = file1:read(block_size)
      if not block then
         break
      end
      file2:write(block)
   end
   local ret = false
   if file1:seek("end") == file2:seek("end") then
      ret = true
   end
   file1:close()
   file2:close()
   return ret
end

--[[
   compare two files, return true if they are the same
--]]
function file_compare(filename1, filename2)
   local block_size = 256
   local file1 = io.open(filename1, "rb")
   if not file1 then
      return false
   end
   local file2 = io.open(filename2, "rb")
   if not file2 then
      file1:close()
      return false
   end
   local ret = true
   while true do
      local block1 = file1:read(block_size)
      local block2 = file2:read(block_size)
      if block1 ~= block2 then
         ret = false
         break
      end
      if not block1 then
         break
      end
   end
   file1:close()
   file2:close()
   return ret
end

--[[
   get the path to the scripts directory. This will be scripts/ on SITL
   and APM/scripts on a ChibiOS board
--]]
function get_scripts_dir()
   local dlist1 = dirlist("APM/scripts")
   if dlist1 and #dlist1 > 0 then
      return "APM/scripts"
   end
   -- otherwise assume scripts/
   return "scripts"
end

--[[
    check if a file exists, returns true if it does' fname is complete path to file
--]]
function file_exists(fname)
   local f = io.open(fname,"rb")
   if not f then
      return false
   end
   f:close()
   return true
end

--[[ compare strings case insensitive and return true if match

--]]
function compare_strings_ci(a,b)
   return string.upper(a) == string.upper(b)
end

--[[
   remove any lua scripts in the scripts directory that are not in the given subdir besides ourselves
   returns true if any files were removed
--]]
function remove_scripts(subdir)
   local sdir = get_scripts_dir()
   local dlist = dirlist(sdir)
   if not dlist then
      return false
   end
   local ret = false
   for _,v in ipairs(dlist) do
      local suffix = v:sub(-4)
      if compare_strings_ci(suffix,".LUA") and not compare_strings_ci(v,THIS_SCRIPT) then
         if not file_exists(subdir .. "/" .. v) then
            ret = true
            remove(sdir .. "/" .. v)
         end
      end
   end
   return ret
end

--[[
   copy scripts from a subdir to the main scripts directory
   return true if any changes were made
--]]
function copy_scripts(subdir)
   local dlist = dirlist(subdir)
   if not dlist then
      return false
   end
   local ret = false
   local sdir = get_scripts_dir()
   for _, v in ipairs(dlist) do
      local suffix = v:sub(-4)
      if compare_strings_ci(suffix,".LUA") and not compare_strings_ci(v,THIS_SCRIPT) then
         local src = subdir .. "/" .. v
         local dest = sdir .. "/" .. v
         if not file_compare(src, dest) then
            ret = true
            file_copy(src, dest)
         end
      end
   end
   if ret then
      gcs:send_text(5,"Copied new files to scripts directory")
   end
   return ret
end

 --[[ 
   load a mission from a MISSION_FILENAME file in subdirectory n
 --]]
function mission_load(n)
  file_name = get_scripts_dir() .. "/" .. n .."/" .. MISSION_FILENAME
  -- Open file
  file = io.open(file_name)
  if not file then
     return
  end
  -- check header
  assert(string.find(file:read('l'),'QGC WPL 110') == 1, file_name .. ': incorrect format')
  -- clear any existing mission
  assert(mission:clear(), 'Could not clear current mission')
  -- read each line and write to mission
  local item = mavlink_mission_item_int_t()
  local index = 0
  local fail = false
  while true and not fail do
     local line = file:read()
     if not line then
        break
     end
     local ret, _, seq, _--[[ curr ]], frame, cmd, p1, p2, p3, p4, x, y, z, _--[[ autocont ]] = string.find(line, "^(%d+)%s+(%d+)%s+(%d+)%s+(%d+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+(%d+)")
     if not ret then
        fail = true
        break
     end
     if tonumber(seq) ~= index then
        fail = true
        break
     end
     item:seq(tonumber(seq))
     item:frame(tonumber(frame))
     item:command(tonumber(cmd))
     item:param1(tonumber(p1))
     item:param2(tonumber(p2))
     item:param3(tonumber(p3))
     item:param4(tonumber(p4))
     if mission:cmd_has_location(tonumber(cmd)) then
        item:x(math.floor(tonumber(x)*10^7))
        item:y(math.floor(tonumber(y)*10^7))
     else
        item:x(math.floor(tonumber(x)))
        item:y(math.floor(tonumber(y)))
     end
     item:z(tonumber(z))
     if not mission:set_item(index,item) then
        mission:clear() -- clear part loaded mission
        fail = true
        break
     end
     index = index + 1
  end
  if fail then
     mission:clear()  --clear anything already loaded
     error(string.format('failed to load mission at seq num %u', index))
  end
  gcs:send_text(0, string.format("Loaded %u mission items", index))
end

--[[
   activate a scripting subdirectory
--]]
function activate_subdir(n)
   -- step1, remove lua files from scripts/ that are not in the given subdirectory
   local subdir = get_scripts_dir() .. "/" .. n
   local changes_made = remove_scripts(subdir)
   changes_made = changes_made or copy_scripts(subdir)  --copy files if different
   return changes_made
end

local sw_last = -1
function update()
   local sw_current = rc:get_aux_cached(SEL_CH)
   if sw_current == sw_last or sw_current == nil then
      return update, 500
   end
   if sw_current == 1  then 
        subdir = 2
      elseif sw_current == 2 then
        subdir = 3
      else
        subdir = 1  --default if RC not established yet
   end
   sw_last = sw_current
   if not check_subdir_exists(subdir) then
      gcs:send_text(0,string.format("Scripts subdirectory /%s does not exist!",subdir))
      return update, 500
   end

   changes_made = activate_subdir(subdir)
   if changes_made then
      scripting:restart_all()
   else
      mission_load(subdir)
      gcs:send_text(0, string.format("Scripts subbdirectory %s active", subdir))
   end
   return update, 500
end

gcs:send_text(6,"Loaded Script_Controller.lua")
return update, 500







================================================
File: applets/Script_Controller.md
================================================
# Script Control LUA Script

This script allows the user to have groups of scripts in three subdirectories of the main scripting directory and copy them into the main scripts directory, removing any files in that directory with the .lua extension (except itself) and issue a scripting restart based on the position of a switch with a programmable auxiliary function option (default is "302", but can be changed by user during setup) or using Mission Planner's AUX Function tab. This provides means to have differing scripts depending on the mission or conditions, and use whichever set is desired without having them consume memory all the time, and without requiring a GCS to manage the content of the scripts directory. It also allows a new mission to be loaded associated with those new scripts, if desired.

If the designated RC switch auxiliary option is not assigned to a RC channel via an RCx_OPTION, or the selected subdirectory does not exist, no action is taken, so the script can reside in the scripts directory even if not being used.

# Setup and Operation

The auxiliary function option (300 - 307) that can be assigned to an RC channel and/or used by Mission Planner is set by the scripting parameter SCR_USER6. If not set (this param's default is "0") then function "302" is assigned automatically. Setting an RC channel's option to this value allows RC control of the scripting subdirectory that will be used for scripts (and optionally to load a mission file from within that subdirectory). Mission Planner can control switching also, or in place of the RC channel, using its AUX Function tab.

The auxiliary function (default "302") is used to determine which of the three scripts subdirectories will be used: LOW:scripts/1, MIDDLE:scripts/2, or HIGH:scripts/3. If an RC channel option has been set to this,but no RC has been established during ground start, it will behave as if subdirectory 1 is selected. Changing this switch position either prior to ground start or after (or using Mission Planner), if the selected subdirectory exists, will remove ALL the *.lua files in the scripts directory (except itself), and copy any *.lua files (only) from the desginated subdirectory, load a new mission if a mission file named "mission.txt" exists in the subdirectory, and then issue a scripting restart. If the subdirectory does not exist, then no action is taken and a GCS message issued.

# CAUTIONS

If parameters are being created by scripts be sure that different scripts do not use the same PARAMETER KEY to create their param tables, unless you desire to use the same parameter set in two different scripts. Otherwise, param values will be corrupt when you change scripts.
Be sure to have unique parameter names for different parameter sets. This script does not create any parameters for potential conflict.

Parameter names are only visible and used by Ground Control Stations. While indentically named params in different scripts will operate fine, you will not be able to distinguish them in the GCS displays!

Any .lua script in the scripts directory will be ERASED! when this script is run. In order to keep another .lua script running when using this script, place it in every subdirectory so that it will be copied into the main scripts directory whenever changing directories.





================================================
File: applets/SmartAudio.lua
================================================
--------------------------------------------------
--------------------------------------------------
--------- VTX LUA for SMARTAUDIO 2.0 -------------
------------based on work by----------------------
---------Craig Fitches 07/07/2020 ----------------
-------------Mods by H. Wurzburg -----------------
------------clean up by Peter Hall----------------

-----------------HARDWARE------------------
-- tested on CUAVv5Nano and TX8111 VTX

-- Prerequisites ----------------------------------
-- 1. Only works in Ardupilot 4.1dev or later
-- 2. FC with 2MB cache for LUA Scripting
-- 3. Currently only works with SmartAudio 2.0

------------ Instructions ------------------------
-- 1. Set an unused Serial port in Ardupilot to protocol 28 (scripting) and option 4 (half-duplex)
-- 2. Setup an rc channel's RXc_OPTION to 300 for changing power and SCR_USER1 parameter for initial power upon boot
---------and set to -1 for unchanged, 0 (PitMode),1,2,3, or 4 for power level (1 lowest,4 maximum)
-- 3. Attach the UART's TX for the Serial port chosen above to the VTX's SmartAudio input

---@diagnostic disable: need-check-nil


-- init local variables
local startup_pwr = param:get('SCR_USER1') 
local scripting_rc = rc:find_channel_for_option(300)
local port = serial:find_serial(0)
local _current_power = -1

-- hexadecimal smart audio 2.0 commands
local power_commands = {}
power_commands[1] = { {0x00,0x00,0xAA,0x55,0x0B,0x01,0x01,0xF8,0x00}, "VTX Pit Mode" }
power_commands[2] = { {0x00,0x00,0xAA,0x55,0x05,0x01,0x00,0x6B,0x00}, "VTX PWR LOW" } -- SMARTAUDIO_V2_COMMAND_POWER_0
power_commands[3] = { {0x00,0x00,0xAA,0x55,0x05,0x01,0x01,0xBE,0x00}, "VTX PWR MED" } -- SMARTAUDIO_V2_COMMAND_POWER_1
power_commands[4] = { {0x00,0x00,0xAA,0x55,0x05,0x01,0x02,0x14,0x00}, "VTX PWR HIGH" } -- SMARTAUDIO_V2_COMMAND_POWER_2
power_commands[5] = { {0x00,0x00,0xAA,0x55,0x05,0x01,0x03,0xC1,0x00}, "VTX PWR MAX" } -- SMARTAUDIO_V2_COMMAND_POWER_3


-- return a power level from 1 to 5 as set with a switch
function get_power()
  input = scripting_rc:norm_input() -- - 1 to 1
  input = (input + 1) * 2 -- 0 to 4
  return math.floor(input+0.5) + 1 -- integer 1 to 5
end

-- set the power in the range 1 to 5
function setPower(power)
  if power == _current_power then
    return
  end
  updateSerial(power_commands[power][1])
  gcs:send_text(4, power_commands[power][2])
  _current_power = power
end

-- write output to the serial port
function updateSerial(value)
  for count = 1, #value do
    port:write(value[count])
  end
end

---- main update ---
function update()
  setPower(get_power())
  return update, 500
end

-- initialization
function init()
  -- check if setup properly
  if not port then
    gcs:send_text(0, "SmartAudio: No Scripting Serial Port")
    return
  end
  if not scripting_rc then
    gcs:send_text(0, "SmartAudio: No RC option for scripting")
    return
  end

  port:begin(4800)

  -- Set initial power after boot based on SCR_USER1
  if startup_pwr then -- make sure we found the param
    if startup_pwr >= 0  and startup_pwr < 5 then
      setPower(math.floor(startup_pwr) + 1)

      -- set the current power local to that requested by the rc in
      -- this prevents instantly changing the power from the startup value
      _current_power = get_power()
    end
  end
  return update, 500
end

return init, 2000 --Wait 2 sec before initializing, gives time for RC in to come good in SITL, also gives a better chance to see errors



================================================
File: applets/SmartAudio.md
================================================
# SmartAudio Lua Script

Allows the setting of Smart Audio 2.0 video transmitters (VTX) via RC transmitter and to set an initial power level on system boot.

Four power levels can be set by the value of an RC channel: Pit Mode, Low, Medium, High, and Maximum. What these power levels actually produce is dependent on transmitter used. The new power level is activated upon the channel's changing to the new power selection.

The power level upon boot can be selected to be unchanged, or set to one of those above values by setting parameter SCR_USER1 to -1,0,1,2,3 or 4. Unchanged is -1. 0-4 correspond to the above levels.

The RC channel used to control the power level has its RCx_OPTION set to "300".

Ground Control Station messages will confirm boot value and any changes made later.

The VTX SmartAudio input is connected to any free autopilot UART TX line. That UART's corresponding SERIALx Port should have its SERIALx_PROTOCOL set to 28 and SERIALx_OPTIONS to 4 for half-duplex.

Pit Mode is set by the RC channel being a RCx_MIN for that channel, and MAXIMUM is set at RCx_MAX for the channel. The other levels are linearly spread in the interval. If MIN is 1000 and MAX is 2000, the mapping would be:

PWM        | Power Level
-----------|------------
1000 - 1124| Pit Mode |
1125 - 1374| LOW |
1375-1624| MED |
1625-1874| HIGH |
1875-2000| MAX |

Note: Some SmartAudio 2.0 VTX cannot be placed in PitMode remotely, but they can exit it and have power changed with this script. SmartAudio 2.1 VTX have the abiity to be remotely commanded into PitMode



================================================
File: applets/UniversalAutoLand.lua
================================================
--[[ Upon Arming , creates a four item mission consisting of: NAV_TAKEOFF, DO_LAND_START,Final Approach WP opposite bearing from HOME of heading used during takeoff, at TKOFF_ALT or SCR_USER3 above home, SCR_USER2 or 2X TKOFF_DIST, and a LAND waypoint at HOME and stops until next disarm/boot. SCR_USER1 is used to enable or disable it.
--]]
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 80
local PARAM_TABLE_PREFIX = "AUTOLAND_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 4), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

--[[
  // @Param: AUTOLAND_ENABLE
  // @DisplayName: AUTOLAND ENABLE
  // @Description: enable AUTOLAND script action
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local AULND_ENABLE = bind_add_param('ENABLE', 1, 1)
local enable = AULND_ENABLE:get()

--[[
  // @Param: AUTOLAND_WP_ALT
  // @DisplayName: Final approach waypoint alt
  // @Description: Altitude of final approach waypoint created by script
  // @Range: 1 100
  // @Units: m
  // @User: Standard
--]]
local AULND_ALT = bind_add_param('WP_ALT', 2, 0)
local final_wp_alt = AULND_ALT:get()
--[[
  // @Param: AUTOLAND_WP_DIST
  // @DisplayName: Final approach waypoint distance
  // @Description: Distance from landng point (HOME) to final approach waypoint created by script in the opposite direction of initial takeoff
  // @Range: 0 1000
  // @Units: m
  // @User: Standard
--]]
local AULND_DIST = bind_add_param('WP_DIST', 3, 0)
local final_wp_dist = AULND_DIST:get()

FRAME_GLOBAL = 3
NAV_WAYPOINT = 16
NAV_TAKEOFF = 22
NAV_LAND = 21
DO_LAND_START = 189

TAKEOFF_PITCH = 15

local function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

local function wrap_180(angle)
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

function create_final_approach_WP(i,bearing,dist,alt) --index,degs,m,m
   local item = mavlink_mission_item_int_t()
   local loc = ahrs:get_home()
   loc:offset_bearing(bearing,dist) ---degs and meters

   item:seq(i)
   item:frame(FRAME_GLOBAL)
   item:command(NAV_WAYPOINT)
   item:param1(0)
   item:param2(0)
   item:param3(0)
   item:param4(0)
   item:x(loc:lat())
   item:y(loc:lng())
   item:z(alt)
   return item
end

function create_takeoff_WP(alt)
   local item = mavlink_mission_item_int_t()
   local loc = ahrs:get_home()
   
   item:seq(1)
   item:frame(FRAME_GLOBAL)
   item:command(NAV_TAKEOFF)
   item:param1(TAKEOFF_PITCH)
   item:param2(0)
   item:param3(0)
   item:param4(0)
   item:x(loc:lat())
   item:y(loc:lng())
   item:z(alt)
   return item
end

function create_land_WP()
   local item = mavlink_mission_item_int_t()
   local loc = ahrs:get_home()

   item:seq(4)
   item:frame(FRAME_GLOBAL)
   item:command(NAV_LAND)
   item:param1(15)
   item:param2(0)
   item:param3(0)
   item:param4(0)
   item:x(loc:lat())
   item:y(loc:lng())
   item:z(0)
   return item
end

function create_do_land_start_WP()
   local item = mavlink_mission_item_int_t()

   item:seq(2)
   item:frame(FRAME_GLOBAL)
   item:command(DO_LAND_START)
   item:param1(0)
   item:param2(0)
   item:param3(0)
   item:param4(0)
   item:x(0)
   item:y(0)
   item:z(0)
   return item
end

function update()
  if not arming:is_armed() then --if disarmed, wait until armed
    mission_loaded = false
    return update,1000
  end
  
  if not mission_loaded then --if first time after arm and enabled is valid then create  mission 
    local home = ahrs:get_home()
    local location = ahrs:get_location()
    local speed = gps:ground_speed(0)
    local alt = baro:get_altitude()
    if location and home and speed > (0.5 * param:get("AIRSPEED_MIN")) then
        local yaw = gps:ground_course(0)
        mission:set_item(3,create_final_approach_WP(3,wrap_180(yaw+180),final_wp_dist,final_wp_alt))
        mission:set_item(4,create_land_WP())
        mission_loaded = true
        gcs:send_text(MAV_SEVERITY.NOTICE, string.format("Captured initial takeoff direction = %.1f at %.1f m and %.1f m/s",yaw, alt, speed))
    end
  end
  return update, 200
end 

gcs:send_text(MAV_SEVERITY.INFO,"Loaded UniversalAutoLand.lua")
if enable == 1 then 
   if final_wp_dist == 0 or final_wp_alt ==0 then
      gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("Must set Final Waypoint alt and dist values!"))
      return
   end
   mission:clear()
   local item = mavlink_mission_item_int_t()
   item:command(NAV_WAYPOINT)
   mission:set_item(0,item)
   mission:set_item(1,create_takeoff_WP(param:get("TKOFF_ALT"))) 
   mission:set_item(2,create_do_land_start_WP()) 
   gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("Set Final Waypoint alt and dist values!"))   
   return update, 1000
else
   gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("Script disabled by AUTOLAND_ENABLE"))
return
end




================================================
File: applets/UniversalAutoLand.md
================================================
This script is intended to allow easy, unpre-planned operation at any location with the protection of a do-land-start autoland sequence for failsafes that accounts for takeoff direction (ie wind direction). Final approach objects must be considered before you launch.

If enabled by AUTOLAND_ENABLE =1, setups up an autotakeoff waypoint as first waypoint and upon Arming , adds mission items consisting of:  DO_LAND_START,Final Approach WP opposite bearing from HOME of heading used during takeoff, to AUTOLAND_WP_ALT above home,  and at AUTOLAND_WP_DIST distancee, and a LAND waypoint at HOME and stops until next disarm/boot. Warnings are given if the AUTOLAND parameters are not set.

In use you just arm and switch to AUTO, and then switch to other flight modes after takeoff is completed to fly around.....relatively assured that a failsafe (assuming defaults for Failsafe) will result in an autolanding in the correct direction. You can also just switch back to AUTO or RTL to do an autoland. 

Caveats: be sure you have tested and setup autoland and AUTOLAND parameters. Setting AUTOLAND_WP_ALT and _WP_DIST for a good glide path on a final approach is required (be aware of possible obstructions when using). Values of 400 meters distance and 55 meters altitude work well for typcial 1m wingspan/1 kg foam planes. RTL_AUTOLAND must be set and a value = 2 is recommended also.

Be aware of obstacles that might come into play on a final approach. Be aware that occasionally final approach waypoints may not be exactly in line with the takeoff if the GPS signal quality is compromised during takeoff.



================================================
File: applets/VTOL-quicktune.lua
================================================
--[[
 fast tuning of VTOL gains for multirotors and quadplanes

 This should be used in QLOITER mode for quadplanes and LOITER mode
 for copters, although it will work in other VTOL modes

--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: missing-parameter

--[[
 - TODO:
 - disable weathervaning while tuning?
 - possibly lower P XY gains during tuning?
 - bail out on a large angle error?
--]]

local MAV_SEVERITY_INFO = 6
local MAV_SEVERITY_NOTICE = 5
local MAV_SEVERITY_CRITICAL = 2
local MAV_SEVERITY_EMERGENCY = 0

local PARAM_TABLE_KEY = 8
local PARAM_TABLE_PREFIX = "QUIK_"

local atc_prefix = "ATC"

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup quicktune specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add param table')

--[[
  // @Param: QUIK_ENABLE
  // @DisplayName: Quicktune enable
  // @Description: Enable quicktune system
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local QUIK_ENABLE      = bind_add_param('ENABLE',         1, 0) 

--[[
  // @Param: QUIK_AXES
  // @DisplayName: Quicktune axes
  // @Description: axes to tune
  // @Bitmask: 0:Roll,1:Pitch,2:Yaw
  // @User: Standard
--]]
local QUIK_AXES        = bind_add_param('AXES',           2, 7)

--[[
  // @Param: QUIK_DOUBLE_TIME
  // @DisplayName: Quicktune doubling time
  // @Description: Time to double a tuning parameter. Raise this for a slower tune.
  // @Range: 5 20
  // @Units: s
  // @User: Standard
--]]
local QUIK_DOUBLE_TIME = bind_add_param('DOUBLE_TIME',    3, 10)

--[[
  // @Param: QUIK_GAIN_MARGIN
  // @DisplayName: Quicktune gain margin
  // @Description: Reduction in gain after oscillation detected. Raise this number to get a more conservative tune
  // @Range: 20 80
  // @Units: %
  // @User: Standard
--]]
local QUIK_GAIN_MARGIN = bind_add_param('GAIN_MARGIN',    4, 60)

--[[
  // @Param: QUIK_OSC_SMAX
  // @DisplayName: Quicktune oscillation rate threshold
  // @Description: Threshold for oscillation detection. A lower value will lead to a more conservative tune.
  // @Range: 1 10
  // @User: Standard
--]]
local QUIK_OSC_SMAX    = bind_add_param('OSC_SMAX',       5, 5)

--[[
  // @Param: QUIK_YAW_P_MAX
  // @DisplayName: Quicktune Yaw P max
  // @Description: Maximum value for yaw P gain
  // @Range: 0.1 3
  // @User: Standard
--]]
local QUIK_YAW_P_MAX   = bind_add_param('YAW_P_MAX',      6, 0.5)

--[[
  // @Param: QUIK_YAW_D_MAX
  // @DisplayName: Quicktune Yaw D max
  // @Description: Maximum value for yaw D gain
  // @Range: 0.001 1
  // @User: Standard
--]]
local QUIK_YAW_D_MAX   = bind_add_param('YAW_D_MAX',      7, 0.01)

--[[
  // @Param: QUIK_RP_PI_RATIO
  // @DisplayName: Quicktune roll/pitch PI ratio
  // @Description: Ratio between P and I gains for roll and pitch. Raise this to get a lower I gain
  // @Range: 0.5 1.0
  // @User: Standard
--]]
local QUIK_RP_PI_RATIO = bind_add_param('RP_PI_RATIO',    8, 1.0)

--[[
  // @Param: QUIK_Y_PI_RATIO
  // @DisplayName: Quicktune Yaw PI ratio
  // @Description: Ratio between P and I gains for yaw. Raise this to get a lower I gain
  // @Range: 0.5 20
  // @User: Standard
--]]
local QUIK_Y_PI_RATIO  = bind_add_param('Y_PI_RATIO',     9, 10)

--[[
  // @Param: QUIK_AUTO_FILTER
  // @DisplayName: Quicktune auto filter enable
  // @Description: When enabled the PID filter settings are automatically set based on INS_GYRO_FILTER
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local QUIK_AUTO_FILTER = bind_add_param('AUTO_FILTER',   10, 1)

--[[
  // @Param: QUIK_AUTO_SAVE
  // @DisplayName: Quicktune auto save
  // @Description: Number of seconds after completion of tune to auto-save. This is useful when using a 2 position switch for quicktune
  // @Units: s
  // @User: Standard
--]]
local QUIK_AUTO_SAVE   = bind_add_param('AUTO_SAVE',     11, 0)

--[[
  // @Param: QUIK_RC_FUNC
  // @DisplayName: Quicktune RC function
  // @Description: RCn_OPTION number to use to control tuning stop/start/save
  // @User: Standard
--]]
local QUIK_RC_FUNC     = bind_add_param('RC_FUNC',       12, 300)

--[[
  // @Param: QUIK_MAX_REDUCE
  // @DisplayName: Quicktune maximum gain reduction
  // @Description: This controls how much quicktune is allowed to lower gains from the original gains. If the vehicle already has a reasonable tune and is not oscillating then you can set this to zero to prevent gain reductions. The default of 20% is reasonable for most vehicles. Using a maximum gain reduction lowers the chance of an angle P oscillation happening if quicktune gets a false positive oscillation at a low gain, which can result in very low rate gains and a dangerous angle P oscillation.
  // @Units: %
  // @Range: 0 100
  // @User: Standard
--]]
local QUIK_MAX_REDUCE  = bind_add_param('MAX_REDUCE',    13, 20)

--[[
  // @Param: QUIK_OPTIONS
  // @DisplayName: Quicktune options
  // @Description: Additional options. When the Two Position Switch option is enabled then a high switch position will start the tune, low will disable the tune. you should also set a QUIK_AUTO_SAVE time so that you will be able to save the tune.
  // @Bitmask: 0:UseTwoPositionSwitch
  // @User: Standard
--]]
local QUIK_OPTIONS     = bind_add_param('OPTIONS',       14, 0)

--[[
  // @Param: QUIK_ANGLE_MAX
  // @DisplayName: maximum angle error for tune abort
  // @Description: If while tuning the angle error goes over this limit then the tune will aborts to prevent a bad oscillation in the case of the tuning algorithm failing. If you get an error "Tuning: attitude error ABORTING" and you think it is a false positive then you can either raise this parameter or you can try increasing the QUIK_DOUBLE_TIME to do the tune more slowly. A value of zero disables this check.
  // @Units: deg
  // @User: Standard
--]]
local QUIK_ANGLE_MAX = bind_add_param('ANGLE_MAX', 15, 10)

local OPTIONS_TWO_POSITION = (1<<0)

local INS_GYRO_FILTER  = bind_param("INS_GYRO_FILTER")

local RCMAP_ROLL       = bind_param("RCMAP_ROLL")
local RCMAP_PITCH      = bind_param("RCMAP_PITCH")
local RCMAP_YAW        = bind_param("RCMAP_YAW")

local RCIN_ROLL  = rc:get_channel(RCMAP_ROLL:get())
local RCIN_PITCH = rc:get_channel(RCMAP_PITCH:get())
local RCIN_YAW   = rc:get_channel(RCMAP_YAW:get())

local UPDATE_RATE_HZ = 40
local STAGE_DELAY = 4.0
local PILOT_INPUT_DELAY = 4.0

local YAW_FLTE_MAX = 8.0
local FLTD_MUL = 0.5
local FLTT_MUL = 0.5

-- SMAX to set if none set at start
local DEFAULT_SMAX = 50.0

-- work out vehicle type
if param:get("Q_A_RAT_RLL_SMAX") then
   is_quadplane = true
   atc_prefix = "Q_A"
   gcs:send_text(MAV_SEVERITY_EMERGENCY, "Quicktune for quadplane loaded")
elseif param:get("ATC_RAT_RLL_SMAX") then
   is_quadplane = false
   gcs:send_text(MAV_SEVERITY_EMERGENCY, "Quicktune for multicopter loaded")
else
   gcs:send_text(MAV_SEVERITY_EMERGENCY, "Quicktune unknown vehicle")
   return
end

-- get time in seconds since boot
function get_time()
   return millis():tofloat() * 0.001
end

local axis_names = { "RLL", "PIT", "YAW" }
local param_suffixes = { "FF", "P", "I", "D", "SMAX", "FLTT", "FLTD", "FLTE" }
local stages = { "D", "P" }
local stage = stages[1]
local last_stage_change = get_time()
local last_gain_report = get_time()
local last_pilot_input = get_time()
local tune_done_time = nil
local slew_parm = nil
local slew_target = 0
local slew_delta = 0
local aborted = false

local axes_done = {}
local filters_done = {}


-- create params dictionary indexed by name, such as "RLL_P"
local params = {}
local param_saved = {}
local param_changed = {}
local need_restore = false

for _, axis in ipairs(axis_names) do
   for _, suffix in ipairs(param_suffixes) do
      local pname = axis .. "_" .. suffix
      params[pname] = bind_param(atc_prefix .. "_" .. "RAT_" .. pname)
      param_changed[pname] = false
   end
end

-- reset to start
function reset_axes_done()
   for _, axis in ipairs(axis_names) do
      axes_done[axis] = false
      filters_done[axis] = false
   end
   stage = stages[1]
end

-- get all current param values into param_saved dictionary
function get_all_params()
   for pname in pairs(params) do
      param_saved[pname] = params[pname]:get()
   end
end

-- restore all param values from param_saved dictionary
function restore_all_params()
   for pname in pairs(params) do
      if param_changed[pname] then
         params[pname]:set(param_saved[pname])
         param_changed[pname] = false
      end
   end
end

-- save all param values to storage
function save_all_params()
   for pname in pairs(params) do
      if param_changed[pname] then
         params[pname]:set_and_save(params[pname]:get())
         param_saved[pname] = params[pname]:get()
         param_changed[pname] = false
      end
   end
end

-- setup a default SMAX if zero
function setup_SMAX()
   for _, axis in ipairs(axis_names) do
      local smax = axis .. "_SMAX"
      if params[smax]:get() <= 0 then
         adjust_gain(smax, DEFAULT_SMAX)
      end
   end
end

-- setup filter frequencies
function setup_filters(axis)
   if QUIK_AUTO_FILTER:get() <= 0 then
      filters_done[axis] = true
      return
   end
   local fltd = axis .. "_FLTD"
   local fltt = axis .. "_FLTT"
   local flte = axis .. "_FLTE"
   adjust_gain(fltt, INS_GYRO_FILTER:get() * FLTT_MUL)
   adjust_gain(fltd, INS_GYRO_FILTER:get() * FLTD_MUL)
   if axis == "YAW" then
      local FLTE = params[flte]
      if FLTE:get() < 0.0 or FLTE:get() > YAW_FLTE_MAX then
         adjust_gain(flte, YAW_FLTE_MAX)
      end
   end
   filters_done[axis] = true
end

-- check for pilot input to pause tune
function have_pilot_input()
   if (math.abs(RCIN_ROLL:norm_input_dz()) > 0 or
       math.abs(RCIN_PITCH:norm_input_dz()) > 0 or
       math.abs(RCIN_YAW:norm_input_dz()) > 0) then
      return true
   end
   return false
end

reset_axes_done()
get_all_params()

function axis_enabled(axis)
   local axes = QUIK_AXES:get()
   for i = 1, #axis_names do
      local mask = (1 << (i-1))
      local axis_name = axis_names[i]
      if axis == axis_name and (mask & axes) ~= 0 then
         return true
      end
   end
   return false
end

-- get the axis name we are working on, or nil for all done
function get_current_axis()
   local axes = QUIK_AXES:get()
   for i = 1, #axis_names do
      local mask = (1 << (i-1))
      local axis_name = axis_names[i]
      if (mask & axes) ~= 0 and axes_done[axis_name] == false then
         return axis_names[i]
      end
   end
   return nil
end

-- get slew rate for an axis
function get_slew_rate(axis)
   local roll_srate, pitch_srate, yaw_srate = AC_AttitudeControl:get_rpy_srate()
   if axis == "RLL" then
      return roll_srate
   end
   if axis == "PIT" then
      return pitch_srate
   end
   if axis == "YAW" then
      return yaw_srate
   end
   return 0.0
end

-- move to next stage of tune
function advance_stage(axis)
   if stage == "D" then
      stage = "P"
   else
      axes_done[axis] = true
      gcs:send_text(5, string.format("Tuning: %s done", axis))
      stage = "D"
   end
end

-- get param name, such as RLL_P, used as index into param dictionaries
function get_pname(axis, tstage)
   return axis .. "_" .. tstage
end

-- get axis name from parameter name
function param_axis(pname)
   return string.sub(pname, 1, 3)
end

-- get parameter suffix from parameter name
function param_suffix(pname)
   return string.sub(pname, 4)
end

-- change a gain
function adjust_gain(pname, value)
   local P = params[pname]
   need_restore = true
   param_changed[pname] = true
   P:set(value)
   if string.sub(pname, -2) == "_P" then
      -- also change I gain
      local iname = string.gsub(pname, "_P", "_I")
      local ffname = string.gsub(pname, "_P", "_FF")
      local I = params[iname]
      local FF = params[ffname]
      if FF:get() > 0 then
         -- if we have any FF on an axis then we don't couple I to P,
         -- usually we want I = FF for a one second time constant for trim
         return
      end
      param_changed[iname] = true

      -- work out ratio of P to I that we want
      local PI_ratio = QUIK_RP_PI_RATIO:get()
      if param_axis(pname) == "YAW" then
         PI_ratio = QUIK_Y_PI_RATIO:get()
      end
      if PI_ratio >= 1 then
         I:set(value/PI_ratio)
      end
   end
end

-- limit a gain change to QUIK_MAX_REDUCE
function limit_gain(pname, value)
   local saved_value = param_saved[pname]
   local max_reduction = QUIK_MAX_REDUCE:get()
   if max_reduction >= 0 and max_reduction < 100 and saved_value > 0 then
      -- check if we exceeded gain reduction
      local reduction_pct = 100.0 * (saved_value - value) / saved_value
      if reduction_pct > max_reduction then
         local new_value = saved_value * (100 - max_reduction) * 0.01
         gcs:send_text(MAV_SEVERITY_INFO, string.format("limiting %s %.3f -> %.3f", pname, value, new_value))
         value = new_value
      end
   end
   return value
end

-- change a gain, limiting to QUIK_MAX_REDUCE
function adjust_gain_limited(pname, value)
   adjust_gain(pname, limit_gain(pname, value))
end

-- return gain multipler for one loop
function get_gain_mul()
   return math.exp(math.log(2.0)/(UPDATE_RATE_HZ*QUIK_DOUBLE_TIME:get()))
end

function setup_slew_gain(pname, gain)
   slew_parm = pname
   slew_target = limit_gain(pname, gain)
   slew_steps = UPDATE_RATE_HZ/2
   slew_delta = (slew_target - params[pname]:get()) / slew_steps
end

function update_slew_gain()
   if slew_parm ~= nil then
      local P = params[slew_parm]
      local axis = param_axis(slew_parm)
      local ax_stage = string.sub(slew_parm, -1)
      adjust_gain(slew_parm, P:get()+slew_delta)
      slew_steps = slew_steps - 1
      logger.write('QUIK','SRate,Gain,Param', 'ffn', get_slew_rate(axis), P:get(), axis .. ax_stage)
      if slew_steps == 0 then
         gcs:send_text(MAV_SEVERITY_INFO, string.format("%s %.4f", slew_parm, P:get()))
         slew_parm = nil
         if get_current_axis() == nil then
            gcs:send_text(MAV_SEVERITY_NOTICE, string.format("Tuning: DONE"))
            tune_done_time = get_time()
         end
      end
   end
end

-- return gain limits on a parameter, or 0 for no limit
function gain_limit(pname)
   if param_axis(pname) == "YAW" then
      local suffix = param_suffix(pname)
      if suffix == "_P" then
         return QUIK_YAW_P_MAX:get()
      end
      if suffix == "_D" then
         return QUIK_YAW_D_MAX:get()
      end
   end
   return 0.0
end

function reached_limit(pname, gain)
   local limit = gain_limit(pname)
   if limit > 0.0 and gain >= limit then
      return true
   end
   return false
end

-- main update function
local last_warning = get_time()
function update()
   if QUIK_ENABLE:get() < 1 then
      return
   end
   if have_pilot_input() then
      last_pilot_input = get_time()
   end

   local sw_pos = rc:get_aux_cached(QUIK_RC_FUNC:get())
   if not sw_pos then
      return
   end
   local sw_pos_tune = 1
   local sw_pos_save = 2
   if (QUIK_OPTIONS:get() & OPTIONS_TWO_POSITION) ~= 0 then
      sw_pos_tune = 2
      sw_pos_save = -1
   end
   if aborted then
       if sw_pos == 0 then
           aborted = false
       else
           -- after an abort require low switch position to reset
           return
       end
   end
   if sw_pos == sw_pos_tune and (not arming:is_armed() or not vehicle:get_likely_flying()) and get_time() > last_warning + 5 then
      gcs:send_text(MAV_SEVERITY_EMERGENCY, string.format("Tuning: Must be flying to tune"))
      last_warning = get_time()
      return
   end
   if sw_pos == 0 or not arming:is_armed() or not vehicle:get_likely_flying() then
      -- abort, revert parameters
      if need_restore then
         need_restore = false
         restore_all_params()
         gcs:send_text(MAV_SEVERITY_EMERGENCY, string.format("Tuning: reverted"))
         tune_done_time = nil
         aborted = true
      end
      reset_axes_done()
      return
   end
   if sw_pos == sw_pos_save then
      -- save all params
      if need_restore then
         need_restore = false
         save_all_params()
         gcs:send_text(MAV_SEVERITY_NOTICE, string.format("Tuning: saved"))
      end
   end
   if sw_pos ~= sw_pos_tune then
      return
   end

   if QUIK_ANGLE_MAX:get() > 0 and need_restore then
       local att_error = AC_AttitudeControl:get_att_error_angle_deg()
       if att_error > QUIK_ANGLE_MAX:get() then
         need_restore = false
         restore_all_params()
         gcs:send_text(MAV_SEVERITY_CRITICAL, string.format("Tuning: attitude error %.1fdeg - ABORTING", att_error))
         tune_done_time = nil
         aborted = true
         reset_axes_done()
         return
      end
   end

   if get_time() - last_stage_change < STAGE_DELAY then
      update_slew_gain()
      return
   end

   axis = get_current_axis()
   if axis == nil then
      -- nothing left to do, check autosave time
      if tune_done_time ~= nil and QUIK_AUTO_SAVE:get() > 0 then
         if get_time() - tune_done_time > QUIK_AUTO_SAVE:get() then
            need_restore = false
            save_all_params()
            gcs:send_text(MAV_SEVERITY_NOTICE, string.format("Tuning: saved"))
            tune_done_time = nil
         end
      end
      return
   end

   if not need_restore then
      -- we are just starting tuning, get current values
      gcs:send_text(MAV_SEVERITY_NOTICE, string.format("Tuning: starting tune"))
      get_all_params()
      setup_SMAX()
   end

   if get_time() - last_pilot_input < PILOT_INPUT_DELAY then
      return
   end

   if not filters_done[axis] then
      gcs:send_text(MAV_SEVERITY_INFO, string.format("Starting %s tune", axis))
      setup_filters(axis)
   end

   local srate = get_slew_rate(axis)
   local pname = get_pname(axis, stage)
   local P = params[pname]
   local oscillating = srate > QUIK_OSC_SMAX:get()
   local limited = reached_limit(pname, P:get())
   if limited or oscillating then
      local reduction = (100.0-QUIK_GAIN_MARGIN:get())*0.01
      if not oscillating then
         reduction = 1.0
      end
      local new_gain = P:get() * reduction
      local limit = gain_limit(pname)
      if limit > 0.0 and new_gain > limit then
         new_gain = limit
      end
      local old_gain = param_saved[pname]
      if new_gain < old_gain and string.sub(pname,-2) == '_D' and param_axis(pname) ~= 'YAW' then
         -- we are lowering a D gain from the original gain. Also lower the P gain by the same amount
         -- so that we don't trigger P oscillation. We don't drop P by more than a factor of 2
         local ratio = math.max(new_gain / old_gain, 0.5)
         local P_name = string.gsub(pname, "_D", "_P")
         local old_P = params[P_name]:get()
         local new_P = old_P * ratio
         gcs:send_text(MAV_SEVERITY_INFO, string.format("adjusting %s %.3f -> %.3f", P_name, old_P, new_P))
         adjust_gain_limited(P_name, new_P)
      end
      setup_slew_gain(pname, new_gain)
      logger.write('QUIK','SRate,Gain,Param', 'ffn', srate, P:get(), axis .. stage)
      gcs:send_text(6, string.format("Tuning: %s done", pname))
      advance_stage(axis)
      last_stage_change = get_time()
   else
      local new_gain = P:get()*get_gain_mul()
      if new_gain <= 0.0001 then
         new_gain = 0.001
      end
      adjust_gain_limited(pname, new_gain)
      logger.write('QUIK','SRate,Gain,Param', 'ffn', srate, P:get(), axis .. stage)
      if get_time() - last_gain_report > 3 then
         last_gain_report = get_time()
         gcs:send_text(MAV_SEVERITY_INFO, string.format("%s %.4f sr:%.2f", pname, new_gain, srate))
      end
   end
end

-- wrapper around update(). This calls update() at 10Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(MAV_SEVERITY_EMERGENCY, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 1000/UPDATE_RATE_HZ
end

-- start running update loop
return protected_wrapper()



================================================
File: applets/VTOL-quicktune.md
================================================
# VTOL QuickTune

This script implements a fast VTOL tuning system for multicopters and
quadplanes. This script can be used to automate the process of
producing a good "manual tune" for the VTOL rate control parameters.

The script is designed to be used in QLOITER mode for quadplanes or
LOITER mode in multicopters, although it can also be used in other
VTOL modes.

# Parameters

The script adds 7 parameters to control it's behaviour. The parameters
are:

## QUIK_ENABLE

this must be set to 1 to enable the script

## QUIK_RC_FUNC

The RCz_OPTIONS scripting function binding to be used for this script.
Default RCz_OPTIONS binding is 300 (scripting1).

## QUIK_AXES

This is the set of axes that the tune will run on. The default is 7,
which means roll, pitch and yaw. It is a bitmask, so if you want just
roll and pitch then set this to 3. For just yaw you would set it to 4.

## QUIK_DOUBLE_TIME

This controls how quickly a gain is raised while tuning. It is a time
in seconds for the gain to double. Most users will want to leave this
at the default of 10 seconds.

## QUIK_GAIN_MARGIN

This is the percentage gain margin to use. Once the oscillation point
for a gain is found the gain is reduced by this percentage. The
default of 60% is good for most users.

## QUIK_OSC_SMAX

This is the oscillation threshold in Hertz for detecting oscillation
when a gain is raised. The default of 5Hz is good for most vehicles,
but on very large vehicles you may wish to lower this. For a vehicle
of 50kg a value of 3 is likely to be good. For a vehicle of 100kg a
value of 1.5 is likely to be good.

You can tell you have this set too high if you still have visible
oscillations after a parameter has completed tuning. In that case
halve this parameter and try again.

## QUIK_YAW_P_MAX

This sets a limit on the YAW_P rate gain. The yaw axis on most
multirotor style vehicles needs to have a much lower limit on the P
gain than the oscillation limit to ensure that enough control remains
for roll, pitch and thrust. A maximum of 0.5 is good for most VTOL
vehicles.

## QUIK_YAW_D_MAX

This sets a limit on the YAW_D rate gain. The yaw axis on most
multirotor style vehicles needs to have a much lower limit on the D
gain than the oscillation limit to ensure that enough control remains
for roll, pitch and thrust. A maximum of 0.01 is good for most VTOL
vehicles.

## QUIK_RP_PI_RATIO

This is the ratio for P to I for roll and pitch axes. This should
normally be 1, but on some large vehicles a value of up to 3 can be
used if the I term in the PID is causing too much phase lag.

If QUIK_RP_PI_RATIO is less than 1 then the I value will not be
changed at all when P is changed.

## QUIK_Y_PI_RATIO

This is the ratio for P to I for the yax axis. This should
normally be 10, but a different value may be needed on some vehicle
types.

If QUIK_Y_PI_RATIO is less than 1 then the I value will not be
changed at all when P is changed.

## QUIK_AUTO_FILTER

This enables automatic setting of the PID filters based on the
INS_GYRO_FILTER value. Set to zero to disable this feature.

## QUIK_AUTO_SAVE

This enables automatic saving of the tune if this number of seconds
pass after the end of the tune without reverting the tune. Setting
this to a non-zero value allows you to use quicktune with a 2-position
switch, with the switch settings as low and mid positions. A zero
value disables auto-save and you need to have a 3 position switch.

## QUIK_MAX_REDUCE

This controls how much quicktune is allowed to lower gains from the
original gains. If the vehicle already has a reasonable tune and is
not oscillating then you can set this to zero to prevent gain
reductions. The default of 20% is reasonable for most vehicles. Using
a maximum gain reduction lowers the chance of an angle P oscillation
happening if quicktune gets a false positive oscillation at a low
gain, which can result in very low rate gains and a dangerous angle P
oscillation.

# Operation

First you should setup harmonic notch filtering using the guide in the
ArduPilot wiki. This tuning system relies on you already having
reduced gyro noise using the harmonic notch filter. It will fail if
your noise is too high.

Install the lua script in the APM/SCRIPTS directory on the flight
controllers microSD card, then set SCR_ENABLE to 1. Reboot, and
refresh parameters. Then set QUIK_ENABLE to 1.

IF vectored yaw ((tilt rotors) or TVBS tailsitter(motors on tilting servos), set Q_A_RAT_YAW_FLTE = 0 before running yaw tuning.

You will then need to setup a 3 position switch on an available RC
input channel for controlling the tune (or 2 position if you set
QUIK_AUTO_SAVE). If for example channel 6 is available with a 3
position switch then you should set RC6_OPTION=300 (scripting1) to associate the
tuning control with that switch.

If needed, the QUIK_RC_FUNC option can be used to associate the tuning switch
with a different scripting binding such as RCz_OPTION = 302 (scripting3).

You should then takeoff and put the vehicle into QLOITER mode (for
quadplanes) or LOITER mode (for multicopters) and have it in a steady
hover in low wind.

Then move the control switch you setup with option 300 (or via QUIK_RC_FUNC)
to the middle position. This will start the tuning process. You will see text
messages on the ground station showing the progress of the tune. As
the aircraft reaches the oscillation limit of each parameter it will
start a small oscillation, then it will reduce that gain by the
configured QUIK_GAIN_MARGIN percentage and then move onto the next
parameter.

With default settings the parameters to be tuned will be:

 - RLL_D
 - RLL_P
 - PIT_D
 - PIT_P
 - YAW_D
 - YAW_P

The script will also adjust filter settings using the following rules
if QUIK_AUTO_FILTER is set to 1 (which is the default):

 - the FLTD and FLTT settings will be set to half of the INS_GYRO_FILTER value
 - the YAW_FLTE filter will be set to a maximum of 8Hz

Additionally, if no SMAX is set for a rate controller than the SMAX will be set to 50Hz.

Once the tuning is finished you will see a "Tuning: done" message. You
can save the tune by moving the switch to the high position (Tune Save). You
should do this to save before you land and disarm. If you save before the tune is completed the tune will pause, and any parameters completed will be saved and the current value of the one being actively tuned will remain active. You can resume tuning by returning the switch again to the middle position, or if moved to the low position, the parameter currently being tuned will be reverted but any previously saved parameters will remain.

If you move the switch to the low position at any time in the tune before using the Tune Save switch position, then all parameters will be reverted to their original
values. Parameters will also be reverted if you disarm before saving.

If the pilot gives roll, pitch or yaw input while tuning then the tune
is paused until 4 seconds after the pilot input stops.

# Using a Two Position Switch

Some transitters only have 2 position switches, with no 3 position
switches available. To support quicktune with a 2 position switch
please set the following:

 - set QUIK_OPTIONS to 1 to indicate the use of a 2 position switch
 - set QUIK_AUTO_SAVE to 10 to automatically save the tune 10 seconds after tuning is done

with these two options the tuning will start when the switch gives a
PWM value of over 1800. Ten seconds after tuning is complete the tune
will automatically save.






================================================
File: applets/advance-wp.lua
================================================
--[[----------------------------------------------------------------------------

advance-wp ArduPilot Lua script

Set WAYPT_ADVANCE to an aux function number (e.g. 300).
Set RCx_OPTION to the chosen aux function number (preferably on a momentary switch).

When the RC switch is activated, waypoint index will be advanced to the next waypoint
(wraps to WP1 after the last waypoint).

Mission Planner's Aux Function tab can be used in lieu of dedicating RC channels.

Optionally:
    Set WAYPT_ANNOUNCE to another aux function number (e.g. 301).
    Set WAYPT_ANNOUNCE_S to desired interval (s) between waypoint announcements (0 to disable).
    Set WAYPT_BUZ_ENABLE to 1 to enable buzzer feedback vs waypoint distance.
    Set RCx_OPTION to the chosen aux function number.

    When the announce switch is activated, the current waypoint index, bearing, and distance
    will be broadcast as a GCS message every WAYPT_ANNOUNCE_S seconds (useful when using a
    telemetry link like "Yaapu" where named float values are not always readily displayed).

    If WAYPT_BUZ_ENABLE is set, the buzzer will increase in frequency and pitch as distance
    to the selected waypoint decreases (useful if no telemetry source is readily available).

CAUTION: This script is capable of engaging and disengaging autonomous control
of a vehicle.  Use this script AT YOUR OWN RISK.

-- Yuri -- Apr 2024

LICENSE - GNU GPLv3 https://www.gnu.org/licenses/gpl-3.0.en.html
------------------------------------------------------------------------------]]

local RUN_INTERVAL_MS = 100
local PARAM_TABLE_KEY = 193
local PARAM_TABLE_PREFIX = 'WAYPT_'
local MAV_SEVERITY = {
    EMERGENCY = 0,
    ALERT = 1,
    CRITICAL = 2,
    ERROR = 3,
    WARNING = 4,
    NOTICE = 5,
    INFO = 6,
    DEBUG = 7
}

-- borrowed from Rover QuikTune
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format("Advance WP: Could not find %s parameter", name))
    return p
end

local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value),
        string.format('Could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

local function get_wp_location(item)
    local loc = Location()
    loc:lat(item:x())
    loc:lng(item:y())
    loc:alt(math.floor(item:z() * 100))
    return loc
end

local function get_pitch_by_distance(distance)
    local max_distance = 300
    local min_distance = 0.01
    local total_notes = 73

    distance = math.max(min_distance, math.min(distance, max_distance))
    local scale_factor = 105                                    -- scale factor adjusted for a good spread over the distance range
    local log_ratio = math.log(max_distance / distance)
    local max_log_ratio = math.log(max_distance / min_distance) -- max possible value of log_ratio
    local log_distance_scaled = log_ratio / max_log_ratio * total_notes * scale_factor / 100
    local note_index = math.min(math.floor(log_distance_scaled), total_notes - 1)

    return 'N' .. math.max(1, note_index)
end

local function get_buzz_interval(distance)
    local max_distance = 100
    local min_distance = 0.01
    local max_interval = 2000
    local min_interval = 250

    distance = math.max(min_distance, math.min(distance, max_distance))
    local interval = max_interval - (max_interval - min_interval) * ((max_distance - distance) / max_distance)
    return math.floor(interval)
end

assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 4), 'Advance WP: Could not add param table')

local WAYPT_ADVANCE = bind_add_param('ADVANCE', 1, 300)
local WAYPT_ANNOUNCE = bind_add_param('ANNOUNCE', 2, 301)
local WAYPT_ANNOUNCE_S = bind_add_param('ANNOUNCE_S', 3, 0)
local WAYPT_BUZ_ENABLE = bind_add_param('BUZ_ENABLE', 4, 1)

local last_advance_sw_pos = -1
local last_announce_ms = uint32_t(0)
local last_buzz_ms = uint32_t(0)
function update()
    ---- WAYPT_ADVANCE ----
    local advance_opt = WAYPT_ADVANCE:get()
    if not advance_opt then return update, RUN_INTERVAL_MS end

    local adv_sw_pos = rc:get_aux_cached(advance_opt)
    if not adv_sw_pos then return update, RUN_INTERVAL_MS end

    local num_commands = mission:num_commands()
    if num_commands < 1 then return update, RUN_INTERVAL_MS end

    if adv_sw_pos > 0 and adv_sw_pos ~= last_advance_sw_pos then
        local nav_index = mission:get_current_nav_index()
        local new_index = (nav_index + 1) % mission:num_commands()
        mission:set_current_cmd(new_index)
        gcs:send_text(MAV_SEVERITY.NOTICE, ('Advance WP -> %d'):format(mission:get_current_nav_index()))
    end
    last_advance_sw_pos = adv_sw_pos or 0

    ---- WAYPT_ANNOUNCE ----
    local announce_s = WAYPT_ANNOUNCE_S:get()
    if not announce_s then return update, RUN_INTERVAL_MS end
    if announce_s <= 0 then return update, RUN_INTERVAL_MS end

    local announce_opt = WAYPT_ANNOUNCE:get()
    if not announce_opt then return update, RUN_INTERVAL_MS end

    local ann_sw_pos = rc:get_aux_cached(announce_opt)
    if not ann_sw_pos then return update, RUN_INTERVAL_MS end

    local now = millis()

    if ann_sw_pos > 0 then
        -- to work when mission is inactive, need to convert current nav item to location
        local nav_index = mission:get_current_nav_index()
        local item = mission:get_item(nav_index)
        local wp_loc = get_wp_location(item)
        local cur_loc = ahrs:get_location()
        if cur_loc then
            local bearing = math.deg(cur_loc:get_bearing(wp_loc))
            local distance = cur_loc:get_distance(wp_loc)

            local buzz_enable = WAYPT_BUZ_ENABLE:get()
            if buzz_enable and buzz_enable > 0 and now - last_buzz_ms > get_buzz_interval(distance) then
                notify:play_tune('MFT240MSL8' .. get_pitch_by_distance(distance))
                last_buzz_ms = now
            end

            if now - last_announce_ms > announce_s * 1000 then
                gcs:send_text(MAV_SEVERITY.NOTICE, ('WP %d: %03.0f° / %.3fm'):format(nav_index, bearing, distance))
                last_announce_ms = now
            end
        elseif now - last_announce_ms > announce_s * 1000 then
            gcs:send_text(MAV_SEVERITY.WARNING, 'Advance WP: Invalid AHRS location')
            last_announce_ms = now
        end
    end

    return update, RUN_INTERVAL_MS
end

gcs:send_text(MAV_SEVERITY.INFO, 'Advance WP Script Active')

return update, RUN_INTERVAL_MS



================================================
File: applets/advance-wp.md
================================================
# Advance Waypoint

Advance Waypoint (`advance-wp.lua`) allows for advancing the current mission waypoint via an RC switch. When the RC switch state is high, the mission waypoint is advanced to the next waypoint (wraps back to WP 1 if the end of the mission is reached).

## How to Use

Install this script in the autopilot's SD card in the `APM/scripts` directory. Set SCR_ENABLE to 1 and reboot the autopilot.

* Set WAYPT_ADVANCE to an available aux function (300 by default).
* Set RCx_OPTION to the chosen aux function number. Preferably, set this to a channel assigned to a momentary switch.

Mission Planner's Aux Function tab can be used in lieu of dedicating an RC channel.

## Additional Features

If Yaapu telemetry (or similar) is in use on the RC transmitter, it may be useful to display bearing and distance to the currently selected waypoint in the messages view, regardless of flight mode or arming state. To enable this:

* Set WAYPT_ANNOUNCE to another available aux function (301 by default).
* Set RCx_OPTION to the chosen aux function.
* Set WAYPT_ANNOUNCE_S to desired interval (in seconds) between waypoint announcements (0 disables the feature).

As above, Mission Planner's Aux Function tab can be used in lieu of dedicating an RC channel.

When the announce switch is activated, the current waypoint index, bearing, and distance will be broadcast as a GCS message every WAYPT_ANNOUNCE_S seconds.

Additionally, there is an audio feedback feature:

* Set WAYPT_BUZ_ENABLE to 1 to enable buzzer feedback (0 to disable).

If WAYPT_BUZ_ENABLE is set, the buzzer will beep when the announce switch is activated, increasing in frequency and pitch as distance to the selected waypoint decreases (useful as a rangefinder for the selected waypoint if no telemetry source is readily available).

### Author's Note

I used this script to create a survey "prism pole" of sorts out of a spare autopilot, RTK GPS module/antenna, RC receiver, and telemetry radio. Using the existing SaveWP feature along with this script, I can save waypoints and subsequently relocate them precisely with the additional features above.


================================================
File: applets/ahrs-set-origin.lua
================================================
-- Sets the AHRS/EKF origin to a specified Location
--
-- Parameter descriptions
-- AHRS_ORIG_LAT : AHRS Origin Latitude (in degrees)
-- AHRS_ORIG_LON : AHRS Origin Longitude (in degrees)
-- AHRS_ORIGIN_ALT : AHRS Origin Altitude (in meters above sea level)
--
-- How to use
-- 1. Install this script on the flight controller
-- 2. Set AHRS_ORIG_LAT, AHRS_ORIG_LON, AHRS_ORIG_ALT to the desired location
-- 3. A message should appear on the messages screen when the AHRS/EKF origin has been set and the vehicle will most often then appear on the map

local PARAM_TABLE_KEY = 87
PARAM_TABLE_PREFIX = "AHRS_ORIG_"
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local SEND_TEXT_PREFIX = "ahrs-set-origin: "

-- bind a parameter to a variable
function bind_param(name)
  local p = Parameter()
  assert(p:init(name), string.format('could not find %s parameter', name))
  return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
  assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
  return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- add param table
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), SEND_TEXT_PREFIX .. 'could not add param table')

--[[
  // @Param: AHRS_ORIG_LAT
  // @DisplayName: AHRS/EKF Origin Latitude
  // @Description: AHRS/EKF origin will be set to this latitude if not already set
  // @Range: -180 180
  // @User: Standard
--]]
local AHRS_ORIG_LAT = bind_add_param('LAT', 1, 0)

--[[
  // @Param: AHRS_ORIG_LON
  // @DisplayName: AHRS/EKF Origin Longitude
  // @Description: AHRS/EKF origin will be set to this longitude if not already set
  // @Range: -180 180
  // @User: Standard
--]]
local AHRS_ORIG_LON = bind_add_param('LON', 2, 0)

--[[
  // @Param: AHRS_ORIG_ALT
  // @DisplayName: AHRS/EKF Origin Altitude
  // @Description: AHRS/EKF origin will be set to this altitude (in meters above sea level) if not already set
  // @Range: 0 10000
  // @User: Standard
--]]
local AHRS_ORIG_ALT = bind_add_param('ALT', 3, 0)

-- print welcome message
gcs:send_text(MAV_SEVERITY.INFO, SEND_TEXT_PREFIX .. "started")

function update()

    -- wait for AHRS to be initialised
    if not ahrs:initialised() then
        return update, 5000
    end

    -- exit if AHRS/EKF origin has already been set
    if ahrs:get_origin() then
        gcs:send_text(MAV_SEVERITY.WARNING, SEND_TEXT_PREFIX .. "EKF origin already set")
        return
    end

    -- return if parameters have not been set
    if AHRS_ORIG_LAT:get() == 0 and AHRS_ORIG_LON:get() == 0 and AHRS_ORIG_ALT == 0 then
        -- try again in 5 seconds
        return update, 5000
    end

    -- create new origin
    local location = Location()
    location:lat(math.floor(AHRS_ORIG_LAT:get() * 10000000.0))
    location:lng(math.floor(AHRS_ORIG_LON:get() * 10000000.0))
    location:alt(math.floor(AHRS_ORIG_ALT:get() * 100.0))

    -- attempt to send origin
    if ahrs:set_origin(location) then
        gcs:send_text(MAV_SEVERITY.INFO, string.format(SEND_TEXT_PREFIX .. "origin set Lat:%.7f Lon:%.7f Alt:%.1f", AHRS_ORIG_LAT:get(), AHRS_ORIG_LON:get(), AHRS_ORIG_ALT:get()))
    else
        gcs:send_text(MAV_SEVERITY.WARNING, SEND_TEXT_PREFIX .. "failed to set origin")
    end

    -- return and do not try again
    return
end

return update()


================================================
File: applets/ahrs-set-origin.md
================================================
# AHRS set origin

Sets the AHRS/EKF origin to a specified Location

## Parmeter Descriptions

-- AHRS_ORIG_LAT : AHRS Origin Latitude (in degrees)
-- AHRS_ORIG_LON : AHRS Origin Longitude (in degrees)
-- AHRS_ORIGIN_ALT : AHRS Origin Altitude (in meters above sea level)

## How to use

Install this script on the flight controller
Set AHRS_ORIG_LAT, AHRS_ORIG_LON, AHRS_ORIG_ALT to the desired location
A message should appear on the messages screen when the AHRS/EKF origin has been set and the vehicle will most often then appear on the map



================================================
File: applets/ahrs-source-extnav-optflow.lua
================================================
-- switches between AHRS/EKF sources based on the pilot's source selection switch or using an automatic source selection algorithm
-- this script is intended to help vehicles automatically switch between ExternalNav and optical flow
--
-- configure a downward facing lidar with a range of at least 5m
-- setup RCx_OPTION = 90 (EKF Source Set) to select the source (low=external nav, middle=opticalflow, high=Not Used)
-- setup RCx_OPTION = 300 (Scripting1).  When this switch is pulled high, the source will be automatically selected
-- SRC_ENABLE = 1 (enable scripting)
-- setup EK3_SRCn_ parameters so that ExternalNav is the primary source, opticalflow is secondary
--     EK3_SRC1_POSXY = 6 (ExternalNav)
--     EK3_SRC1_VELXY = 6 (ExternalNav)
--     EK3_SRC1_VELZ  = 6 (ExternalNav)
--     EK3_SRC1_POSZ  = 6 (ExternalNav) or 1 (Baro)
--     EK3_SRC1_YAW   = 6 (ExternalNav) or 1 (Compass)
--     EK3_SRC2_POSXY = 0 (None)
--     EK3_SRC2_VELXY = 5 (OpticalFlow)
--     EK3_SRC2_VELZ  = 0 (None)
--     EK3_SRC2_POSZ  = 1 (Baro)
--     EK3_SRC2_YAW   = 1 (Compass)
--     EK3_SRC_OPTIONS = 0 (Do not fuse all velocities)
--
-- When the 2nd auxiliary switch (300/Scripting1) is pulled high automatic source selection is used based on the following criteria:
--     ESRC_EXTN_THRESH holds the threshold for ExternalNav innovation threshold (around 0.3 is a good choice)
--     ESRC_EXTN_QUAL holds the ExternalNav quality threshold (about 10 is a good choice)
--     ESRC_FLOW_QUAL holds the optical flow quality threshold (about 50 is a good choice)
--     ESRC_FLOW_THRESH holds the threshold for optical flow innovations (about 0.15 is a good choice)
--     ESRC_RNGFND_MAX holds the threshold (in meters) for rangefinder altitude
--
--     If ExternalNav's quality is above ESRC_EXTN_QUAL and innovations are below ESRC_EXTN_THRESH, ExternalNav is used
--     Optical flow is used if the above is not true and:
--         optical flow's quality is above ESRC_FLOW_QUAL
--         innovations are below ESRC_FLOW_THRESH
--         rangefinder distance is below ESRC_RNGFND_MAX

local PARAM_TABLE_KEY = 81
PARAM_TABLE_PREFIX = "ESRC_"
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable
function bind_param(name)
  local p = Parameter()
  assert(p:init(name), string.format('could not find %s parameter', name))
  return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
  assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
  return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- add param table
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 5), 'ahrs-source-extnav-optflow: could not add param table')

--[[
  // @Param: ESRC_EXTN_THRESH
  // @DisplayName: EKF Source ExternalNav Innovation Threshold
  // @Description: ExternalNav may be used if innovations are below this threshold
  // @Range: 0 1
  // @User: Standard
--]]
local ESRC_EXTN_THRESH = bind_add_param('EXTN_THRESH', 1, 0.3)

--[[
  // @Param: ESRC_EXTN_QUAL
  // @DisplayName: EKF Source ExternalNav Quality Threshold
  // @Description: ExternalNav may be used if quality is above this threshold
  // @Range: 0 100
  // @Units: %
  // @User: Standard
--]]
local ESRC_EXTN_QUAL = bind_add_param('EXTN_QUAL', 2, 10)

--[[
  // @Param: ESRC_FLOW_THRESH
  // @DisplayName: EKF Source OpticalFlow Innovation Threshold
  // @Description: OpticalFlow may be used if innovations are below this threshold
  // @Range: 0 1
  // @User: Standard
--]]
local ESRC_FLOW_THRESH = bind_add_param('FLOW_THRESH', 3, 0.3)

--[[
  // @Param: ESRC_FLOW_QUAL
  // @DisplayName: EKF Source OpticalFlow Quality Threshold
  // @Description: OpticalFlow may be used if quality is above this threshold
  // @Range: 0 100
  // @Units: %
  // @User: Standard
--]]
local ESRC_FLOW_QUAL = bind_add_param('FLOW_QUAL', 4, 50)

--[[
  // @Param: ESRC_RNGFND_MAX
  // @DisplayName: EKF Source Rangefinder Max
  // @Description: OpticalFlow may be used if rangefinder distance is below this threshold
  // @Range: 0 50
  // @Units: m
  // @User: Standard
--]]
local ESRC_RNGFND_MAX = bind_add_param('RNGFND_MAX', 5, 7)

local last_rc_ekfsrc_pos = 0        -- last known position of EKF source select switch
local last_rc_autosrc_pos = 0       -- last known position of automatic source select switch
local rangefinder_rotation = 25     -- check downward (25) facing lidar
local auto_switch = false           -- true when auto switching between sources is active
local source_prev = 0               -- previous source, defaults to primary source (ExternalNav)
local vote_counter_max = 20         -- when a vote counter reaches this number (i.e. 2sec) source may be switched
local extnav_vs_opticalflow_vote = 0  -- vote counter for external nav vs optical (-20 = external nav, +20 = optical flow)

assert(visual_odom, 'could not access optical flow')
assert(optical_flow, 'could not access optical flow')

-- play tune on buzzer to alert user to change in active source set
function play_source_tune(source)
  if (source) then
    if (source == 0) then
      notify:play_tune("L8C")       -- one long lower tone
    elseif (source == 1) then
      notify:play_tune("L12DD")     -- two fast medium tones
    elseif (source == 2) then
      notify:play_tune("L16FFF")    -- three very fast, high tones
    end
  end
end

-- convert a boolean to a number
function bool_to_int(b)
  if b then
    return 1
  end
  return 0
end

-- the main update function
function update()

  -- check for EKF Source Select switch position change
  local rc_ekfsrc_pos = rc:get_aux_cached(90)  -- RCx_OPTION = 90 (EKF Source Set)
  if rc_ekfsrc_pos == nil then
    rc_ekfsrc_pos = 0
  end
  local rc_ekfsrc_pos_changed = (rc_ekfsrc_pos ~= last_rc_ekfsrc_pos)
  last_rc_ekfsrc_pos = rc_ekfsrc_pos

  -- check for EKF automatic source select switch position change
  local rc_autosrc_pos = rc:get_aux_cached(300) -- RCx_OPTION = 300 (Scripting1)
  if rc_autosrc_pos == nil then
    rc_autosrc_pos = 0
  end
  local rc_autosrc_pos_changed = (rc_autosrc_pos ~= last_rc_autosrc_pos)
  last_rc_autosrc_pos = rc_autosrc_pos

  -- check external nav quality and innovations
  local extnav_over_threshold = true
  local extnav_innov
  extnav_innov, _ = ahrs:get_vel_innovations_and_variances_for_source(6)
  if (extnav_innov) then
    local extnav_xyz_innov = extnav_innov:length()
    extnav_over_threshold = (extnav_xyz_innov == 0.0) or (extnav_xyz_innov > ESRC_EXTN_THRESH:get())
    gcs:send_named_float("ExtNInnov", extnav_xyz_innov)
  end
  local extnav_usable = (not extnav_over_threshold) and visual_odom and visual_odom:healthy() and (visual_odom:quality() >= ESRC_EXTN_QUAL:get())
  if visual_odom then
    gcs:send_named_float("ExtNQuality", visual_odom:quality())
  end
  gcs:send_named_float("ExtNUsable", bool_to_int(extnav_usable))

  -- check optical flow quality and innovations
  local opticalflow_quality_good = false
  if (optical_flow) then
    opticalflow_quality_good = (optical_flow:enabled() and optical_flow:healthy() and optical_flow:quality() >= ESRC_FLOW_QUAL:get())
  end

  -- get opticalflow innovations from ahrs (only x and y values are valid)
  local opticalflow_over_threshold = true
  local opticalflow_innov
  opticalflow_innov, _ = ahrs:get_vel_innovations_and_variances_for_source(5)
  if (opticalflow_innov) then
    local opticalflow_xy_innov = math.sqrt(opticalflow_innov:x() * opticalflow_innov:x() + opticalflow_innov:y() * opticalflow_innov:y())
    opticalflow_over_threshold = (opticalflow_xy_innov == 0.0) or (opticalflow_xy_innov > ESRC_FLOW_THRESH:get())
    gcs:send_named_float("FlowInnov", opticalflow_xy_innov)
  end

  -- get rangefinder distance
  local rngfnd_distance_m = 0
  if rangefinder:has_data_orient(rangefinder_rotation) then
    rngfnd_distance_m = rangefinder:distance_orient(rangefinder_rotation)
  end
  local rngfnd_over_threshold = (rngfnd_distance_m == 0) or (rngfnd_distance_m > ESRC_RNGFND_MAX:get())

  -- opticalflow is usable if quality and innovations are good and rangefinder is in range
  local opticalflow_usable = opticalflow_quality_good and (not opticalflow_over_threshold) and (not rngfnd_over_threshold)
  gcs:send_named_float("FlowUsable", bool_to_int(opticalflow_usable))

  -- automatic selection logic --

  -- ExtNav vs opticalflow vote. "-1" to move towards EXtNav, "+1" to move to opticalflow
  if (extnav_usable) then
    -- vote for external nav if usable and innovations are low
    extnav_vs_opticalflow_vote = math.max(extnav_vs_opticalflow_vote - 1, -vote_counter_max)
  elseif opticalflow_usable then
    -- vote for opticalflow if usable
    extnav_vs_opticalflow_vote = math.min(extnav_vs_opticalflow_vote + 1, vote_counter_max)
  end

  -- auto source vote collation
  local auto_source = -1                         -- auto source undecided if -1
  if extnav_vs_opticalflow_vote <= -vote_counter_max then
    auto_source = 0                              -- external nav
  elseif extnav_vs_opticalflow_vote >= vote_counter_max then
    auto_source = 1                              -- opticalflow
  end

  -- read source switch position from user
  if rc_ekfsrc_pos_changed then                 -- check for changes in source switch position
    auto_switch = false                         -- disable auto switching of source
    if source_prev ~= rc_ekfsrc_pos then        -- check if switch position does not match source (there is a one-to-one mapping of switch position to source)
      source_prev = rc_ekfsrc_pos                -- record what source should now be (changed by ArduPilot vehicle code)
      gcs:send_text(MAV_SEVERITY.INFO, "Pilot switched to Source " .. string.format("%d", source_prev+1))
    else
      gcs:send_text(MAV_SEVERITY.INFO, "Pilot switched but already Source " .. string.format("%d", source_prev+1))
    end
    play_source_tune(source_prev)                -- alert user of source whether changed or not
  end

  -- if auto switch exists then read auto source switch position from RCx_FUNCTION = 300 (Scripting1)
  if rc_autosrc_pos_changed  then                -- check for changes in source auto switch position
    if rc_autosrc_pos == 0 then                  -- pilot has pulled switch low
      auto_switch = false                        -- disable auto switching of source
      if rc_ekfsrc_pos ~= source_prev then       -- check if source will change
        source_prev = rc_ekfsrc_pos              -- record pilot's selected source
        ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
        gcs:send_text(MAV_SEVERITY.INFO, "Auto source disabled, switched to Source " .. string.format("%d", source_prev+1))
      else
        gcs:send_text(MAV_SEVERITY.INFO, "Auto source disabled, already Source " .. string.format("%d", source_prev+1))
      end
    elseif rc_autosrc_pos == 2 then              -- pilot has pulled auto switch high
      auto_switch = true                         -- enable auto switching of source
      if auto_source < 0 then
        gcs:send_text(MAV_SEVERITY.INFO, "Auto source enabled, undecided, Source " .. string.format("%d", source_prev+1))
      elseif auto_source ~= source_prev then     -- check if source will change
        source_prev = auto_source                -- record pilot's selected source
        ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
        gcs:send_text(MAV_SEVERITY.INFO, "Auto source enabled, switched to Source " .. string.format("%d", source_prev+1))
      else
        gcs:send_text(MAV_SEVERITY.INFO, "Auto source enabled, already Source " .. string.format("%d", source_prev+1))
      end
    end
    play_source_tune(source_prev)
  end

  -- auto switching
  if auto_switch and (auto_source >= 0) and (auto_source ~= source_prev) then
    source_prev = auto_source                  -- record selected source
    ahrs:set_posvelyaw_source_set(source_prev) -- switch to pilot's selected source
    gcs:send_text(MAV_SEVERITY.INFO, "Auto switched to Source " .. string.format("%d", source_prev+1))
    play_source_tune(source_prev)
  end

  return update, 100
end

return update()



================================================
File: applets/ahrs-source-extnav-optflow.md
================================================
# ExternalNav / Optical flow source switching

Switches between AHRS/EKF sources based on the pilot's source selection switch or using an automatic source selection algorithm
This script is intended to help vehicles automatically switch between ExternalNav and optical flow

## Parmeter Descriptions

-- ESRC_EXTN_THRESH : ExternalNav innovation threshold
-- ESRC_EXTN_QUAL : ExternalNav quality threshold
-- ESRC_FLOW_THRESH : OpticalFlow innovation threshold
-- ESRC_FLOW_QUAL : OpticalFlow quality threshold
-- ESRC_RNGFND_MAX : Rangefinder altitude threshold (in meters)

## How to use

Configure a downward facing lidar with a range of at least 5m
Set RCx_OPTION = 90 (EKF Source Set) to select the source (low=ExternalNav, middle=opticalflow, high=Not Used)
Set RCx_OPTION = 300 (Scripting1).  When this switch is pulled high, the source will be automatically selected
Set SRC_ENABLE = 1 (enable scripting)
Set EK3_SRCn_ parameters so that ExternalNav is the primary source, opticalflow is secondary

  - EK3_SRC1_POSXY = 6 (ExternalNav)
  - EK3_SRC1_VELXY = 6 (ExternalNav)
  - EK3_SRC1_VELZ  = 6 (ExternalNav)
  - EK3_SRC1_POSZ  = 6 (ExternalNav) or 1 (Baro)
  - EK3_SRC1_YAW   = 6 (ExternalNav) or 1 (Compass)
  - EK3_SRC2_POSXY = 0 (None)
  - EK3_SRC2_VELXY = 5 (OpticalFlow)
  - EK3_SRC2_VELZ  = 0 (None)
  - EK3_SRC2_POSZ  = 1 (Baro)
  - EK3_SRC2_YAW   = 1 (Compass)
  - EK3_SRC_OPTIONS = 0 (Do not fuse all velocities)

When the 2nd auxiliary switch (300/Scripting1) is pulled high automatic source selection is used based on the following criteria:

  - ESRC_EXTN_THRESH holds the threshold for ExternalNav innovation threshold (around 0.3 is a good choice)
  - ESRC_EXTN_QUAL holds the ExternalNav quality threshold (about 10 is a good choice)
  - ESRC_FLOW_QUAL holds the optical flow quality threshold (about 50 is a good choice)
  - ESRC_FLOW_THRESH holds the threshold for optical flow innovations (about 0.15 is a good choice)
  - ESRC_RNGFND_MAX holds the threshold (in meters) for rangefinder altitude

  - If ExternalNav's quality is above ESRC_EXTN_QUAL and innovations are below ESRC_EXTN_THRESH, ExternalNav is used
  - Optical flow is used if the above is not true and:

    - Quality is above ESRC_FLOW_QUAL
    - Innovations are below ESRC_FLOW_THRESH
    - Rangefinder distance is below ESRC_RNGFND_MAX



================================================
File: applets/camera-change-setting.lua
================================================
--[[
script to allow users to more easily change camera settings
--]]

local PARAM_TABLE_KEY = 85
local PARAM_TABLE_PREFIX = "CAM1_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local CAMERA_SETTINGS = {THERMAL_PALETTE=0, THERMAL_GAIN=1, THERMAL_RAW_DATA=2}  -- see AP_Camera_shareddefs.h

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'could not add param table')

--[[
  // @Param: CAM1_THERM_PAL
  // @DisplayName: Camera1 Thermal Palette
  // @Description: thermal image colour palette
  // @Values: -1:Leave Unchanged, 0:WhiteHot, 2:Sepia, 3:IronBow, 4:Rainbow, 5:Night, 6:Aurora, 7:RedHot, 8:Jungle, 9:Medical, 10:BlackHot, 11:GloryHot
  // @User: Standard
--]]
local CAM1_THERM_PAL = bind_add_param('THERM_PAL', 1, -1)

--[[
  // @Param: CAM1_THERM_GAIN
  // @DisplayName: Camera1 Thermal Gain
  // @Description: thermal image temperature range
  // @Values: -1:Leave Unchanged, 0:LowGain (50C to 550C), 1:HighGain (-20C to 150C)
  // @User: Standard
--]]
local CAM1_THERM_GAIN = bind_add_param('THERM_GAIN', 2, -1)

--[[
  // @Param: CAM1_THERM_RAW
  // @DisplayName: Camera1 Thermal Raw Data
  // @Description: save images with raw temperatures
  // @Values: -1:Leave Unchanged, 0:Disabled (30fps), 1:Enabled (25 fps)
  // @Units: m
  // @User: Standard
--]]
local CAM1_THERM_RAW = bind_add_param('THERM_RAW', 3, -1)

-- local variables
local update_rate_ms = 3000            -- update every 3 seconds
local CAM1_THERM_PAL_saved_value = -1  -- true if thermal palette has been saved
local CAM1_THERM_GAIN_saved_value = -1 -- true if thermal gain has been saved
local CAM1_THERM_RAW_saved_value = -1  -- true if thermal raw data has been saved

--[[
   main update function, called at 1Hz
--]]
function update()
   
   -- check if we should update any settings
   if CAM1_THERM_PAL:get() >= 0 and CAM1_THERM_PAL:get() ~= CAM1_THERM_PAL_saved_value then
      if camera:change_setting(0, CAMERA_SETTINGS.THERMAL_PALETTE, CAM1_THERM_PAL:get()) then
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Camera1 Thermal Palette to %d", CAM1_THERM_PAL:get()))
         CAM1_THERM_PAL_saved_value = CAM1_THERM_PAL:get()
      else
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("Failed to set Camera1 Thermal Palette to %d", CAM1_THERM_PAL:get()))
      end
   end

   if CAM1_THERM_GAIN:get() >= 0 and CAM1_THERM_GAIN:get() ~= CAM1_THERM_GAIN_saved_value then
      if camera:change_setting(0, CAMERA_SETTINGS.THERMAL_GAIN, CAM1_THERM_GAIN:get()) then
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Camera1 Thermal Gain to %d", CAM1_THERM_GAIN:get()))
         CAM1_THERM_GAIN_saved_value = CAM1_THERM_GAIN:get()
      else
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("Failed to set Camera1 Thermal Gain to %d", CAM1_THERM_GAIN:get()))
      end
   end

   if CAM1_THERM_RAW:get() >= 0 and CAM1_THERM_RAW:get() ~= CAM1_THERM_RAW_saved_value then
      if camera:change_setting(0, CAMERA_SETTINGS.THERMAL_RAW_DATA, CAM1_THERM_RAW:get()) then
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Camera1 Thermal Raw Data to %d", CAM1_THERM_RAW:get()))
         CAM1_THERM_RAW_saved_value = CAM1_THERM_RAW:get()
      else
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("Failed to set Camera1 Thermal Raw Data to %d", CAM1_THERM_RAW:get()))
      end
   end

   return update, update_rate_ms
end

-- print welcome message
gcs:send_text(MAV_SEVERITY.INFO, "Loaded camera-change-settings.lua")

-- start running update loop
return update, update_rate_ms



================================================
File: applets/camera-change-settings.md
================================================
# Camera Change Settings

Allows changing some camera settings that are not normallly used by the autopilot

# Parameters

## CAM1_THERM_PAL

Set the camera's thermal palette

Supported values are
-1: leave unchanged
0: WhiteHot
2: Sepia
3: IronBow
4: Rainbow
5: Night
6: Aurora
7: RedHot
8: Jungle
9: Medical
10: BlackHot
11: GloryHot

## CAM1_THERM_GAIN

Set the camera's thermal gain

Supported values are
-1: leave unchanged
0: LowGain (50C to 550C)
1: HighGain (-20C to 150C)

## CAM1_THERM_RAW

Enable/Disable the saving of raw thermal images.  Enabling raw iamges slightly slows the live video feed

Supported values are
-1: leave unchanged
0: Disabled (30fps)
1: Enabled (25 fps)

# Operation

Install the lua script in the APM/SCRIPTS directory on the flight
controllers microSD card. Review the above parameter descriptions and
decide on the right parameter values for your vehicle and operations.



================================================
File: applets/copter-deadreckon-home.lua
================================================
-- Copter attempts to fly home using dead reckoning if the GPS quality deteriorates or an EKF failsafe triggers
--
-- CAUTION: This script only works for Copter 4.3 (and higher)
-- this script checks for low GPS quality and/or an EKF failsafe and if either occurs, flies in the last known direction towards home
--
-- DR_ENABLE : 1 = enabled, 0 = disabled
-- DR_ENABLE_DIST : distance from home (in meters) beyond which the dead reckoning will be enabled
-- DR_GPS_SACC_MAX : GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy.
-- DR_GPS_SAT_MIN : GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count.
-- DR_GPS_TRIGG_SEC : GPS checks must fail for this many seconds before dead reckoning will be triggered.
-- DR_FLY_ANGLE : lean angle (in degrees) during deadreckoning.  Most vehicles reach maximum speed at 22deg
-- DR_FLY_ALT_MIN : min alt (above home in meters) during deadreckoning. zero to return at current alt
-- DR_FLY_TIMEOUT : timeout (in seconds).  Vehicle will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
-- DR_NEXT_MODE : flight mode vehicle will change to when GPS / EKF recovers or DR_FLY_TIMEOUT expires.  Default is 6=RTL, see FLTMODE1 parameter description for list of flight mode number.  Set to -1 to return to mode used before deadreckoning was triggered

-- How to use:
--   1. set SCR_ENABLE = 1 to enable scripting (and reboot the autopilot)
--   2. set SCR_HEAP_SIZE to 80000 or higher to allocate enough memory for this script
--   3. set DR_ENABLE = 1 to enable dead reckoning
--   4. optionally set DR_GPS_SACC_MAX and/or DR_GPS_SAT_MIN parameters to adjust how bad the GPS quality must be before triggering
--   5. confirm "DR: waiting for dist (Xm < 50m)" message is displayed on ground station (so you know script is working)
--   6. arm and takeoff to a safe altitude
--   7. fly at least DR_ENABLE_DIST meters from home and confirm "DR: activated!" is displayed on ground station
--
--   If this script senses low GPS quality or an EKF failsafe triggers:
--       - vehicle will change to Guided_NoGPS mode
--       - vehicle will lean in the last known direction of home (see DR_FLY_ANGLE)
--       - if GPS recovers or EKF failsafe is cleared the vehicle will switch to DR_NEXT_MODE (if -1 then it will switch back to the mode in use before the GPS/EKF failure)
--       - if the timeout is surpassed (see DR_FLY_TIMEOUT) the vehicle will try to switch to DR_NEXT_MODE.  If it fails to change it will continue in Guided_NoGPS but keep trying to change mode
--       - the pilot can retake control by switching to an "unprotected" mode like AltHold, Loiter (see "protected_mode_array" below)
--
-- Testing in SITL:
--   a. set map setshowsimpos 1 (to allow seeing where vehicle really is in simulator even with GPS disabled)
--   b. set SIM_GPS1_ENABLE = 0 to disable GPS (confirm dead reckoning begins)
--   c. set SIM_GPS1_ENABLE = 1 to re-enable GPS
--   d. set SIM_GPS_NUMSAT = 3 to lower simulated satellite count to confirm script triggers
--   e. set DR_GPS_SACC_MAX = 0.01 to lower the threshold and trigger below the simulator value which is 0.04 (remember to set this back after testing!)
--
-- Test on a real vehicle:
--   A. set DR_FLY_TIMEOUT to a low value (e.g. 5 seconds)
--   B. fly the vehicle at least DR_DIST_MIN meters from home and confirm the "DR: activated!" message is displayed
--   C. set GPS1_TYPE = 0 to disable GPS and confirm the vehicle begins deadreckoning after a few seconds
--   D. restore GPS1_TYPE to its original value (normally 1) and confirm the vehicle switches to DR_NEXT_MODE
--   E. restore DR_FLY_TIMEOUT to a higher value for real-world use
-- Note: Instaed of setting GPS1_TYPE, an auxiliary function switch can be setup to disable the GPS (e.g. RC9_OPTION = 65/"Disable GPS")
--
-- Testing that it does not require RC (in SITL):
--   a. set FS_OPTIONS's "Continue if in Guided on RC failsafe" bit
--   b. set FS_GCS_ENABLE = 1 (to enable GCS failsafe otherwise RC failsafe will trigger anyway)
--   c. optionally set MAV_GCS_SYSID = 77 (or almost any other unused system id) to trick the above check so that GCS failsafe can really be disabled
--   d. set SIM_RC_FAIL = 1 (to simulate RC failure, note vehicle keeps flying)
--   e. set SIM_RC_FAIL = 0 (to simulate RC recovery)
--
-- Test with wind (in SITL)
--   a. SIM_WIND_DIR <-- sets direction wind is coming from
--   b. SIM_WIND_SPD <-- sets wind speed in m/s
--

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type

-- create and initialise parameters
local PARAM_TABLE_KEY = 86  -- parameter table key must be used by only one script on a particular flight controller
assert(param:add_table(PARAM_TABLE_KEY, "DR_", 9), 'could not add param table')
assert(param:add_param(PARAM_TABLE_KEY, 1, 'ENABLE', 1), 'could not add DR_ENABLE param')   -- 1 = enabled, 0 = disabled
assert(param:add_param(PARAM_TABLE_KEY, 2, 'ENABLE_DIST', 50), 'could not add DR_ENABLE_DIST param')   -- distance from home (in meters) beyond which the dead reckoning will be enabled
assert(param:add_param(PARAM_TABLE_KEY, 3, 'GPS_SACC_MAX', 0.8), 'could not add DR_GPS_SACC_MAX param') -- GPS speed accuracy max threshold
assert(param:add_param(PARAM_TABLE_KEY, 4, 'GPS_SAT_MIN', 6), 'could not add DR_GPS_SAT_MIN param')  -- GPS satellite count min threshold
assert(param:add_param(PARAM_TABLE_KEY, 5, 'GPS_TRIGG_SEC', 3), 'could not add DR_GPS_TRIGG_SEC parameter') -- GPS checks must fail for this many seconds before dead reckoning will be triggered

assert(param:add_param(PARAM_TABLE_KEY, 6, 'FLY_ANGLE', 10), 'could not add DR_FLY_ANGLE param')    -- lean angle (in degrees) during deadreckoning
assert(param:add_param(PARAM_TABLE_KEY, 7, 'FLY_ALT_MIN', 0), 'could not add DR_FLY_ALT_MIN param') -- min alt above home (in meters) during deadreckoning. zero to return at current alt
assert(param:add_param(PARAM_TABLE_KEY, 8, 'FLY_TIMEOUT', 30), 'could not add DR_FLY_TIMEOUT param')-- deadreckoning timeout (in seconds)
assert(param:add_param(PARAM_TABLE_KEY, 9, 'NEXT_MODE', 6), 'could not add DR_NEXT_MODE param')     -- mode to switch to after GPS recovers or timeout elapses

-- bind parameters to variables
--[[
  // @Param: DR_ENABLE
  // @DisplayName: Deadreckoning Enable
  // @Description: Deadreckoning Enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local enable = Parameter("DR_ENABLE")                  -- 1 = enabled, 0 = disabled

--[[
  // @Param: DR_ENABLE_DIST
  // @DisplayName: Deadreckoning Enable Distance
  // @Description: Distance from home (in meters) beyond which the dead reckoning will be enabled
  // @Units: m
  // @User: Standard
--]]
local enable_dist = Parameter("DR_ENABLE_DIST")        -- distance from home (in meters) beyond which the dead reckoning will be enabled

--[[
  // @Param: DR_GPS_SACC_MAX
  // @DisplayName: Deadreckoning GPS speed accuracy maximum threshold
  // @Description: GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy
  // @Range: 0 10
  // @User: Standard
--]]
local gps_speed_acc_max = Parameter("DR_GPS_SACC_MAX") -- GPS speed accuracy max threshold

--[[
  // @Param: DR_GPS_SAT_MIN
  // @DisplayName: Deadreckoning GPS satellite count min threshold
  // @Description: GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count
  // @Range: 0 30
  // @User: Standard
--]]
local gps_sat_count_min = Parameter("DR_GPS_SAT_MIN")  -- GPS satellite count min threshold

--[[
  // @Param: DR_GPS_TRIGG_SEC
  // @DisplayName: Deadreckoning GPS check trigger seconds
  // @Description: GPS checks must fail for this many seconds before dead reckoning will be triggered
  // @Units: s
  // @User: Standard
--]]
local gps_trigger_sec = Parameter("DR_GPS_TRIGG_SEC")  -- GPS checks must fail for this many seconds before dead reckoning will be triggered

--[[
  // @Param: DR_FLY_ANGLE
  // @DisplayName: Deadreckoning Lean Angle
  // @Description: lean angle (in degrees) during deadreckoning
  // @Units: deg
  // @Range: 0 45
  // @User: Standard
--]]
local fly_angle = Parameter("DR_FLY_ANGLE")            -- lean angle (in degrees) during deadreckoning

--[[
  // @Param: DR_FLY_ALT_MIN
  // @DisplayName: Deadreckoning Altitude Min
  // @Description: Copter will fly at at least this altitude (in meters) above home during deadreckoning
  // @Units: m
  // @Range: 0 1000
  // @User: Standard
--]]
local fly_alt_min = Parameter("DR_FLY_ALT_MIN")        -- min alt above home (in meters) during deadreckoning

--[[
  // @Param: DR_FLY_TIMEOUT
  // @DisplayName: Deadreckoning flight timeout
  // @Description: Copter will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
  // @Units: s
  // @User: Standard
--]]
local fly_timeoout = Parameter("DR_FLY_TIMEOUT")       -- deadreckoning timeout (in seconds)

--[[
  // @Param: DR_NEXT_MODE
  // @DisplayName: Deadreckoning Next Mode
  // @Description: Copter switch to this mode after GPS recovers or DR_FLY_TIMEOUT has elapsed.  Default is 6/RTL.  Set to -1 to return to mode used before deadreckoning was triggered
  // @Values: 2:AltHold,3:Auto,4:Guided,5:Loiter,6:RTL,7:Circle,9:Land,16:PosHold,17:Brake,20:Guided_NoGPS,21:Smart_RTL,27:Auto RTL
  // @User: Standard
--]]
local next_mode = Parameter("DR_NEXT_MODE")            -- mode to switch to after GPS recovers or timeout elapses
local wpnav_speedup = Parameter("WPNAV_SPEED_UP")      -- maximum climb rate from WPNAV_SPEED_UP
local wpnav_accel_z = Parameter("WPNAV_ACCEL_Z")       -- maximum vertical acceleration from WPNAV_ACCEL_Z

-- modes deadreckoning may be activated from
-- comment out lines below to remove protection from these modes
local protected_mode_array = {
         3, -- AUTO
         4, -- GUIDED
         --5, -- LOITER
         6, -- RTL
         7, -- CIRCLE
         9, -- LAND
         --11, -- DRIFT
         --16, -- POSHOLD
         17, -- BRAKE
         21, -- SMART_RTL
         27, -- AUTO_RTL
        }
function is_protected_mode()
   local curr_mode = vehicle:get_mode()
   for i = 1, #protected_mode_array do
     if curr_mode == protected_mode_array[i] then
       return true
     end
   end
   return false
end

local copter_guided_nogps_mode = 20 -- Guided_NoGPS is mode 20 on Copter
local copter_RTL_mode = 6           -- RTL is mode 6 on Copter
local recovery_delay_ms = 3000      -- switch to NEXT_MODE happens this many milliseconds after GPS and EKF failsafe recover

local gps_bad = false               -- true if GPS is failing checks
local ekf_bad = false               -- true if EKF failsafe has triggered
local gps_or_ekf_bad = true         -- true if GPS and/or EKF is bad, true once both have recovered

local flight_stage = 0  -- 0. wait for good-gps and dist-from-home, 1=wait for bad gps or ekf, 2=level vehicle, 3=deadreckon home
local gps_bad_start_time_ms = 0 -- system time GPS quality went bad (0 if not bad)
local recovery_start_time_ms = 0-- system time GPS quality and EKF failsafe recovered (0 if not recovered)

local home_dist = 0     -- distance to home in meters
local home_yaw = 0      -- direction to home in degrees

local target_yaw = 0    -- deg
local climb_rate = 0    -- m/s

local stage1_flight_mode = nil  -- flight mode vehicle was in during stage1 (may be used during recovery)
local stage2_start_time_ms  -- system time stage2 started (level vehicle)
local stage3_start_time_ms  -- system time stage3 started (deadreckon home)
local last_print_ms = 0     -- pilot update timer
local interval_ms = 100     -- update at 10hz

function update()

  -- exit immediately if not enabled
  if (enable:get() < 1) then
    return update, 1000
  end

  -- determine if progress update should be sent to user
  local now_ms = millis()
  local update_user = false
  if (now_ms - last_print_ms > 5000) then
    last_print_ms = now_ms
    update_user = true
  end

  -- check GPS
  local gps_speed_acc = gps:speed_accuracy(gps:primary_sensor())
  if gps_speed_acc == nil then
    gps_speed_acc = 99
  end
  local gps_speed_acc_bad = ((gps_speed_acc_max:get() > 0) and (gps_speed_acc > gps_speed_acc_max:get()))
  local gps_num_sat = gps:num_sats(gps:primary_sensor())
  local gps_num_sat_bad = (gps_sat_count_min:get() > 0) and ((gps_num_sat == nil) or (gps:num_sats(gps:primary_sensor()) < gps_sat_count_min:get()))
  if gps_bad then
    -- GPS is bad, check for recovery
    if (not gps_speed_acc_bad and not gps_num_sat_bad) then
      gps_bad = false
    end
  else
    -- GPS is good, check for GPS going bad
    if (gps_speed_acc_bad or gps_num_sat_bad) then
      if (gps_bad_start_time_ms == 0) then
        -- start gps bad timer
        gps_bad_start_time_ms = now_ms
      elseif (now_ms - gps_bad_start_time_ms > gps_trigger_sec:get()) then
        gps_bad = true
      end
    end
  end

  -- check EKF failsafe
  local fs_ekf = vehicle:has_ekf_failsafed()
  if ekf_bad ~= fs_ekf then
    ekf_bad = fs_ekf
  end

  -- check for GPS and/or EKF going bad
  if not gps_or_ekf_bad and (gps_bad or ekf_bad) then
    gps_or_ekf_bad = true
    gcs:send_text(0, "DR: GPS or EKF bad")
  end

  -- check for GPS and/or EKF recovery
  if (gps_or_ekf_bad and (not gps_bad and not ekf_bad)) then
    -- start recovery timer
    if recovery_start_time_ms == 0 then
      recovery_start_time_ms = now_ms
    end
    if (now_ms - recovery_start_time_ms > recovery_delay_ms) then
      gps_or_ekf_bad = false
      recovery_start_time_ms = 0
      gcs:send_text(0, "DR: GPS and EKF recovered")
    end
  end

  -- update distance and direction home while GPS and EKF are good
  if (not gps_or_ekf_bad) then
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_location()
    if home and curr_loc then
      home_dist = curr_loc:get_distance(home)
      home_yaw = math.deg(curr_loc:get_bearing(home))
    elseif (update_user) then
      -- warn user of unexpected failure
      gcs:send_text(0, "DR: could not get home or vehicle location")
    end
  end

  -- reset flight_stage when disarmed
  if not arming:is_armed() then 
    flight_stage = 0
    transition_start_time_ms = 0
    return update, interval_ms
  end

  -- flight_stage 0: wait for good gps and dist-from-home
  if (flight_stage == 0) then

    -- wait for GPS and EKF to be good
    if (gps_or_ekf_bad) then
      return update, interval_ms
    end

    -- wait for distance from home to pass DR_ENABLE_DIST
    if ((home_dist > 0) and (home_dist >= enable_dist:get())) then
      gcs:send_text(5, "DR: enabled")
      flight_stage = 1
    elseif (update_user) then
      gcs:send_text(5, "DR: waiting for dist:" .. tostring(math.floor(home_dist)) .. " need:" .. tostring(math.floor(enable_dist:get())))
    end
    return update, interval_ms
  end

  -- flight_stage 1: wait for bad gps or ekf
  if (flight_stage == 1) then
    if (gps_or_ekf_bad and is_protected_mode()) then
      -- change to Guided_NoGPS and initialise stage2
      if (vehicle:set_mode(copter_guided_nogps_mode)) then
        flight_stage = 2
        target_yaw = math.deg(ahrs:get_yaw_rad())
        stage2_start_time_ms = now_ms
      else
        -- warn user of unexpected failure
        if (update_user) then
          gcs:send_text(5, "DR: failed to change to Guided_NoGPS mode")
        end
      end
    else
      -- store flight mode (may be used during recovery)
      stage1_flight_mode = vehicle:get_mode()
    end
    return update, interval_ms
  end

  -- flight_stage 2: level vehicle for 5 seconds
  if (flight_stage == 2) then
    -- allow pilot to retake control
    if (vehicle:get_mode() ~= copter_guided_nogps_mode) then
      gcs:send_text(5, "DR: pilot retook control")
      flight_stage = 1
      return update, interval_ms
    end

    -- level vehicle for 5 seconds
    climb_rate = 0
    vehicle:set_target_angle_and_climbrate(0, 0, target_yaw, climb_rate, false, 0)
    if ((now_ms - stage2_start_time_ms) >= 5000) then
      flight_stage = 3
      stage3_start_time_ms = now_ms
      gcs:send_text(5, "DR: flying home")
    end
    if (update_user) then
      gcs:send_text(5, "DR: leveling vehicle")
    end
    return update, interval_ms
  end

  -- flight_stage 3: deadreckon towards home
  if (flight_stage == 3) then

    -- allow pilot to retake control
    if (vehicle:get_mode() ~= copter_guided_nogps_mode) then
      gcs:send_text(5, "DR: pilot retook control")
      flight_stage = 1
      return update, interval_ms
    end

    -- check for timeout
    local time_elapsed_ms = now_ms - stage3_start_time_ms
    local timeout = (fly_timeoout:get() > 0) and (time_elapsed_ms >= (fly_timeoout:get() * 1000))

    -- calculate climb rate in m/s
    if (fly_alt_min:get() > 0) then
      local curr_alt_below_home = ahrs:get_relative_position_D_home()
      if curr_alt_below_home then
        local target_alt_above_vehicle = fly_alt_min:get() + curr_alt_below_home
        if target_alt_above_vehicle > 0 then
          -- climb at up to 1m/s towards target above vehicle.  climb rate change is limited by WPNAV_ACCEL_Z
          local climb_rate_chg_max = interval_ms * 0.001 * (wpnav_accel_z:get() * 0.01)
          climb_rate = math.min(target_alt_above_vehicle * 0.1, wpnav_speedup:get() * 0.01, climb_rate + climb_rate_chg_max)
        end
      end
    end

    -- set angle target to roll 0, pitch to lean angle (note: negative is forward), yaw towards home
    if (vehicle:set_target_angle_and_climbrate(0, -math.abs(fly_angle:get()), home_yaw, climb_rate, false, 0)) then
      if (update_user) then
        local time_left_str = ""
        if (not timeout and (fly_timeoout:get() > 0)) then
          time_left_str = " t:" .. tostring(math.max(0, ((fly_timeoout:get() * 1000) - time_elapsed_ms) / 1000))
        end
        gcs:send_text(5, "DR: fly home yaw:" .. tostring(math.floor(home_yaw)) .. " pit:" .. tostring(math.floor(fly_angle:get())) .. " cr:" .. tostring(math.floor(climb_rate*10)/10) .. time_left_str)
      end
    elseif (update_user) then
      gcs:send_text(0, "DR: failed to set attitude target")
    end

    -- if GPS and EKF recover or timeout switch to next mode
    if (not gps_or_ekf_bad) or timeout then
      local recovery_mode = stage1_flight_mode
      if (next_mode:get() >= 0) then
        recovery_mode = next_mode:get()
      end
      if (recovery_mode == nil) then
        recovery_mode = copter_RTL_mode
        gcs:send_text(0, "DR: NEXT_MODE=-1 but fallingback to RTL")
      end
      -- change to DR_NEXT_MODE
      if (vehicle:set_mode(recovery_mode)) then
        flight_stage = 0
      elseif (update_user) then
        -- warn user of unexpected failure        
        gcs:send_text(0, "DR: failed to change to mode " .. tostring(recovery_mode))
      end
    end
    return update, interval_ms
  end

  -- we should never get here but just in case
  return update, interval_ms
end

return update()




================================================
File: applets/copter-deadreckon-home.md
================================================
# Copter Deadreckon Home applet

Copter attempts to fly home using dead reckoning if the GPS quality deteriorates or an EKF failsafe triggers

CAUTION: This script only works for Copter 4.3 (and higher)

Deadreckoning will only be activated while the vehicle is in autonomous modes (e.g. Auto, Guided, RTL, Circle, Land, Brake, SmartRTL or AutoRTL modes).  Deadreckoning is not activated in pilot controlled modes (e.g. Loiter, PosHold, etc) because we assume the pilot could simply switch to AltHold and fly the vehicle home manually.

## Parmeter Descriptions

  - DR_ENABLE : 1 = enabled, 0 = disabled
  - DR_ENABLE_DIST : distance from home (in meters) beyond which the dead reckoning will be enabled
  - DR_GPS_SACC_MAX : GPS speed accuracy maximum, above which deadreckoning home will begin (default is 0.8).  Lower values trigger with good GPS quality, higher values will allow poorer GPS before triggering. Set to 0 to disable use of GPS speed accuracy.
  - DR_GPS_SAT_MIN : GPS satellite count threshold below which deadreckoning home will begin (default is 6).  Higher values trigger with good GPS quality, Lower values trigger with worse GPS quality. Set to 0 to disable use of GPS satellite count.
  - DR_GPS_TRIGG_SEC : GPS checks must fail for this many seconds before dead reckoning will be triggered.
  - DR_FLY_ANGLE : lean angle (in degrees) during deadreckoning.  Most vehicles reach maximum speed at 22deg
  - DR_FLY_ALT_MIN : min alt (above home in meters) during deadreckoning. zero to return at current alt
  - DR_FLY_TIMEOUT : timeout (in seconds).  Vehicle will attempt to switch to NEXT_MODE after this many seconds of deadreckoning.  If it cannot switch modes it will continue in Guided_NoGPS.  Set to 0 to disable timeout
  - DR_NEXT_MODE : flight mode vehicle will change to when GPS / EKF recovers or DR_FLY_TIMEOUT expires.  Default is 6=RTL, see FLTMODE1 parameter description for list of flight mode number.  Set to -1 to return to mode used before deadreckoning was triggered

## How to use

  1. set SCR_ENABLE = 1 to enable scripting (and reboot the autopilot)
  2. set SCR_HEAP_SIZE to 80000 or higher to allocate enough memory for this script
  3. set DR_ENABLE = 1 to enable dead reckoning
  4. optionally set DR_GPS_SACC_MAX and/or DR_GPS_SAT_MIN parameters to adjust how bad the GPS quality must be before triggering
  5. confirm "DR: waiting for dist (Xm < 50m)" message is displayed on ground station (so you know script is working)
  6. arm and takeoff to a safe altitude
  7. fly at least DR_ENABLE_DIST meters from home and confirm "DR: activated!" is displayed on ground station

  If this script senses low GPS quality or an EKF failsafe triggers

  - vehicle will change to Guided_NoGPS mode
  - vehicle will lean in the last known direction of home (see DR_FLY_ANGLE)
  - if GPS recovers or EKF failsafe is cleared the vehicle will switch to DR_NEXT_MODE (if -1 then it will switch back to the mode in use before the GPS/EKF failure)
  - if the timeout is surpassed (see DR_FLY_TIMEOUT) the vehicle will try to switch to DR_NEXT_MODE.  If it fails to change it will continue in Guided_NoGPS but keep trying to change mode
  - the pilot can retake control by switching to an "unprotected" mode like AltHold, Loiter (see "protected_mode_array" below)

## Testing in SITL

  - set map setshowsimpos 1 (to allow seeing where vehicle really is in simulator even with GPS disabled)
  - set SIM_GPS1_ENABLE = 0 to disable GPS (confirm dead reckoning begins)
  - set SIM_GPS1_ENABLE = 1 to re-enable GPS
  - set SIM_GPS_NUMSAT = 3 to lower simulated satellite count to confirm script triggers
  - set DR_GPS_SACC_MAX = 0.01 to lower the threshold and trigger below the simulator value which is 0.04 (remember to set this back after testing!)

## Test on a real vehicle

  1. set DR_FLY_TIMEOUT to a low value (e.g. 5 seconds)
  2. fly the vehicle at least DR_DIST_MIN meters from home and confirm the "DR: activated!" message is displayed
  3. set GPS1_TYPE = 0 to disable GPS and confirm the vehicle begins deadreckoning after a few seconds
  4. restore GPS1_TYPE to its original value (normally 1) and confirm the vehicle switches to DR_NEXT_MODE
  5. restore DR_FLY_TIMEOUT to a higher value for real-world use

  Note: Instaed of setting GPS1_TYPE, an auxiliary function switch can be setup to disable the GPS (e.g. RC9_OPTION = 65/"Disable GPS")

## Testing that it does not require RC (in SITL):
  - set FS_OPTIONS's "Continue if in Guided on RC failsafe" bit
  - set FS_GCS_ENABLE = 1 (to enable GCS failsafe otherwise RC failsafe will trigger anyway)
  - optionally set MAV_GCS_SYSID = 77 (or almost any other unused system id) to trick the above check so that GCS failsafe can really be disabled
  - set SIM_RC_FAIL = 1 (to simulate RC failure, note vehicle keeps flying)
  - set SIM_RC_FAIL = 0 (to simulate RC recovery)

## Test with wind (in SITL)
  - SIM_WIND_DIR <-- sets direction wind is coming from
  - SIM_WIND_SPD <-- sets wind speed in m/s



================================================
File: applets/copter-slung-payload.lua
================================================
-- Move a Copter so as to reduce a slung payload's oscillation.  Requires the payload be capable of sending its position and velocity to the main vehicle
--
-- How To Use
-- 1. copy this script to the autopilot's "scripts" directory
-- 2. within the "scripts" directory create a "modules" directory
-- 3. copy the MAVLink/mavlink_msgs_xxx files to the "scripts" directory
-- 4. add an autopilot and GPS to the payload and configure it to send GLOBAL_POSITION_INT messages at 10hz to the vehicle
-- 5. create a mission with a SCRIPT_TIME or PAYLOAD_PLACE command included
-- 6. fly the mission and the vehicle should move so as to reduce the payload's oscillations while executing the SCRIPT_TIME or PAYLOAD_PLACE commands
-- 7. optionally set SLUP_SYSID to the system id of the payload autopilot
-- 8. optionally set WP_YAW_BEHAVIOR to 0 to prevent the vehicle from yawing while moving to the payload

-- load mavlink message definitions from modules/MAVLink directory
local mavlink_msgs = require("MAVLink/mavlink_msgs")

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local UPDATE_INTERVAL_MS = 10           -- update at about 100hz
local COPTER_MODE_AUTO = 3
local MAV_CMD_NAV_PAYLOAD_PLACE = 94
local MAV_CMD_NAV_SCRIPT_TIME = 42702
local PAYLOAD_OFFSET_COMP_VEL_MAX = 1   -- payload offset compensation will be active when the payload's horizontal velocity is no more than this speed in m/s
local PAYLOAD_UPDATE_TIMEOUT_MS = 1000  -- payload update timeout, used to warn user on loss of connection
local CONTROL_TIMEOUT_MS = 3000         -- control timeout, used to reset offsets if they have not been set for more than 3 seconds
local TEXT_PREFIX_STR = "copter-slung-payload:"    -- prefix for all text messages

 -- setup script specific parameters
local PARAM_TABLE_KEY = 82
local PARAM_TABLE_PREFIX = "SLUP_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 7), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', PARAM_TABLE_PREFIX .. name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
 end

--[[
  // @Param: SLUP_ENABLE
  // @DisplayName: Slung Payload enable
  // @Description: Slung Payload enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local SLUP_ENABLE = bind_add_param("ENABLE", 1, 1)

--[[
  // @Param: SLUP_VEL_P
  // @DisplayName: Slung Payload Velocity P gain
  // @Description: Slung Payload Velocity P gain, higher values will result in faster movements in sync with payload
  // @Range: 0 0.8
  // @User: Standard
--]]
local SLUP_VEL_P = bind_add_param("VEL_P", 2, 0.5)

--[[
  // @Param: SLUP_DIST_MAX
  // @DisplayName: Slung Payload horizontal distance max
  // @Description: Oscillation is suppressed when vehicle and payload are no more than this distance horizontally.  Set to 0 to always suppress
  // @Range: 0 30
  // @User: Standard
--]]
local SLUP_DIST_MAX = bind_add_param("DIST_MAX", 3, 15)

--[[
  // @Param: SLUP_SYSID
  // @DisplayName: Slung Payload mavlink system id
  // @Description: Slung Payload mavlink system id.  0 to use any/all system ids
  // @Range: 0 255
  // @User: Standard
--]]
local SLUP_SYSID = bind_add_param("SYSID", 4, 0)

--[[
  // @Param: SLUP_WP_POS_P
  // @DisplayName: Slung Payload return to WP position P gain
  // @Description: WP position P gain. higher values will result in vehicle moving more quickly back to the original waypoint
  // @Range: 0 1
  // @User: Standard
--]]
local SLUP_WP_POS_P = bind_add_param("WP_POS_P", 5, 0.05)

--[[
  // @Param: SLUP_RESTOFS_TC
  // @DisplayName: Slung Payload resting offset estimate filter time constant
  // @Description: payload's position estimator's time constant used to compensate for GPS errors and wind.  Higher values result in smoother estimate but slower response
  // @Range: 1 20
  // @User: Standard
--]]
local SLUP_RESTOFS_TC = bind_add_param("RESTOFS_TC", 6, 10)

--[[
  // @Param: SLUP_DEBUG
  // @DisplayName: Slung Payload debug output
  // @Description: Slung payload debug output, set to 1 to enable debug
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local SLUP_DEBUG = bind_add_param("DEBUG", 7, 0)

-- mavlink definitions
local GLOBAL_POSITION_INT_ID = 33
local msg_map = {}
msg_map[GLOBAL_POSITION_INT_ID] = "GLOBAL_POSITION_INT"

-- initialize MAVLink rx with buffer depth and number of rx message IDs to register
mavlink:init(5, 1)

-- register message id to receive
mavlink:register_rx_msgid(GLOBAL_POSITION_INT_ID)

-- variables
local payload_sysid = nil                       -- holds sysid of payload once a matching global position int message has been received
local payload_loc = Location()                  -- payload location
local payload_vel = Vector3f()                  -- payload velocity
local payload_acc = Vector3f()                  -- payload acceleration
local payload_update_timeout_prev = true        -- payload update timeout state from previous iteration, used to detect loss/recovery of payload updates
local payload_loc_update_ms = uint32_t(0)       -- system time that payload_loc was last updated
local payload_dist_NED = Vector3f()             -- distance between vehicle and payload in NED frame
local global_pos_int_timebootms_prev = 0        -- global position int message's time_boot_ms field from previous iteration (used to calc dt)
local resting_offset_NED = Vector3f()           -- estimated position offset between payload and vehicle
local resting_vel_NED = Vector3f()              -- estimated velocity offset.  should be near zero when hovering
local resting_offset_valid = false              -- true if resting_offset_NED and resting_vel_NED can be used
local resting_offset_update_ms = uint32_t(0)    -- system time that resting_offset_NED was last updated
local resting_offset_notify_ms = uint32_t(0)    -- system time that the user was sent the resting_offset_NED
local send_velocity_offsets = false             -- true if we should send vehicle velocity offset commands to reduce payload oscillation
local sent_velocity_offsets_ms = uint32_t(0)    -- system time that the last velocity offset was sent to the vehicle
local control_timeout_ms = uint32_t(0)          -- system time that the control timeout occurred
local payload_vel_prev = Vector3f()             -- previous iterations payload velocity used to calculate acceleration
local print_warning_ms = uint32_t(0)            -- system time that the last warning was printed.  used to prevent spamming the user with warnings

-- display a text warning to the user.  only displays a warning every second
-- prefix is automatically added
function print_warning(text_warning)
    local now_ms = millis()
    if (now_ms - print_warning_ms > 1000) then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("%s %s", TEXT_PREFIX_STR, text_warning))
        print_warning_ms = now_ms
    end
end

-- calculate sign of a number.  1 if positive, -1 if negative, 0 if exactly zero
function get_sign(value)
    if value > 0 then
        return 1
    elseif value < 0 then
        return -1
    end
    return 0
end

-- calculate an alpha for a first order low pass filter
function calc_lowpass_alpha(dt, time_constant)
    local rc = time_constant/(math.pi*2)
    return dt/(dt+rc)
end

-- handle global position int message
-- returns true if the message was from the payload and updates payload_loc, payload_vel, payload_acc and payload_loc_update_ms
function handle_global_position_int(msg)
    -- check if message is from the correct system id
    if (SLUP_SYSID:get() > 0 and msg.sysid ~= SLUP_SYSID:get()) then
        return false
    end

    -- lock onto the first matching system id
    if payload_sysid == nil then
        payload_sysid = msg.sysid
        gcs:send_text(MAV_SEVERITY.INFO, string.format("%s found sysid:%d", TEXT_PREFIX_STR, msg.sysid))
    elseif payload_sysid ~= msg.sysid then
        return false
    end

    -- check for duplicate messages and calculate dt
    local time_boot_ms = msg.time_boot_ms
    local dt = (time_boot_ms - global_pos_int_timebootms_prev) * 0.001
    global_pos_int_timebootms_prev = time_boot_ms
    if dt <= 0 or dt > 1 then
        return false
    end

    -- update payload location
    payload_loc:lat(msg.lat)
    payload_loc:lng(msg.lon)
    payload_loc:alt(msg.alt * 0.1)

    -- update payload velocity
    payload_vel:x(msg.vx * 0.01)
    payload_vel:y(msg.vy * 0.01)
    payload_vel:z(msg.vz * 0.01)

    -- calc payload acceleration
    payload_acc:x((payload_vel:x() - payload_vel_prev:x()) / dt)
    payload_acc:y((payload_vel:y() - payload_vel_prev:y()) / dt)
    payload_acc:z((payload_vel:z() - payload_vel_prev:z()) / dt)
    payload_vel_prev = payload_vel:copy()

    -- record time of update
    payload_loc_update_ms = millis()
    return true
end

-- estimate the payload's resting position offset based on its current offset and velocity
-- relies on payload_dist_NED and payload_vel being updated
function update_payload_resting_offset()

    -- calculate dt since last update
    local now_ms = millis()
    local dt = (now_ms - resting_offset_update_ms):tofloat() * 0.001
    resting_offset_update_ms = now_ms

    -- sanity check dt
    if (dt <= 0) then
        resting_offset_valid = false
        do return end
    end

    -- if not updated for more than 1 second, reset resting offset to current offset
    if (dt > 1) then
        resting_offset_NED = payload_dist_NED
        resting_vel_NED = payload_vel
        resting_offset_valid = false
        do return end
    end

    -- use a low-pass filter to move the resting offset NED towards the pos_offset_NED
    local alpha = calc_lowpass_alpha(dt, SLUP_RESTOFS_TC:get())
    resting_offset_NED:x(resting_offset_NED:x() + (payload_dist_NED:x() - resting_offset_NED:x()) * alpha)
    resting_offset_NED:y(resting_offset_NED:y() + (payload_dist_NED:y() - resting_offset_NED:y()) * alpha)
    resting_offset_NED:z(resting_offset_NED:z() + (payload_dist_NED:z() - resting_offset_NED:z()) * alpha)
    resting_vel_NED:x(resting_vel_NED:x() + (payload_vel:x() - resting_vel_NED:x()) * alpha)
    resting_vel_NED:y(resting_vel_NED:y() + (payload_vel:y() - resting_vel_NED:y()) * alpha)
    resting_vel_NED:z(resting_vel_NED:z() + (payload_vel:z() - resting_vel_NED:z()) * alpha)

    -- debug output every 3 seconds
    local print_debug = false
    if (SLUP_DEBUG:get() > 0) and (now_ms - resting_offset_notify_ms > 3000) then
        print_debug = true
        resting_offset_notify_ms = now_ms
    end

    -- validate that resting offsets are valid
    -- resting velocity should be low to ensure the resting position estimate is accurate
    if (resting_vel_NED:xy():length() > PAYLOAD_OFFSET_COMP_VEL_MAX) then
        resting_offset_valid = false
        if print_debug then
            print_warning("resting velocity too high")
        end
        return
    end

    -- resting position should be within SLUP_DIST_MAX of the vehicle
    if resting_offset_NED:xy():length() > SLUP_DIST_MAX:get() then
        resting_offset_valid = false
        if print_debug then
            print_warning("payload resting pos too far, ignoring");
        end
        return
    end

    -- update user
    if (print_debug) then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("resting a:%f px:%4.1f py:%4.1f pz:%4.1f vx:%4.1f vy:%4.1f vz:%4.1f", alpha, resting_offset_NED:x(), resting_offset_NED:y(), resting_offset_NED:z(), resting_vel_NED:x(), resting_vel_NED:y(), resting_vel_NED:z()))
    end

    -- if set got this far the resting offsets must be valid
    resting_offset_valid = true
end

-- move vehicle to reduce payload oscillation
-- relies on payload_dist_NED, payload_vel, payload_acc, resting_offset_NED, resting_vel_NED being updated
function move_vehicle()

    -- check horizontal distance is less than SLUP_DIST_MAX
    if SLUP_DIST_MAX:get() > 0 then
        local dist_xy = payload_dist_NED:xy():length()
        if (dist_xy > SLUP_DIST_MAX:get()) then
            print_warning(string.format("payload too far %4.1fm", dist_xy));
            do return end
        end
    end

    -- get long-term payload offset used to compensate for GPS errors and wind
    local payload_offset_NED = Vector3f()
    if resting_offset_valid then
        payload_offset_NED = resting_offset_NED
    end

    -- get position offset (cumulative effect of velocity offsets) and use to slowly move back to waypoint
    local pos_offset_NED, _, _ = poscontrol:get_posvelaccel_offset()
    if pos_offset_NED == nil then
        print_warning("unable to get dist to waypoint")
        pos_offset_NED = Vector3f()
    end

    -- calculate send velocity offsets in m/s in NED frame
    local vel_offset_NED = Vector3f()
    vel_offset_NED:x(-payload_acc:x() * SLUP_VEL_P:get() + (-pos_offset_NED:x() - payload_offset_NED:x()) * SLUP_WP_POS_P:get())
    vel_offset_NED:y(-payload_acc:y() * SLUP_VEL_P:get() + (-pos_offset_NED:y() - payload_offset_NED:y()) * SLUP_WP_POS_P:get())
    if poscontrol:set_posvelaccel_offset(pos_offset_NED, vel_offset_NED, Vector3f()) then
        sent_velocity_offsets_ms = millis()
    end
end

-- display welcome message
gcs:send_text(MAV_SEVERITY.INFO, "copter-slung-payload script loaded")

-- update function to receive location from payload and move vehicle to reduce payload's oscillation
function update()

    -- exit immediately if not enabled
    if (SLUP_ENABLE:get() <= 0) then
        return update, 1000
    end

    -- get vehicle location
    local curr_loc = ahrs:get_location()
    if curr_loc == nil then
        return update, UPDATE_INTERVAL_MS
    end

    -- consume all available mavlink messages
    local payload_update_received = false
    local msg
    repeat
        msg, _ = mavlink:receive_chan()
        if (msg ~= nil) then
            local parsed_msg = mavlink_msgs.decode(msg, msg_map)
            if (parsed_msg ~= nil) then
                if parsed_msg.msgid == GLOBAL_POSITION_INT_ID then
                    if handle_global_position_int(parsed_msg) then
                        payload_update_received = true
                    end
                end
            end
        end
    until msg == nil

    -- warn user on loss of recovery of telemetry from payload
    local payload_timeout = millis() - payload_loc_update_ms > PAYLOAD_UPDATE_TIMEOUT_MS
    if payload_timeout ~= payload_update_timeout_prev then
        if payload_timeout then
            gcs:send_text(MAV_SEVERITY.WARNING, string.format("%s payload updates lost", TEXT_PREFIX_STR))
        else
            gcs:send_text(MAV_SEVERITY.INFO, string.format("%s payload updates received", TEXT_PREFIX_STR))
        end
    end
    payload_update_timeout_prev = payload_timeout

    if payload_update_received then
        -- calculate position difference vs vehicle
        payload_dist_NED = curr_loc:get_distance_NED(payload_loc)

        -- estimate the payload's resting position offset based on its current offset and velocity
        -- relies on payload_dist_NED and payload_vel being updated
        update_payload_resting_offset()
    end

    -- check if we can control the vehicle
    -- vehicle must be in Auto mode executing a SCRIPT_TIME or PAYLOAD_PLACE command
    local send_velocity_offsets_prev = send_velocity_offsets
    local armed_and_flying = arming:is_armed() and vehicle:get_likely_flying()
    local takingoff_or_landing = vehicle:is_landing() or vehicle:is_taking_off()
    local auto_mode = (vehicle:get_mode() == COPTER_MODE_AUTO)
    local scripting_or_payloadplace = (mission:get_current_nav_id() == MAV_CMD_NAV_SCRIPT_TIME) or (mission:get_current_nav_id() == MAV_CMD_NAV_PAYLOAD_PLACE)
    send_velocity_offsets = armed_and_flying and not takingoff_or_landing and auto_mode and scripting_or_payloadplace and not payload_timeout

    -- alert user if we start or stop sending velocity offsets
    if (send_velocity_offsets and not send_velocity_offsets_prev) then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("%s activated", TEXT_PREFIX_STR))
    end
    if (not send_velocity_offsets and send_velocity_offsets_prev) then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("%s deactivated", TEXT_PREFIX_STR))
        poscontrol:set_posvelaccel_offset(Vector3f(), Vector3f(), Vector3f())
    end

    -- move vehicle to reduce payload oscillation
    if send_velocity_offsets then
        move_vehicle()

        -- check for unexpected control timeout
        -- reset vehicle offsets if not sent within last 3 seconds
        local now_ms = millis()
        local time_since_vel_offset_sent = now_ms - sent_velocity_offsets_ms
        local time_since_last_control_timeout = now_ms - control_timeout_ms
        if (time_since_vel_offset_sent > CONTROL_TIMEOUT_MS) and (time_since_last_control_timeout > CONTROL_TIMEOUT_MS) then
            poscontrol:set_posvelaccel_offset(Vector3f(), Vector3f(), Vector3f())
            control_timeout_ms = now_ms
            print_warning("control timeout, clearing offsets")
        end
    end

    return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: applets/copter-slung-payload.md
================================================
# Slung Payload

This script moves a Copter so as to reduce a slung payload's oscillation.  Requires the payload be capable of sending its position and velocity to the main vehicle

# Parameters

- SLUP_ENABLE : Set to 1 to enable this script
- SLUP_VEL_P : Oscillation controller velocity P gain.  Higher values will result in the vehicle moving more quickly in sync with the payload
- SLUP_DIST_MAX : maximum acceptable distance between vehicle and payload.  Within this distance oscillation suppression will operate
- SLUP_SYSID : System id of payload's autopilot.  If zero any system id is accepted
- SLUP_WP_POS_P : Return to waypoint position P gain.  Higher values result in the vehicle returning more quickly to the latest waypoint
- SLUP_RESTOFS_TC : Slung Payload resting offset estimate filter time constant.  Higher values result in smoother estimate but slower response
- SLUP_DEBUG : Slung payload debug output, set to 1 to enable debug

# How To Use

1. mount an autopilot on the payload connected to the main vehicle using telemetry
2. ensure the vehicle and payload autopilots have unique system ids
3. copy this script to the vehicle autopilot's "scripts" directory
4. within the "scripts" directory create a "modules" directory
5. copy the MAVLink/mavlink_msgs_xxx files to the "scripts" directory

# How It Works

The script's algorithm is implemented as follows

1. Consume GLOBAL_POSITION_INT messages from the payload
2. Calculate the payload's position vs the vehicle position
3. Use a P controller to move the vehicle towards the payload to reduce oscillation
4. Simultaneously the vehicle moves back towards the original location.  The speed depends upon the SLUP_WP_POS_P parameter



================================================
File: applets/copter_box_pattern.lua
================================================
--[[
  Fly a box pattern of a configurable size.
  The pattern is initiated when a RC switch is moved high.
  The vehicle must be in Loiter or Guided mode.
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 103  -- Unique key for this script's parameters
local PARAM_TABLE_PREFIX = "BOX_"

assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'copter_box_pattern: could not add param table')

--[[
  // @Param: BOX_ENABLE
  // @DisplayName: Box Pattern Enable
  // @Description: Enable the box pattern script.
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local BOX_ENABLE = assert(param:add_param(PARAM_TABLE_KEY, 1, 'ENABLE', 1), 'could not add BOX_ENABLE param')

--[[
  // @Param: BOX_SIZE
  // @DisplayName: Box Pattern Size
  // @Description: The size of one side of the box in meters.
  // @Units: m
  // @Range: 5 100
  // @User: Standard
--]]
local BOX_SIZE = assert(param:add_param(PARAM_TABLE_KEY, 2, 'SIZE', 20), 'could not add BOX_SIZE param')

--[[
  // @Param: BOX_SPEED
  // @DisplayName: Box Pattern Speed
  // @Description: The speed at which to fly the pattern in meters/second. 0 means use WPNAV_SPEED.
  // @Units: m/s
  // @Range: 0 20
  // @User: Standard
--]]
local BOX_SPEED = assert(param:add_param(PARAM_TABLE_KEY, 3, 'SPEED', 0), 'could not add BOX_SPEED param')


local SCRIPTING_AUX_FUNC = 300 -- Corresponds to "Scripting1"

local PATTERN_STATE = {
    INACTIVE = 0,
    STARTING = 1,
    LEG_1 = 2, -- North
    LEG_2 = 3, -- East
    LEG_3 = 4, -- South
    LEG_4 = 5, -- West
    RETURNING = 6,
    DONE = 7,
}

local pattern_state = PATTERN_STATE.INACTIVE
local start_location = nil
local leg_start_location = nil

-- check preconditions for running the pattern
function can_run()
    if not arming:is_armed() or not vehicle:get_likely_flying() then
        return false, "Disarmed or not flying"
    end
    local mode = vehicle:get_mode()
    if mode ~= 5 and mode ~= 4 then -- 5=Loiter, 4=Guided
        return false, "Requires Loiter or Guided mode"
    end
    if not ahrs:get_position() then
        return false, "Position not available"
    end
    return true
end

-- function to set the target location
function set_target(target_loc)
    if vehicle:get_mode() ~= 4 then -- Guided
        vehicle:set_mode(4)
    end
    -- set speed if specified
    local speed = BOX_SPEED:get()
    if speed > 0 then
        vehicle:set_desired_speed(speed)
    end
    vehicle:set_target_location(target_loc)
end

function update()
    if BOX_ENABLE:get() == 0 then
        pattern_state = PATTERN_STATE.INACTIVE
        return update, 1000  -- check again in a second
    end

    local switch_pos = rc:get_aux_cached(SCRIPTING_AUX_FUNC)

    if switch_pos == 2 and pattern_state == PATTERN_STATE.INACTIVE then -- High position
        local ok, reason = can_run()
        if ok then
            gcs:send_text(MAV_SEVERITY.INFO, "Box Pattern: Starting")
            pattern_state = PATTERN_STATE.STARTING
            start_location = ahrs:get_location()
            leg_start_location = start_location:copy()
        else
            gcs:send_text(MAV_SEVERITY.WARNING, "Box Pattern: Cannot start: " .. reason)
            return update, 500
        end
    elseif switch_pos ~= 2 and pattern_state ~= PATTERN_STATE.INACTIVE then
        gcs:send_text(MAV_SEVERITY.INFO, "Box Pattern: Deactivated by switch")
        pattern_state = PATTERN_STATE.INACTIVE
        start_location = nil
        leg_start_location = nil
        if vehicle:get_mode() == 4 then -- Guided
             vehicle:set_mode(5) -- Loiter
        end
        return update, 500
    end

    if pattern_state == PATTERN_STATE.INACTIVE then
        return update, 200
    end

    local current_pos = ahrs:get_location()
    if not current_pos then return update, 200 end

    local distance_to_target = current_pos:get_distance(leg_start_location)
    if (pattern_state > PATTERN_STATE.STARTING and distance_to_target < 2) or pattern_state == PATTERN_STATE.STARTING then
        pattern_state = pattern_state + 1
        if pattern_state > PATTERN_STATE.LEG_4 then
            pattern_state = PATTERN_STATE.DONE
        end
        leg_start_location = current_pos:copy()
        local target = start_location:copy()
        local size = BOX_SIZE:get()
        if pattern_state == PATTERN_STATE.LEG_1 then gcs:send_text(MAV_SEVERITY.INFO, "Box Leg 1"); target:offset(size, 0)
        elseif pattern_state == PATTERN_STATE.LEG_2 then gcs:send_text(MAV_SEVERITY.INFO, "Box Leg 2"); target:offset(size, size)
        elseif pattern_state == PATTERN_STATE.LEG_3 then gcs:send_text(MAV_SEVERITY.INFO, "Box Leg 3"); target:offset(0, size)
        elseif pattern_state == PATTERN_STATE.LEG_4 then gcs:send_text(MAV_SEVERITY.INFO, "Box Leg 4"); target:offset(0, 0) -- Back to start
        elseif pattern_state == PATTERN_STATE.DONE then
             gcs:send_text(MAV_SEVERITY.INFO, "Box Pattern: Complete"); pattern_state = PATTERN_STATE.INACTIVE; return update, 500
        end
        set_target(target)
    end

    return update, 200 -- reschedule
end



================================================
File: applets/copter_box_pattern.md
================================================
# Copter Box Pattern

This script allows a copter to fly a square "box" pattern of a configurable size.

## How to Use

1.  Copy the  script to the  directory on your autopilot's SD card.
2.  Enable Lua scripting by setting  to 1 and reboot the autopilot.
3.  Configure the script's parameters.
4.  Set up an RC switch to activate the script.

## Parameters

-   : Set to 1 to enable the script. Default is 1.
-   : The size of each side of the box in meters. Default is 20m.
-   : The speed (in m/s) to fly the pattern. A value of 0 will use the  parameter value. Default is 0.

## RC Switch Setup

To activate the script, you need to assign an RC switch to the "Scripting1" auxiliary function.

-   Set an  parameter to 300, where  is the RC channel number of your desired switch.
-   A 3-position switch is recommended.
    -   **LOW**: The script is inactive.
    -   **MIDDLE**: No action.
    -   **HIGH**: The box pattern will start.

## Operation

The vehicle must be in **Loiter** or **Guided** mode and flying for the script to start. When the assigned RC switch is moved to the high position, the script will take control, switch to Guided mode (if not already in it), and fly a square pattern north, then east, then south, then west, returning to the starting point. The script provides feedback to the GCS at the start of each leg of the pattern. Moving the switch out of the high position will cancel the pattern.EOF



================================================
File: applets/copter_terrain_brake.lua
================================================
--[[
script to prevent terrain impact in LOITER mode while flying copters in steep terrain
--]]

local PARAM_TABLE_KEY = 84
local PARAM_TABLE_PREFIX = "TERR_BRK_"

local MODE_LOITER = 5
local MODE_BRAKE = 17

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 14), 'could not add param table')

--[[
  // @Param: TERR_BRK_ENABLE
  // @DisplayName: terrain brake enable
  // @Description: terrain brake enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local TERR_BRK_ENABLE = bind_add_param('ENABLE', 1, 1)

--[[
  // @Param: TERR_BRK_ALT
  // @DisplayName: terrain brake altitude
  // @Description: terrain brake altitude. The altitude above the ground below which BRAKE mode will be engaged if in LOITER mode.
  // @Range: 1 100
  // @Units: m
  // @User: Standard
--]]
local TERR_BRK_ALT = bind_add_param('ALT', 2, 30)

--[[
  // @Param: TERR_BRK_HDIST
  // @DisplayName: terrain brake home distance
  // @Description: terrain brake home distance. The distance from home where the auto BRAKE will be enabled. When within this distance of home the script will not activate
  // @Range: 0 1000
  // @Units: m
  // @User: Standard
--]]
local TERR_BRK_HDIST = bind_add_param('HDIST', 3, 100)

--[[
  // @Param: TERR_BRK_SPD
  // @DisplayName: terrain brake speed threshold
  // @Description: terrain brake speed threshold. Don't trigger BRAKE if both horizontal speed and descent rate are below this threshold. By setting this to a small value this can be used to allow the user to climb up to a safe altitude in LOITER mode. A value of 0.5 is recommended if you want to use LOITER to recover from an emergency terrain BRAKE mode change.
  // @Range: 0 5
  // @Units: m/s
  // @User: Standard
--]]
local TERR_BRK_SPD = bind_add_param('SPD', 4, 0)

local function sq(x)
   return x*x
end

local function run_checks()
   if TERR_BRK_ENABLE:get() ~= 1 then
      return
   end
   if not arming:is_armed() then
      return
   end
   if vehicle:get_mode() ~= MODE_LOITER then
      return
   end

   if not ahrs:home_is_set() then
      return
   end
   local home = ahrs:get_home()
   local pos = ahrs:get_location()
   if not pos then
      return
   end
   local home_dist = pos:get_distance(home)
   if home_dist <= TERR_BRK_HDIST:get() then
      return
   end

   --[[
      get height above terrain with extrapolation
   --]]
   local hagl = terrain:height_above_terrain(true)
   if hagl >= TERR_BRK_ALT:get() then
      return
   end

   --[[
      allow for climbing in LOITER mode if enabled
   --]]
   if TERR_BRK_SPD:get() > 0 then
      local spd = ahrs:get_velocity_NED()
      if spd ~= nil then
         local hspd = math.sqrt(sq(spd:x())+sq(spd:y()))
         local drate = spd:z()
         if hspd < TERR_BRK_SPD:get() and drate < TERR_BRK_SPD:get() then
            return
         end
      end
   end

   if vehicle:set_mode(MODE_BRAKE) then
      gcs:send_text(MAV_SEVERITY.EMERGENCY, string.format("Terrain %.1fm - BRAKE", hagl))
   end
end

--[[
   main update function, called at 1Hz
--]]
function update()
   run_checks()
   return update, 100
end

if TERR_BRK_ENABLE:get() == 1 then
   gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded Loiter/Brake checker"))
end

-- start running update loop
return update, 1000




================================================
File: applets/copter_terrain_brake.md
================================================
# Copter Loiter Brake

This script implements an emergency change to BRAKE mode in copter if
you are in LOITER mode and break a terrain altitude limit. The script
is useful when flying in LOITER mode in steep terrain.

# Parameters

The script adds the following parameters to control it's behaviour.

## TERR_BRK_ENABLE

This must be set to 1 to enable the script.

## TERR_BRK_ALT

This is the terrain altitude threshold for engaging BRAKE mode. The
onboard terrain system must be enabled with TERRAIN_ENABLE=1 and
terrain must have either been preloaded to the vehicle (see
https://terrain.ardupilot.org ) or be available from the ground
station over MAVLink.

Make sure you set sufficient margin to cope with obstacles such as
trees or any local towers or other obstacles.

## TERR_BRK_HDIST

This is the distance from home for the BRAKE checking to be
enabled. The default of 100 meters is good for most operations. This
threshold allows you to take over in LOITER mode for low altitude
operations and takeoff/landing when close to home.

## TERR_BRK_SPD

This is a speed threshold BRAKE checking to be enabled. If both the
horizontal speed and the descent rate are below this threshold then
BRAKE will not be engaged. This defaults to zero which means no speed
checking is performed.

You should set this to a small value if you want to be able to recover
from BRAKE mode by climbing straight up in LOITER mode. A value of 0.5
m/s is recommended. The value needed will be dependent on the amount
of noise there is in your velocity measurement and how gusty the wind
is, but 0.5 should work in most applications.

If you set this value then to recover in LOITER mode you should raise
the throttle stick to demand climb before you switch back to LOITER
mode. The positive climb rate means BRAKE will not re-engage.

# Operation

Install the lua script in the APM/SCRIPTS directory on the flight
controllers microSD card. Review the above parameter descriptions and
decide on the right parameter values for your vehicle and operations.

Make sure TERRAIN_ENABLE is 1 and you should preload terrain data for
the flight area from https://terrain.ardupilot.org

It is strongly recommended that you set TERRAIN_SPACING=30 and preload
the SRTM1 terrain data for 30m horizontal resolution of terrain data.

When the system engages you will see a message like this
 "Terrain 29.2m - BRAKE"
where in this example you are 29.2m above the terrain.

To recover you could use GUIDED mode, or RTL (make sure you have set
RTL_ALT_TYPE to terrain) or if you have set TERR_BRK_SPD to a positive
value then you could raise the throttle stick and switch back to
LOITER mode.

If the system is continually giving false positives then set
TERR_BRK_ENABLE to zero to disable.



================================================
File: applets/crsf-calibrate.lua
================================================
--[[
-- A script to perform ArduPilot calibrations using a custom CRSF menu
-- copy this script to the autopilot's "scripts" directory
--]]

SCRIPT_NAME = "ArduPilot Calibration"
SCRIPT_NAME_SHORT = "Calibration"
SCRIPT_VERSION = "0.1"

MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
CRSF_EVENT = {PARAMETER_READ=1, PARAMETER_WRITE=2}
CRSF_PARAM_TYPE = {
    UINT8 = 0,  -- deprecated
    INT8 = 1,   -- deprecated
    UINT16 = 2, -- deprecated
    INT16 = 3,  -- deprecated
    FLOAT = 8,
    TEXT_SELECTION = 9,
    STRING = 10,
    FOLDER = 11,
    INFO = 12,
    COMMAND = 13,
}

CRSF_COMMAND_STATUS = {
    READY = 0, --               --> feedback
    START = 1, --               <-- input
    PROGRESS = 2, --            --> feedback
    CONFIRMATION_NEEDED = 3, -- --> feedback
    CONFIRM = 4, --             <-- input
    CANCEL = 5, --              <-- input
    POLL = 6 --                 <-- input
}

MAV_CMD_PREFLIGHT_CALIBRATION = 241
MAV_CMD_DO_START_MAG_CAL = 42424
MAV_CMD_DO_ACCEPT_MAG_CAL = 42425
MAV_CMD_DO_CANCEL_MAG_CAL = 42426

-- create a CRSF menu float item
function create_float_entry(name, value, min, max, default, dpoint, step, unit)
    return string.pack(">BzllllBlz", CRSF_PARAM_TYPE.FLOAT, name, value, min, max, default, dpoint, step, unit)
end

-- create a CRSF menu text selection item
function create_text_entry(name, options, value, min, max, default, unit)
    return string.pack(">BzzBBBBz", CRSF_PARAM_TYPE.TEXT_SELECTION, name, options, value, min, max, default, unit)
end

-- create a CRSF menu string item
function create_string_entry(name, value, max)
    return string.pack(">BzzB", CRSF_PARAM_TYPE.STRING, name, value, max)
end

-- create a CRSF menu info item
function create_info_entry(name, info)
    return string.pack(">Bzz", CRSF_PARAM_TYPE.INFO, name, info)
end

-- create a CRSF command entry
function create_command_entry(name, status, timeout, info)
    timeout = timeout or 10 -- 1s
    return string.pack(">BzBBz", CRSF_PARAM_TYPE.COMMAND, name, status, timeout, info)
end

local compass_command, accel_command, gyro_command, forceaccel_command, forcecompass_command, ahrs_command

local menu = crsf:add_menu('Calibrate')
local compass_param = create_command_entry("Calibrate Compass", CRSF_COMMAND_STATUS.READY, 50, "Start Calibration")
local accel_param = create_command_entry("Calibrate Accels", CRSF_COMMAND_STATUS.READY, 50, "Calibrate Accels")
local gyro_param = create_command_entry("Calibrate Gyros", CRSF_COMMAND_STATUS.READY, 50, "Calibrate Gyros")
local forceaccel_param = create_command_entry("Forcecal Accels", CRSF_COMMAND_STATUS.READY, 50, "Forcecal Accels")
local forcecompass_param = create_command_entry("Forcecal Compass", CRSF_COMMAND_STATUS.READY, 50, "Forcecal Compass")
local ahrs_param = create_command_entry("Trim AHRS", CRSF_COMMAND_STATUS.READY, 50, "Trim AHRS")

if menu ~= nil then
    compass_command = menu:add_parameter(compass_param)
    accel_command = menu:add_parameter(accel_param)
    gyro_command = menu:add_parameter(gyro_param)
    forceaccel_command = menu:add_parameter(forceaccel_param)
    forcecompass_command = menu:add_parameter(forcecompass_param)
    ahrs_command = menu:add_parameter(ahrs_param)
    gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded CRSF calibration menu"))
end

local calibration_running = false

function update()
    local param, payload, events = crsf:get_menu_event(CRSF_EVENT.PARAMETER_WRITE)
    if (events & CRSF_EVENT.PARAMETER_WRITE) ~= 0 then
        if compass_command ~= nil and param == compass_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then -- start calibration
                -- mag cal
                if calibration_running then
                    gcs:run_command_int(MAV_CMD_DO_CANCEL_MAG_CAL, { p3 = 1 })
                end
                calibration_running = true
                gcs:run_command_int(MAV_CMD_DO_START_MAG_CAL, { p3 = 1 })
                gcs:send_text(MAV_SEVERITY.INFO, "Compass calibration running")
                crsf:send_write_response(create_command_entry("Calibrate Compass", CRSF_COMMAND_STATUS.CONFIRMATION_NEEDED, 50, "Accept Calibration"))
            elseif command_action == CRSF_COMMAND_STATUS.CONFIRM then -- confirm acceptance
                gcs:run_command_int(MAV_CMD_DO_ACCEPT_MAG_CAL, { p3 = 1 })
                gcs:send_text(MAV_SEVERITY.INFO, "Compass calibration accepted")
                crsf:send_write_response(compass_param)
            elseif command_action == CRSF_COMMAND_STATUS.CANCEL and calibration_running then
                gcs:run_command_int(MAV_CMD_DO_CANCEL_MAG_CAL, { p3 = 1 })
                gcs:send_text(MAV_SEVERITY.WARNING, "Calibration cancelled")
                calibration_running = false
                crsf:send_write_response(compass_param)
            end
        elseif accel_command ~= nil and param == accel_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- accelcalsimple
                gcs:run_command_int(MAV_CMD_PREFLIGHT_CALIBRATION, { p5 = 4 })
                gcs:send_text(MAV_SEVERITY.INFO, "Accels calibrated")
                crsf:send_write_response(accel_param)
            end
        elseif gyro_command ~= nil and param == gyro_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- gyro cal
                gcs:run_command_int(MAV_CMD_PREFLIGHT_CALIBRATION, { p1 = 1 })
                gcs:send_text(MAV_SEVERITY.INFO, "Gyros calibrated")
                crsf:send_write_response(gyro_param)
            end
        elseif forceaccel_command ~= nil and param == forceaccel_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- forcecal accel
                gcs:run_command_int(MAV_CMD_PREFLIGHT_CALIBRATION, { p5 = 76 })
                gcs:send_text(MAV_SEVERITY.INFO, "Accels force calibrated")
                crsf:send_write_response(forceaccel_param)
            end
        elseif forcecompass_command ~= nil and param == forcecompass_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- forcecal compass
                gcs:run_command_int(MAV_CMD_PREFLIGHT_CALIBRATION, { p2 = 76 })
                gcs:send_text(MAV_SEVERITY.INFO, "Compass force calibrated")
                crsf:send_write_response(forcecompass_param)
            end
        elseif ahrs_command ~= nil and param == ahrs_command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- ahrs trim
                gcs:run_command_int(MAV_CMD_PREFLIGHT_CALIBRATION, { p5 = 2 })
                gcs:send_text(MAV_SEVERITY.INFO, "AHRS trimmed")
                crsf:send_write_response(ahrs_param)
            end
        end
    elseif (events & CRSF_EVENT.PARAMETER_READ) ~= 0 then
        gcs:send_text(MAV_SEVERITY.INFO, "Parameter read " .. param)
    end
    return update, 100
end

return update, 5000


================================================
File: applets/crsf-calibrate.md
================================================
# CRSF Calibration Menu

This script implements a vehicle calibration menu via CRSF parameter commands
which can be accessed from your radio transmitter via [TBS Agent Lite](https://www.team-blacksheep.com/products/prod:agentx)
You can calibrate compass, accels, gyros and trim via the menu

# Operation

Install the lua script in the APM/scripts directory on the flight
controller's microSD card. Enable scripting via SCR_ENABLE.



================================================
File: applets/figure-eight.lua
================================================
--[[
  figure_eight.lua: Fly a figure of eight pattern with a flip in each quadrant.

  This script makes the vehicle fly a figure-eight pattern. In each of the four
  quadrants of the figure eight, the vehicle performs a flip, returning to the
  same attitude and velocity it had before the flip.
--]]

-- User-configurable parameters
local RADIUS = 20       -- Radius of the circles in the figure eight (meters)
local SPEED = 10        -- Speed of the vehicle during the pattern (m/s)
local FLIP_ROLL_RATE = 360  -- Roll rate during the flip (degrees/second)
local FLIP_PITCH_RATE = 180 -- Pitch rate during the flip (degrees/second)

-- Internal state variables
local MAV_SEVERITY = {INFO = 6, WARNING = 4}
local SCRIPTING_AUX_FUNC = 300 -- RCx_OPTION for activation

local PATTERN_STATE = {
    INACTIVE = 0,
    CIRCLE_1 = 1,
    FLIP_1 = 2,
    CIRCLE_2 = 3,
    FLIP_2 = 4,
    CIRCLE_3 = 5,
    FLIP_3 = 6,
    CIRCLE_4 = 7,
    FLIP_4 = 8,
    RETURNING = 9,
}

local pattern_state = PATTERN_STATE.INACTIVE
local start_location = nil
local center_1 = nil
local center_2 = nil
local flip_start_attitude = nil
local flip_start_velocity = nil

-- Function to check if the vehicle is ready to start the pattern
function can_run()
    if not arming:is_armed() or not vehicle:get_likely_flying() then
        return false, "Disarmed or not flying"
    end
    local mode = vehicle:get_mode()
    if mode ~= 5 and mode ~= 4 then -- 5=Loiter, 4=Guided
        return false, "Requires Loiter or Guided mode"
    end
    if not ahrs:get_position() then
        return false, "Position not available"
    end
    return true
end

-- Function to set the vehicle's target location
function set_target(target_loc)
    if vehicle:get_mode() ~= 4 then -- Guided
        assert(vehicle:set_mode(4), "Failed to set mode to Guided")
    end
    assert(vehicle:set_desired_speed(SPEED), "Failed to set desired speed")
    assert(vehicle:set_target_location(target_loc), "Failed to set target location")
end

-- Function to execute a flip
function execute_flip(roll_rate, pitch_rate)
    -- Store entry attitude and velocity
    if flip_start_attitude == nil then
        flip_start_attitude = {
            roll = ahrs:get_roll_rad(),
            pitch = ahrs:get_pitch_rad(),
            yaw = ahrs:get_yaw_rad()
        }
        flip_start_velocity = ahrs:get_velocity_NED()
    end

    -- Command the flip using rate control
    assert(vehicle:set_target_rate_and_throttle(roll_rate, pitch_rate, 0, 0.5), "Failed to set target rate and throttle")

    -- Check for completion (e.g., full rotation)
    -- For simplicity, this example assumes a fixed duration for the flip
    -- A more robust implementation would monitor attitude
    -- After the flip, restore the original attitude and velocity
    -- This part is complex and requires careful management of the vehicle's state
end

-- Main update function
function update()
    local switch_pos = rc:get_aux_cached(SCRIPTING_AUX_FUNC)

    if switch_pos == 2 and pattern_state == PATTERN_STATE.INACTIVE then -- High position
        local ok, reason = can_run()
        if ok then
            gcs:send_text(MAV_SEVERITY.INFO, "Figure Eight: Starting")
            pattern_state = PATTERN_STATE.CIRCLE_1
            start_location = ahrs:get_location()
            center_1 = start_location:copy()
            center_1:offset(0, RADIUS)
            center_2 = start_location:copy()
            center_2:offset(0, -RADIUS)
            set_target(center_1) -- Start with the first circle
        else
            gcs:send_text(MAV_SEVERITY.WARNING, "Figure Eight: Cannot start: " .. reason)
        end
    elseif switch_pos ~= 2 and pattern_state ~= PATTERN_STATE.INACTIVE then
        gcs:send_text(MAV_SEVERITY.INFO, "Figure Eight: Deactivated by switch")
        pattern_state = PATTERN_STATE.INACTIVE
        start_location = nil
        if vehicle:get_mode() == 4 then -- Guided
             assert(vehicle:set_mode(5), "Failed to set mode to Loiter") -- Loiter
        end
    end

    if pattern_state == PATTERN_STATE.INACTIVE then
        return update, 200
    end

    local current_pos = ahrs:get_location()
    if not current_pos then return update, 200 end

    -- State machine for the figure-eight pattern
    if pattern_state == PATTERN_STATE.CIRCLE_1 then
        -- Fly first circle, check for quadrant change
        -- Simplified: transition after a certain time/distance
        if current_pos:get_distance(center_1) < 5 then
            pattern_state = PATTERN_STATE.FLIP_1
            flip_start_attitude = nil
        end
    elseif pattern_state == PATTERN_STATE.FLIP_1 then
        execute_flip(FLIP_ROLL_RATE, FLIP_PITCH_RATE)
        -- Simplified: assume flip takes a fixed time
        pattern_state = PATTERN_STATE.CIRCLE_2
        set_target(center_2)
    elseif pattern_state == PATTERN_STATE.CIRCLE_2 then
        if current_pos:get_distance(center_2) < 5 then
            pattern_state = PATTERN_STATE.FLIP_2
            flip_start_attitude = nil
        end
    elseif pattern_state == PATTERN_STATE.FLIP_2 then
        execute_flip(-FLIP_ROLL_RATE, -FLIP_PITCH_RATE)
        pattern_state = PATTERN_STATE.CIRCLE_3
        set_target(center_2)
    elseif pattern_state == PATTERN_STATE.CIRCLE_3 then
        if current_pos:get_distance(center_2) < 5 then
            pattern_state = PATTERN_STATE.FLIP_3
            flip_start_attitude = nil
        end
    elseif pattern_state == PATTERN_STATE.FLIP_3 then
        execute_flip(FLIP_ROLL_RATE, FLIP_PITCH_RATE)
        pattern_state = PATTERN_STATE.CIRCLE_4
        set_target(center_1)
    elseif pattern_state == PATTERN_STATE.CIRCLE_4 then
        if current_pos:get_distance(center_1) < 5 then
            pattern_state = PATTERN_STATE.FLIP_4
            flip_start_attitude = nil
        end
    elseif pattern_state == PATTERN_STATE.FLIP_4 then
        execute_flip(-FLIP_ROLL_RATE, -FLIP_PITCH_RATE)
        pattern_state = PATTERN_STATE.RETURNING
        set_target(start_location)
    elseif pattern_state == PATTERN_STATE.RETURNING then
        if current_pos:get_distance(start_location) < 5 then
            gcs:send_text(MAV_SEVERITY.INFO, "Figure Eight: Complete")
            pattern_state = PATTERN_STATE.INACTIVE
            assert(vehicle:set_mode(5), "Failed to set mode to Loiter") -- Loiter
        end
    end

    return update, 100 -- Reschedule
end

gcs:send_text(MAV_SEVERITY.INFO, "Figure Eight script loaded")
return update, 1000



================================================
File: applets/figure-eight.md
================================================



================================================
File: applets/flip_on_a_switch.lua
================================================
--[[
  flip_on_switch.lua: An applet to perform continuous flips on a switch.

  This script uses the vehicle_control module to execute a flip maneuver
  repeatedly while an RC switch is held in the high position. The drone
  will maintain altitude during the flips.
]]

local vehicle_control = require('vehicle_control')

-- Header Comment
-- This script allows a user to trigger a continuous flip maneuver on a drone
-- using a 3-position RC switch. The flip axis, rate, and duration are
-- configurable via parameters. The script ensures the drone is in a safe
-- state before starting the maneuver and maintains altitude throughout.

-- Enum for MAV_SEVERITY levels
local MAV_SEVERITY = {
    EMERGENCY = 0,
    ALERT = 1,
    CRITICAL = 2,
    ERROR = 3,
    WARNING = 4,
    NOTICE = 5,
    INFO = 6,
    DEBUG = 7
}

-- Parameters
local PARAM_TABLE_KEY = 107
local PARAM_TABLE_PREFIX = "FLIP_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 5), 'flip_on_switch: could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

local FLIP_ENABLE = bind_add_param('ENABLE', 1, 1)
local FLIP_AXIS = bind_add_param('AXIS', 2, vehicle_control.axis.ROLL)
local FLIP_RATE = bind_add_param('RATE', 3, 720)
local FLIP_DURATION = bind_add_param('DURATION', 4, 1.0)
local FLIP_THROTTLE = bind_add_param('THROTTLE', 5, 0.5)


-- RC Function Constant
local SCRIPTING_AUX_FUNC = 300 -- Corresponds to "Scripting1"

-- State variables
local flip_state = nil
local flip_active = false
local original_mode = nil

-- Precondition checks
assert(FWVersion:type() == 2, 'Script requires a Copter frame')

-- Main update function
function update()
    if FLIP_ENABLE:get() == 0 then
        return update, 1000
    end

    local switch_pos = rc:get_aux_cached(SCRIPTING_AUX_FUNC)

    if switch_pos == 2 then -- High position
        if not flip_active then
            -- Pre-flight checks
            if not arming:is_armed() or not vehicle:get_likely_flying() then
                gcs:send_text(MAV_SEVERITY.WARNING, "Flip: Vehicle must be armed and flying")
                return update, 500
            end

            original_mode = vehicle:get_mode()
            if not (original_mode == vehicle_control.mode.LOITER or original_mode == vehicle_control.mode.GUIDED) then
                gcs:send_text(MAV_SEVERITY.WARNING, "Flip: Must be in Loiter or Guided mode to start")
                original_mode = nil
                return update, 500
            end

            -- Set to Guided mode for flip execution
            if original_mode ~= vehicle_control.mode.GUIDED then
                if not vehicle:set_mode(vehicle_control.mode.GUIDED) then
                    gcs:send_text(MAV_SEVERITY.WARNING, "Flip: Failed to set Guided mode")
                    original_mode = nil
                    return update, 500
                end
            end

            -- Start a new flip
            gcs:send_text(MAV_SEVERITY.INFO, "Flip: Starting continuous flip")
            flip_active = true
            flip_state = vehicle_control.maneuver.flip_start(
                FLIP_AXIS:get(),
                FLIP_RATE:get(),
                FLIP_THROTTLE:get(),
                FLIP_DURATION:get()
            )
            if flip_state == nil then
                gcs:send_text(MAV_SEVERITY.WARNING, "Flip: Failed to start flip")
                flip_active = false
                if original_mode then
                    vehicle:set_mode(original_mode)
                    original_mode = nil
                end
            end
        elseif flip_state then
            -- Update existing flip
            local status = vehicle_control.maneuver.flip_update(flip_state)
            if status == vehicle_control.SUCCESS then
                -- Flip finished, start another one immediately
                flip_state = vehicle_control.maneuver.flip_start(
                    FLIP_AXIS:get(),
                    FLIP_RATE:get(),
                    FLIP_THROTTLE:get(),
                    FLIP_DURATION:get()
                )
                if flip_state == nil then
                    gcs:send_text(MAV_SEVERITY.WARNING, "Flip: Failed to restart flip")
                    flip_active = false
                end
            end
        end
    else -- Low or Middle position
        if flip_active then
            gcs:send_text(MAV_SEVERITY.INFO, "Flip: Stopping continuous flip")
            flip_active = false
            flip_state = nil
            -- Restore attitude by setting target rates to zero and providing a neutral hover throttle
            vehicle:set_target_rate_and_throttle(0, 0, 0, 0.5)
            -- Restore original flight mode
            if original_mode and vehicle:get_mode() ~= original_mode then
                vehicle:set_mode(original_mode)
            end
            original_mode = nil
        end
    end

    return update, 50 -- Run at 20Hz for responsiveness
end

-- Protected wrapper for error handling
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY.ERROR, "Flip Error: " .. err)
        return protected_wrapper, 1000 -- Reschedule with a longer delay after an error
    end
    return protected_wrapper, 50
end

gcs:send_text(MAV_SEVERITY.INFO, "Flip on switch script loaded")
return protected_wrapper, 1000



================================================
File: applets/flip_on_a_switch.md
================================================
# **Flip On Switch**

This applet allows a drone to perform continuous flips while an RC switch is held in the high position. It utilizes the vehicle\_control.lua module for the flip maneuver logic.

## **How to Use**

1. Ensure vehicle\_control.lua is present in the APM/scripts/ directory on your autopilot's SD card.  
2. Copy the flip\_on\_switch.lua script to the APM/scripts/ directory.  
3. Enable Lua scripting by setting SCR\_ENABLE to 1 and reboot the autopilot.  
4. Configure the script's parameters.  
5. Set up an RC switch to activate the script.

## **Parameters**

* FLIP\_ENABLE: Set to 1 to enable the script. Default is 1\.  
* FLIP\_AXIS: The axis for the flip. 1 for Roll, 2 for Pitch. Default is 1 (Roll).  
* FLIP\_RATE: The rotation rate for the flip in degrees per second. Default is 720\.  
* FLIP\_DURATION: The duration of a single 360-degree flip in seconds. Default is 1.0.  
* FLIP\_THROTTLE: The throttle level to use during the flip (0-1). Default is 0.5.

## **RC Switch Setup**

To activate the script, you need to assign an RC switch to the "Scripting1" auxiliary function.

* Set an RCx\_OPTION parameter to 300, where x is the RC channel number of your desired 3-position switch.  
  * **LOW/MIDDLE**: The script is inactive. The drone will stop flipping.  
  * **HIGH**: The drone will continuously flip until the switch is moved.

## **Operation**

The vehicle must be in a VTOL mode (like Loiter or Guided) and flying for the script to start. When the assigned RC switch is moved to the high position, the script will take control and initiate the flip sequence. The drone will continue to flip as long as the switch is held high. Releasing the switch will stop the flips and the drone will recover to a level attitude. The script is designed to maintain the drone's altitude during the maneuver.


================================================
File: applets/follow-target-send.lua
================================================
-- Send the FOLLOW_TARGET mavlink message to allow other vehicles to follow this one
--
-- How To Use
-- 1. copy this script to the autopilot's "scripts" directory
-- 2. within the "scripts" directory create a "modules" directory
-- 3. copy the MAVLink/mavlink_msgs_xxx files to the "scripts" directory
-- 4. the FOLLOW_TARGET message will be published at 10hz

-- load mavlink message definitions from modules/MAVLink directory
local mavlink_msgs = require("MAVLink/mavlink_msgs")

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local UPDATE_INTERVAL_MS = 100                  -- update at about 10hz
local FOLLOW_TARGET_CAPABILITIES = {POS=2^0, VEL=2^1, ACCEL=2^2, ATT_RATES=2^3}

 -- setup script specific parameters
local PARAM_TABLE_KEY = 88
local PARAM_TABLE_PREFIX = "FOLT_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', PARAM_TABLE_PREFIX .. name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

--[[
  // @Param: FOLT_ENABLE
  // @DisplayName: Follow Target Send Enable
  // @Description: Follow Target Send Enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local FOLT_ENABLE = bind_add_param("ENABLE", 1, 1)

--[[
  // @Param: FOLT_MAV_CHAN
  // @DisplayName: Follow Target Send MAVLink Channel
  // @Description: MAVLink channel to which FOLLOW_TARGET should be sent
  // @Range: 0 10
  // @User: Standard
--]]
local FOLT_MAV_CHAN = bind_add_param("MAV_CHAN", 2, 0)

-- send FOLLOW_TARGET message
local function send_follow_target_msg()

    -- get vehicle location
    local curr_loc = ahrs:get_location()
    if curr_loc == nil then
        do return end
    end
    local capabilities = FOLLOW_TARGET_CAPABILITIES.POS

    -- get vehicle target velocity in m/s in NED frame
    local vel_target_NED = poscontrol:get_vel_target()
    if vel_target_NED ~= nil then
        capabilities = capabilities + FOLLOW_TARGET_CAPABILITIES.VEL
    else
        vel_target_NED = Vector3f()
    end

    -- get vehicle target acceleration in m/s/s in NED frame
    local accel_target_NED = poscontrol:get_accel_target()
    if accel_target_NED ~= nil then
        capabilities = capabilities + FOLLOW_TARGET_CAPABILITIES.ACCEL
    else
        accel_target_NED = Vector3f()
    end

    -- get vehicle current attitude as quaternion and rates
    local attitude_quat = ahrs:get_quaternion()
    local curr_rot_rate = ahrs:get_gyro()
    if attitude_quat ~= nil and curr_rot_rate ~= nil then
        capabilities = capabilities + FOLLOW_TARGET_CAPABILITIES.ATT_RATES
    else
        attitude_quat = Quaternion()
        curr_rot_rate = Vector3f()
    end
    local curr_rot_rate_NED = ahrs:body_to_earth(curr_rot_rate)

    -- prepare FOLLOW_TARGET message
    local follow_target_msg = {}
    follow_target_msg.timestamp = millis():toint()
    follow_target_msg.est_capabilities = capabilities
    follow_target_msg.lat = curr_loc:lat()
    follow_target_msg.lon = curr_loc:lng()
    follow_target_msg.alt = curr_loc:alt() * 0.01
    follow_target_msg.vel = {vel_target_NED:x(), vel_target_NED:y(), vel_target_NED:z()}
    follow_target_msg.acc = {accel_target_NED:x(), accel_target_NED:y(), accel_target_NED:z()}
    follow_target_msg.attitude_q = {attitude_quat:q1(), attitude_quat:q2(), attitude_quat:q3(), attitude_quat:q4()}
    follow_target_msg.rates = {curr_rot_rate_NED:x(), curr_rot_rate_NED:y(), curr_rot_rate_NED:z()}
    follow_target_msg.position_cov = {0, 0, 0}
    follow_target_msg.custom_state = 0

    -- send FOLLOW_TARGET message
    mavlink:send_chan(FOLT_MAV_CHAN:get(), mavlink_msgs.encode("FOLLOW_TARGET", follow_target_msg))
end

-- display welcome message
gcs:send_text(MAV_SEVERITY.INFO, "follow-target-send script loaded")

-- update function to receive location from payload and move vehicle to reduce payload's oscillation
local function update()

    -- exit immediately if not enabled
    if (FOLT_ENABLE:get() <= 0) then
        return update, 1000
    end

    -- send FOLLOW_TARGET message
    send_follow_target_msg()

    return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: applets/follow-target-send.md
================================================
# Follow Target Send

Sends the FOLLOW_TARGET mavlink message to allow other vehicles to follow this one

# Parameters

- FOLT_ENABLE : Set to 1 to enable this script
- FOLT_MAV_CHAN : MAVLink channel to which FOLLOW_TARGET should be sent

# How To Use

1. copy this script to the autopilot's "scripts" directory
2. within the "scripts" directory create a "modules" directory
3. copy the MAVLink/mavlink_msgs_xxx files to the "scripts" directory
4. the FOLLOW_TARGET message will be published at 10hz



================================================
File: applets/forward_flight_motor_shutdown.lua
================================================
-- This is a script that stops motors in forward flight, for use on tiltrotors and tailsitters
-- Thanks to PteroDynamics for supporting the development of this script
-- Set the motor numbers to stop and configure a RCx_OPTION to 300 to enable and disable
-- Throttle thresholds also allow automatic enable and disable of stop motors
-- slew up and down times allow to configure how fast the motors are disabled and re-enabled



-- Config

-- Motors numbers to stop
local stop_motors = {2,4}

-- motors should be shutdown if throttle goes lower than this value (%), set to > 100 to disable auto enable/disable
local throttle_off_threshold = 50

-- motors should be re-enabled if throttle higher than this value (%)
local throttle_on_threshold = 75

local slew_down_time = 5 -- seconds
local slew_up_time = 1 -- seconds

-- end of config

local switch = assert(rc:find_channel_for_option(300),"Lua: Could not find switch")

-- read spin min param, we set motors to this PWM to stop them
local pwm_min = assert(param:get("Q_M_PWM_MIN"),"Lua: Could not read Q_M_PWM_MIN")
local pwm_max = assert(param:get("Q_M_PWM_MAX"),"Lua: Could not read Q_M_PWM_MAX")

-- calculate the slew up and down steps to achieve the given slew time
local pwm_range = pwm_max - pwm_min
local slew_down = (-pwm_range / slew_down_time) * (10/1000)
local slew_up = (pwm_range / slew_up_time) * (10/1000)

if throttle_off_threshold < 100 then
  assert((throttle_off_threshold < throttle_on_threshold) and (throttle_on_threshold < 100), "throttle on and off thresholds not configured correctly")
end

for i = 1, #stop_motors do
  -- Check for a valid motor number
  assert(stop_motors[i] >= 1 and stop_motors[i] <= 12, string.format("Lua: motor %i not valid",stop_motors[i]))
end

-- find any motors enabled, populate channels to stop and channels to run
-- run channels provide a average motor PWM to slew down from
local stop_motor_chan = {}
local run_motor_fun = {}
for i = 1, 12 do

  local output_function
  if i <= 8 then
    output_function = i+32
  else
    output_function = i+81-8
  end

  local temp_chan = SRV_Channels:find_channel(output_function)

  local should_stop = false
  for j = 1, #stop_motors do
    if i == stop_motors[j] then
      should_stop = true
      break
    end
  end

  if should_stop then
    assert(temp_chan, string.format("Lua: Could not find motor %i",i))
    table.insert(stop_motor_chan, temp_chan)
  elseif temp_chan then
    table.insert(run_motor_fun, output_function)
  end
end
assert(#stop_motor_chan == #stop_motors, "Lua: could not find all motors to stop")
assert(#run_motor_fun > 0, "Lua: cannot stop all motors")

-- keep track of last time in a VTOL mode, this allows to delay switching after a transition/assist
local last_vtol_active = uint32_t(0)

-- current action
local script_enabled = false
local motors_disabled = false
local slew
local slew_pwm
function update()

  if switch:get_aux_switch_pos() == 2 then
    if not script_enabled then
      gcs:send_text(0, "Lua: Forward flight motor shutdown enabled")
    end
    script_enabled = true
  else
    if script_enabled then
      gcs:send_text(0, "Lua: Forward flight motor shutdown disabled")
    end
    script_enabled = false
  end

  if quadplane:in_vtol_mode() or quadplane:in_assisted_flight() or not arming:is_armed() then
    -- in a VTOL mode, nothing to do
    last_vtol_active = millis()
    motors_disabled = false
    return update, 1000 -- reschedule at 1hz
  end

  -- script not enabled
  if not script_enabled then
    motors_disabled = false
    return update, 1000 -- reschedule at 1hz
  end

  -- in forward flight and enabled with switch, if armed then check that we are at least 10s past transition
  if (millis() - last_vtol_active) < 10000 then
    -- armed and have not been in a VTOL mode for longer than 10s
    motors_disabled = false
    return update, 1000 -- reschedule at 10hz
  end

  -- check throttle level to see if motors should be disabled or enabled
  local throttle = SRV_Channels:get_output_scaled(70)

  if motors_disabled and (throttle > throttle_on_threshold) then
    gcs:send_text(0, "Lua: Throttle high motors enabled")
    slew = slew_up

  elseif (not motors_disabled) and (throttle < throttle_off_threshold) then
    slew_pwm = pwm_max
    motors_disabled = true
    gcs:send_text(0, "Lua: Throttle low motors disabled")
    slew = slew_down
  end

  if not motors_disabled then
    return update, 10
  end

  local average_pwm = 0
  for i = 1, #run_motor_fun do
    average_pwm = average_pwm + SRV_Channels:get_output_pwm(run_motor_fun[i])
  end
  average_pwm = average_pwm / #run_motor_fun

  slew_pwm = slew_pwm + slew
  if (slew > 0) and (slew_pwm > average_pwm) then
    -- slewed back up past the output of other motors, stop overriding
    motors_disabled = false
    slew_pwm = pwm_max
    return update, 1000
  end

  -- never slew lower than min
  slew_pwm = math.max(slew_pwm, pwm_min)

  -- never output higher than other motors
  local output_pwm = math.min(slew_pwm, average_pwm)

  -- make sure a integer
  output_pwm = math.floor(output_pwm + 0.5)

  for i = 1, #stop_motor_chan do
    -- override for 15ms, should be called every 10ms when active
    -- using timeout means if the script dies the timeout will expire and all motors will come back
    -- we cant leave the vehicle in a un-flyable state
    SRV_Channels:set_output_pwm_chan_timeout(stop_motor_chan[i],output_pwm,15)
  end

  return update, 10 -- reschedule at 100hz
end

return update() -- run immediately before starting to reschedule



================================================
File: applets/forward_flight_motor_shutdown.md
================================================
# Forward flight motor shutdown script for tailsitters and tiltrotors

This allows to shutdown selected motors to be stopped once in forward flight for efficiency.

Set the motors to shutdown in with the `stop_motors` variable. Enable and disable the functionality with a RC switch with options 300 (Scripting1).

Motors will automatically be shutdown if forward throttle is lower than the value set in `throttle_off_threshold` (50% by default) the motors will then be re-enabled if the throttle goes above the value set in `throttle_on_threshold` (75% by default).

Time for stopped motors to go from throttle value to 0 and 0 back to throttle can be set with `slew_down_time` and `slew_up_time`.



================================================
File: applets/leds_on_a_switch.lua
================================================
-- leds_on_a_switch.lua: control led brightness with a radio switch
--

---@diagnostic disable: cast-local-type

-- constants
local AuxSwitchPos = {LOW=0, MIDDLE=1, HIGH=2}
local NTF_LED_BRIGHT = Parameter("NTF_LED_BRIGHT")
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- state
local prev_pos = -1

function update()
    local sw_pos = rc:get_aux_cached(300)
    if sw_pos ~= prev_pos then
        if sw_pos == AuxSwitchPos.LOW then
            NTF_LED_BRIGHT:set(0)
            gcs:send_text(MAV_SEVERITY.INFO, "LEDs turned OFF")
        elseif sw_pos == AuxSwitchPos.MIDDLE then
            NTF_LED_BRIGHT:set(1)
            gcs:send_text(MAV_SEVERITY.INFO, "LEDs dimmed")
        else
            NTF_LED_BRIGHT:set(3)
            gcs:send_text(MAV_SEVERITY.INFO, "LEDs turned ON")
        end
        prev_pos = sw_pos
    end
    return update, 1000
end

return update, 5000



================================================
File: applets/leds_on_a_switch.md
================================================
# `leds_on_a_switch.lua`: change LED brightness using an RC switch

ArduPilot controls LED brightness via the parameter `NTF_LED_BRIGHT`. This script allows you to control the value of the parameter using an RC switch.

Configure an `RCx_OPTION` as 300 for scripting and load this script.
The low position will turn off the LEDs, the high position with give maximum brightness and the middle position will dim the LEDs


================================================
File: applets/motor_failure_test.lua
================================================
-- This is a script that stops motors in flight, for use testing motor failure handling

-- add new param MOT_STOP_BITMASK
local PARAM_TABLE_KEY = 75
assert(param:add_table(PARAM_TABLE_KEY, "MOT_", 1), "could not add param table")
assert(param:add_param(PARAM_TABLE_KEY, 1, "STOP_BITMASK", 0), "could not add param")

local stop_motor_bitmask = Parameter()
assert(stop_motor_bitmask:init("MOT_STOP_BITMASK"), "could not find param")

-- find rc switch with option 300
local switch = assert(rc:find_channel_for_option(300),"Lua: Could not find switch")

-- read spin min param, we set motors to this PWM to stop them
local pwm_min
if quadplane then
  pwm_min = assert(param:get("Q_M_PWM_MIN"),"Lua: Could not read Q_M_PWM_MIN")
else
  pwm_min = assert(param:get("MOT_PWM_MIN"),"Lua: Could not read MOT_PWM_MIN")
end

local stop_motor_chan
local last_motor_bitmask

-- find any motors enabled, populate channels numbers to stop
local function update_stop_motors(new_bitmask)
  if last_motor_bitmask == new_bitmask then
    return
  end
  stop_motor_chan = {}
  for i = 1, 12 do
    if ((1 << (i-1)) & new_bitmask) ~= 0 then
      -- convert motor number to output function number
      local output_function
      if i <= 8 then
        output_function = i+32
      else
        output_function = i+81-8
      end

      -- get channel number for output function
      local temp_chan = SRV_Channels:find_channel(output_function)
      if temp_chan then
        table.insert(stop_motor_chan, temp_chan)
      end
    end
  end
  last_motor_bitmask = new_bitmask
end

function update()

  update_stop_motors(stop_motor_bitmask:get())

  if switch:get_aux_switch_pos() == 2 then
    for i = 1, #stop_motor_chan do
      -- override for 15ms, called every 10ms
      -- using timeout means if the script dies the timeout will expire and all motors will come back
      -- we cant leave the vehicle in a un-flyable state
      SRV_Channels:set_output_pwm_chan_timeout(stop_motor_chan[i],pwm_min,15)
    end
  end

  return update, 10 -- reschedule at 100hz
end

return update() -- run immediately before starting to reschedule



================================================
File: applets/motor_failure_test.md
================================================
# Motor Failure testing Lua script

This script allows testing failure of motors on copter and quadplane (VTOL only). Vehicles with eight or more motors should be able to fly easily with a single failed motor. Hexacopters can also cope with motor failure if they have sufficient thrust.

Motor failure is triggered by a RC switch configured to option 300 (Scripting1). Switch low all motors will run, switch high will stop motors.

Configure which motors stop with the param MOT_STOP_BITMASK, this is added by the script so will only show up once the script is loaded on the SD card. The parameters is a bitmask of motors to stop. A value of 1 will stop motor 1, value of 2 stop motor 2, a value of 3 stops both motors 1 and 2.



================================================
File: applets/mount-poi.lua
================================================
-- mount-poi.lua: finds the point-of-interest that the gimbal mount is pointing at using the vehicle's current Location, mount attitude and terrain database
--
-- How To Use
--   1. Set RCx_OPTION to 300 or 301 to enable triggering the POI calculation from an auxiliary switch.  If 301 is used the gimbal will also lock onto the location
--   2. optionally set POI_DIST_MAX to the maximum distance (in meters) that the POI point could be from the vehicle
--   3. fly the vehicle and point the camera gimbal at a point on the ground
--   4. raise the RC auxiliary switch and check the GCS's messages tab for the latitude, longitude and alt (above sea-level)
--
-- How It Works
--   1. retrieve the POI_DIST_MAX and TERRAIN_SPACING param values
--   2. get the vehicle Location (lat, lon, height above sea-level), initialise test-loc and prev-test-loc
--   3. get the vehicle's current alt-above-terrain
--   4. get gimbal attitude (only pitch and yaw are used)
--   5. "test_loc" is initialised to the vehicle's location
--   6. "prev_test_loc" is a backup of test_loc
--   7. test_loc is moved along the line defined by the gimbal's pitch and yaw by TERRAIN_SPACING (meters)
--   8. retrieve the terrain's altitude (above sea-level) at the test_loc
--   9. repeat step 6, 7 and 8 until the test_loc's altitude falls below the terrain altitude
--  10. interpolate between test_loc and prev_test_loc to find the lat, lon, alt (above sea-level) where alt-above-terrain is zero
--  11. display the POI to the user

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type
---@diagnostic disable: missing-parameter

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local ALT_FRAME_ABSOLUTE = 0
local UPDATE_INTERVAL_MS = 100

-- add new param POI_DIST_MAX
local PARAM_TABLE_KEY = 78
assert(param:add_table(PARAM_TABLE_KEY, "POI_", 1), "could not add param table")
assert(param:add_param(PARAM_TABLE_KEY, 1, "DIST_MAX", 10000), "could not add POI_DIST_MAX param")

--[[
  // @Param: POI_DIST_MAX
  // @DisplayName: Mount POI distance max
  // @Description: POI's max distance (in meters) from the vehicle
  // @Range: 0 10000
  // @User: Standard
--]]
local POI_DIST_MAX = Parameter("POI_DIST_MAX")

-- bind to other parameters this script depends upon
TERRAIN_SPACING = Parameter("TERRAIN_SPACING")

-- local variables and definitions
local last_poi_switch_pos = 0           -- last known rc poi switch position.  Used to detect change in RC switch position
local last_roi_switch_pos = 0           -- last known rc roi switch position.  Used to detect change in RC switch position
local success_count = 0                 -- count of the number of POI calculations (sent to GCS in CAMERA_FEEDBACK message)

-- mavlink message definition
local messages = {}
messages[180] = { -- CAMERA_FEEDBACK
             { "time_usec", "<I8" },
             { "lat", "<i4" },
             { "lng", "<i4" },
             { "alt_msl", "<f" },
             { "alt_rel", "<f" },
             { "roll", "<f" },
             { "pitch", "<f" },
             { "yaw", "<f" },
             { "foc_len", "<f" },
             { "img_idx", "<I2" },
             { "target_system", "<B" },
             { "cam_idx", "<B" },
             { "flags", "<B" },
             { "completed_captures", "<I2" },
             }

function encode(msgid, message, messages_array)
  local message_map = messages_array[msgid]
  if not message_map then
    -- we don't know how to encode this message, bail on it
    error("Unknown MAVLink message " .. msgid)
  end

  local packString = "<"
  local packedTable = {}                  
  local packedIndex = 1
  for i,v in ipairs(message_map) do
    if v[3] then
      packString = (packString .. string.rep(string.sub(v[2], 2), v[3]))
      for j = 1, v[3] do
        packedTable[packedIndex] = message[message_map[i][1]][j]
        packedIndex = packedIndex + 1
      end
    else
      packString = (packString .. string.sub(v[2], 2))
      packedTable[packedIndex] = message[message_map[i][1]]
      packedIndex = packedIndex + 1
    end
  end

  return string.pack(packString, table.unpack(packedTable))
end

-- send CAMERA_FEEDBACK message to GCS
function send_camera_feedback(lat_degE7, lon_degE7, alt_msl_m, alt_rel_m, roll_deg, pitch_deg, yaw_deg, foc_len_mm, feedback_flags, captures_count)
  -- prepare camera feedback msg
  local camera_feedback_msg = {
      time_usec = micros():toint(),
      target_system = 0,
      cam_idx = 0,
      img_idx = 1,
      lat = lat_degE7,
      lng = lon_degE7,
      alt_msl = alt_msl_m,
      alt_rel = alt_rel_m,
      roll = roll_deg,
      pitch = pitch_deg,
      yaw = yaw_deg,
      foc_len = foc_len_mm,
      flags = feedback_flags,
      completed_captures = captures_count
  }

  -- send camera feedback msg
  local encoded_msg = encode(180, camera_feedback_msg, messages)
  mavlink.send_chan(0, 180, encoded_msg)
  mavlink.send_chan(1, 180, encoded_msg)
end

-- helper functions
function wrap_360(angle_deg)
  local res = math.fmod(angle_deg, 360.0)
  if res < 0 then
    res = res + 360.0
  end
  return res
end

function wrap_180(angle_deg)
  local res = wrap_360(angle_deg)
  if res > 180 then
    res = res - 360
  end
  return res
end

function swap_float(f1, f2)
  return f2, f1
end

function interpolate(low_output, high_output, var_value, var_low, var_high)
  -- support either polarity
  if (var_low > var_high) then
    var_low, var_high = swap_float(var_low, var_high)
    low_output, high_output = swap_float(low_output, high_output)
  end
  if (var_value <= var_low) then
    return low_output
  end
  if (var_value > var_high) then
    return high_output
  end
  local p = (var_value - var_low) / (var_high - var_low)
  return (low_output + p * (high_output - low_output))
end

gcs:send_text(MAV_SEVERITY.INFO, "Mount-poi script started")

-- the main update function called at 10hz
function update()

  -- check if user has raised POI switch
  local poi_switch_pos = rc:get_aux_cached(300) -- scripting ch 1 (drop icon on map where mount is pointing)
  local poi_switch_pulled_high = (poi_switch_pos ~= nil) and (poi_switch_pos ~= last_poi_switch_pos) and (poi_switch_pos == 2)
  last_poi_switch_pos = poi_switch_pos

  -- check if user has raised ROI switch
  local roi_switch_pos = rc:get_aux_cached(301) -- scripting ch 2 (drop icon and lock mount on location)
  local roi_switch_pulled_high = (roi_switch_pos ~= nil) and (roi_switch_pos ~= last_roi_switch_pos) and (roi_switch_pos == 2)
  last_roi_switch_pos = roi_switch_pos
  
  -- return if neither switch was pulled high
  if not poi_switch_pulled_high and not roi_switch_pulled_high then
    return update, UPDATE_INTERVAL_MS
  end

  -- POI or ROI has been requested

  -- retrieve vehicle location
  local vehicle_loc = ahrs:get_location()
  if vehicle_loc == nil then
    gcs:send_text(MAV_SEVERITY.ERROR, "POI: vehicle pos unavailable")
    return update, UPDATE_INTERVAL_MS
  end
  
  -- change vehicle location to ASML
  vehicle_loc:change_alt_frame(ALT_FRAME_ABSOLUTE)

  -- retrieve gimbal attitude
  local _, pitch_deg, yaw_bf_deg = mount:get_attitude_euler(0)
  if pitch_deg == nil or yaw_bf_deg == nil then
    gcs:send_text(MAV_SEVERITY.ERROR, "POI: gimbal attitude unavailable")
    return update, UPDATE_INTERVAL_MS
  end

  -- project forward from vehicle looking for terrain
  -- start testing at vehicle's location
  local test_loc = vehicle_loc:copy()
  local prev_test_loc = test_loc:copy()

  -- get terrain altitude (asml) at test_loc
  local terrain_amsl_m = terrain:height_amsl(test_loc, true)  -- terrain alt (above amsl) at test_loc
  local prev_terrain_amsl_m = terrain_amsl_m    -- terrain alt (above amsl) at prev_test_loc

  -- fail if terrain alt cannot be retrieved
  if terrain_amsl_m == nil then
    gcs:send_text(MAV_SEVERITY.ERROR, "POI: failed to get terrain alt")
    return update, UPDATE_INTERVAL_MS
  end

  -- get gimbal mount's pitch and yaw
  local mount_pitch_deg = pitch_deg
  local mount_yaw_ef_deg = wrap_180(yaw_bf_deg + math.deg(ahrs:get_yaw_rad()))
  local dist_increment_m = TERRAIN_SPACING:get()

  -- initialise total distance test_loc has moved
  local total_dist = 0
  local dist_max = POI_DIST_MAX:get()

  -- iteratively move test_loc forward until its alt-above-sea-level is below terrain-alt-above-sea-level
  while (total_dist < dist_max) and ((test_loc:alt() * 0.01) > terrain_amsl_m) do
    total_dist = total_dist + dist_increment_m

    -- take backup of previous test location and terrain asml
    prev_test_loc = test_loc:copy()
    prev_terrain_amsl_m = terrain_amsl_m

    -- move test location forward
    test_loc:offset_bearing_and_pitch(mount_yaw_ef_deg, mount_pitch_deg, dist_increment_m)

    -- get terrain's alt-above-sea-level (at test_loc)
    terrain_amsl_m = terrain:height_amsl(test_loc, true)

    -- fail if terrain alt cannot be retrieved
    if terrain_amsl_m == nil then
      gcs:send_text(MAV_SEVERITY.ERROR, "POI: failed to get terrain alt")
      return update, UPDATE_INTERVAL_MS
    end
  end

  -- check for errors
  if (total_dist >= dist_max) then
    gcs:send_text(MAV_SEVERITY.ERROR, "POI: unable to find terrain within " .. tostring(dist_max) .. " m")
  elseif not terrain_amsl_m then
    gcs:send_text(MAV_SEVERITY.ERROR, "POI: failed to retrieve terrain alt")
  else
    -- test location has dropped below terrain
    -- interpolate along line between prev_test_loc and test_loc
    local dist_interp_m = interpolate(0, dist_increment_m, 0, prev_test_loc:alt() * 0.01 - prev_terrain_amsl_m, test_loc:alt() * 0.01 - terrain_amsl_m)
    local poi_loc = prev_test_loc:copy()
    poi_loc:offset_bearing_and_pitch(mount_yaw_ef_deg, mount_pitch_deg, dist_interp_m)
    gcs:send_text(MAV_SEVERITY.INFO, string.format("POI %.7f, %.7f, %.2f (asml)", poi_loc:lat()/10000000.0, poi_loc:lng()/10000000.0, poi_loc:alt() * 0.01))

    -- if ROI requested then also lock gimbal to location
    if roi_switch_pulled_high then
      mount:set_roi_target(0, poi_loc)
    end

    -- send feedback to GCS so it can display icon on map
    success_count = success_count + 1
    send_camera_feedback(poi_loc:lat(), poi_loc:lng(), poi_loc:alt(), poi_loc:alt(), 0, 0, 0, 0, 0, success_count)
  end

  return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: applets/mount-poi.md
================================================
# Mount POI

This script displays the location (lat, lon and altitude) that the gimbal is currently pointing towards

# Parameters

POI_DIST_MAX : POI's max distance (in meters) from the vehicle

# How To Use

1. Set RCx_OPTION to 300 or 301 to enable triggering the POI calculation from an auxiliary switch.  If 301 is used the gimbal will also lock onto the location
2. Optionally set POI_DIST_MAX to the maximum distance (in meters) that the POI point could be from the vehicle
3. Fly the vehicle and point the camera gimbal at a point on the ground
4. Raise one of the RC auxiliary switches and check the GCS's messages tab for the latitude, longitude and alt (above sea-level)

# How It Works

The script's algorithm is implemented as follows

1. Get the POI_DIST_MAX and TERRAIN_SPACING parameter values
2. Get the vehicle Location (lat, lon, height above sea-level), initialise test-loc and prev-test-loc
3. Get the vehicle's current alt-above-terrain
4. Get gimbal attitude (only pitch and yaw are used)
5. The test_loc variable is initialised to the vehicle's current location
6. The prev_test_loc variable is a backup of test_loc
7. test_loc is moved along the line defined by the gimbal's pitch and yaw by TERRAIN_SPACING (meters)
8. Get the terrain's altitude (above sea-level) at test_loc
9. Steps 6, 7 and 8 are repeated until test_loc's altitude falls below the terrain altitude
10. Interpolate between test_loc and prev_test_loc to find the lat, lon, alt (above sea-level) where alt-above-terrain is zero
11. Display the POI to the user



================================================
File: applets/net_webserver.lua
================================================
--[[
   example script to test lua socket API
--]]
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: undefined-field
---@diagnostic disable: need-check-nil
---@diagnostic disable: redundant-parameter

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

PARAM_TABLE_KEY = 47
PARAM_TABLE_PREFIX = "WEB_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Setup Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'net_test: could not add param table')

--[[
  // @Param: WEB_ENABLE
  // @DisplayName: enable web server
  // @Description: enable web server
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local WEB_ENABLE = bind_add_param('ENABLE',  1, 1)

--[[
  // @Param: WEB_BIND_PORT
  // @DisplayName: web server TCP port
  // @Description: web server TCP port
  // @Range: 1 65535
  // @User: Standard
--]]
local WEB_BIND_PORT = bind_add_param('BIND_PORT', 2, 8080)

--[[
  // @Param: WEB_DEBUG
  // @DisplayName: web server debugging
  // @Description: web server debugging
  // @Values: 0:Disabled,1:Enabled
  // @User: Advanced
--]]
local WEB_DEBUG = bind_add_param('DEBUG', 3, 0)

--[[
  // @Param: WEB_BLOCK_SIZE
  // @DisplayName: web server block size
  // @Description: web server block size for download
  // @Range: 1 65535
  // @User: Advanced
--]]
local WEB_BLOCK_SIZE = bind_add_param('BLOCK_SIZE', 4, 10240)

--[[
  // @Param: WEB_TIMEOUT
  // @DisplayName: web server timeout
  // @Description: timeout for inactive connections
  // @Units: s
  // @Range: 0.1 60
  // @User: Advanced
--]]
local WEB_TIMEOUT = bind_add_param('TIMEOUT', 5, 2.0)

--[[
  // @Param: WEB_SENDFILE_MIN
  // @DisplayName: web server minimum file size for sendfile
  // @Description: sendfile is an offloading mechanism for faster file download. If this is non-zero and the file is larger than this size then sendfile will be used for file download
  // @Range: 0 10000000
  // @User: Advanced
--]]
local WEB_SENDFILE_MIN = bind_add_param('SENDFILE_MIN', 6, 100000)

if WEB_ENABLE:get() ~= 1 then
   gcs:send_text(MAV_SEVERITY.INFO, "WebServer: disabled")
   return
end

local BRD_RTC_TZ_MIN = Parameter("BRD_RTC_TZ_MIN")

gcs:send_text(MAV_SEVERITY.INFO, string.format("WebServer: starting on port %u", WEB_BIND_PORT:get()))

local sock_listen = Socket(0)
local clients = {}

local DOCTYPE = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">"
local SERVER_VERSION = "net_webserver 1.0"
local CONTENT_TEXT_HTML = "text/html;charset=UTF-8"
local CONTENT_OCTET_STREAM = "application/octet-stream"

local HIDDEN_FOLDERS = { "@SYS", "@ROMFS", "@MISSION", "@PARAM" }

local MNT_PREFIX = "/mnt"
local MNT_PREFIX2 = MNT_PREFIX .. "/"

local MIME_TYPES = {
   ["apj"] = CONTENT_OCTET_STREAM,
   ["dat"] = CONTENT_OCTET_STREAM,
   ["o"] = CONTENT_OCTET_STREAM,
   ["obj"] = CONTENT_OCTET_STREAM,
   ["lua"] = "text/x-lua",
   ["py"] = "text/x-python",
   ["shtml"] = CONTENT_TEXT_HTML,
   ["js"] = "text/javascript",
   -- thanks to https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
   ["aac"] = "audio/aac",
   ["abw"] = "application/x-abiword",
   ["arc"] = "application/x-freearc",
   ["avif"] = "image/avif",
   ["avi"] = "video/x-msvideo",
   ["azw"] = "application/vnd.amazon.ebook",
   ["bin"] = "application/octet-stream",
   ["bmp"] = "image/bmp",
   ["bz"] = "application/x-bzip",
   ["bz2"] = "application/x-bzip2",
   ["cda"] = "application/x-cdf",
   ["csh"] = "application/x-csh",
   ["css"] = "text/css",
   ["csv"] = "text/csv",
   ["doc"] = "application/msword",
   ["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
   ["eot"] = "application/vnd.ms-fontobject",
   ["epub"] = "application/epub+zip",
   ["gz"] = "application/gzip",
   ["gif"] = "image/gif",
   ["htm"] = CONTENT_TEXT_HTML,
   ["html"] = CONTENT_TEXT_HTML,
   ["ico"] = "image/vnd.microsoft.icon",
   ["ics"] = "text/calendar",
   ["jar"] = "application/java-archive",
   ["jpeg"] = "image/jpeg",
   ["json"] = "application/json",
   ["jsonld"] = "application/ld+json",
   ["mid"] = "audio/x-midi",
   ["mjs"] = "text/javascript",
   ["mp3"] = "audio/mpeg",
   ["mp4"] = "video/mp4",
   ["mpeg"] = "video/mpeg",
   ["mpkg"] = "application/vnd.apple.installer+xml",
   ["odp"] = "application/vnd.oasis.opendocument.presentation",
   ["ods"] = "application/vnd.oasis.opendocument.spreadsheet",
   ["odt"] = "application/vnd.oasis.opendocument.text",
   ["oga"] = "audio/ogg",
   ["ogv"] = "video/ogg",
   ["ogx"] = "application/ogg",
   ["opus"] = "audio/opus",
   ["otf"] = "font/otf",
   ["png"] = "image/png",
   ["pdf"] = "application/pdf",
   ["php"] = "application/x-httpd-php",
   ["ppt"] = "application/vnd.ms-powerpoint",
   ["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
   ["rar"] = "application/vnd.rar",
   ["rtf"] = "application/rtf",
   ["sh"] = "application/x-sh",
   ["svg"] = "image/svg+xml",
   ["tar"] = "application/x-tar",
   ["tif"] = "image/tiff",
   ["tiff"] = "image/tiff",
   ["ts"] = "video/mp2t",
   ["ttf"] = "font/ttf",
   ["txt"] = "text/plain",
   ["vsd"] = "application/vnd.visio",
   ["wav"] = "audio/wav",
   ["weba"] = "audio/webm",
   ["webm"] = "video/webm",
   ["webp"] = "image/webp",
   ["woff"] = "font/woff",
   ["woff2"] = "font/woff2",
   ["xhtml"] = "application/xhtml+xml",
   ["xls"] = "application/vnd.ms-excel",
   ["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
   ["xml"] = "default.",
   ["xul"] = "application/vnd.mozilla.xul+xml",
   ["zip"] = "application/zip",
   ["3gp"] = "video",
   ["3g2"] = "video",
   ["7z"] = "application/x-7z-compressed",
}

--[[
 builtin dynamic pages
--]]
local DYNAMIC_PAGES = {

-- main home page
["/"] = [[
<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>ArduPilot</title>
    <script>
      <?lstr JS_LIBRARY['dynamic_load']?>
    </script>
</head>

<h2>ArduPilot Web Server</h2>
<body onload="javascript: dynamic_load('board_status','/@DYNAMIC/board_status.shtml',1000)">

  <div id="main">
    <ul>
      <li><a href="mnt/">SDCard Access</a></li>
    </ul>
    </div>
<h2>Controller Status</h2>
  <div id="board_status"></div>
</body>
</html>
]],    
   
-- board status section on front page
["@DYNAMIC/board_status.shtml"] = [[
         <table>
         <tr><td>Firmware</td><td><?lstr FWVersion:string() ?></td></tr>
         <tr><td>GIT Hash</td><td><?lstr FWVersion:hash() ?></td></tr>
         <tr><td>Uptime</td><td><?lstr hms_uptime() ?></td></tr>
         <tr><td>Arm Status</td><td><?lstr arming:is_armed() and "ARMED" or "DISARMED" ?></td></tr>
         <tr><td>AHRS Location</td><td><?lstr location_string(ahrs:get_location()) ?></td>
         <tr><td>GPS Location</td><td><?lstr location_string(ahrs:get_location()) ?></td>
         </table>
]]
}

--[[
 builtin javascript library functions
--]]
JS_LIBRARY = {
   ["dynamic_load"] = [[
      function dynamic_load(div_id, uri, period_ms) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', uri);
          
          xhr.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
          xhr.setRequestHeader("Expires", "Tue, 01 Jan 1980 1:00:00 GMT");
          xhr.setRequestHeader("Pragma", "no-cache");
          
          xhr.onload = function () {
              if (xhr.status === 200) {
                 var output = document.getElementById(div_id);
                 if (uri.endsWith('.shtml') || uri.endsWith('.html')) {
                  output.innerHTML = xhr.responseText;
                 } else {
                  output.textContent = xhr.responseText;
                 }
              }
              setTimeout(function() { dynamic_load(div_id,uri, period_ms); }, period_ms);
          }
          xhr.send();
     }
]]
}

if not sock_listen:bind("0.0.0.0", WEB_BIND_PORT:get()) then
   gcs:send_text(MAV_SEVERITY.ERROR, string.format("WebServer: failed to bind to TCP %u", WEB_BIND_PORT:get()))
   return
end

if not sock_listen:listen(20) then
   gcs:send_text(MAV_SEVERITY.ERROR, "WebServer: failed to listen")
   return
end

function hms_uptime()
   local s = (millis()/1000):toint()
   local min = math.floor(s / 60) % 60
   local hr = math.floor(s / 3600)
   return string.format("%u hours %u minutes %u seconds", hr, min, s%60)
end

--[[
   split string by pattern
--]]
local function split(str, pattern)
   local ret = {}
   for s in string.gmatch(str, pattern) do
      table.insert(ret, s)
   end
   return ret
end

--[[
   return true if a string ends in the 2nd string
--]]
local function endswith(str, s)
   local len1 = #str
   local len2 = #s
   return string.sub(str,1+len1-len2,len1) == s
end

--[[
   return true if a string starts with the 2nd string
--]]
local function startswith(str, s)
   return string.sub(str,1,#s) == s
end

local debug_count=0

function DEBUG(txt)
   if WEB_DEBUG:get() ~= 0 then
      gcs:send_text(MAV_SEVERITY.DEBUG, txt .. string.format(" [%u]", debug_count))
      debug_count = debug_count + 1
   end
end

--[[
   return index of element in a table
--]]
function table_index(t,el)
   for i,v in ipairs(t) do
      if v == el then
         return i
      end
   end
   return nil
end

--[[
   return true if a table contains a given element
--]]
function table_contains(t,el)
   local i = table_index(t, el)
   return i ~= nil
end

function is_hidden_dir(path)
   return table_contains(HIDDEN_FOLDERS, path)
end

local DAYS = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" }
local MONTHS = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" }

function isdirectory(path)
   local s = fs:stat(path)
   return s and s:is_directory()
end

--[[
   time string for directory listings
--]]
function file_timestring(path)
   local s = fs:stat(path)
   if not s then
      return ""
   end
   local mtime = s:mtime()
   mtime = mtime + BRD_RTC_TZ_MIN:get()*60
   local year, month, day, hour, min, sec, _ = rtc:clock_s_to_date_fields(mtime)
   if not year then
      return ""
   end
   return string.format("%04u-%02u-%02u %02u:%02u", year, month+1, day, hour, min, sec)
end

--[[
   time string for Last-Modified
--]]
function file_timestring_http(mtime)
   local year, month, day, hour, min, sec, wday = rtc:clock_s_to_date_fields(mtime)
   if not year then
      return ""
   end
   return string.format("%s, %02u %s %u %02u:%02u:%02u GMT",
                        DAYS[wday+1],
                        day,
                        MONTHS[month+1],
                        year,
                        hour,
                        min,
                        sec)
end

--[[
   parse a http time string to a uint32_t seconds timestamp
--]]
function file_timestring_http_parse(tstring)
   local dayname, day, monthname, year, hour, min, sec =
      string.match(tstring,
                   '(%w%w%w), (%d+) (%w%w%w) (%d%d%d%d) (%d%d):(%d%d):(%d%d) GMT')
   if not dayname then
      return nil
   end
   local mon = table_index(MONTHS, monthname)
   return rtc:date_fields_to_clock_s(year, mon-1, day, hour, min, sec)
end

--[[
   return true if path exists and is not a directory
--]]
function file_exists(path)
   local s = fs:stat(path)
   if not s then
      return false
   end
   return not s:is_directory()
end

--[[
   substitute variables of form {xxx} from a table
   from http://lua-users.org/wiki/StringInterpolation
--]]
function substitute_vars(s, vars)
   s = (string.gsub(s, "({([^}]+)})",
                    function(whole,i)
                       return vars[i] or whole
   end))
   return s
end

--[[
  lat or lon as a string, working around limited type in ftoa_engine
--]]
function latlon_str(ll)
   local ipart = tonumber(string.match(tostring(ll*1.0e-7), '(.*[.]).*'))
   local fpart = math.abs(ll - ipart*10000000)
   return string.format("%d.%u", ipart, fpart, ipart*10000000, ll)
end

--[[
 location string for home page
--]]
function location_string(loc)
   return substitute_vars([[<a href="https://www.google.com/maps/search/?api=1&query={lat},{lon}" target="_blank">{lat} {lon}</a> {alt}]],
      { ["lat"] = latlon_str(loc:lat()),
        ["lon"] = latlon_str(loc:lng()),
        ["alt"] = string.format("%.1fm", loc:alt()*1.0e-2) })
end

--[[
   client class for open connections
--]]
local function Client(sock, idx)
   local self = {}

   self.closed = false

   local have_header = false
   local header = ""
   local header_lines = {}
   local header_vars = {}
   local run = nil
   local protocol = nil
   local file = nil
   local start_time = millis()
   local offset = 0

   function self.read_header()
      local s = sock:recv(2048)
      if not s then
         local now = millis()
         if not sock:is_connected() or now - start_time > WEB_TIMEOUT:get()*1000 then
            -- EOF while looking for header
            DEBUG(string.format("%u: EOF", idx))
            self.remove()
            return false
         end
         return false
      end
      if not s or #s == 0 then
         return false
      end
      header = header .. s
      local eoh = string.find(s, '\r\n\r\n')
      if eoh then
         DEBUG(string.format("%u: got header", idx))
         have_header = true
         header_lines = split(header, "[^\r\n]+")
         -- blocking for reply
         sock:set_blocking(true)
         return true
      end
      return false
   end

   function self.sendstring(s)
      sock:send(s, #s)
   end

   function self.sendline(s)
      self.sendstring(s .. "\r\n")
   end

   --[[
      send a string with variable substitution using {varname}
   --]]
   function self.sendstring_vars(s, vars)
      self.sendstring(substitute_vars(s, vars))
   end
   
   function self.send_header(code, codestr, vars)
      self.sendline(string.format("%s %u %s", protocol, code, codestr))
      self.sendline(string.format("Server: %s", SERVER_VERSION))
      for k,v in pairs(vars) do
         self.sendline(string.format("%s: %s", k, v))
      end
      self.sendline("Connection: close")
      self.sendline("")
   end

   -- get size of a file
   function self.file_size(fname)
      local s = fs:stat(fname)
      if not s then
         return 0
      end
      local ret = s:size():toint()
      DEBUG(string.format("%u: size of '%s' -> %u", idx, fname, ret))
      return ret
   end


   --[[
      return full path with .. resolution
   --]]
   function self.full_path(path, name)
      DEBUG(string.format("%u: full_path(%s,%s)", idx, path, name))
      local ret = path
      if path == "/" and startswith(name,"@") then
         return name
      end
      if name == ".." then
         if path == "/" then
            return "/"
         end
         if endswith(path,"/") then
            path = string.sub(path, 1, #path-1)
         end
         local dir, _ = string.match(path, '(.*/)(.*)')
         if not dir then
            return path
         end
         return dir
      end
      if not endswith(ret, "/") then
         ret = ret .. "/"
      end
      ret = ret .. name
      DEBUG(string.format("%u: full_path(%s,%s) -> %s", idx, path, name, ret))
      return ret
   end
   
   function self.directory_list(path)
      sock:set_blocking(true)
      if startswith(path, "/@") then
         path = string.sub(path, 2, #path-1)
      end
      DEBUG(string.format("%u: directory_list(%s)", idx, path))
      local dlist = dirlist(path)
      if not dlist then
         dlist = {}
      end
      if not table_contains(dlist, "..") then
         -- on ChibiOS we don't get ..
         table.insert(dlist, "..")
      end
      if path == "/" then
         for _,v in ipairs(HIDDEN_FOLDERS) do
            table.insert(dlist, v)
         end
      end

      table.sort(dlist)
      self.send_header(200, "OK", {["Content-Type"]=CONTENT_TEXT_HTML})
      self.sendline(DOCTYPE)
      self.sendstring_vars([[
<html>
 <head>
  <title>Index of {path}</title>
 </head>
 <body>
<h1>Index of {path}</h1>
  <table>
   <tr><th align="left">Name</th><th align="left">Last modified</th><th align="left">Size</th></tr>
]], {path=path})
      for _,d in ipairs(dlist) do
         local skip = d == "."
         if not skip then
            local fullpath = self.full_path(path, d)
            local name = d
            local sizestr = "0"
            local stat = fs:stat(fullpath)
            local size = stat and stat:size() or 0
            if is_hidden_dir(fullpath) or (stat and stat:is_directory()) then
               name = name .. "/"
            elseif size >= 100*1000*1000 then
               sizestr = string.format("%uM", (size/(1000*1000)):toint())
            else
               sizestr = tostring(size)
            end
            local modtime = file_timestring(fullpath)
            self.sendstring_vars([[<tr><td align="left"><a href="{name}">{name}</a></td><td align="left">{modtime}</td><td align="left">{size}</td></tr>
]], { name=name, size=sizestr, modtime=modtime })
         end
      end
      self.sendstring([[
</table>
</body>
</html>
]])
   end

   -- send file content
   function self.send_file()
      if not sock:pollout(0) then
         return
      end
      local chunk = WEB_BLOCK_SIZE:get()
      local b = file:read(chunk)
      sock:set_blocking(true)
      if b and #b > 0 then
         local sent = sock:send(b, #b)
         if sent == -1 then
            run = nil
            self.remove()
            return
         end
         if sent < #b then
            file:seek(offset+sent)
         end
         offset = offset + sent
      end
      if not b or #b < chunk then
         -- EOF
         DEBUG(string.format("%u: sent file", idx))
         run = nil
         self.remove()
         return
      end
   end

   --[[
      load whole file as a string
   --]]
   function self.load_file()
      local chunk = WEB_BLOCK_SIZE:get()
      local ret = ""
      while true do
         local b = file:read(chunk)
         if not b or #b == 0 then
            break
         end
         ret = ret .. b
      end
      return ret
   end
   
   --[[
      evaluate some lua code and return as a string
   --]]
   function self.evaluate(code)
      local eval_code = "function eval_func()\n" .. code .. "\nend\n"
      local f, errloc, err = load(eval_code, "eval_func", "t", _ENV)
      if not f then
         DEBUG(string.format("load failed: err=%s errloc=%s", err, errloc))
         return nil
      end
      local success, err2 = pcall(f)
      if not success then
         DEBUG(string.format("pcall failed: err=%s", err2))
         return nil
      end
      local ok, s2 = pcall(eval_func)
      eval_func = nil
      if ok then
         return s2
      end
      return nil
   end

   --[[
      process a file as a lua CGI
   --]]
   function self.send_cgi()
      sock:set_blocking(true)
      local contents = self.load_file()
      local s = self.evaluate(contents)
      if s then
         self.sendstring(s)
      end
      self.remove()
   end

   --[[
      send file content with server side processsing
      files ending in .shtml can have embedded lua lika this:
      <?lua return "foo" ?>
      <?lstr 2.6+7.2 ?>

      Using 'lstr' a return tostring(yourcode) is added to the code
      automatically
   --]]
   function self.send_processed_file(dynamic_page)
      sock:set_blocking(true)
      local contents
      if dynamic_page then
         contents = file
      else
         contents = self.load_file()
      end
      while #contents > 0 do
         local pat1 = "(.-)[<][?]lua[ \n](.-)[?][>](.*)"
         local pat2 = "(.-)[<][?]lstr[ \n](.-)[?][>](.*)"
         local p1, p2, p3 = string.match(contents, pat1)
         if not p1 then
            p1, p2, p3 = string.match(contents, pat2)
            if not p1 then
               break
            end
            p2 = "return tostring(" .. p2 .. ")"
         end
         self.sendstring(p1)
         local s2 = self.evaluate(p2)
         if s2 then
            self.sendstring(s2)
         end
         contents = p3
      end
      self.sendstring(contents)
      self.remove()
   end
   
   -- return a content type
   function self.content_type(path)
      if path == "/" then
         return MIME_TYPES["html"]
      end
      local _, ext = string.match(path, '(.*[.])(.*)')
      ext = string.lower(ext)
      local ret = MIME_TYPES[ext]
      if not ret then
         return CONTENT_OCTET_STREAM
      end
      return ret
   end

   -- perform a file download
   function self.file_download(path)
      if startswith(path, "/@") then
         path = string.sub(path, 2, #path)
      end
      DEBUG(string.format("%u: file_download(%s)", idx, path))
      file = DYNAMIC_PAGES[path]
      dynamic_page = file ~= nil
      if not dynamic_page then
         file = io.open(path,"rb")
         if not file then
            DEBUG(string.format("%u: Failed to open '%s'", idx, path))
            return false
         end
      end
      local vars = {["Content-Type"]=self.content_type(path)}
      local cgi_processing = startswith(path, "/cgi-bin/") and endswith(path, ".lua")
      local server_side_processing = endswith(path, ".shtml")
      local stat = fs:stat(path)
      if not startswith(path, "@") and
         not server_side_processing and
         not cgi_processing and stat and
         not dynamic_page then
         local fsize = stat:size()
         local mtime = stat:mtime()
         vars["Content-Length"]= tostring(fsize)
         local modtime = file_timestring_http(mtime)
         if modtime then
            vars["Last-Modified"] = modtime
         end
         local if_modified_since = header_vars['If-Modified-Since']
         if if_modified_since then
            local tsec = file_timestring_http_parse(if_modified_since)
            if tsec and tsec >= mtime then
               DEBUG(string.format("%u: Not modified: %s %s", idx, modtime, if_modified_since))
               self.send_header(304, "Not Modified", vars)
               return true
            end
         end
      end
      self.send_header(200, "OK", vars)
      if server_side_processing or dynamic_page then
         DEBUG(string.format("%u: shtml processing %s", idx, path))
         run = self.send_processed_file(dynamic_page)
      elseif cgi_processing then
         DEBUG(string.format("%u: CGI processing %s", idx, path))
         run = self.send_cgi
      elseif stat and
         WEB_SENDFILE_MIN:get() > 0 and
         stat:size() >= WEB_SENDFILE_MIN:get() and
         sock:sendfile(file) then
         return true
      else
         run = self.send_file
      end
      return true
   end

   function self.not_found()
      self.send_header(404, "Not found", {})
   end

   function self.moved_permanently(relpath)
      if not startswith(relpath, "/") then
         relpath = "/" .. relpath
      end
      local location = string.format("http://%s%s", header_vars['Host'], relpath)
      DEBUG(string.format("%u: Redirect -> %s", idx, location))
      self.send_header(301, "Moved Permanently", {["Location"]=location})
   end
   
   -- process a single request
   function self.process_request()
      local h1 = header_lines[1]
      if not h1 or #h1 == 0 then
         DEBUG(string.format("%u: empty request", idx))
         return
      end
      local cmd = split(header_lines[1], "%S+")
      if not cmd or #cmd < 3 then
         DEBUG(string.format("bad request: %s", header_lines[1]))
         return
      end
      if cmd[1] ~= "GET" then
         DEBUG(string.format("bad op: %s", cmd[1]))
         return
      end
      protocol = cmd[3]
      if protocol ~= "HTTP/1.0" and protocol ~= "HTTP/1.1" then
         DEBUG(string.format("bad protocol: %s", protocol))
         return
      end
      local path = cmd[2]
      DEBUG(string.format("%u: path='%s'", idx, path))

      -- extract header variables
      for i = 2,#header_lines do
         local key, var = string.match(header_lines[i], '(.*): (.*)')
         if key then
            header_vars[key] = var
         end
      end

      if DYNAMIC_PAGES[path] ~= nil then
         self.file_download(path)
         return
      end

      if path == MNT_PREFIX then
         path = "/"
      end
      if startswith(path, MNT_PREFIX2) then
         path = string.sub(path,#MNT_PREFIX2,#path)
      end

      if isdirectory(path) and
         not endswith(path,"/") and
         header_vars['Host'] and
         not is_hidden_dir(path) then
         self.moved_permanently(path .. "/")
         return
      end

      if path ~= "/" and endswith(path,"/") then
         path = string.sub(path, 1, #path-1)
      end

      if startswith(path,"/@") then
         path = string.sub(path, 2, #path)
      end

      -- see if we have an index file
      if isdirectory(path) and file_exists(path .. "/index.html") then
         DEBUG(string.format("%u: found index.html", idx))
         if self.file_download(path .. "/index.html") then
            return
         end
      end
      
      -- see if it is a directory
      if (path == "/" or
         DYNAMIC_PAGES[path] == nil) and
         (endswith(path,"/") or
          isdirectory(path) or
          is_hidden_dir(path)) then
         self.directory_list(path)
         return
      end
      
      -- or a file
      if self.file_download(path) then
         return
      end
      self.not_found(path)
   end

   -- update the client
   function self.update()
      if run then
         run()
         return
      end
      if not have_header then
         if not self.read_header() then
            return
         end
      end
      self.process_request()
      if not run then
         -- nothing more to do
         self.remove()
      end
   end

   function self.remove()
      DEBUG(string.format("%u: removing client OFFSET=%u", idx, offset))
      if sock then
         sock:close()
         sock = nil
      end
      self.closed = true
   end

   -- return the instance
   return self
end

--[[
   see if any new clients want to connect
--]]
local function check_new_clients()
   while sock_listen:pollin(0) do
      local sock = sock_listen:accept()
      if not sock then
         return
      end
      -- non-blocking for header read
      sock:set_blocking(false)
      -- find free client slot
      for i = 1, #clients+1 do
         if clients[i] == nil then
            local idx = i
            local client = Client(sock, idx)
            DEBUG(string.format("%u: New client", idx))
            clients[idx] = client
         end
      end
   end
end

--[[
   check for client activity
--]]
local function check_clients()
   for idx,client in ipairs(clients) do
      if not client.closed then
         client.update()
      end
      if client.closed then
         table.remove(clients,idx)
      end
   end
end

local function update()
   check_new_clients()
   check_clients()
   return update,5
end

return update,100



================================================
File: applets/net_webserver.md
================================================
# Web Server Application

This implements a web server for boards that have networking support.

# Parameters

The web server has a small number of parameters

## WEB_ENABLE

This must be set to 1 to enable the web server

## WEB_BIND_PORT

This sets the network port to use for the server. It defaults to 8080

## WEB_DEBUG

This enables verbose debugging

## WEB_BLOCK_SIZE

This sets the block size for network and file read/write
operations. Setting a larger value can increase performance at the
cost of more memory

## WEB_TIMEOUT

This sets the timeout in seconds for inactive client connections.

# Operation

By default the web server serves the root of your microSD card. You
can include html, javascript (*.js), image files etc on your microSD
to create a full web server with any structure you want.

## Server Side Scripting

The web server supports embedding lua script elements inside html
files for files with a filename of *.shtml. Here is an example:

```
<html>
  <head>
       <meta http-equiv="refresh" content="1">
  </head>
  <body>
    <h1>Server Side Scripting Test</h1>
    <table>
      <tr><th>Roll</th><th>Pitch</th><th>Yaw</th></tr>
      <tr>
      <td><?lua return tostring(math.deg(ahrs:get_roll_rad()))?></td>
      <td><?lstr math.deg(ahrs:get_pitch_rad())?></td>
      <td><?lstr math.deg(ahrs:get_yaw_rad())?></td>
      </tr>
    </table>
  </body>
</html>
```
In this example we are using two forms of embedded lua scripts. The
first form starts with "<?lua" and requires you to have a return
statement at the end which returns a string. This form can use as many
lines as you like.

The second form starts with "<?lstr" and will automatically cast the
expression to a string. The second form is for short single value
elements.

You can use any of the normal ArduPilot lua script bindings inside
these lua embedded elements to access sensor data etc.

## CGI Scripts

You can have CGI scripts written in lua by putting them in a directory
called "cgi-bin" in the root of the microSD card. The files must have
a file extension of ".lua".

Here is an example of a simple cgi script:
```
--[[
example lua cgi file for cgi-bin/ folder
--]]
return [[
test-from-cgi
2nd line
and a third line
]]
```

You can use any of the normal ArduPilot lua script bindings inside CGI
scripts to access sensor data etc.



================================================
File: applets/param-set.lua
================================================
-- Inspect parameter sets received via MAVLink, determine action based
-- on whitelist.

-- When this script runs and ENABLE is true ArduPilot will stop
--   processing parameter-sets via the GCS library.  Instead, this
--   script becomes responsible for setting parameters, and it will
--   only set parameters which are whitelisted.  Setting ENABLE to
--   false will allow ArduPilot to set parameters normally.

-- Setting SCR_ENABLE to false while this script is running in the
--   ENABLE state is... not advised.

-- How To Use
-- 1. copy this script to the autopilot's "scripts" directory
-- 2. set SCR_ENABLE to 1

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local UPDATE_INTERVAL_MS = 10           -- update at about 100hz

-- prefix for all text messages:
local TEXT_PREFIX_STR = "param-set"

--
-- parameter setup
--
local PARAM_TABLE_KEY = 92
local PARAM_TABLE_PREFIX = "PARAM_SET_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 7), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', PARAM_TABLE_PREFIX .. name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

--[[
  // @Param: PARAM_SET_ENABLE
  // @DisplayName: Param Set enable
  // @Description: Param Set enable
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local PARAM_SET_ENABLE = bind_add_param("ENABLE", 1, 1)

-- initialize MAVLink rx with buffer depth and number of rx message IDs to register
mavlink:init(5, 1)

-- register message id to receive
local PARAM_SET_ID = 23
mavlink:register_rx_msgid(PARAM_SET_ID)

-- handle PARAM_SET message
local parameters_which_can_be_set = {}
parameters_which_can_be_set["MAV_OPTIONS"] = true
parameters_which_can_be_set["PARAM_SET_ENABLE"] = true
parameters_which_can_be_set["BATT_ARM_MAH"] = true
parameters_which_can_be_set["BATT_ARM_VOLT"] = true
parameters_which_can_be_set["BATT_CAPACITY"] = true
parameters_which_can_be_set["BATT_CRT_MAH"] = true
parameters_which_can_be_set["BATT_CRT_VOLT"] = true
parameters_which_can_be_set["BATT_FS_CRT_ACT"] = true
parameters_which_can_be_set["BATT_FS_LOW_ACT"] = true
parameters_which_can_be_set["BATT_LOW_MAH"] = true
parameters_which_can_be_set["BATT_LOW_VOLT"] = true
parameters_which_can_be_set["BRD_OPTIONS"] = true
parameters_which_can_be_set["COMPASS_USE3"] = true
parameters_which_can_be_set["FENCE_ACTION"] = true
parameters_which_can_be_set["FENCE_ALT_MAX"] = true
parameters_which_can_be_set["FENCE_ENABLE"] = true
parameters_which_can_be_set["FENCE_RADIUS"] = true
parameters_which_can_be_set["FENCE_TYPE"] = true
parameters_which_can_be_set["LIGHTS_ON"] = true
parameters_which_can_be_set["LOG_BITMASK"] = true
parameters_which_can_be_set["LOG_DISARMED"] = true
parameters_which_can_be_set["LOG_FILE_DSRMROT"] = true
parameters_which_can_be_set["RTL_ALT"] = true
parameters_which_can_be_set["RTL_LOIT_TIME"] = true
parameters_which_can_be_set["RTL_SPEED"] = true

local function should_set_parameter_id(param_id)
    if parameters_which_can_be_set[param_id] == nil then
        return false
    end
    return parameters_which_can_be_set[param_id]
end

local function handle_param_set(name, value)
    -- we will not receive packets in here for the wrong system ID /
    --   component ID; this is handled by ArduPilot's MAVLink routing
    --   code

    -- check for this specific ID:
    if not should_set_parameter_id(name) then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("%s: param set denied (%s)", TEXT_PREFIX_STR, name))
        return
    end

    param:set_and_save(name, value)
    gcs:send_text(MAV_SEVERITY.WARNING, string.format("%s: param set applied", TEXT_PREFIX_STR))
end

-- display welcome message
gcs:send_text(MAV_SEVERITY.INFO, "param-set script loaded")

-- initialise our knowledge of the GCS's allow-set-parameters state.
--   We do not want to fight over setting this GCS state via other
--   mechanisms (eg. an auxiliary function), so we keep this state
--   around to track what we last set:
local gcs_allow_set = gcs:get_allow_param_set()

-- update function to receive param_set messages and perhaps act on them
local function update()
    -- return immediately if not enabled
    if (PARAM_SET_ENABLE:get() <= 0) then
        -- this script is disabled, set allow-via-GCS (once):
        if not gcs_allow_set then
          gcs:set_allow_param_set(true)
          gcs_allow_set = true
        end
        -- drain all mavlink messages to avoid processing them when enabled
        while true do
          local msg, _ = mavlink:receive_chan()
          if msg == nil then
            break
          end
        end
        return
    end

    -- this script is enabled, disallow setting via normal means (once):
    if gcs_allow_set then
        gcs:set_allow_param_set(false)
        gcs_allow_set = false
    end

    -- consume all available mavlink messages
    while true do
        local msg, _ = mavlink:receive_chan()
        if msg == nil then
            break
        end

        local param_value, _, _, param_id, _ = string.unpack("<fBBc16B", string.sub(msg, 13, 36))
        param_id = string.gsub(param_id, string.char(0), "")

        handle_param_set(param_id, param_value)
    end
end

-- wrapper around update(). This calls update() with an interval of
-- UPDATE_INTERVAL_MS, and if update faults then an error is
-- displayed, but the script is not stopped

function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(MAV_SEVERITY.EMERGENCY, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, UPDATE_INTERVAL_MS
end

-- start running update loop
return protected_wrapper()



================================================
File: applets/param-set.md
================================================
# Parameter Set Filter Script

## Description

This Lua script adds a safty-focused layer to MAVLink parameter setting. When enabled, it intercepts all incoming `PARAM_SET` messages and only allows modification of a predefined whitelist of parameters.

This is especially useful in scenarios where parameter integrity is critical (e.g., automated testing, payload-hosted GCS systems, or shared telemetry environments).

When enabled, the script disables ArduPilot's default GCS handling for parameter writes and takes over that responsibility with additional filtering.

## How It Works

- Intercepts MAVLink `PARAM_SET` messages targeted at the vehicle.
- Validates that the parameter ID is in the whitelist.
- Only whitelisted parameters will be updated.
- Dynamically toggles ArduPilot’s `gcs:set_allow_param_set()` based on enable state.

## Requirements

- ArduPilot 4.7 or later with Lua scripting enabled (`SCR_ENABLE = 1`)
- copy the script to the vehicle autopilot's "scripts" directory
- The script must be placed in appropriate directories:

## Parameters

This script introduces a new parameter table named `PARAM_SET_`. It includes:

| Name              | Type   | Default | Description                            |
|-------------------|--------|---------|----------------------------------------|
| `ENABLE`          | `int`  | `1`     | Enables (1) or disables (0) the script |

You can disable the script by setting `PARAM_SET_ENABLE = 0`. **Note:** disabling `SCR_ENABLE` while this script is actively blocking parameter sets is not recommended.

## Whitelisted Parameters

Only the following parameters are allowed to be set when the script is enabled:

- `MAV_OPTIONS`
- `PARAM_SET_ENABLE`
- Battery parameters (e.g., `BATT_ARM_MAH`, `BATT_FS_CRT_ACT`, etc.)
- `BRD_OPTIONS`
- `COMPASS_USE3`
- Geofence and RTL parameters (e.g., `FENCE_TYPE`, `RTL_ALT`)
- `LOG_*`, `LIGHTS_ON`

(See the full script for the complete whitelist.)

## Usage

1. Copy the script into the SD card's scripts directory.
2. Ensure `SCR_ENABLE` and `PARAM_SET_ENABLE` are both set to `1`.
3. Reboot the autopilot or reload the script if necessary.

## Logging & Debugging

The script sends diagnostic messages to the GCS:

- Allowed parameter updates show a `param set received` message.
- Blocked updates show a `param set denied` message with the offending parameter name.

Example output:

[param-set] param set received
[param-set] param set denied (LOG_BACKEND_TYPE)


## Limitations

- Only handles `PARAM_SET` messages (not `PARAM_REQUEST_*`).
- The parameter whitelist is hardcoded; changes require script edits.
- ArduPilot must support the `gcs:set_allow_param_set()` interface.
- parameter upload via FTP is denied when this script is running

## Author

[Contributed via PR #29989](https://github.com/ArduPilot/ardupilot/pull/29989)  
May 2025



================================================
File: applets/pelco_d_antennatracker.lua
================================================
--[[
   Pelco-D control implementation for antennatracker.
   Implemented by using knowledge from the excellent python implementation in https://gist.github.com/jn0/cc5c78f4a0f447a6fb2e45a5d9efa13d.
--]]

local SERVO_PAN = 71
local SERVO_TILT = 72
local SERIAL_BAUD = 9600

-- Antennattracker modes
local MODE_STOP = 1
local MODE_SCAN = 2
local MODE_SERVOTEST = 3
local MODE_GUIDED = 4

gcs:send_text(0, "Starting Pelco-D Control")

local port = assert(serial:find_serial(0), "Pelco-D: No Scripting Serial Port")
port:begin(SERIAL_BAUD)
port:set_flow_control(0)

function set_bit(value, n)
  return value | (0x01 << n) 
end

function PelcoD_msg_addchecksum(msg)
  local sum = 0
  for i = 2, #msg-1 do
      sum = sum + msg[i]
  end
  checksum =  sum % 256
  msg[7] = checksum
end

function PelcoD_move(panspeed, tiltspeed)
  local command = 0x00
  local scale = 63 -- max pelcod speed
  if panspeed < 0 then -- left
      command = set_bit(command, 2)
  elseif panspeed > 0 then -- right
      command = set_bit(command, 1)
  end
  if tiltspeed < 0 then -- down
      command = set_bit(command, 4)
  elseif tiltspeed > 0 then -- up
      command = set_bit(command, 3)
  end
  local msg = {0xFF, 0x01, 0x00, command, math.floor(math.abs(panspeed) * scale), math.floor(math.abs(tiltspeed) * scale), 0x00}
  PelcoD_msg_addchecksum(msg)
  return msg
end

-- write msg to the serial port
function send_message(msg)
  for _, v in ipairs(msg) do
    port:write(v)
  end
end
 
function update()
  tilt_norm = SRV_Channels:get_output_scaled(SERVO_TILT)
  pan_norm = SRV_Channels:get_output_scaled(SERVO_PAN)
  if (vehicle:get_mode() == MODE_SCAN or vehicle:get_mode() == MODE_SERVOTEST or vehicle:get_mode() == MODE_GUIDED) then
    -- Limit pan and tilt to -1...+1
    pan_norm=math.max(pan_norm,-1.0)
    pan_norm=math.min(pan_norm,1.0)
    tilt_norm=math.max(tilt_norm,-1.0)
    tilt_norm=math.min(tilt_norm,1.0)
    local msg=PelcoD_move(-pan_norm,tilt_norm)
    send_message(msg)
  elseif (vehicle:get_mode() == MODE_STOP) then
    local msg=PelcoD_move(0,0)
    send_message(msg)
  end 

  return update, 20 -- 50 hz
end

PelcoD_move(0,0)
return update()


--[[
function PelcoD_pan_absolute_position(degrees)
  centidegrees = degrees*100
  local msg = {0xFF, 0x01, 0x00, 0x4b, (centidegrees >> 8) & 255 , centidegrees & 255, 0x00}
  PelcoD_msg_addchecksum(msg)
  return msg
end

function PelcoD_tilt_absolute_position(degrees)
  centidegrees = degrees*100
  local msg = {0xFF, 0x01, 0x00, 0x4d, (centidegrees >> 8) & 255 , centidegrees & 255, 0x00}
  PelcoD_msg_addchecksum(msg)
  return msg
end

function PelcoD_zoom_absolute_position(position)
  local msg = {0xFF, 0x01, 0x00, 0x4f, (position >> 8) & 255 , position & 255, 0x00}
  PelcoD_msg_addchecksum(msg)
  return msg
end

function PelcoD_zero_absolute_position(degrees)
  centidegrees = degrees*100
  local msg = {0xFF, 0x01, 0x00, 0x49, 0x00, 0x00, 0x00}
  PelcoD_msg_addchecksum(msg)
  return msg
end
--]]


================================================
File: applets/pelco_d_antennatracker.md
================================================
# Pelco-D antennatracker lua script

This scripts uses the scaled output from the antennatracker servos and map them to corresponding Pelco-D messages to be sent via a RS-485 interface to a motorized base (can be anything from motorized tracker to a PTZ camera). If your FCU doesnt offer a RS-485 interface by default, you can use or TTL-RS485- or USB-RS485-adapters. I tested this script using a USB-RS485 adapter using Linux/Obal board and a Hikvision PTZ camera.

Pelco-D allows to control using either speed-/differential- or absolute-control control of the pan-/tilt-axis. Currently the script uses speed based control using by mapping the "ContinuousRotation" type servos outputs to the corresponding Pelco-D messages. The absolute control messages are implemented nevertheless for future use.

The script assumes the following parameters to be set:

SCR_ENABLE = 1
SERVO_PITCH_TYPE = 2  # ContinuousRotation type servo 
SERVO_YAW_TYPE = 2    # ContinuousRotation type servo
SERIALx_PROTOCOL = 28 # replace 'x' with the serial port used by luascript

Additionally the PITCH2SRV, YAW2SRV tuning needs to be done as described by the antennatracker description.
Also keep attention to the PITCH_MIN, PITCH_MAX and YAW_RANGE parameters to fit your Pelco-D hardware!




================================================
File: applets/plane_package_place.lua
================================================
--[[
 support package place for quadplanes
--]]

local PARAM_TABLE_KEY = 9
local PARAM_TABLE_PREFIX = "PKG_"

local MODE_AUTO = 10

local NAV_VTOL_PAYLOAD_PLACE = 94

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup package place specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 5), 'could not add param table')
local PKG_ENABLE        = bind_add_param('ENABLE', 1, 0)
local PKG_RELEASE_FUNC  = bind_add_param('RELEASE_FUNC', 2, 94)
local PKG_RELEASE_HGT   = bind_add_param('RELEASE_HGT',  3, 10)
local PKG_RELEASE_HOLD  = bind_add_param('RELEASE_HOLD', 4, 1)

local Q_LAND_SPEED = Parameter("Q_LAND_SPEED")
local Q_LAND_FINAL_ALT = Parameter("Q_LAND_FINAL_ALT")

local MAV_SEVERITY_INFO = 6
local MAV_SEVERITY_NOTICE = 5

local RNG_ORIENT_DOWN = 25

-- motors state
local MOTORS_SHUT_DOWN = 0

-- release state
local RELEASE_NONE    = 0
local RELEASE_DESCENT = 1
local RELEASE_HOLD1   = 2
local RELEASE_HOLD2   = 3
local RELEASE_DONE    = 4
local release_state = RELEASE_NONE

local release_start_t = 0

if PKG_ENABLE:get() ~= 1 then
   -- not enabled
   return
end

SRV_Channels:set_range(PKG_RELEASE_FUNC:get(), 1000)
SRV_Channels:set_output_scaled(PKG_RELEASE_FUNC:get(), 0)

-- get time in seconds
function get_time()
   return millis():tofloat() * 0.001
end

-- reset state
function reset()
   release_state = RELEASE_NONE
   SRV_Channels:set_output_scaled(PKG_RELEASE_FUNC:get(), 0)
end

--[[
   main update function, called at 20Hz
--]]
function update()
   if PKG_ENABLE:get() ~= 1 then
      -- not enabled
      return
   end

   -- only do something if in AUTO and in a PACKAGE_PLACE waypoint
   if vehicle:get_mode() ~= MODE_AUTO or mission:get_current_nav_id() ~= NAV_VTOL_PAYLOAD_PLACE then
      reset()
      return
   end

   if not arming:is_armed() then
      -- nothing to do when disarmed
      reset()
      return
   end

   -- check spool state for if we are landed
   local landed = false
   if motors:get_desired_spool_state() == MOTORS_SHUT_DOWN and release_state >= RELEASE_DESCENT then
      landed = true
   end

   -- wait till we are in the descent
   if not quadplane:in_vtol_land_descent() and release_state == RELEASE_NONE then
      reset()
      return
   end

   if release_state == RELEASE_NONE then
      -- we have started the descent
      release_state = RELEASE_DESCENT
   end

   -- see if we have valid rangefinder data
   if not landed and not rangefinder:has_data_orient(RNG_ORIENT_DOWN) then
      return
   end

   -- check the distance, if less than RNG_ORIENT_DOWN then release
   local dist_m
   if not landed then
      dist_m = rangefinder:distance_orient(RNG_ORIENT_DOWN)
   else
      dist_m = 0.0
   end

   -- slow down when within Q_LAND_FINAL_ALT of target
   local remaining_m = dist_m - PKG_RELEASE_HGT:get()
   if remaining_m > 0 and remaining_m < Q_LAND_FINAL_ALT:get() then
      vehicle:set_land_descent_rate(Q_LAND_SPEED:get()*0.01)
   end

   if remaining_m <= 0 then
      if PKG_RELEASE_HGT:get() <= 0 and not landed then
         -- wait for landing
         return
      end

      local now = get_time()
      -- we are at the target altitude
      if release_state == RELEASE_DESCENT then
         -- start timer
         release_start_t = now
         release_state = RELEASE_HOLD1
         vehicle:set_land_descent_rate(0)
      elseif release_state == RELEASE_HOLD1 then
         -- start waiting for the hold time for vehicle to settle
         vehicle:set_land_descent_rate(0)
         if now - release_start_t > PKG_RELEASE_HOLD:get() then
            gcs:send_text(MAV_SEVERITY_INFO, string.format("Package released at %.1fm", dist_m))
            SRV_Channels:set_output_scaled(PKG_RELEASE_FUNC:get(), 1000)
            release_state = RELEASE_HOLD2
         end
      elseif release_state == RELEASE_HOLD2 then
         -- do the release and wait for hold time again to ensure clean release
         vehicle:set_land_descent_rate(0)
         if now - release_start_t > PKG_RELEASE_HOLD:get()*2 then
            release_state = RELEASE_DONE
            -- aborting the landing causes us to climb back up and continue the mission
            if quadplane:abort_landing() then
               gcs:send_text(MAV_SEVERITY_INFO, string.format("Climbing"))
            else
               gcs:send_text(MAV_SEVERITY_NOTICE, string.format("land abort failed"))
            end
         end
      end
   end

end

function loop()
   update()
   -- run at 20Hz
   return loop, 50
end

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 50
end

gcs:send_text(MAV_SEVERITY_INFO, "Loaded package place script")

-- start running update loop
return protected_wrapper()




================================================
File: applets/plane_package_place.md
================================================
# Quadplane Package Place Support

This script implements support for package place in quadplanes.

To use this script you need to install it in the APM/scripts folder on
your microSD card (or build it into the firmware in ROMFS). Then
enable scripting with SCR_ENABLE=1 and reboot.

# Parameters

The script adds the following parameters:

## PKG_ENABLE

You need to set PKG_ENABLE=1 to enable this script

## PKG_RELEASE_FUNC

This needs to be set to the SERVOn_FUNCTION of the release servo. It
is recommended that you leave it at the default of 94 and set
SERVOn_FUNCTION to 94 for the servo you want to use for package
release.

## PKG_RELEASE_HGT

The parameter PKG_RELEASE_HGT controls the rangefinder height at which
the package will be released. This can be zero if you want to release
the package after you land.

## PKG_RELEASE_HOLD

This controls the time that the vehicle will stop the descent before
it releases the package. This defaults to 1 second and is used to let
the vehicle get into a steady hover.

After package release the vehicle will hold for another
PKG_RELEASE_HOLD seconds to let the package cleanly release before the
vehicle climbs.

# Operation

To setup a mission for package place you should setup your vehicle for
rangefinder landings. Setup a good lidar or radar and test that it
works. Then set RNGFND_LANDING=1 to enable use of rangefinder for VTOL
landing.

In the mission you should add a PAYLOAD_PLACE waypoint at the desired
location of the payload placement. The altitude of the PAYLOAD_PLACE
command should be set to zero as a relative height.

The PAYLOAD_PLACE command has a parametere "max descent" (parameter 1
of the command). If this is non-zero then this is the maximum amount
of height that the aircraft will descend from the start of the
descent. If the aircraft tries to descend more than this height then
the payload place will abort and the aircraft will climb back up to
the initial descent height then continue the mission.

# Landing Then Release

You can also do payload place where you wait till the vehicle fully
lands before doing the release. To do that set PGK_RELEASE_HGT to 0
and the aircraft will land fully and shutdown the motors for
PKG_RELEASE_HOLD seconds before releasing the servo. It will then hold
for another PKG_RELEASE_HOLD seconds, then will climb back up to the
original descent start height before continuing with the mission.



================================================
File: applets/plane_precland.lua
================================================
--[[
 support precision landing on quadplanes

 This is a very simple implementation intended to act as a framework
 for development of a custom solution
--]]

---@diagnostic disable: param-type-mismatch

local PARAM_TABLE_KEY = 12
local PARAM_TABLE_PREFIX = "PLND_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local MODE_QLAND = 20
local MODE_QLOITER = 19

local AUX_PRECLOITER = 39

local precloiter_enabled = false

-- bind a parameter to a variable
function bind_param(name)
   return Parameter(name)
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup precland specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')

--[[
  // @Param: PLND_ALT_CUTOFF
  // @DisplayName: Precland altitude cutoff
  // @Description: The altitude (rangefinder distance) below which we stop using the precision landing sensor and continue landing
  // @Range: 0 20
  // @Units: m
  // @User: Standard
--]]
PLND_ALT_CUTOFF = bind_add_param('ALT_CUTOFF', 1, 0)

--[[
  // @Param: DIST_CUTOFF
  // @DisplayName: Precland distance cutoff
  // @Description: The distance from target beyond which the target is ignored
  // @Range: 0 100
  // @Units: m
  // @User: Standard
--]]
PLND_DIST_CUTOFF = bind_add_param('DIST_CUTOFF', 2, 0)

-- other parameters
PLND_ENABLED = bind_param("PLND_ENABLED")
PLND_XY_DIST_MAX = bind_param("PLND_XY_DIST_MAX")
PLND_OPTIONS = bind_param("PLND_OPTIONS")

if PLND_ENABLED:get() == 0 then
   gcs:send_text(MAV_SEVERITY.INFO, "PLND: Disabled")
   return
end

local have_target = false

local rangefinder_orient = 25 -- downward

--[[
   update the have_target variable
--]]
local function update_target()
   if not precland:healthy() then
      have_target = false
      return
   end
   local ok = precland:target_acquired()

   if PLND_ALT_CUTOFF:get() > 0 then
      -- require rangefinder as well
      if not rangefinder:has_data_orient(rangefinder_orient) then
         ok = false
      end
   end
   
   if ok ~= have_target then
      have_target = ok
      if have_target then
         gcs:send_text(MAV_SEVERITY.INFO, "PLND: Target Acquired")
      else
         gcs:send_text(MAV_SEVERITY.INFO, "PLND: Target Lost")
      end
   end
end

--[[
   return true if we are in a state where precision landing control should apply
--]]
local function precision_landing_active()
   local mode = vehicle:get_mode()

   if mode == MODE_QLOITER then
      -- support precision loiter under pilot control
      return precloiter_enabled
   end

   return quadplane:in_vtol_land_descent() or mode == MODE_QLAND
end

--[[
   check for user activating precision loiter
--]]
local function precloiter_check()
   local precloiter_pos = rc:get_aux_cached(AUX_PRECLOITER)
   if precloiter_pos then
      enabled = precloiter_pos == 2
      if enabled ~= precloiter_enabled then
         precloiter_enabled = enabled
         if enabled then
            gcs:send_text(MAV_SEVERITY.INFO, "PLND: PrecLoiter enabled")
         else
            gcs:send_text(MAV_SEVERITY.INFO, "PLND: PrecLoiter disabled")
         end
      end
   end
end

-- main update function
local function update()
   if PLND_ENABLED:get() < 1 then
      return
   end

   precloiter_check()

   --[[
      get the current navigation target. Note that we must get this
      before we check if we are in a landing descent to prevent a race condition
      with vehicle:update_target_location()
   --]]
   local next_WP = vehicle:get_target_location()
   if not next_WP then
      -- not in a flight mode with a target location
      return
   end

   -- see if we are a precision landing state
   if not precision_landing_active() then
      return
   end

   update_target()
   if not have_target then
      return
   end

   --[[ ask precland for the target. Note that we ignore the altitude
      in the return as it is unreliable
   --]]
   local loc = precland:get_target_location()
   if not loc then
      return
   end

   --[[ get rangefinder distance, and if PLND_ALT_CUTOFF is set then
      stop precland operation if below the cutoff
   --]]
   local rngfnd_distance_m = rangefinder:distance_orient(rangefinder_orient)
   if PLND_ALT_CUTOFF:get() > 0 and rngfnd_distance_m < PLND_ALT_CUTOFF:get() then
      return
   end
   
   --[[
      update the vehicle target to match the precland target
   --]]
   local new_WP = next_WP:copy()
   new_WP:lat(loc:lat())
   new_WP:lng(loc:lng())
   vehicle:update_target_location(next_WP, new_WP)

   veh_loc = ahrs:get_location()

   local xy_dist = veh_loc:get_distance(new_WP)

   --[[
      get target velocity and if velocity matching is enabled in
      PLND_OPTIONS then ask vehicle to match
   --]]
   local target_vel = precland:get_target_velocity()
   if target_vel and (PLND_OPTIONS:get() & 1) ~= 0 then
      vehicle:set_velocity_match(target_vel)
   end
   if not target_vel then
      target_vel = Vector2f()
   end

   --[[
      log the target and distance
   --]]
   logger.write("PPLD", 'Lat,Lon,Alt,HDist,TDist,RFND,VN,VE',
                'LLffffff',
                'DUmmmmmm',
                'GG------',
                new_WP:lat(),
                new_WP:lng(),
                new_WP:alt(),
                xy_dist,
                next_WP:get_distance(next_WP),
                rngfnd_distance_m,
                target_vel:x(),
                target_vel:y())
   
   --[[
      stop using precland if too far away
   --]]
   if PLND_DIST_CUTOFF:get() > 0 and xy_dist > PLND_DIST_CUTOFF:get() then
      return
   end

   if xy_dist > PLND_XY_DIST_MAX:get() then
      -- pause descent till we are within the given radius
      vehicle:set_land_descent_rate(0)
   end
end

gcs:send_text(MAV_SEVERITY.INFO, "PLND: Loaded")

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
local function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 100
end

-- start running update loop
return protected_wrapper()




================================================
File: applets/plane_precland.md
================================================
# Plane Precision Landing

This script implements a precision landing system for VTOL fixed wing
aircraft (quadplanes).

Precision positioning over a landing sensor is supported in QLOITER,
QLAND, QRTL and AUTO landing.

# Parameters

Beyond the normal PLND parameters the script adds 2 additional parameters to
control it's behaviour. The parameters are:

## PLND_ALT_CUTOFF

This is an optional altitude in meters below which the precision
landing system will stop correcting the landing position. Many
precision landing sensors have poor performance at low altitudes, so
setting this to around 5 meters is advisable. A value of zero disables
this cutoff.

## PLND_DIST_CUTOFF

This is a maximum horizontal distance in meters that will be accepted
for a landing corrections. If this parameter is greater than zero and
the precision landing subsystem gives a distance beyond this distance
then precision landing correction will stop and the last landing
position will be used.

# Operation

You should first install and configure a precision landing sensor as described here:

  https://ardupilot.org/copter/docs/precision-landing-with-irlock.html

then you should enable the precision subsystem and install the lua
script in the APM/scripts folder of your flight controller.

The script will start adjusting the landing position only when in the
descent phase of an automatic VTOL landing. The PPLD log message can
be used to analyse the performance of the precision landing.

It is advisable to have a manual pilot able to take over control in a
mode such as QLOITER for instances where the precision landing system
may malfunction.

## Moving Target

If the PLND_OPTIONS bit for a moving target is enabled then the
vehicle will be set to track the estimated target velocity during
descent

## Precision QLoiter

To enable precision position hold in QLOITER you will need to use
auxiliary function 39 (PRECISION_LOITER) on an R/C switch or via GCS
auxiliary switch buttons. When enabled the vehicle will position
itself above the landing target. Height control is under user control.




================================================
File: applets/plane_ship_landing.lua
================================================
--[[
 support takeoff and landing on moving platforms for VTOL planes

 See this post for details: https://discuss.ardupilot.org/t/ship-landing-support
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type
---@diagnostic disable: need-check-nil

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 7
local PARAM_TABLE_PREFIX = "SHIP_"

local MODE_MANUAL = 0
local MODE_RTL = 11
local MODE_QRTL = 21
local MODE_AUTO = 10
local MODE_QLOITER = 19

local NAV_TAKEOFF = 22
local NAV_VTOL_TAKEOFF = 84

local ALT_FRAME_ABSOLUTE = 0

-- 3 throttle position
local THROTTLE_LOW = 0
local THROTTLE_MID = 1
local THROTTLE_HIGH = 2

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup SHIP specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'could not add param table')
--[[
  // @Param: SHIP_ENABLE
  // @DisplayName: Ship landing enable
  // @Description: Enable ship landing system
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
SHIP_ENABLE     = bind_add_param('ENABLE', 1, 0)

--[[
  // @Param: SHIP_LAND_ANGLE
  // @DisplayName: Ship landing angle
  // @Description: Angle from the stern of the ship for landing approach. Use this to ensure that on a go-around that ship superstructure and cables are avoided. A value of zero means to approach from the rear of the ship. A value of 90 means the landing will approach from the port (left) side of the ship. A value of -90 will mean approaching from the starboard (right) side of the ship. A value of 180 will approach from the bow of the ship. This parameter is combined with the sign of the RTL_RADIUS parameter to determine the holdoff pattern. If RTL_RADIUS is positive then a clockwise loiter is performed, if RTL_RADIUS is negative then a counter-clockwise loiter is used.
  // @Range: -180 180
  // @Units: deg
  // @User: Standard
--]]
SHIP_LAND_ANGLE = bind_add_param('LAND_ANGLE', 2, 0)

--[[
  // @Param: SHIP_AUTO_OFS
  // @DisplayName: Ship automatic offset trigger
  // @Description: Settings this parameter to one triggers an automatic follow offset calculation based on current position of the vehicle and the landing target. NOTE: This parameter will auto-reset to zero once the offset has been calculated.
  // @Values: 0:Disabled,1:Trigger
  // @User: Standard
--]]
SHIP_AUTO_OFS   = bind_add_param('AUTO_OFS', 3, 0)

-- other parameters
RCMAP_THROTTLE  = bind_param("RCMAP_THROTTLE")
RTL_ALTITUDE    = bind_param("RTL_ALTITUDE")
Q_RTL_ALT       = bind_param("Q_RTL_ALT")
AIRSPEED_CRUISE = bind_param("AIRSPEED_CRUISE")
TECS_LAND_ARSPD = bind_param("TECS_LAND_ARSPD")
Q_TRANS_DECEL   = bind_param("Q_TRANS_DECEL")
WP_LOITER_RAD   = bind_param("WP_LOITER_RAD")
RTL_RADIUS      = bind_param("RTL_RADIUS")
FOLL_OFS_X      = bind_param("FOLL_OFS_X")
FOLL_OFS_Y      = bind_param("FOLL_OFS_Y")
FOLL_OFS_Z      = bind_param("FOLL_OFS_Z")

-- an auth ID to disallow arming when we don't have the beacon
local auth_id = arming:get_aux_auth_id()
arming:set_aux_auth_failed(auth_id, "Ship: no beacon")

-- current target
local target_pos = Location()
local current_pos = Location()
local target_velocity = Vector3f()
local target_heading = 0.0

-- landing stages
local STAGE_HOLDOFF = 0
local STAGE_DESCEND = 1
local STAGE_APPROACH = 2
local STAGE_IDLE = 2
local landing_stage = STAGE_HOLDOFF

-- other state
local vehicle_mode = MODE_MANUAL
local reached_alt = false
local throttle_pos = THROTTLE_HIGH
local have_target = false

-- square a variable
function sq(v)
   return v*v
end

-- check key parameters
function check_parameters()
  --[[
     parameter values which are auto-set on startup
  --]]
   local key_params = {
      FOLL_ENABLE = 1,
      FOLL_OFS_TYPE = 1,
      FOLL_ALT_TYPE = 0,
   }

   for p, v in pairs(key_params) do
      local current = param:get(p)
      assert(current, string.format("Parameter %s not found", p))
      if math.abs(v-current) > 0.001 then
         param:set_and_save(p, v)
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Parameter %s set to %.2f was %.2f", p, v, current))
      end
   end
end

-- update the pilots throttle position
function update_throttle_pos()
   local tpos
   if not rc:has_valid_input() then
      tpos = THROTTLE_LOW
   else
      local tchan = rc:get_channel(RCMAP_THROTTLE:get())
      local tval = (tchan:norm_input_ignore_trim()+1.0)*0.5
      if tval >= 0.40 then
         tpos = THROTTLE_HIGH
      elseif tval >= 0.1 then
         tpos = THROTTLE_MID
      else
         tpos = THROTTLE_LOW
      end
   end
   if tpos ~= throttle_pos then
      reached_alt = false
      if landing_stage == STAGE_HOLDOFF and tpos <= THROTTLE_MID then
         landing_stage = STAGE_DESCEND
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Descending for approach (hd=%.1fm h=%.1f th=%.1f)",
                                        get_holdoff_distance(), current_pos:alt()*0.01, get_target_alt()))
      end
      if landing_stage == STAGE_DESCEND and tpos == THROTTLE_HIGH then
         gcs:send_text(MAV_SEVERITY.INFO, "Climbing for holdoff")
         landing_stage = STAGE_HOLDOFF
      end
   end
   throttle_pos = tpos
end

-- get landing airspeed
function get_land_airspeed()
   if TECS_LAND_ARSPD:get() < 0 then
      return AIRSPEED_CRUISE:get()
   end
   return TECS_LAND_ARSPD:get()
end

--[[
  calculate stopping distance assuming we are flying at
  TECS_LAND_ARSPD and are approaching the landing target from
  behind. Take account of the wind estimate to get approach
  groundspeed
--]]
function stopping_distance()
   -- get the target true airspeed for approach
   local tas = get_land_airspeed() * ahrs:get_EAS2TAS()

   -- add in wind in direction of flight
   local wind = ahrs:wind_estimate():xy()

   -- rotate wind to be in approach frame
   wind:rotate(-math.rad(target_heading + SHIP_LAND_ANGLE:get()))

   -- ship velocity rotated to the approach frame
   local ship2d = target_velocity:xy()
   ship2d:rotate(-math.rad(target_heading + SHIP_LAND_ANGLE:get()))

   -- calculate closing speed
   -- use pythagoras theorem to solve for the wind triangle
   local tas_sq = sq(tas)
   local y_sq = sq(wind:y())
   local closing_speed
   if tas_sq >= y_sq then
      closing_speed = math.sqrt(tas_sq - y_sq)
   else
      -- min 1 m/s
      closing_speed = 1.0
   end

   -- include the wind in the direction of the ship
   closing_speed = closing_speed + wind:x()

   -- account for the ship velocity
   closing_speed = closing_speed - ship2d:x()

   -- calculate stopping distance
   return sq(closing_speed) / (2.0 * Q_TRANS_DECEL:get())
end

-- get holdoff distance
function get_holdoff_radius()
   if RTL_RADIUS:get() ~= 0 then
      return RTL_RADIUS:get()
   end
   return WP_LOITER_RAD:get()
end

-- get holdoff distance
function get_holdoff_distance()
   local radius = get_holdoff_radius()
   local holdoff_dist = math.abs(radius*1.5)
   local stop_distance = stopping_distance()

   -- increase holdoff distance by up to 50% to ensure we can stop
   holdoff_dist = math.max(holdoff_dist, math.min(holdoff_dist*2.5, stop_distance*2))
   return holdoff_dist
end

-- get the holdoff position
function get_holdoff_position()
   local radius = get_holdoff_radius()
   local heading_deg = target_heading + SHIP_LAND_ANGLE:get()
   local holdoff_dist = get_holdoff_distance()

   local ofs = Vector2f()
   ofs:x(-holdoff_dist)
   ofs:y(radius)
   ofs:rotate(math.rad(heading_deg))
   local target = target_pos:copy()
   target:offset(ofs:x(), ofs:y())
   return target
end

function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

function wrap_180(angle)
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

--[[
   check if we have reached the tangent to the landing location
--]]
function check_approach_tangent()
   local distance = current_pos:get_distance(target_pos)
   local holdoff_dist = get_holdoff_distance()
   if landing_stage == STAGE_HOLDOFF and throttle_pos <= THROTTLE_MID and distance < 4*holdoff_dist then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("Descending for approach (hd=%.1fm)", holdoff_dist))
      landing_stage = STAGE_DESCEND
   end
   if reached_alt and landing_stage == STAGE_DESCEND then
      -- go to approach stage when throttle is low, we are
      -- pointing at the ship and have reached target alt.
      -- Also require we are within 2.5 radius of the ship, and our heading is within 20
      -- degrees of the target heading
      local target_bearing_deg = wrap_180(math.deg(current_pos:get_bearing(target_pos)))
      local ground_bearing_deg = wrap_180(math.deg(ahrs:groundspeed_vector():angle()))
      local margin = 10
      local error1 = math.abs(wrap_180(target_bearing_deg - ground_bearing_deg))
      local error2 = math.abs(wrap_180(ground_bearing_deg - (target_heading + SHIP_LAND_ANGLE:get())))
      logger.write('SLND','TBrg,GBrg,Dist,HDist,Err1,Err2','ffffff',target_bearing_deg, ground_bearing_deg, distance, holdoff_dist, error1, error2)
      if (error1 < margin and
          distance < 2.5*holdoff_dist and
          distance > 0.7*holdoff_dist and
          error2 < 2*margin) then
         -- we are on the tangent, switch to QRTL
         gcs:send_text(MAV_SEVERITY.INFO, "Starting approach")
         landing_stage = STAGE_APPROACH
         vehicle:set_mode(MODE_QRTL)
      end
   end
end

--[[
   check if we should abort a QRTL landing
--]]
function check_approach_abort()
   local alt = current_pos:alt() * 0.01
   local target_alt = get_target_alt()
   if alt > target_alt then
      gcs:send_text(MAV_SEVERITY.NOTICE, "Aborting landing")
      landing_stage = STAGE_HOLDOFF
      vehicle:set_mode(MODE_RTL)
   end
end

-- update state based on vehicle mode
function update_mode()
   local mode = vehicle:get_mode()
   if mode == vehicle_mode then
      return
   end
   vehicle_mode = mode
   if mode == MODE_RTL then
      landing_stage = STAGE_HOLDOFF
      reached_alt = false
   elseif mode ~= MODE_QRTL then
      landing_stage = STAGE_IDLE
      reached_alt = false
   end
end

-- update target state
function update_target()
   if not follow:have_target() then
      if have_target then
         gcs:send_text(MAV_SEVERITY.WARNING, "Lost beacon")
         arming:set_aux_auth_failed(auth_id, "Ship: no beacon")
      end
      have_target = false
      return
   end

   target_pos, target_velocity = follow:get_target_location_and_velocity_ofs()
   if target_pos == nil or target_velocity == nil then
      if have_target then
         gcs:send_text(MAV_SEVERITY.WARNING, "No target location/velocity")
         have_target = false
      end
      return
   end

   if not have_target then
      gcs:send_text(MAV_SEVERITY.INFO, "Have beacon")
      arming:set_aux_auth_passed(auth_id)
   end

   have_target = true

   target_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)
   target_heading = follow:get_target_heading_deg()
   -- zero vertical velocity to reduce impact of ship movement
   target_velocity:z(0)
end

-- get the alt target for holdoff, AMSL
function get_target_alt()
   local base_alt = target_pos:alt() * 0.01
   if landing_stage == STAGE_HOLDOFF then
      return base_alt + RTL_ALTITUDE:get()
   end
   return base_alt + Q_RTL_ALT:get()
end

function update_alt()
   local alt = current_pos:alt() * 0.01
   local target_alt = get_target_alt()
   if landing_stage == STAGE_HOLDOFF or landing_stage == STAGE_DESCEND then
      if math.abs(alt - target_alt) < 3 then
         if not reached_alt then
            gcs:send_text(MAV_SEVERITY.INFO, "Reached target altitude")
         end
         reached_alt = true
      end
   end
end

--[[
  update automatic beacon offsets
--]]

function update_auto_offset()
   if arming:is_armed() or math.floor(SHIP_AUTO_OFS:get()) ~= 1 then
      return
   end

   -- get target without offsets applied
   target_no_ofs, vel = follow:get_target_location_and_velocity()
   target_no_ofs:change_alt_frame(ALT_FRAME_ABSOLUTE)

   -- setup offsets so target location will be current location
   local new = target_no_ofs:get_distance_NED(current_pos)
   new:rotate_xy(-math.rad(target_heading))

   gcs:send_text(MAV_SEVERITY.INFO, string.format("Set follow offset (%.2f,%.2f,%.2f)", new:x(), new:y(), new:z()))
   FOLL_OFS_X:set_and_save(new:x())
   FOLL_OFS_Y:set_and_save(new:y())
   FOLL_OFS_Z:set_and_save(new:z())

   SHIP_AUTO_OFS:set_and_save(0)
end

-- main update function
function update()
   if SHIP_ENABLE:get() < 1 then
      return
   end

   update_target()
   if not have_target then
      return
   end

   current_pos = ahrs:get_position()
   if not current_pos then
      return
   end
   current_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)

   --[[
      get target location before we check vehicle state to prevent a
      race condition with the user changing mode or target
   --]]
   local next_WP = vehicle:get_target_location()
   if not next_WP then
      -- not in a flight mode with a target location
      return
   end

   update_throttle_pos()
   update_mode()
   update_alt()
   update_auto_offset()

   ahrs:set_home(target_pos)

   next_WP:change_alt_frame(ALT_FRAME_ABSOLUTE)

   if vehicle_mode == MODE_RTL then
      local holdoff_pos = get_holdoff_position()
      holdoff_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)
      holdoff_pos:alt(math.floor(get_target_alt()*100))
      vehicle:update_target_location(next_WP, holdoff_pos)

      if throttle_pos == THROTTLE_LOW then
         check_approach_tangent()
      end

   elseif vehicle_mode == MODE_QRTL then
      vehicle:set_velocity_match(target_velocity:xy())
      target_pos:alt(next_WP:alt())
      vehicle:update_target_location(next_WP, target_pos)

      if throttle_pos == THROTTLE_HIGH then
         check_approach_abort()
      end
      
   elseif vehicle_mode == MODE_AUTO then
      local id = mission:get_current_nav_id()
      if id == NAV_VTOL_TAKEOFF or id == NAV_TAKEOFF then
         vehicle:set_velocity_match(target_velocity:xy())
         local tpos = current_pos:copy()
         tpos:alt(next_WP:alt())
         vehicle:update_target_location(next_WP, tpos)
      end

   elseif vehicle_mode == MODE_QLOITER then
      vehicle:set_velocity_match(target_velocity:xy())
   end

end

function loop()
   update()
   -- run at 20Hz
   return loop, 50
end

check_parameters()

gcs:send_text(MAV_SEVERITY.INFO, "ShipLanding: loaded")

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(MAV_SEVERITY.ERROR, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 50
end

-- start running update loop
return protected_wrapper()




================================================
File: applets/repl.lua
================================================
-- Interactive REPL (read-evaluate-print-loop) for the Lua scripting engine
-- accessible over serial, with line editing, history, and output formatting.

-- 0-based index of Scripting protocol port to use, or nil to use MAVLink
local PORT_IDX = 0
local MAX_HISTORY = 50 -- number of lines of history to keep (must be >= 1)
local VERSION = "v1.0" -- version is convenience for the user

local port
if PORT_IDX == nil then
  port = require("mavport")
else
  port = serial:find_serial(PORT_IDX)
end
assert(port, "REPL scripting port not configured")

-- scan through parameters to find our port and grab its baud rate
do
  local serial_info = ""
  local baud = 115200
  if PORT_IDX ~= nil then
    local port_num = 0
    while PORT_IDX >= 0 and port_num <= 9 do
      local protocol = param:get(("SERIAL%d_PROTOCOL"):format(port_num))
      port_num = port_num + 1
      if protocol == 28 then PORT_IDX = PORT_IDX - 1 end
    end
    if PORT_IDX == -1 then -- correct port index found
      port_num = port_num - 1
      baud = param:get(("SERIAL%d_BAUD"):format(port_num)) or 115200
      serial_info = (" on SERIAL%d, BAUD=%d"):format(port_num, baud)
    end
  end
  -- if we can't find the right port, the baud probably does not matter
  -- (e.g. CAN or network port)
  port:begin(baud)

  gcs:send_text(6, "Lua REPL "..VERSION.." starting"..serial_info)
end

-- grab things we use from the environment in case the user messes them up
local string = string
local table = table

-- declaration of main state variable and functions
local state_func, state_read, state_eval, state_print

-- write the string s to the port, buffering if not all could be written.
-- buffer starts of with the first message and prompt
local tx_buf = {"\r\n\r\nLua REPL "..VERSION.." started.\r\n> "}
local writestring
if port.writestring then -- use more efficient method if we have it
  writestring = function(s)
    if tx_buf then -- stuff already in the buffer?
      tx_buf[#tx_buf+1] = s -- this needs to go after
    else
      local written = port:writestring(s)
      if written < #s then
        -- write was short i.e. port buffer is full. buffer the rest of the
        -- string ourselves and transmit it later
        tx_buf = { s:sub(written+1) }
      end
    end
  end
else
  writestring = function(s)
    if tx_buf then -- stuff already in the buffer?
      tx_buf[#tx_buf+1] = s -- this needs to go after
    else
      for ci = 1, #s do
        if port:write(s:byte(ci)) == 0 then
          -- write failed i.e. port buffer is full. we now buffer the rest of
          -- the string ourselves and transmit it later
          tx_buf = { s:sub(ci) }
          break
        end
      end
    end
  end
end

-- don't use print substitute in the REPL's code (e.g. for debugging the REPL)
local print = print -- luacheck: ignore 211 (unused variable warning)

-- substitute print function for within the REPL that prints to the port
function _ENV.print(...)
  local t = table.pack(...)
  for i = 1, t.n do
    writestring(tostring(t[i]))
    writestring((i ~= t.n) and "\t" or "\r\n")
  end
end

-- write the character c to the port, buffering if failed
local function writechar(c)
  -- buffer character if stuff already in buffer or write fails
  if tx_buf or port:write(c) == 0 then
    tx_buf[#tx_buf+1] = string.char(c) -- massive overhead...
  end
end

local function writeobj(o)
  if type(o) == "table" then
    writestring("{ ")
    for k, v in pairs(o) do
      if type(k) ~= "number" then k = '"'..k..'"' end
      writestring("["..k.."] = ")
      writeobj(v)
      writestring(", ")
    end
    writestring("}")
  else
    writestring(tostring(o))
  end
end

local curr_line = nil -- table of line bytes, or nil if viewing history
local curr_pos = 1 -- position the next character will be put at
local curr_esc = nil -- table of escape sequence bytes

local eval_pieces = {} -- pieces of code being evaluated

local history_lines = {""} -- lines in the history (one is always being edited)
local history_pos = 1 -- position in the history being edited

local function writeprompt()
  writestring((#eval_pieces > 0) and ">> " or "> ")
end

local function movehistory(dir)
  if curr_line then -- current line was edited, store it in history
    history_lines[history_pos] = string.char(table.unpack(curr_line))
    curr_line = nil
  end

  history_pos = history_pos + dir -- move to new position

  writestring("\x1B[2K\r") -- erase line and return cursor to start
  writeprompt() -- draw prompt
  local line = history_lines[history_pos] -- and current line from history
  writestring(line)
  curr_pos = #line + 1
end

local function readesc(c)
  assert(curr_esc) -- only called if curr_esc isn't nil

  if c == 27 then -- another escape, clear line and buffer and exit escape mode
    curr_line = nil
    curr_pos = 1
    curr_esc = nil
    eval_pieces = {}
    history_pos = #history_lines
    history_lines[history_pos] = ""
    writestring("\r\n")
    writeprompt()
    return
  else
    curr_esc[#curr_esc+1] = c
  end

  if curr_esc[1] ~= 91 then -- not a [, exit escape mode
    curr_esc = nil
    return
  end

  if #curr_esc < 2 then return end -- command character not yet present

  local line_len = #history_lines[history_pos]
  if curr_line then line_len = #curr_line end

  -- c is now the command character
  if c == 65 then -- up
    if history_pos > 1 then
      movehistory(-1)
    end
  elseif c == 66 then -- down
    if history_pos < #history_lines then
      movehistory(1)
    end
  elseif c == 67 then -- right
    if curr_pos < line_len + 1 then
      writestring("\x1B[C")
      curr_pos = curr_pos + 1
    end
  elseif c == 68 then -- left
    if curr_pos > 1 then
      writestring("\x1B[D")
      curr_pos = curr_pos - 1
    end
  elseif c == 72 then -- home
    if curr_pos > 1 then
      writestring(("\x1B[%dD"):format(curr_pos-1))
      curr_pos = 1
    end
  elseif c == 70 then -- end
    if curr_pos < line_len + 1 then
      writestring(("\x1B[%dC"):format(line_len-curr_pos+1))
      curr_pos = line_len + 1
    end
  end

  curr_esc = nil -- exit escape mode, handling complete
end

local last_c = 0
state_read = function ()
  while true do
    local c = port:read()
    if c == -1 then return end -- no new character, give time for more to come

    if curr_esc then -- in escape sequence
      readesc(c)
    elseif c == 27 then -- escape, start of a control sequence
      curr_esc = {} -- engage escape sequence handler
    elseif c == 13 or c == 10 then -- line complete
      if last_c ~= 13 or c ~= 10 then -- ignore \n after \r
        writestring("\r\n")
        last_c = c
        break
      end
    elseif c == 8 or c == 127 then -- backspace
      if curr_pos > 1 then -- a character to delete?
        if curr_line == nil then -- retrieve line for editing
          curr_line = table.pack(history_lines[history_pos]:byte(1, -1))
        end
        table.remove(curr_line, curr_pos-1) -- delete the character
        writechar(8) -- back cursor up
        curr_pos = curr_pos - 1
        if curr_pos <= #curr_line then -- draw characters after deletion point
          writestring(string.char(table.unpack(curr_line, curr_pos)))
        end
        -- blank out trailing character and back cursor up to deletion point
        writestring((" \x1B[%dD"):format(#curr_line-curr_pos+2))
      end
    elseif c >= 32 and c <= 126 then -- a character to type
      if curr_line == nil then -- retrieve line for editing
        curr_line = table.pack(history_lines[history_pos]:byte(1, -1))
      end
      table.insert(curr_line, curr_pos, c) -- store character in the line
      writechar(c) -- draw the new character
      curr_pos = curr_pos + 1
      if curr_pos <= #curr_line then -- and any after
        writestring(string.char(table.unpack(curr_line, curr_pos)))
        -- back cursor up to insertion point
        writestring(("\x1B[%dD"):format(#curr_line-curr_pos+1))
      end
    end

    last_c = c
    if tx_buf then return end -- give time to flush if buffer full
  end

  -- loop break, line is complete!
  local line = history_lines[history_pos]
  if curr_line then
    line = string.char(table.unpack(curr_line)) -- store line for processing
    curr_line = nil
  end

  if #line == 0 then -- line is empty, ignore it
    writeprompt()
    return
  end

  -- if this line is different to the last one added (one before the last entry)
  if history_lines[#history_lines-1] ~= line then
    history_lines[#history_lines] = line -- insert it at history end
    history_lines[#history_lines+1] = "" -- create empty entry for next line
    if #history_lines > MAX_HISTORY then table.remove(history_lines, 1) end
  else -- don't create a new entry with a duplicate line
    history_lines[#history_lines] = "" -- just clear and reuse the last entry
  end
  history_pos = #history_lines -- now editing the last entry
  curr_pos = 1

  eval_pieces[#eval_pieces+1] = line -- evaluate the line
  state_func = state_eval
end

local function to_chunk(pieces)
  local pos = 1

  local function next_piece()
    -- going past the last piece returns nil which signals the end
    local piece = pieces[pos]
    pos = pos + 1
    return piece
  end

  return next_piece
end

local eval_results
state_eval = function ()
  local func, err
  -- try to compile a single line as "return %s;" assuming it could be an
  -- expression. technique borrowed from the official Lua REPL.
  if #eval_pieces == 1 then
    local expr_pieces = {"return ", eval_pieces[1], ";"}
    func = load(to_chunk(expr_pieces), "=input", "t", _ENV)
  end
  if func == nil then -- compilation unsuccessful, load normally
    func, err = load(to_chunk(eval_pieces), "=input", "t", _ENV)
  end

  -- if there is an error at the end of the statement, assume we need more to
  -- complete it. technique borrowed from the official Lua REPL.
  -- ignore check since load defines that err is not nil if func is nil
  ---@diagnostic disable-next-line: need-check-nil
  if func == nil and err:sub(-5, -1) == "<eof>" then
    -- add a newline and get another line from the user
    eval_pieces[#eval_pieces+1] = "\n"
    writeprompt()
    state_func = state_read
    return
  end

  eval_pieces = {} -- destroy to make room for result
  if func == nil then -- result is the load error message
    eval_results = { false, err, n = 2 }
  else
    eval_results = table.pack(pcall(func))
  end
  state_func = state_print
end

state_print = function ()
  for i = 2, eval_results.n do -- skip pcall result
    writeobj(eval_results[i]) -- write each result separated by tabs
    writestring((i ~= eval_results.n) and "\t" or "\r\n")
    eval_results[i] = nil -- destroy to make room for stringified version
  end
  eval_results = nil

  writeprompt()
  state_func = state_read -- loop back to read
end

state_func = state_read
local function update()
  if tx_buf then -- write out stuff in tx buffer if present
    local old_buf = tx_buf
    tx_buf = nil
    for _, s in ipairs(old_buf) do -- re-write all data
      writestring(s)
    end
  else -- otherwise we have time to process
    state_func()
  end

  ---@diagnostic disable-next-line: undefined-field
  if PORT_IDX == nil then port:flush() end -- flush MAVLink port if using it

  return update, 10
end

return update()



================================================
File: applets/repl.md
================================================
# Lua REPL

This script implements an interactive REPL (read-evaluate-print-loop) for the
Lua scripting engine accessible over serial, with line editing, history, and
output formatting.

The script can also act as a client for QGroundControl's MAVLink Console
functionality (within the Analyze view), subject to limitations detailed
below.

### Basic Usage
* Configure a serial port (e.g. `SERIALn_PROTOCOL`) to protocol 28 (Scripting).
    * By default the first such port is used; this can be adjusted in the script
      text.
    * `SERIAL6` is the alternate USB serial port on Cube Orange, and convenient
      for bench testing. CAN and network serial ports will also work.
* Load the `repl.lua` script onto the autopilot.
* Connect a terminal emulator to the port and enter Lua statements/expressions
  at the `> ` prompt, then press Enter to execute. Results and errors will be
  printed back.
    * A `>> ` prompt indicates that more input is needed to complete the
      statement.
    * You can use the arrow keys to edit the current and previous inputs.
    * Press ESC twice to clear the input and any incomplete statement then
      return to an empty prompt.

### Autopilot Connection
* On Linux a convenient command is e.g. `minicom -w -D /dev/ttyACM1 -b 115200`,
  assuming you have the minicom terminal emulator installed.
* Any terminal emulator on any platform should work; see notes below about
  control codes and other configuration.

### SITL Connection
* Start SITL with a command like `Tools/autotest/sim_vehicle.py -A --serialN=tcp:9995:wait` to allow connection to the selected serial port.
* Connect a terminal emulator to localhost TCP port 9995
    * On Linux a convenient command is `stty -icanon -echo -icrnl && netcat localhost 9995`.
    * Note that you must execute `reset` to turn echo back on once disconnected.
    * Scripting must be restarted after a TCP reconnection.

### MAVLink Connection
* Requires at least Ardupilot 4.6.
* Set the port in the script text to `nil` to enable.
* In addition to `repl.lua`, copy the `mavport.lua` file and `MAVLink` directory
  from `AP_Scripting/modules` to `APM/SCRIPTS/MODULES` on your autopilot.
* The ESC key is not supported; cause a syntax error to reset the prompt.
* The experience over a radio link might be sub-par due to lack of any sort of
  packet loss tracking or retransmission.

### Notes and Limitations
* Statements like `local x = 3` create a variable which immediately goes out of
  scope once evaluated. Names must be global to survive to the next prompt.
* There is currently no facility for installing periodic update callbacks.
* While theoretically impossible to accidentally crash the autopilot software,
  certain scripting APIs can cause damage to you or your vehicle if used
  improperly. Use extreme caution with an armed vehicle!
* The script expects Enter to be `\r`, `\r\n`, or `\n`. It prints `\r\n` for a
  new line, and uses ANSI cursor control codes for line editing and history.
  Check your terminal configuration if Enter doesn't work or you see garbage
  characters. Lines longer than the terminal width likely won't edit properly.
* Evaluating complex statements or printing complex results can cause an
  `exceeded time limit` error, stopping the script and losing variables and
  history. Increasing the vehicle's `SCR_VM_I_COUNT` parameter reduces the
  chance of this occurring.



================================================
File: applets/revert_param.lua
================================================
--[[
   parameter reversion utility. This helps with manual tuning
   in-flight by giving a way to instantly revert parameters to the startup parameters
--]]

---@diagnostic disable: param-type-mismatch


local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 31
local PARAM_TABLE_PREFIX = "PREV_"

local UPDATE_RATE_HZ = 4

-- bind a parameter to a variable, old syntax to support older firmware
function bind_param(name)
   local p = Parameter()
   if not p:init(name) then
      return nil
   end
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   local p = bind_param(PARAM_TABLE_PREFIX .. name)
   assert(p, string.format("count not find parameter %s", name))
   return p
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 5), 'could not add param table')

--[[
  // @Param: PREV_ENABLE
  // @DisplayName: parameter reversion enable
  // @Description: Enable parameter reversion system
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local PREV_ENABLE      = bind_add_param('ENABLE',         1, 0)

--[[
  // @Param: PREV_RC_FUNC
  // @DisplayName: param reversion RC function
  // @Description: RCn_OPTION number to used to trigger parameter reversion
  // @User: Standard
--]]
local PREV_RC_FUNC     = bind_add_param('RC_FUNC',       2, 300)

-- params dictionary indexed by name
local params = {}
local param_saved = {}
local param_count = 0

local ATC_prefixes = { "ATC", "Q_A" }
local PSC_prefixes = { "PSC", "Q_P" }
local PID_prefixes = { "_RAT_RLL_", "_RAT_PIT_", "_RAT_YAW_" }
local PID_suffixes = { "FF", "P", "I", "D", "D_FF", "PDMX", "NEF", "NTF", "IMAX", "FLTD", "FLTE", "FLTT", "SMAX" }
local angle_axes = { "RLL", "PIT", "YAW" }
local rate_limit_axes = { "R", "P", "Y"}
local PSC_types = { "ACCZ", "VELZ", "POSZ", "VELXY", "POSXY" }
local OTHER_PARAMS = { "INS_GYRO_FILTER", "INS_ACCEL_FILTER", "PTCH2SRV_TCONST", "RLL2SRV_TCONST" }

-- TECS params
TECS_PARAMS = { "TECS_APPR_SMAX", "TECS_CLMB_MAX", "TECS_FLARE_HGT", "TECS_HDEM_TCONST", "TECS_HGT_OMEGA", "TECS_INTEG_GAIN", "TECS_LAND_ARSPD", "TECS_LAND_DAMP", "TECS_LAND_IGAIN", "TECS_LAND_PDAMP", "TECS_LAND_PMAX", "TECS_LAND_SINK", "TECS_LAND_SPDWGT", "TECS_LAND_SRC", "TECS_LAND_TCONST", "TECS_LAND_TDAMP", "TECS_LAND_THR", "TECS_OPTIONS", "TECS_PITCH_MAX", "TECS_PITCH_MIN", "TECS_PTCH_DAMP", "TECS_PTCH_FF_K", "TECS_PTCH_FF_V0", "TECS_RLL2THR", "TECS_SINK_MAX", "TECS_SINK_MIN", "TECS_SPDWEIGHT", "TECS_SPD_OMEGA", "TECS_SYNAIRSPEED", "TECS_THR_DAMP", "TECS_TIME_CONST", "TECS_TKOFF_IGAIN", "TECS_VERT_ACC" }

local INS_HNTCH_PREFIX = { "INS_HNTCH_", "INS_HNTC2_" }
local INS_NOTCH_PARMS = { "ENABLE", "ATT", "FREQ", "BW", "OPTS", "REF", "FM_RAT", "MODE" }

if PREV_ENABLE:get() == 0 then
   return
end

local function add_param(pname)
   local p = bind_param(pname)
   if p then
      params[pname] = p
      param_saved[pname] = p:get()
      param_count = param_count + 1
      -- gcs:send_text(MAV_SEVERITY.INFO, string.format("Added %s", pname))
   end
end

-- add rate PIDs
for _, atc in ipairs(ATC_prefixes) do
   for _, prefix in ipairs(PID_prefixes) do
      for _, suffix in ipairs(PID_suffixes) do
         add_param(atc .. prefix .. suffix)
      end
   end
end

-- add angle Ps
for _, atc in ipairs(ATC_prefixes) do
   for _, axis in ipairs(angle_axes) do
      add_param(atc .. "_ANG_" .. axis .. "_P" )
   end
end

-- add angular rate limits
for _, atc in ipairs(ATC_prefixes) do
   for _, axis in ipairs(rate_limit_axes) do
      add_param(atc .. "_RATE_" .. axis .. "_MAX")
   end
end

-- add fixed wing tuning
for _, suffix in ipairs(PID_suffixes) do
   add_param("RLL_RATE_" .. suffix)
   add_param("PTCH_RATE_" .. suffix)
   add_param("YAW_RATE_" .. suffix)
end

-- add PSC tuning
for _, psc in ipairs(PSC_prefixes) do
   for _, ptype in ipairs(PSC_types) do
      for _, suffix in ipairs(PID_suffixes) do
         add_param(psc .. "_" .. ptype .. "_" .. suffix)
      end
   end
end

-- add in TECS parameters
for _, p in ipairs(TECS_PARAMS) do
   add_param(p)
end

-- add notch parameters
for _, ins_notch in ipairs(INS_HNTCH_PREFIX) do
   for _, p in ipairs(INS_NOTCH_PARMS) do
      add_param(ins_notch .. p)
   end
end

-- add in other parameters
for _, p in ipairs(OTHER_PARAMS) do
   add_param(p)
end


local function revert_parameters()
   local count = 0
   for pname, p in pairs(params) do
      local v1 = p:get()
      local v2 = param_saved[pname]
      if v1 ~= v2 then
         p:set_and_save(param_saved[pname])
         count = count + 1
      end
   end
   return count
end

gcs:send_text(MAV_SEVERITY.INFO, string.format("Stored %u parameters", param_count))

local done_revert = false

-- main update function
function update()
   local sw_pos = rc:get_aux_cached(PREV_RC_FUNC:get())
   if not sw_pos then
      return
   end
   if sw_pos == 2 and not done_revert then
      done_revert = true
      count = revert_parameters()
      gcs:send_text(MAV_SEVERITY.INFO, string.format("Reverted %u parameters", count))
      return
   end
   if sw_pos == 0 then
      done_revert = false
   end
end

-- wrapper around update(). This calls update() at 10Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(MAV_SEVERITY.EMERGENCY, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 1000/UPDATE_RATE_HZ
end

-- start running update loop
return protected_wrapper()



================================================
File: applets/revert_param.md
================================================
# Parameter Revert

This script implements a easy parameter reversion system to help with
manual in-flight tuning. It allows you to do a wide range of manual
tuning while flying and if you get in trouble (eg. an oscillation)
then you can use a switch to instantly revert all the parameter
changes to the values from startup.

# Parameters

The script adds 2 parameters to control it's behaviour. The parameters
are:

## PREV_ENABLE

this must be set to 1 to enable the script

## PREV_RC_FUNC

The RCz_OPTIONS scripting function binding to be used for this script.
Default RCz_OPTIONS binding is 300 (scripting1).

# Operation

Install the script in the APM/SCRIPTS folder on your microSD (you can
use mavFTP for that). Then reboot and re-fetch parameters. You will
find you now have PREV_ENABLE and PREV_RC_FUNC parameters.

Set PREV_ENABLE to 1 and set PREV_RC_FUNC to an available RC
option. You would typically use 300 if not used by another
script. Then set RCn_OPTION for your chosen R/C channel to revert
parameter to the PREV_RC_FUNC value (eg. 300).

Now reboot to start the script. To test it try changing one of the
covered parameter values while on the ground, then trigger the
reversion with your R/C switch. Then fetch your parameters and you
will see it has been reverted. You will see a message "Reverted N
parameters" in the messages tab when this happens.

# Covered Parameters

The script covers the following parameters on quadplanes:

 - Q_A_RAT_RLL_*
 - Q_A_RAT_PIT_*
 - Q_A_RAT_YAW_*
 - Q_A_ANG_RLL_P
 - Q_A_ANG_PIT_P
 - Q_A_ANG_YAW_P
 - Q_A_RATE_*_MAX
 - Q_P_ACCZ_*
 - Q_P_VELZ_*
 - Q_P_POSZ_*
 - Q_P_VELXY_*
 - Q_P_POSXY_*

The script covers the following parameters on copters:

 - ATC_RAT_RLL_*
 - ATC_RAT_PIT_*
 - ATC_RAT_YAW_*
 - ATC_ANG_RLL_P
 - ATC_ANG_PIT_P
 - ATC_ANG_YAW_P
 - ATC_RATE_*_MAX
 - PSC_ACCZ_*
 - PSC_VELZ_*
 - PSC_POSZ_*
 - PSC_VELXY_*
 - PSC_POSXY_*

For fixed wing the following parameters are covered:

 - RLL_RATE_*
 - PTCH_RATE_*
 - RLL2SRV_TCONST
 - PTCH2SRV_TCONST
 - all TECS parameters



================================================
File: applets/rover-quicktune.lua
================================================
--[[

Rover QuickTune tunes the steering (aka turn rate) and speed controller gains for rovers and boats

The script is designed to be used in Circle mode and updates the following parameters

ATC_STR_RAT_P
ATC_STR_RAT_I
ATC_STR_RAT_D
ATC_STR_RAT_FF
ATC_SPEED_P
ATC_SPEED_I
ATC_SPEED_D
CRUISE_SPEED
CRUISE_THROTTLE

See the accompanying rover-quiktune.md file for instructions on how to use

--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 15
local PARAM_TABLE_PREFIX = "RTUN_"
local PARAM_TABLE_SIZE = 12

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format("RTun: could not find %s parameter", name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format("RTun: could not add param %s", name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup quicktune specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, PARAM_TABLE_SIZE), "RTun: could not add param table")

--[[
  // @Param: RTUN_ENABLE
  // @DisplayName: Rover Quicktune enable
  // @Description: Enable quicktune system
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local RTUN_ENABLE = bind_add_param('ENABLE', 1, 1)

--[[
  // @Param: RTUN_AXES
  // @DisplayName: Rover Quicktune axes
  // @Description: axes to tune
  // @Bitmask: 0:Steering,1:Speed
  // @User: Standard
--]]
local RTUN_AXES = bind_add_param('AXES', 2, 3)

--[[
  // @Param: RTUN_STR_FFRATIO
  // @DisplayName: Rover Quicktune Steering Rate FeedForward ratio
  // @Description: Ratio between measured response and FF gain. Raise this to get a higher FF gain
  // @Range: 0 1.0
  // @User: Standard
--]]
local RTUN_STR_FFRATIO = bind_add_param('STR_FFRATIO', 3, 0.9)

--[[
  // @Param: RTUN_STR_P_RATIO
  // @DisplayName: Rover Quicktune Steering FF to P ratio
  // @Description: Ratio between steering FF and P gains. Raise this to get a higher P gain, 0 to leave P unchanged
  // @Range: 0 2.0
  // @User: Standard
--]]
local RTUN_STR_P_RATIO = bind_add_param('STR_P_RATIO', 4, 0.5)

--[[
  // @Param: RTUN_STR_I_RATIO
  // @DisplayName: Rover Quicktune Steering FF to I ratio
  // @Description: Ratio between steering FF and I gains. Raise this to get a higher I gain, 0 to leave I unchanged
  // @Range: 0 2.0
  // @User: Standard
--]]
local RTUN_STR_I_RATIO = bind_add_param('STR_I_RATIO', 5, 0.5)

--[[
  // @Param: RTUN_SPD_FFRATIO
  // @DisplayName: Rover Quicktune Speed FeedForward (equivalent) ratio
  // @Description: Ratio between measured response and CRUISE_THROTTLE value. Raise this to get a higher CRUISE_THROTTLE value
  // @Range: 0 1.0
  // @User: Standard
--]]
local RTUN_SPD_FFRATIO = bind_add_param('SPD_FFRATIO', 6, 1.0)

--[[
  // @Param: RTUN_SPD_P_RATIO
  // @DisplayName: Rover Quicktune Speed FF to P ratio
  // @Description: Ratio between speed FF and P gain. Raise this to get a higher P gain, 0 to leave P unchanged
  // @Range: 0 2.0
  // @User: Standard
--]]
local RTUN_SPD_P_RATIO = bind_add_param('SPD_P_RATIO', 7, 1.0)

--[[
  // @Param: RTUN_SPD_I_RATIO
  // @DisplayName: Rover Quicktune Speed FF to I ratio
  // @Description: Ratio between speed FF and I gain. Raise this to get a higher I gain, 0 to leave I unchanged
  // @Range: 0 2.0
  // @User: Standard
--]]
local RTUN_SPD_I_RATIO = bind_add_param('SPD_I_RATIO', 8, 1.0)

--[[
  // @Param: RTUN_AUTO_FILTER
  // @DisplayName: Rover Quicktune auto filter enable
  // @Description: When enabled the PID filter settings are automatically set based on INS_GYRO_FILTER
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local RTUN_AUTO_FILTER = bind_add_param('AUTO_FILTER', 9, 1)

--[[
  // @Param: RTUN_AUTO_SAVE
  // @DisplayName: Rover Quicktune auto save
  // @Description: Number of seconds after completion of tune to auto-save. This is useful when using a 2 position switch for quicktune
  // @Units: s
  // @User: Standard
--]]
local RTUN_AUTO_SAVE = bind_add_param('AUTO_SAVE', 10, 5)

--[[
  // @Param: RTUN_RC_FUNC
  // @DisplayName: Rover Quicktune RC function
  // @Description: RCn_OPTION number to use to control tuning stop/start/save
  // @Values: 300:Scripting1, 301:Scripting2, 302:Scripting3, 303:Scripting4, 304:Scripting5, 305:Scripting6, 306:Scripting7, 307:Scripting8
  // @User: Standard
--]]
local RTUN_RC_FUNC = bind_add_param('RC_FUNC', 11, 300)

--[[
  // @Param: RTUN_SPEED_MIN
  // @DisplayName: Rover Quicktune minimum speed for tuning
  // @Description: The mimimum speed in m/s required for tuning to start
  // @Units: m/s
  // @Range: 0.1 0.5
  // @User: Standard
--]]
local SPEED_FF_SPEED_MIN = bind_add_param('SPEED_MIN', 12, 0.5)

-- other vehicle parameters used by this script
local INS_GYRO_FILTER  = bind_param("INS_GYRO_FILTER")
local GCS_PID_MASK     = bind_param("GCS_PID_MASK")
local RCMAP_ROLL       = bind_param("RCMAP_ROLL")
local RCMAP_THROTTLE   = bind_param("RCMAP_THROTTLE")
local RCIN_ROLL  = rc:get_channel(RCMAP_ROLL:get())
local RCIN_THROTTLE = rc:get_channel(RCMAP_THROTTLE:get())

-- definitions
local UPDATE_RATE_HZ = 40           -- this script updates at 40hz
local AXIS_CHANGE_DELAY = 4.0       -- delay of 4 seconds between axis to allow vehicle to settle
local PILOT_INPUT_DELAY = 4.0       -- gains are not updated for 4 seconds after pilot releases sticks
local FLTD_MUL = 0.5                -- ATC_STR_RAT_FLTD set to 0.5 * INS_GYRO_FILTER
local FLTT_MUL = 0.5                -- ATC_STR_RAT_FLTT set to 0.5 * INS_GYRO_FILTER
local STR_RAT_FF_TURNRATE_MIN = math.rad(10)    -- steering rate feedforward min vehicle turn rate (in radians/sec)
local STR_RAT_FF_STEERING_MIN = 0.10            -- steering rate feedforward min steering output (in the range 0 to 1)
local SPEED_FF_THROTTLE_MIN = 0.20  -- speed feedforward requires throttle output (in the range 0 to 1)

-- get time in seconds since boot
function get_time()
   return millis():tofloat() * 0.001
end

-- local variables
local axis_names = { "ATC_STR_RAT", "ATC_SPEED" }                       -- table of axis that may be tuned
local param_suffixes = { "FF", "P", "I", "D", "FLTT", "FLTD", "FLTE" }  -- table of parameters that may be tuned
local params_extra = {"CRUISE_SPEED", "CRUISE_THROTTLE"}                -- table of extra parameters that may be changed
local last_axis_change = get_time()     -- time (in seconds) that axis last changed
local last_pilot_input = get_time()     -- time pilot last provided RC input
local tune_done_time = nil              -- time that tuning completed (used for auto save feature)
local axes_done = {}                    -- list of axes that have been tuned
local filters_done = {}                 -- table recording if filters have been set for each axis
local gcs_pid_mask_done = {}            -- table recording if GCS_PID_MASK has been set for each axis
local gcs_pid_mask_orig                 -- GCS_PID_MASK value before tuning started

-- feed forward tuning related local variables
local ff_throttle_sum = 0               -- total throttle recorded during speed FF tuning (divided by count to calc average)
local ff_speed_sum = 0                  -- total speed recorded during speed FF tuning (divided by count to calc average)
local ff_speed_count = 0                -- number of speed and throttle samples taken during FF tuning
local ff_steering_sum = 0               -- total steering input recorded during steering rate FF tuning (divided by count to calc average)
local ff_turn_rate_sum = 0              -- total turn rate recorded during steering rate FF tuning (divided by count to calc average)
local ff_turn_rate_count = 0            -- number of steering and turn rate samples taken during FF tuning
local ff_last_warning = 0               -- time of last warning to user

-- params dictionary indexed by name, such as "ATC_STR_RAT_P"
local params = {}                       -- table of all parameters that may be tuned
local params_axis = {}                  -- table of each parameter's axis (used for logging of the appropriate srate)
local param_saved = {}                  -- table holding backup of each parameter's value from before tuning
local param_changed = {}                -- table holding whether each param's gain has been saved
local need_restore = false              -- true if any param's gain has been changed

-- initialise params, params_axis and param_changed tables
function init_params_tables()
  -- add parameters to params dictionary
  for _, axis in ipairs(axis_names) do
    for _, suffix in ipairs(param_suffixes) do
      local pname = axis .. "_" .. suffix
      params[pname] = bind_param(pname)
      params_axis[pname] = axis
      param_changed[pname] = false
    end
  end

  -- add extra parameters to param dictionary
  for _, extra_param_name in ipairs(params_extra) do
    params[extra_param_name] = bind_param(extra_param_name)
    params_axis[extra_param_name] = "ATC_SPEED"  -- axis hard-coded to always be ATC_SPEED
    param_changed[extra_param_name] = false
  end
end

-- initialise all state variables so we are ready to start another tune
function reset_axes_done()
  for _, axis in ipairs(axis_names) do
    axes_done[axis] = false
    filters_done[axis] = false
    gcs_pid_mask_done[axis] = false
  end
  tune_done_time = nil
  init_steering_ff()
  init_speed_ff()
end

-- get all current param values into param_saved dictionary
function get_all_params()
  for pname in pairs(params) do
    param_saved[pname] = params[pname]:get()
  end
end

-- restore all param values from param_saved dictionary
function restore_all_params()
  for pname in pairs(params) do
    if param_changed[pname] then
      params[pname]:set(param_saved[pname])
      param_changed[pname] = false
    end
  end
end

-- save all param values to storage
function save_all_params()
  for pname in pairs(params) do
    if param_changed[pname] then
      params[pname]:set_and_save(params[pname]:get())
      param_saved[pname] = params[pname]:get()
      param_changed[pname] = false
    end
  end
  gcs:send_text(MAV_SEVERITY.NOTICE, "RTun: tuning gains saved")
end

-- setup filter frequencies
function setup_filters(axis)
  if RTUN_AUTO_FILTER:get() > 0 then
    if axis == "ATC_STR_RAT" then
      adjust_gain(axis .. "_FLTT", INS_GYRO_FILTER:get() * FLTT_MUL)
      adjust_gain(axis .. "_FLTD", INS_GYRO_FILTER:get() * FLTD_MUL)
    end
  end
  filters_done[axis] = true
end

-- backup GCS_PID_MASK to value before tuning
function save_gcs_pid_mask()
  gcs_pid_mask_orig = GCS_PID_MASK:get()
end

-- restore GCS_PID_MASK to value before tuning started
function restore_gcs_pid_mask()
  GCS_PID_MASK:set(gcs_pid_mask_orig)
end

-- setup GCS_PID_MASK to provide real-time PID info to GCS during tuning
function setup_gcs_pid_mask(axis)
  if axis == "ATC_STR_RAT" then
    GCS_PID_MASK:set(1)
  elseif axis == "ATC_SPEED" then
    GCS_PID_MASK:set(2)
  else
    gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("RTun: setup_gcs_pid_mask received unhandled aixs %s", axis))
  end
  gcs_pid_mask_done[axis] = true
end

-- check for pilot input to pause tune
function have_pilot_input()
  if (math.abs(RCIN_ROLL:norm_input_dz()) > 0 or
     math.abs(RCIN_THROTTLE:norm_input_dz()) > 0) then
    return true
  end
  return false
end

-- get the axis name we are working on, or nil for all done
function get_current_axis()
  local axes = RTUN_AXES:get()
  for i = 1, #axis_names do
    local mask = (1 << (i-1))
    local axis_name = axis_names[i]
    if (mask & axes) ~= 0 and axes_done[axis_name] == false then
      return axis_names[i]
    end
  end
  return nil
end

-- get slew rate for an axis
function get_slew_rate(axis)
  local steering_srate, speed_srate = AR_AttitudeControl:get_srate()
  if axis == "ATC_STR_RAT" then
    return steering_srate
  end
  if axis == "ATC_SPEED" then
    return speed_srate
  end
  gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("RTUN: get_slew_rate unsupported axis:%s", axis))
  return 0.0
end

-- move to next axis of tune
function advance_axis(axis)
  local now_sec = get_time()
  local prev_axis = get_current_axis()
  axes_done[axis] = true
  -- check for tune completion
  if prev_axis ~= nil and get_current_axis() == nil then
    gcs:send_text(MAV_SEVERITY.NOTICE, string.format("RTun: Tuning DONE"))
    tune_done_time = now_sec
  end
  last_axis_change = now_sec
end

-- change a gain, log and update user
function adjust_gain(pname, value)
  local P = params[pname]
  local old_value = P:get()
  need_restore = true
  param_changed[pname] = true
  P:set(value)
  write_log(pname)
  gcs:send_text(MAV_SEVERITY.INFO, string.format("RTun: adjusted %s %.3f -> %.3f", pname, old_value, value))
end

-- log parameter, current gain and current slew rate
function write_log(pname)
  local param_gain = params[pname]:get()
  local pname_axis = params_axis[pname]
  local slew_rate = get_slew_rate(pname_axis)
  logger:write("RTUN","SRate,Gain,Param", "ffN", slew_rate, param_gain, pname)
end

-- initialise steering ff tuning
function init_steering_ff()
  ff_steering_sum = 0
  ff_turn_rate_sum = 0
  ff_turn_rate_count = 0
end

-- run steering turn rate controller feedforward calibration
-- ff_pname is the FF parameter being tuned
-- returns true once the tuning has completed
function update_steering_ff(ff_pname)
  -- get steering, turn rate, throttle and speed
  local steering_out, _ = vehicle:get_steering_and_throttle()
  local turn_rate_rads = ahrs:get_gyro():z()

  -- update user every 5 sec
  local now_sec = get_time()
  local update_user = false
  if (now_sec > ff_last_warning + 5) then
    update_user = true
    ff_last_warning = now_sec
  end

  -- calculate percentage complete
  local turn_rate_complete_pct = (ff_turn_rate_sum / math.pi * 2.0) * 100
  local time_complete_pct = (ff_turn_rate_count  / (10 * UPDATE_RATE_HZ)) * 100
  local complete_pct = math.min(turn_rate_complete_pct, time_complete_pct)

  -- check steering and turn rate and accumulate output and response
  local steering_ok = steering_out >= STR_RAT_FF_STEERING_MIN
  local turnrate_ok = math.abs(turn_rate_rads) > STR_RAT_FF_TURNRATE_MIN
  if (steering_ok and turnrate_ok) then
    ff_steering_sum = ff_steering_sum + steering_out
    ff_turn_rate_sum = ff_turn_rate_sum + math.abs(turn_rate_rads)
    ff_turn_rate_count = ff_turn_rate_count + 1
    if (update_user) then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("RTun: %s %.0f%% complete", ff_pname, complete_pct))
    end
  else
    if update_user then
      if not steering_ok then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("RTun: increase steering (%d%% < %d%%)", math.floor(steering_out * 100), math.floor(STR_RAT_FF_STEERING_MIN * 100)))
      elseif not turnrate_ok then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("RTun: increase turn rate (%d deg/s < %d)", math.floor(math.deg(math.abs(turn_rate_rads))), math.floor(math.deg(STR_RAT_FF_TURNRATE_MIN))))
      end
    end
  end

  -- check for completion of two rotations of turns data and 10 seconds
  if complete_pct >= 100 then
    local FF_new_gain = (ff_steering_sum / ff_turn_rate_sum) * RTUN_STR_FFRATIO:get()
    adjust_gain(ff_pname, FF_new_gain)

    -- set P gain
    if RTUN_STR_P_RATIO:get() > 0 then
      local pname = string.gsub(ff_pname, "_FF", "_P")
      adjust_gain(pname, FF_new_gain * RTUN_STR_P_RATIO:get())
    end

    -- set I gain
    if RTUN_STR_I_RATIO:get() > 0 then
      local iname = string.gsub(ff_pname, "_FF", "_I")
      adjust_gain(iname, FF_new_gain * RTUN_STR_I_RATIO:get())
    end

    return true
  end

  return false
end

-- initialise speed ff tuning
function init_speed_ff()
  ff_throttle_sum = 0
  ff_speed_sum = 0
  ff_speed_count = 0
end

-- run speed controller feedforward calibration
-- ff_pname is the FF parameter being tuned
-- returns true once the tuning has completed
function update_speed_ff(ff_pname)
  -- get steering, turn rate, throttle and speed
  local _, throttle_out = vehicle:get_steering_and_throttle()
  local velocity_ned = ahrs:get_velocity_NED()
  if velocity_ned then
    speed = ahrs:earth_to_body(velocity_ned):x()
  end

  -- update user every 5 sec
  local now_sec = get_time()
  local update_user = false
  if (now_sec > ff_last_warning + 5) then
    update_user = true
    ff_last_warning = now_sec
  end

  -- calculate percentage complete
  local complete_pct = (ff_speed_count / (10 * UPDATE_RATE_HZ)) * 100

  -- check throttle and speed
  local throttle_ok = throttle_out >= SPEED_FF_THROTTLE_MIN
  local speed_ok = speed > SPEED_FF_SPEED_MIN:get()
  if (throttle_ok and speed_ok) then
    ff_throttle_sum = ff_throttle_sum + throttle_out
    ff_speed_sum = ff_speed_sum + speed
    ff_speed_count = ff_speed_count + 1
    if (update_user) then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("RTun: %s %.0f%% complete", ff_pname, complete_pct))
    end
  else
    if update_user then
      if not throttle_ok then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("RTun: increase throttle (%d < %d)", math.floor(throttle_out * 100), math.floor(SPEED_FF_THROTTLE_MIN * 100)))
      elseif not speed_ok then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("RTun: increase speed (%3.1f < %3.1f)", speed, SPEED_FF_SPEED_MIN:get()))
      end
    end
  end

  -- check for 10 seconds of data
  if complete_pct >= 100 then
    local cruise_speed_new = ff_speed_sum / ff_speed_count
    local cruise_throttle_new = (ff_throttle_sum / ff_speed_count) * 100 * RTUN_SPD_FFRATIO:get()
    adjust_gain("CRUISE_SPEED", cruise_speed_new)
    adjust_gain("CRUISE_THROTTLE", cruise_throttle_new)

    -- calculate FF equivalent gain (used for setting P and I below)
    local speed_ff_equivalent = (ff_throttle_sum / ff_speed_sum) * RTUN_SPD_FFRATIO:get();

    -- set P gain
    if RTUN_SPD_P_RATIO:get() > 0 then
      local pname = string.gsub(ff_pname, "_FF", "_P")
      local P_new_gain = speed_ff_equivalent * RTUN_SPD_P_RATIO:get()
      adjust_gain(pname, P_new_gain)
    end

    -- set I gain
    if RTUN_SPD_I_RATIO:get() > 0 then
      local iname = string.gsub(ff_pname, "_FF", "_I")
      local I_new_gain = speed_ff_equivalent * RTUN_SPD_I_RATIO:get()
      adjust_gain(iname, I_new_gain)
    end

    return true
  end

  return false
end

-- initialisation
init_params_tables()
reset_axes_done()
get_all_params()
save_gcs_pid_mask()
gcs:send_text(MAV_SEVERITY.INFO, "Rover quiktune loaded")

-- main update function
local last_warning = get_time()
function update()

  -- exit immediately if not enabled
  if RTUN_ENABLE:get() <= 0 then
    return
  end

  if have_pilot_input() then
    last_pilot_input = get_time()
  end

  local sw_pos = rc:get_aux_cached(RTUN_RC_FUNC:get())
  if not sw_pos then
    return
  end

  -- get output throttle
  local _, throttle_out = vehicle:get_steering_and_throttle()

  -- check switch position (0:low is stop, 1:middle is tune, 2:high is save gains
  if sw_pos == 1 and (not arming:is_armed() or (throttle_out <= 0)) and get_time() > last_warning + 5 then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "RTun: must be armed and moving to tune")
    last_warning = get_time()
    return
  end
  if sw_pos == 0 or not arming:is_armed() then
    -- abort, revert parameters
    if need_restore then
      need_restore = false
      restore_all_params()
      restore_gcs_pid_mask()
      gcs:send_text(MAV_SEVERITY.CRITICAL, "RTun: gains reverted")
    end
    reset_axes_done()
    return
  end
  if sw_pos == 2 then
    -- save all params
    if need_restore then
      need_restore = false
      save_all_params()
      restore_gcs_pid_mask()
    end
  end

  -- if we reach here we must be tuning
  if sw_pos ~= 1 then
    return
  end

  -- return if we have just changed stages to give time for oscillations to subside
  if get_time() - last_axis_change < AXIS_CHANGE_DELAY then
    return
  end

  -- get axis currently being tuned
  axis = get_current_axis()

  -- if no axis is being tuned we must be done
  if axis == nil then
    -- check if params should be auto saved
    if tune_done_time ~= nil and RTUN_AUTO_SAVE:get() > 0 then
      if get_time() - tune_done_time > RTUN_AUTO_SAVE:get() then
         need_restore = false
         save_all_params()
         restore_gcs_pid_mask()
         tune_done_time = nil
      end
    end
    return
  end

  if not need_restore then
    -- we are just starting tuning, get current values
    get_all_params()
  end

  -- return immediately if pilot has provided input recently
  if get_time() - last_pilot_input < PILOT_INPUT_DELAY then
    return
  end

  -- check filters have been set for this axis
  if not filters_done[axis] then
    gcs:send_text(MAV_SEVERITY.INFO, string.format("RTun: starting %s tune", axis))
    setup_filters(axis)
  end

  -- check GCS_PID_MASK has been set for this axis
  if not gcs_pid_mask_done[axis] then
    setup_gcs_pid_mask(axis)
  end

  -- get parameter currently being tuned
  local pname = axis .. "_FF"

  -- feedforward tuning
  local ff_done
  if axis == "ATC_STR_RAT" then
    ff_done = update_steering_ff(pname)
  elseif axis == "ATC_SPEED" then
    ff_done = update_speed_ff(pname)
  else
    gcs:send_text(MAV_SEVERITY.CRITICAL, string.format("RTun: unsupported FF tuning %s", pname))
    ff_done = true
  end
  if ff_done then
    gcs:send_text(MAV_SEVERITY.NOTICE, string.format("RTun: %s tuning done", pname))
    advance_axis(axis)
  end
end

-- wrapper around update(). This calls update() at 10Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "RTun: Internal Error: " .. err)
    -- when we fault we run the update function again after 1s, slowing it
    -- down a bit so we don't flood the console with errors
    return protected_wrapper, 1000
  end
  return protected_wrapper, 1000/UPDATE_RATE_HZ
end

-- start running update loop
return protected_wrapper()



================================================
File: applets/rover-quicktune.md
================================================
# Rover QuickTune

Rover QuickTune tunes the steering (aka turn rate) and speed controller gains for rovers and boats

The script is designed to be used in Circle mode and updates the following parameters

ATC_STR_RAT_P
ATC_STR_RAT_I
ATC_STR_RAT_D
ATC_STR_RAT_FF
ATC_STR_RAT_FLTD
ATC_STR_RAT_FLTT
ATC_SPEED_P
ATC_SPEED_I
ATC_SPEED_D
CRUISE_SPEED
CRUISE_THROTTLE

# How To Use
Install this script in the autopilot's SD card's APM/scripts directory
Set SCR_ENABLE to 1 and reboot the autopilot
Set RTUN_ENABLE to 1 (default)

Set RCx_OPTION = 300 where "x" refers to the transmitter's 2 or 3 position switch
use to start/stop/save tuning.  E.g. if channel 6 is used set RC6_OPTION = 300

If necessary, the RTUN_RC_FUNC parameter can be set to another number (e.g. 302 for scripting3)
to avoid RCx_OPTION conflicts with other scripts.

By default the tune is saved a few seconds after completion.  To control saving of the tune manually set RTUN_AUTO_SAVE to 0

Arm the vehicle and switch to Circle mode
Optionally set CIRC_SPEED (or WP_SPEED) to about half the vehicle's max speed
Optionally set CIRC_RADIUS to a value at least twice the vehicle's turning radius
Note the above parmaters only take effect when the vehicle is switched into Circle mode

Move the RC switch to the middle position to begin the tuning process.
Text messages should appear on the ground station's messages area showing progress

During tuning the steering or throttle output are compared to the response for at least 10 seconds.
A message may appear stating the steering, turn rate, throttle or speed are too low in which case
the vehicle speed should be increased (Mission Planner's Action tab "Change Speed" button may be used)
or the radius should be reduced.

By default the gains will be tuned in this order:

- ATC_STR_RAT_FF, then ATC_STR_RAT_P and I are set to ratios of the FF
- CRUISE_SPEED and CRUISE_THROTTLE, then ATC_SPEED_P and I are set to ratios of the FF

The script will also adjust filter settings:

 - ATC_STR_RAT_FLTD and FLTT will be set to half of the INS_GYRO_FILTER value

Once tuning is complete "RTUN: tuning done" will be displayed
Save the tune by raising the RC switch to the high position

If the RC switch is moved high (ie. Save Tune) before the tune is completed the tune will pause, and any parameters completed will be saved and the current value of the one being actively tuned will remain active. You can resume tuning by returning the switch again to the middle position.  If the RC switch is moved to the low position, the parameter currently being tuned will be reverted but any previously saved parameters will remain.

If you move the switch to the low position at any time in the tune before gains are saved, then all parameters will be reverted to their original values. Parameters will also be reverted if you disarm before saving.

If the pilot gives steering or throttle input during tuning then tuning is paused for 4 seconds.  Tuning restarts once the pilot returns to the input to the neutral position.

If the vehicle is not able to turn correctly to enter or track the circle, the ``PSC`` parameters may be to be increased. For example ``PSC_VEL_P`` to 20 for very slow (<0.4m/s) vehicles.

# Parameters

The script has the following parameters to configure its behaviour

## RTUN_ENABLE

Set to 1 to enable the script

## RTUN_RC_FUNC

The RCx_OPTIONS function number to be used to start/stop tuning
By default RCx_OPTIONS of 300 (scripting1) is used

## RTUN_AXES

The axes that will be tuned. The default is 3 meaning steering and speed
This parameter is a bitmask, so set 1 to tune just steering.  2 for just speed

## RTUN_STR_FFRATIO

Ratio between measured response and FF gain. Raise this to get a higher FF gain
The default of 0.9 is good for most users.

## RTUN_STR_P_RATIO

Ratio between steering FF and P gains. Raise this to get a higher P gain, 0 to leave P unchanged
The default of 0.2 is good for most users.

## RTUN_STR_I_RATIO

Ratio between steering FF and I gains. Raise this to get a higher I gain, 0 to leave I unchanged
The default of 0.2 is good for most users.

## RTUN_SPD_FFRATIO

Ratio between measured response and CRUISE_THROTTLE value. Raise this to get a higher CRUISE_THROTTLE value
The default of 1.0 is good for most users.

## RTUN_SPD_P_RATIO

Ratio between speed FF and P gain. Raise this to get a higher P gain, 0 to leave P unchanged
The default of 1.0 is good for most users.

## RTUN_SPD_I_RATIO

Ratio between speed FF and I gain. Raise this to get a higher I gain, 0 to leave I unchanged
The default of 1.0 is good for most users.

## RTUN_AUTO_FILTER

This enables automatic setting of the PID filters based on the
INS_GYRO_FILTER value. Set to zero to disable this feature.

## RTUN_AUTO_SAVE

Enables automatic saving of the gains this many seconds after the tuning
completes unless the pilot move the RC switch low to revert the tune.
Setting this to a non-zero value allows you to use quicktune with a 2-position
switch, with the switch settings as low and mid positions. A zero
value disables auto-save and you need to have a 3 position switch.

## RTUN_SPEED_MIN

The minimum speed at which tuning will occur. The vehicle must be able to
run in Circle mode at this speed or greater.


================================================
File: applets/runcam_on_arm.lua
================================================
-- runcam_on_arm.lua: start and stop video recording on arm/disarm
--
-- ArduPilot can turn a RUNCAM on and off with a TX switch if you set
-- its function to 78:RunCamControl. This script uses
-- `rc:run_aux_function()' to start and stop the camera without human
-- intervention or a separate RC channel.
--
-- An interesting aspect of this script is variable rescheduling
-- time. RUNCAM serial protocol controls the camera by simulating a
-- button press both to start and stop recording--it's the same
-- button. If you send commands faster than the camera can process
-- them, it can ignore a command and interpret the next one as the
-- opposite of what you intend, e.g., you may lose a button press to
-- stop recording, and the camera keeps rolling; when you're ready to
-- start recording again, the camera interprets your button press as a
-- command to stop recording. To address this, AP has a special
-- parameter, `CAM_RC_BTN_DELAY'. I use this parameter as the
-- rescheduling delay after a button press. But between button
-- presses, I want the script to be responsive and start recording as
-- soon as the vehicle arms, so there I use a shorter delay.



-- constants
local RC_OPTION = {RunCamControl=78}
local AuxSwitchPos = {LOW=0, MIDDLE=1, HIGH=2}
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- configuration
local DELAY_LONG = param:get("CAM_RC_BTN_DELAY")
if not DELAY_LONG then
   gcs:send_text(MAV_SEVERITY.ERROR, "CAM_RC_* parameters missing; camera autoarming unavailable")
   return
end
local DELAY_SHORT = DELAY_LONG / 3


gcs:send_text(MAV_SEVERITY.NOTICE, "Arming controls RUNCAM recording")


-- state
local prev_armed = false

function update()
   local is_armed = arming:is_armed()

   local delay = DELAY_SHORT
   if is_armed ~= prev_armed then
      -- a state transition has occurred
      if is_armed then
         gcs:send_text(MAV_SEVERITY.INFO, "RUNCAM on")
         rc:run_aux_function(RC_OPTION.RunCamControl, AuxSwitchPos.HIGH)
      else
         gcs:send_text(MAV_SEVERITY.INFO, "RUNCAM off")
         rc:run_aux_function(RC_OPTION.RunCamControl, AuxSwitchPos.LOW)
      end
      delay = DELAY_LONG
   end

   prev_armed = is_armed

   return update, delay
end

return update()




================================================
File: applets/runcam_on_arm.md
================================================
# `runcam_on_arm.lua`: start and stop video recording on arm/disarm

ArduPilot can control RunCam devices out of the box.
Normally, you use a 2-position switch with `RCx_OPTION=78:RunCamControl` to start and stop video recording.
This applet starts recording automatically when your vehicle arms and stops on disarm.

Information on setting up RunCam devices with ArduPilot is on this page: https://ardupilot.org/plane/docs/common-camera-runcam.html
You need a free serial port.
You need to set these three parameters: `SERIALx_PROTOCOL=26`, `SERIALx_BAUD=115` (where `x` is your serial port) and `CAM_RC_TYPE=y` where `y` depends on the RunCam model you are using.
You do not need to configure any `RCx_OPTION`s.

## If camera commands get out of sync

RUNCAM serial protocol controls the camera by simulating a button press both to start and stop recording--it's the same button.
If you send commands faster than the camera can process them, it can ignore a command and interpret the next one as the opposite of what you intend, e.g., you may lose a button press to stop recording, and the camera keeps rolling; when you're ready to start recording again, the camera interprets your button press as a
command to stop recording.
To address this, AP has a special parameter, `CAM_RC_BTN_DELAY`, that controls minimum time between simulated button presses.
If you find your commands getting out of sync--camera starting when you want it to stop--try increasing this value.
I find that with my RunCam Split HD, the default 300ms is inadequate, and 1500ms gives reliable performance.



================================================
File: applets/video-stream-information.lua
================================================
 --[[
    Populate the VIDEO_STREAM_INFORMATION message based on user parameters
 --]]

local PARAM_TABLE_KEY = 90
local PARAM_TABLE_PREFIX = "VID1_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local VID_TYPE_ENUM = {RTSP=0, RTPUDP=1, TCP_MPEG=2, MPEG_TS=3}
local CAMMODEL_ENUM = {UNKNOWN=0, SIYI_A8=1, SIYI_ZR10=2, SIYI_ZR30=3, SIYI_ZT30_ZOOM=4, SIYI_ZT30_WIDE=5,
                       SIYI_ZT30_IR=6, SIYI_ZT6_RGB=7, SIYI_ZT6_IR=8, HERELINK_WIFIAP=9, HERELINK_USB_TETHERING=10,
                       TOPOTEK_1080P=11, TOPOTEK_480P=12, VIEWPRO=13}
local TEXT_PREFIX_STR = "video-stream-information:"
local SIYI_IP_DEFAULT = '192.168.144.25:8554'
local TOPOTEK_IP_DEFAULT = '192.168.144.108:554'
local VIEWPRO_IP_DEFAULT = '192.168.2.119:554'

 -- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add param table')

--[[
  // @Param: VID1_CAMMODEL
  // @DisplayName: Camera1 Video Stream Camera Model
  // @Description: Video stream camera model
  // @Values: 0:Unknown, 1:Siyi A8, 2:Siyi ZR10, 3:Siyi ZR30, 4:Siyi ZT30 Zoom, 5:Siyi ZT30 Wide, 6:Siyi ZT30 IR, 7:Siyi ZT6 RGB, 8:Siyi ZT6 IR, 9:Herelink WifiAP, 10:Herelink USB-tethering, 11:Topotek 1080p, 12:Topotek 480p, 13:Viewpro
  // @User: Standard
--]]
-- values should match CAMMODEL_ENUM
local VID1_CAMMODEL = bind_add_param('CAMMODEL', 1, 0)

--[[
  // @Param: VID1_ID
  // @DisplayName: Camera1 Video Stream Id
  // @Description: Video stream id
  // @Range: 0 50
  // @User: Standard
--]]
local VID1_ID = bind_add_param('ID', 2, 1)

--[[
  // @Param: VID1_TYPE
  // @DisplayName: Camera1 Video Stream Type
  // @Description: Video stream type
  // @Values: 0:RTSP, 1:RTPUDP, 2:TCP_MPEG, 3:MPEG_TS
  // @User: Standard
--]]
-- values should match VID_TYPE_ENUM
local VID1_TYPE = bind_add_param('TYPE', 3, 0)

--[[
  // @Param: VID1_FLAG
  // @DisplayName: Camera1 Video Stream Flags
  // @Description: Video stream flags
  // @Bitmask: 0:Running,1:Thermal,2:Thermal Range Enabled
  // @User: Standard
--]]
local VID1_FLAG = bind_add_param('FLAG', 4, 1)

--[[
  // @Param: VID1_FRAME_RATE
  // @DisplayName: Camera1 Video Stream Frame Rate
  // @Description: Video stream frame rate
  // @Range: 0 50
  // @User: Standard
--]]
local VID1_FR = bind_add_param('FRAME_RATE', 5, 30)

--[[
  // @Param: VID1_HRES
  // @DisplayName: Camera1 Video Stream Horizontal Resolution
  // @Description: Video stream horizontal resolution
  // @Range: 0 4096
  // @User: Standard
--]]
local VID1_HRES = bind_add_param('HRES', 6, 1920)

--[[
  // @Param: VID1_VRES
  // @DisplayName: Camera1 Video Stream Vertical Resolution
  // @Description: Video stream vertical resolution
  // @Range: 0 4096
  // @User: Standard
--]]
local VID1_VRES = bind_add_param('VRES', 7, 1080)

 --[[
  // @Param: VID1_BITRATE
  // @DisplayName: Camera1 Video Stream Bitrate
  // @Description: Video stream bitrate
  // @Range: 0 10000
  // @User: Standard
--]]
local VID1_BITR = bind_add_param('BITRATE', 8, 1500)

--[[
  // @Param: VID1_HFOV
  // @DisplayName: Camera1 Video Stream Horizontal FOV
  // @Description: Video stream horizontal FOV
  // @Range: 0 360
  // @User: Standard
--]]
local VID1_HFOV = bind_add_param('HFOV', 9, 0)

--[[
  // @Param: VID1_ENCODING
  // @DisplayName: Camera1 Video Stream Encoding
  // @Description: Video stream encoding
  // @Values: 0:Unknown, 1:H264, 2:H265
  // @User: Standard
--]]
local VID1_ENCODING = bind_add_param('ENCODING', 10, 1)

--[[
  // @Param: VID1_IPADDR0
  // @DisplayName: Camera1 Video Stream IP Address 0
  // @Description: Video stream IP Address first octet
  // @Range: 0 255
  // @User: Standard
--]]
local VID1_IPADDR0 = bind_add_param('IPADDR0', 11, -1)

--[[
  // @Param: VID1_IPADDR1
  // @DisplayName: Camera1 Video Stream IP Address 1
  // @Description: Video stream IP Address second octet
  // @Range: 0 255
  // @User: Standard
--]]
local VID1_IPADDR1 = bind_add_param('IPADDR1', 12, -1)

--[[
  // @Param: VID1_IPADDR2
  // @DisplayName: Camera1 Video Stream IP Address 2
  // @Description: Video stream IP Address third octet
  // @Range: 0 255
  // @User: Standard
--]]
local VID1_IPADDR2 = bind_add_param('IPADDR2', 13, -1)

--[[
  // @Param: VID1_IPADDR3
  // @DisplayName: Camera1 Video Stream IP Address 3
  // @Description: Video stream IP Address fourth octet
  // @Range: 0 255
  // @User: Standard
--]]
local VID1_IPADDR3 = bind_add_param('IPADDR3', 14, -1)

--[[
  // @Param: VID1_IPPORT
  // @DisplayName: Camera1 Video Stream IP Address Port
  // @Description: Video stream IP Address Port
  // @Range: 0 65535
  // @User: Standard
--]]
local VID1_IPPORT = bind_add_param('IPPORT', 15, -1)

function set_video_stream_information()
    local INSTANCE = 0
    local name = 'Video'

    -- set defaults by camera model
    local uri_ip = ''
    local uri_suffix = ''
    local hfov = 50
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_A8 then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/main.264'
        hfov = 81
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZR10 then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/main.264'
        hfov = 62
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZR30 then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/main.264'
        hfov = 58
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZT30_ZOOM then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/video2'
        hfov = 58
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZT30_WIDE then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/video2'
        hfov = 85
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZT30_IR then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/video1'
        hfov = 24
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZT6_RGB then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/video2'
        hfov = 85
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.SIYI_ZT6_IR then
        uri_ip = SIYI_IP_DEFAULT
        uri_suffix = '/video1'
        hfov = 32
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.HERELINK_WIFIAP then
        uri_ip = '192.168.42.1:8554'
        uri_suffix = '/fpv_stream'
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.HERELINK_USB_TETHERING then
        uri_ip = '192.168.42.129:8554'
        uri_suffix = '/fpv_stream'
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.TOPOTEK_1080P then
        uri_ip = TOPOTEK_IP_DEFAULT
        uri_suffix = '/stream=0'
        hfov = 50
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.TOPOTEK_480P then
        uri_ip = TOPOTEK_IP_DEFAULT
        uri_suffix = '/stream=1'
        hfov = 50
    end
    if VID1_CAMMODEL:get() == CAMMODEL_ENUM.VIEWPRO then
        uri_ip = VIEWPRO_IP_DEFAULT
    end

    -- calculate hfov
    if VID1_HFOV:get() ~= 0 then
        hfov = VID1_HFOV:get()
    end

    -- construct uri
    if VID1_IPADDR0:get() > 0 or VID1_IPADDR1:get() > 0 or
       VID1_IPADDR2:get() > 0 or VID1_IPADDR3:get() > 0 or
       VID1_IPPORT:get() > 0 then
        uri_ip = math.floor(VID1_IPADDR0:get()) .. '.' ..
                 math.floor(VID1_IPADDR1:get())  .. '.' ..
                 math.floor(VID1_IPADDR2:get())  .. '.' ..
                 math.floor(VID1_IPADDR3:get())  .. ':' ..
                 math.floor(VID1_IPPORT:get())
    end
    local uri
    if VID1_TYPE:get() == VID_TYPE_ENUM.RTPUDP or VID1_TYPE:get() == VID_TYPE_ENUM.MPEG_TS then
        -- sanity check port number
        if VID1_IPPORT:get() < 0 then
          gcs:send_text(MAV_SEVERITY.ERROR, TEXT_PREFIX_STR .. "check VID1_IPPORT")
          do return end
        end
        uri = tostring(math.floor(VID1_IPPORT:get()))
    elseif VID1_TYPE:get() == VID_TYPE_ENUM.RTSP then
        -- sanity check IP address
        if uri_ip == '' then
          gcs:send_text(MAV_SEVERITY.ERROR, TEXT_PREFIX_STR .. "check VID1_IPADDR params")
          do return end
        end
        uri = 'rtsp://' .. uri_ip .. uri_suffix
    else
        uri = uri_ip .. uri_suffix
    end

    -- create Video Stream Information message
    local stream_info = mavlink_video_stream_information_t()
    stream_info:stream_id(VID1_ID:get())
    stream_info:count(1)    -- hard coded to just a single stream
    stream_info:type(VID1_TYPE:get())
    stream_info:flags(VID1_FLAG:get())
    stream_info:framerate(VID1_FR:get())
    stream_info:resolution_h(VID1_HRES:get())
    stream_info:resolution_v(VID1_VRES:get())
    stream_info:bitrate(VID1_BITR:get())
    stream_info:rotation(0) -- video image rotation clockwise, hardcoded to zero
    stream_info:hfov(hfov)
    stream_info:encoding(VID1_ENCODING:get())

    for i = 0, #name do
        stream_info:name(i, name:byte(i+1))
    end
    for i = 0, #uri do
        stream_info:uri(i, uri:byte(i+1))
    end

    -- update camera library with the latest stream information
    camera:set_stream_information(INSTANCE, stream_info)
end

-- print welcome message
gcs:send_text(MAV_SEVERITY.INFO, "video-stream-information script loaded")

-- update function runs every 5 secs
function update()
  set_video_stream_information()
  return update, 5000
end

return update()



================================================
File: applets/video-stream-information.md
================================================
# Video Stream Information

This script updates the ArduPilot Camera library with the values required to populate the VIDEO_STREAM_INFORMATION
mavlink message allow the GCS to find and display live video to the user

# Parameters

- VID1_CAMMODEL: Video stream camera model (1:Siyi A8, 2:Siyi ZR10, 3:Siyi ZR30, 4:Siyi ZT30 Zoom, 5:Siyi ZT30 Wide, 6:Siyi ZT30 IR, 7:Siyi ZT6 RGB, 8:Siyi ZT6 IR, 9:Herelink WifiAP, 10:Herelink USB-tethering, 11:Topotek 1080p, 12:Topotek 480p, 13:Viewpro)
- VID1_ID: Video stream id
- VID1_TYPE: Video stream type (0:RTSP, 1:RTPUDP, 2:TCP_MPEG, 3:MPEG_TS)
- VID1_FLAG: Video stream flags (Bitmask: 0:Running,1:Thermal,2:Thermal Range Enabled)
- VID1_FRAME_RATE: Video stream frame rate
- VID1_HRES: Video stream horizontal resolution
- VID1_VRES: Video stream vertical resolution
- VID1_BITR: Video stream bitrate
- VID1_HFOV: Video stream horizontal FOV in degrees
- VID1_ENCODING: Video stream encoding (0:Unknown, 1:H264, 2:H265)
- VID1_IPADDR0: Video stream IP Address first octet
- VID1_IPADDR1: Video stream IP Address second octet
- VID1_IPADDR2: Video stream IP Address third octet
- VID1_IPADDR3: Video stream IP Address fourth octet
- VID1_IPPORT: Video Stream IP Address Port

# How To Use

1. Setup the camera gimbal as described on the ArduPilot wiki including ethernet setup
2. Check the IP address of the camera gimbal
3. Setup scripting per https://ardupilot.org/plane/docs/common-lua-scripts.html and reboot the autopilot
4. Copy this script to the vehicle autopilot's "scripts" directory
5. Set the VID1_CAMMODEL parameter to the camera gimbal model and adjust the new VID1 params as required
6. If necessary using the GCS's mavlink inspector to confirm the VIDEO_STREAM_INFORMATION URI field is correct
7. Confirm the ground station can display the live video



================================================
File: applets/winch-control.lua
================================================
-- winch-control.lua: allows the winch to be deployed or retracted at a fixed speed using an auxiliary switch
--
-- How To Use
--   1. set RCx_OPTION to 300 to enable controlling the winch rate from an auxiliary switch
--   2. set WINCH_RATE_UP to the fixed retract speed (in m/s)
--   3. set WINCH_RATE_DN to the fixed deploy speed (in m/s)
--   4. raise the RC auxiliary switch to retract the winch's line
--   5. lower the RC auxiliary switch to deploy the winch's line
--   6. center the RC auxiliary switch to stop the winch
-- Alternatively Mission Planner's Aux Function screen can be used in place of an actual RC switch
--

---@diagnostic disable: param-type-mismatch


-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local PARAM_TABLE_KEY = 80
local PARAM_TABLE_PREFIX = "WINCH_"

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format("WinchControl: could not find %s parameter", name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format("WinchControl: could not add param %s", name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup quicktune specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), "WinchControl: could not add param table")

--[[
  // @Param: WINCH_RATE_UP
  // @DisplayName: WinchControl Rate Up
  // @Description: Maximum rate when retracting line
  // @Range: 0.1 5.0
  // @User: Standard
--]]
local WINCH_RATE_UP = bind_add_param('RATE_UP', 1, 0.5)

--[[
  // @Param: WINCH_RATE_DN
  // @DisplayName: WinchControl Rate Down
  // @Description: Maximum rate when releasing line
  // @Range: 0.1 5.0
  // @User: Standard
--]]
local WINCH_RATE_DN = bind_add_param('RATE_DN', 2, 2.0)

--[[
  // @Param: WINCH_RC_FUNC
  // @DisplayName: Winch Rate Control RC function
  // @Description: RCn_OPTION number to use to control winch rate
  // @Values: 300:Scripting1, 301:Scripting2, 302:Scripting3, 303:Scripting4, 304:Scripting5, 305:Scripting6, 306:Scripting7, 307:Scripting8
  // @User: Standard
--]]
local WINCH_RC_FUNC = bind_add_param('RC_FUNC', 3, 300)

-- local variables and definitions
local UPDATE_INTERVAL_MS = 100
local last_rc_switch_pos = -1   -- last known rc switch position.  Used to detect change in RC switch position

-- initialisation
gcs:send_text(MAV_SEVERITY.INFO, "WinchControl: started")

-- the main update function
function update()

  -- get RC switch position
  local rc_switch_pos = rc:get_aux_cached(WINCH_RC_FUNC:get())
  if not rc_switch_pos then
    -- if rc switch has never been set the return immediately
    return update, UPDATE_INTERVAL_MS
  end

  -- initialise RC switch at startup
  if last_rc_switch_pos == -1 then
    last_rc_switch_pos = rc_switch_pos
  end

  -- check if user has moved RC switch
  if rc_switch_pos == last_rc_switch_pos then
    return update, UPDATE_INTERVAL_MS
  end
  last_rc_switch_pos = rc_switch_pos

  -- set winch rate based on switch position
  if rc_switch_pos == 0 then -- LOW, deploy winch line
    local rate_dn = math.abs(WINCH_RATE_DN:get())
    winch:set_desired_rate(rate_dn)
    gcs:send_text(6, string.format("Winch: lowering at %.1f m/s", rate_dn))
  end
  if rc_switch_pos == 1 then -- MIDDLE, stop winch
    winch:set_desired_rate(0)
    gcs:send_text(6, "Winch: stopped")
  end
  if rc_switch_pos == 2 then -- HIGH, retract winch line
    local rate_up = math.abs(WINCH_RATE_UP:get())
    winch:set_desired_rate(-rate_up)
    gcs:send_text(6, string.format("Winch: raising at %.1f m/s", rate_up))
  end

  return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: applets/winch-control.md
================================================
# Winch Control

Allows the winch to be deployed or retracted at a fixed speed using an auxiliary switch

# Parameters

WINCH_RATE_UP : rate (in m/s) when retracting line
WINCH_RATE_DN : rate (in m/s) when deploying line
WINCH_RC_FUNC : RCn_OPTION number to use to control winch rate. Default is 300 (Scripting1)

# How To Use

1. set RCx_OPTION to 300 to enable controlling the winch rate from an auxiliary switch
2. set WINCH_RATE_UP to the fixed retract speed (in m/s)
3. set WINCH_RATE_DN to the fixed release speed (in m/s)
4. raise the RC auxiliary switch to retract the winch's line
5. lower the RC auxiliary switch to deploy the winch's line
6. center the RC auxiliary switch to stop the winch

Alternatively Mission Planner's Aux Function screen can be used in place of an actual RC switch



================================================
File: applets/x-quad-cg-allocation.lua
================================================
-- x-quad-cg-allocation.lua: Adjust the control allocation matrix for offset CoG.
--
-- WARNING: This script is applicable only to X-type quadrotors and quadplanes.
--
-- How To Use
--   1. Place this script in the "scripts" directory.
--   2. Set FRAME_CLASS or Q_FRAME_CLASS to 17 to enable the dynamic scriptable mixer.
--   3. Enable Lua scripting via the SCR_ENABLE parameter.
--   4. Reboot.
--   5. Fly the vehicle.
--   6. Adjust the value of the CGA_RATIO parameter.
--
-- How It Works
--   1. The control allocation matrix is adjusted for thrust and pitch based on the ??? parameter value.

--[[
Global definitions.
--]]
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local SCRIPT_NAME = "CoG adjust script"
local LOOP_RATE_HZ = 10
local last_warning_time_ms = uint32_t() -- Time we last sent a warning message to the user.
local WARNING_DEADTIME_MS = 1000 -- How often the user should be warned.
local is_mixer_matrix_static = false
local is_mixer_matrix_dynamic = false
local last_ratio = 1

-- State machine states.
local FSM_STATE = {
    INACTIVE = 0,
    INITIALIZE = 1,
    ACTIVE = 2,
    FINISHED = 3
}
local current_state = FSM_STATE.INACTIVE
local next_state = FSM_STATE.INACTIVE


--[[
New parameter declarations
--]]
local PARAM_TABLE_KEY = 139
local PARAM_TABLE_PREFIX = "CGA_"

-- Bind a parameter to a variable.
function bind_param(name)
    return Parameter(name)
end

-- Add a parameter and bind it to a variable.
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('Could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- Add param table.
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 1), SCRIPT_NAME .. ': Could not add param table.')

--[[
  // @Param: CGA_RATIO
  // @DisplayName: CoG adjustment ratio
  // @Description: The ratio between the front and back motor outputs during steady-state hover. Positive when the CoG is in front of the motors midpoint (front motors work harder).
  // @Range: 0.5 2
  // @User: Advanced
--]]
CGA_RATIO = bind_add_param('RATIO', 1, 1)

-- Bindings to existing parameters

--[[
Potential additions:
--]]
-- Warn the user, throttling the message rate.
function warn_user(msg, severity)
    severity = severity or MAV_SEVERITY.WARNING -- Optional severity argument.
    if millis() - last_warning_time_ms > WARNING_DEADTIME_MS then
            gcs:send_text(severity, SCRIPT_NAME .. ": " .. msg)
        last_warning_time_ms = millis()
    end
end

-- Decide if the given ratio value makes sense.
function sanitize_ratio(ratio)
    if (ratio < 0.5) or (ratio > 2) then
        warn_user("CGA_RATIO value out of bounds.", MAV_SEVERITY.ERROR)
        CGA_RATIO:set(1.0)
        return 1.0 -- Return default.
    else
        return ratio
    end
end

-- Normalize the throttle factors to max 1
function normalize_throttle(factors)
    -- Find maximum value.
    local max_factor = 0
    for _, factor in ipairs(factors) do
        max_factor = math.max(max_factor, factor)
    end
    -- Adjust all values by it.
    normalized_factors = {}
    for _, factor in ipairs(factors) do
        table.insert(normalized_factors, factor / max_factor)
    end
    return normalized_factors
end

-- Calculate the thrust factors given a ratio.
function build_factors(ratio)
    local r1 = 2.0/(1+ratio)
    local r2 = 2.0*ratio/(1+ratio)
    local quad_x_factors = {r2, r1, r2, r1}
    return normalize_throttle(quad_x_factors)
end

-- Adjust the dynamic motor mixer.
function update_dynamic_mixer(ratio)

    Motors_dynamic:add_motor(0, 1)
    Motors_dynamic:add_motor(1, 3)
    Motors_dynamic:add_motor(2, 4)
    Motors_dynamic:add_motor(3, 2)

    factors = motor_factor_table()

    -- Roll stays as-is.
    factors:roll(0, -0.5)
    factors:roll(1,  0.5)
    factors:roll(2,  0.5)
    factors:roll(3, -0.5)

    -- Pitch stays as-is.
    factors:pitch(0, 0.5)
    factors:pitch(1, -0.5)
    factors:pitch(2, 0.5)
    factors:pitch(3, -0.5)

    -- Yaw stays as-is.
    factors:yaw(0,  0.5)
    factors:yaw(1,  0.5)
    factors:yaw(2, -0.5)
    factors:yaw(3, -0.5)

    -- Throttle is modulated.
    throttle_factors = build_factors(ratio)
    factors:throttle(0, throttle_factors[1])
    factors:throttle(1, throttle_factors[2])
    factors:throttle(2, throttle_factors[3])
    factors:throttle(3, throttle_factors[4])

    Motors_dynamic:load_factors(factors)

    if not Motors_dynamic:init(4) then
        warn_user("Failed to initialize motor matrix!", MAV_SEVERITY.EMERGENCY)
    else
        if ratio ~= last_ratio then
            warn_user("Set ratio to " .. tostring(ratio), MAV_SEVERITY.INFO)
            last_ratio = ratio
        end
    end
    motors:set_frame_string("Dynamic CoM adjust")

end

-- Adjust the static motor mixer.
function update_static_mixer(ratio)
    MotorsMatrix:add_motor_raw(0,-0.5, 0.5, 0.5, 2)
    MotorsMatrix:add_motor_raw(1, 0.5,-0.5, 0.5, 4)
    MotorsMatrix:add_motor_raw(2, 0.5, 0.5,-0.5, 1)
    MotorsMatrix:add_motor_raw(3,-0.5,-0.5,-0.5, 3)

    throttle_factors = build_factors(ratio)
    MotorsMatrix:set_throttle_factor(0, throttle_factors[1])
    MotorsMatrix:set_throttle_factor(1, throttle_factors[2])
    MotorsMatrix:set_throttle_factor(2, throttle_factors[3])
    MotorsMatrix:set_throttle_factor(3, throttle_factors[4])

    if not MotorsMatrix:init(4) then
        warn_user("Failed to initialize motor matrix!", MAV_SEVERITY.EMERGENCY)
    else
        if ratio ~= last_ratio then
            warn_user("Set ratio to " .. tostring(ratio), MAV_SEVERITY.INFO)
            last_ratio = ratio
        end
    end
    motors:set_frame_string("Static CoM adjust")
end

-- Decide if the UA is a Quad X quadplane.
function inspect_frame_class_fw()

    Q_ENABLE = bind_param("Q_ENABLE")
    Q_FRAME_CLASS = bind_param("Q_FRAME_CLASS")

    if FWVersion:type()==3 then
        -- Test for the validity of the parameters.
        if Q_ENABLE:get()==1 then
            if Q_FRAME_CLASS:get()==15 then
                is_mixer_matrix_static = true
            elseif Q_FRAME_CLASS:get()==17 then
                is_mixer_matrix_dynamic = true
            end
        end
    end
end

-- Decide if the UA is a Quad X multicopter.
function inspect_frame_class_mc()

    FRAME_CLASS = bind_param("FRAME_CLASS")

    if FWVersion:type()==2 then 
        if FRAME_CLASS:get()==15 then
            is_mixer_matrix_static = true
        elseif FRAME_CLASS:get()==17 then
            is_mixer_matrix_dynamic = true
        end
    end
end

--[[
Activation conditions
--]]
-- Check for script activating conditions here.
-- Check frame types.
function can_start()
    result = is_mixer_matrix_static or is_mixer_matrix_dynamic
    return result
end

--[[
State machine
--]]
function fsm_step()
    if current_state == FSM_STATE.INACTIVE then
        if can_start() then
            next_state = FSM_STATE.INITIALIZE
        else
            next_state = FSM_STATE.FINISHED
            warn_user("Could not find scriptable mixer", MAV_SEVERITY.ERROR)
        end

    elseif current_state == FSM_STATE.INITIALIZE then
        if is_mixer_matrix_static then
            local ratio = sanitize_ratio(CGA_RATIO:get())
            update_static_mixer(ratio)
            next_state = FSM_STATE.FINISHED
        else
            next_state = FSM_STATE.ACTIVE
        end

    elseif current_state == FSM_STATE.ACTIVE then
        -- Assert the parameter limits.
        local ratio = sanitize_ratio(CGA_RATIO:get())
        -- Create the control allocation matrix parameters.
        update_dynamic_mixer(ratio)
        
    else
        gcs:send_text(MAV_SEVERITY.CRITICAL, "Unexpected FSM state!")
    end

    current_state = next_state
end

-- Check once on boot if the frame type is suitable for this script.
pcall(inspect_frame_class_mc)
pcall(inspect_frame_class_fw)
gcs:send_text(MAV_SEVERITY.INFO, SCRIPT_NAME .. string.format(" loaded."))

-- Wrapper around update() to catch errors.
function protected_wrapper()
  local success, err = pcall(fsm_step)
  if not success then
    gcs:send_text(MAV_SEVERITY.EMERGENCY, "Internal Error: " .. err)
    return protected_wrapper, 1000
  end
  if current_state ~= FSM_STATE.FINISHED then
    return protected_wrapper, 1000.0/LOOP_RATE_HZ
  end
end

-- Start running update loop
return protected_wrapper()



================================================
File: applets/x-quad-cg-allocation.md
================================================
# Multicopter CoM compensation

This script allows for adjusting the control allocation matrix.

When the Center of Mass (CoM) of an airframe does not coincide with the center
of its thrusters, then there is a lever arm between the thrust vector and the
CoM. This often is the case in VTOL fixed-wing aircraft (quadplanes) where
typically the CoM is more forward than the center of thrust. As a result, the
thrust produces a pitch-down moment. This produces a disturbance in the pitch
control and requires significant wind-up in the pitch integrator.

To compensate for this issue, this script employs the scriptable control
allocation matrix to request asymmeterical front and back thrust.

WARNING: This script is applicable only to X-type quadrotors and quadplanes. Do
not use in any other frame configuration!

# Parameters

The script adds 1 parameter to control its behaviour.

## CGA_RATIO

This is the desired ratio between the front and back thrust. To have the front
motors produce more lift that the rear, increase higher than 1.

Reasonable extreme values are 2 (front works twice as hard as the rear) and 0.5
(the inverse case). Given an out-of-bounds parameter value, the script will
revert to the default 1.0. 

# Operation

## How To Use

First of all, place this script in the "scripts" directory.

To tune `CGA_RATIO` on the fly:

  1. Set `FRAME_CLASS` or `Q_FRAME_CLASS` (for quadplanes) to 17 to enable the
  dynamic scriptable mixer.
  2. Enable Lua scripting via the `SCR_ENABLE` parameter.
  3. Reboot.
  4. Fly the vehicle.
  5. Adjust the value of the `CGA_RATIO` parameter. A good indicator of a good
  tune is to monitor the telemetry value `PID_TUNE[2].I` (pitch rate controller
  integrator) until it reaches zero during a stable hover.

Once you are happy with the tuning, you can fall back to the static motor
matrix, which consumes no resources from the scripting engine:

  1. Set `FRAME_CLASS` or `Q_FRAME_CLASS` (for quadplanes) to 15 to enable the
  static scriptable mixer.
  2. Ensure Lua scripting is enabled via the `SCR_ENABLE` parameter.
  3. Reboot.
  
The aircraft is ready to fly.
Keep in mind that any further changes to `CGA_RATIO` will now require a reboot.

## How It Works

  1. The dynamic control allocation matrix is able to change the coefficients
  that convert the throttle command to individual PWM commands for every motor.
  These coefficients have a default value of 1.
  2. The parameter `CGA_RATIO` is used to alter these coefficients, so that the
  front and back thrust commands are not equal.


================================================
File: applets/Aerobatics/FixedWing/README.md
================================================
# Scripted Aerobatics

NOTE: this script requires an ArduPilot version of 4.4.1 or greater to execute

The lua script "plane_aerobatics.lua" implements scripted aerobatics,
allowing fixed wing aircraft to execute a number of aerobatic
manoeuvres either in AUTO mission or by triggering using pilot commands
using RC switches.

As always, but particularly with scripted aerobatics, test in SITL until 
you understand the function and behaviour of each manouver. You will need 
an appropriate aircraft, and be ready to take manual control if necessary!

## Available Manoeuvres

The following table gives the available manoeuvres. Each manoeuvre has
an ID number which is used in the AUTO mission or in the TRIKn_ID
parameters (described below). The present ground track is used as the track for the trick.
The "Turnaround" column indicates if the manoeuvre results in a course reversal, which impacts how it is used in 
AUTO missions. Once the trick is completed, the mode that was being used at the start of the trick is restored. If the mode is CRUISE, its
track and altitude are reset to the values present when the mode is restored. Tricks in AUTO missions require that they be performed between two waypoints to establish
the ground track.

| ID | Name                     | Arg1   | Arg2        | Arg3        | Arg4       | Turnaround |
| -- | ------------------------ | ------ | ----------  | -------     | ---------- | ---------- |
| 1  | Figure Eight             | radius | bank angle  |             |            | No         |
| 2  | Loop                     | radius | bank angle  | num loops   |            | No         |
| 3  | Horizontal Rectangle     | length | width       | radius      | bank angle | No         |
| 4  | Climbing Circle          | radius | height      | bank angle  |            | No         |
| 5  | vertical Box             | length | height      | radius      |            | No         |
| 6  | Immelmann (FastRoll)     | radius |             |             |            | Yes        |
| 7  | Straight Roll            | length | num rolls   |             |            | No         |
| 8  | Rolling Circle           | radius | num rolls   |             |            | No         |
| 9  | Half Cuban Eight         | radius |             |             |            | Yes        |
| 10 | Half Reverse Cuban Eight | radius |             |             |            | Yes        |
| 11 | Cuban Eight              | radius |             |             |            | No         |
| 12 | Humpty Bump              | radius | height      |             |            | Yes        |
| 13 | Straight Flight          | length | bank angle  |             |            | No         |
| 14 | Scale Figure Eight       | radius | bank angle  |             |            | No         |
| 15 | Immelmann Turn           | radius |             |             |            | Yes        |
| 16 | Split-S                  | radius |             |             |            | Yes        |
| 17 | Upline-45                | radius | height gain |             |            | No         |
| 18 | Downline-45              | radius | height loss |             |            | No         |
| 19 | Stall Turn(experimental) | radius | height      | direction   |            | Yes        |
| 20 | Procedure Turn           | radius | bank angle  | step-out    |            | Yes        |
| 23 | Half Climbing Circle     | radius | height      | bank angle  |            | Yes        |
| 25 | Laydown Humpty           | radius | height      |             |            | Yes        |
| 26 | Barrel Roll              | radius | length      | num spirals |            | No         |
| 27 | Straight Hold            | length | bank angle  |             |            | No         |
| 28 | Partial Circle           | radius | bank angle  | arc angle   |            | No         |
| 31 | Multi Point Roll         | length | num points  | hold frac   | pts to do  | No         |
| 32 | Side Step                | width  | length      |             |            | No         |

Some notes about maneuver arguments (arg1 - arg4):
These are parameters each maneuver requires to execute. For example the length of a roll or radius of a loop (in meters), the number of rolls, the height of the maneuver, etc.
When setting up a multi-point roll, for example, the length is in meters, the number of points is 'how many points should the roll have during 360 degrees', the hold fraction is the amount of the maneuver 'not rolling', and the points to do is how many points do you wish to fly. For example, if we want '2 of 4 point roll' : two points of a four point roll. From upright roll through 90 degrees, pause, and then roll through a further 90 degrees - finishing inverted. And we want the maneuver to happen over 100m, and the pause between points to be 50% of the maneuver length. Then the four arguments would be?

Length = 100, num points = 4, hold fraction = 0.5, pts to do = 2.

Remember, the model is now exiting inverted so the next maneuver must be planned to start from this position.

Note: In the script you will find other (specialised) manouvers which do not appear in the 
'command table'. These are not intended to be used for 'tricks on a switch'. These 
manouvers are used in some of the schedules defined below. 

Some are explained in the README.md file for the Schedules examples.

## Available Schedules (pre-defined sequences of manouvers)

See the Schedules subdirectory for a wide variety of pre-defined
full aerobatic schedules you can use and instructions for how to
install them. They can be used either in AUTO missions (See below) or as
"tricks on a switch".

In addition, new tricks can be created and loaded from within these schedules files. See the "Airshow.txt" schedule for an example.

## Loading the script

Put the plane_aerobatics.lua script on your microSD card in the
APM/SCRIPTS directory. You can use MAVFtp to do this.

Then set

 - SCR_ENABLE = 1
 - SCR_HEAP_SIZE = 300000
 - SCR_VM_I_COUNT = 200000

You will need to refresh parameters after setting SCR_ENABLE. Then
reboot to start scripting.

## Aircraft Setup

The aircraft needs to be setup to perform well in ACRO mode. You need
to enable the yaw rate controller by setting:

 - YAW_RATE_ENABLE = 1
 - ACRO_YAW_RATE = 90

The ACRO_YAW_RATE depends on the capabilities of the aircraft, but
around 90 degrees/second is reasonable.

You need to tune the yaw rate controller by flying in AUTOTUNE mode
and moving the rudder stick from side to side until the yaw rate
tuning is reported as being finished. For optimal results, log examination and manual adjustment
of axis tuning will sometimes be required, especially pitch and yaw tuning in order to get precise rolling circles. A future 
video on this optimization will be produced and posted in the ArduPilot YouTube channel.

## Use In AUTO Missions

To use in an AUTO mission you can create waypoint missions containing
NAV_SCRIPT_TIME elements (shown as SCRIPT_TIME in MissionPlanner). These mission items take the following arguments:

 - the command ID from the table above
 - the timeout in seconds
 - up to four arguments as shown in the above table

The aerobatics system will use the location of the previous and next
waypoints to line up the manoeuvre. You need to plan a normal
waypoint just before the location where you want to start the
manoeuvre, then the NAV_SCRIPT_TIME with the trick or schedule ID, a timeout that is long enough to allow the trick or schedule, and then a normal waypoint after the manoeuvre.

## Use with "tricks on a switch"

You can trigger the manoeuvres using RC switches, allowing you to have
up to 11 tricks pre-programmed on your transmitter ready for use in
fixed wing flight. You can trigger the tricks in the following flight
modes:

 - CIRCLE
 - STABILIZE
 - ACRO
 - FBWA
 - FBWB
 - CRUISE
 - LOITER

To setup tricks you need to first set the parameter TRIK_ENABLE to 1.

After setting TRIK_ENABLE, either restart scripting or reboot. Then
set TRIK_COUNT to the number of tricks you want to make available,
with a maximum of 11.

After setting TRIK_COUNT, reboot and refresh parameters. You will find
you will now have 5 parameters per trick.

 - TRIKn_ID
 - TRIKn_ARG1
 - TRIKn_ARG2
 - TRIKn_ARG3
 - TRIKn_ARG4

The ID parameter is the manoeuvre from the above table, and the arguments are the arguments to each manoeuvre.

Note: these parameters, if being loaded from a file, will not be present until scripting is enabled, the the LUA script has been
actually run, since they are created via the script, not the firmware.

Now you need to setup your two control channels. You should have one 3
position switch for activating tricks, and one knob or switch to
select tricks. It is best to use a knob for the trick selector so you can have up to 11 tricks.

Work out which RC input channel you want to use for activation (a 3 position switch) and set

 - RCn_OPTION = 300

Then work out what RC input channel you want to use for selection and set

 - RCn_OPTION = 301

## Flying with tricks

When the activation channel (the one marked with option 300) is in the
middle position then when you move the knob the GCS will display the
currently selected trick.

To activate a trick you move the activation channel to the top
position, and the trick will run.

Moving the activation switch to the bottom position cancels any
running trick and stops the trick system.

Changing flight modes will also cancel any active trick.

## Parameters

There are a number of parameters you can set to adjust the path
tracking. Some of the key parameters are:

 - AEROM_ANG_ACCEL : maximum angular acceleration in degrees per second per second. Reduce to give smoother flight, but more lag
 - AEROM_ANG_TC : time constant for correcting angular roll errors. Reduce for snappier rolls, but more risk of oscillation
 - AEROM_KE_RUDD : This is the required rudder percentage in knifeedge flight to hold height at cruise speed.
 - AEROM_KE_RUDD_LK : This is the time ahead in seconds that the anticipated rudder required will be applied
 - AEROM_ENTRY_RATE : roll rate in degrees per second for entering and exiting a roll change
 - AEROM_THR_MIN : minumum throttle percentage for all aerobatic maneuvers
 - AEROM_THR_BOOST: minumum throttle percentage for maneuvers marked as throttle boost
 - AEROM_YAW_ACCEL: maximum yaw acceleration in degrees per second per second. Lower to soften yaw control
 - AEROM_BOX_WIDTH: the length of the aerobatic box whose center is defined by the start of a schedule
 - AEROM_PATH_SCALE: scale factor for all maneuvers. A value above 1.0 will increase the size of the maneuvers. A value below 1.0 will decrease the size. A negative value will mirror the maneuvers, allowing a sequence designed for left-to-right to be flown right-to-left.
 - AEROM_ALT_ABORT: Maximum altitude loss from the start of trick or shcedule before an abort will occur.



================================================
File: applets/Aerobatics/FixedWing/dual_log.py
================================================
#!/usr/bin/env python

'''
combined two aerobatics logs to generate a new log for showing the combined
path of more than one aircraft
'''

import os
from argparse import ArgumentParser

parser = ArgumentParser(description=__doc__)

parser.add_argument("log1", metavar="LOG1")
parser.add_argument("log2", metavar="LOG2")
parser.add_argument("logout", metavar="LOGOUT")
parser.add_argument("--decimate", type=int, default=1)

args = parser.parse_args()

os.environ['MAVLINK20'] = '1'

from pymavlink import mavutil

mlog1 = mavutil.mavlink_connection(args.log1)
mlog2 = mavutil.mavlink_connection(args.log2)
output = open(args.logout, mode='wb')

types1 = ['ORGN','VEH','PARM','MSG','FMT','FMTU','MULT','MODE','EVT','PTHT']
types2 = ['VEH','PTHT']

m1 = None
m2 = None

veh1_formats = {}

def write_message(m):
    global veh1_formats
    mtype = m.get_type()
    if not mtype in veh1_formats:
        return
    veh1_fmt = veh1_formats[mtype]
    buf = bytearray(m.get_msgbuf())
    buf[2] = veh1_fmt
    output.write(buf)

m1_count = 0
m2_count = 0

while True:
    if m1 is None:
        m1 = mlog1.recv_match(type=types1)
    if m2 is None:
        m2 = mlog2.recv_match(type=types2)

    if m1 is not None:
        veh1_formats[m1.get_type()] = m1.get_msgbuf()[2]

    if m1 is not None and m1.get_type() not in types2:
        # passthrough
        output.write(m1.get_msgbuf())
        m1 = None
        continue

    if m2 is not None and m2.get_type() not in types2:
        continue

    if m1 is None and m2 is None:
        break

    if m1 is None:
        write_message(m2)
        m2 = None
        continue

    if m2 is None:
        write_message(m1)
        m1 = None
        continue

    t1 = m1.GWk*7*24*60*60 + m1.GMS*0.001
    t2 = m2.GWk*7*24*60*60 + m2.GMS*0.001

    if t1 <= t2:
        m1_count += 1
        if m1_count % args.decimate == 0:
            write_message(m1)
        m1 = None
    else:
        m2_count += 1
        if m2_count % args.decimate == 0:
            write_message(m2)
        m2 = None



================================================
File: applets/Aerobatics/FixedWing/dual_plane.sh
================================================
#!/usr/bin/env bash

# two planes flying together doing aerobatics

# assume we start the script from the root directory
ROOTDIR=$PWD
PLANE=$ROOTDIR/build/sitl/bin/arduplane

LOC1="-35.36274643,149.16513199,585,353.8"
LOC2="-35.36274593,149.16516256,585,353.8"

[ -x "$PLANE" ] || {
    ./waf configure --board sitl --debug
    ./waf plane
}

# setup multicast
#SERIAL0="tcp:0"
SERIAL0="mcast:"

PLANE_DEFAULTS="$ROOTDIR/Tools/autotest/models/plane-3d.parm"

(cd ArduPlane/AeroBatics1 && $PLANE --instance 1 --home $LOC1 --model plane-3d --serial0 $SERIAL0 --defaults $PLANE_DEFAULTS) &
(cd ArduPlane/AeroBatics2 && $PLANE --instance 2 --home $LOC2 --model plane-3d --serial0 $SERIAL0 --defaults $PLANE_DEFAULTS) &

wait



================================================
File: applets/Aerobatics/FixedWing/plane_aerobatics.lua
================================================
--[[
   trajectory tracking aerobatic control
   See README.md for usage
   Written by Matthew Hampsey, Andy Palmer and Andrew Tridgell, with controller
   assistance from Paul Riseborough, testing by Henry Wurzburg
]]--
-- luacheck: ignore 212 (Unused argument)
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: undefined-field
---@diagnostic disable: missing-parameter
---@diagnostic disable: need-check-nil
---@diagnostic disable: undefined-global
---@diagnostic disable: inject-field

-- setup param block for aerobatics, reserving 35 params beginning with AERO_
local PARAM_TABLE_KEY = 70
local PARAM_TABLE_PREFIX = 'AEROM_'
assert(param:add_table(PARAM_TABLE_KEY, "AEROM_", 40), 'could not add param table')

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end


--[[
  // @Param: AEROM_ANG_ACCEL
  // @DisplayName: Angular acceleration limit
  // @Description: Maximum angular acceleration in maneuvers
  // @Units: deg/s/s
--]]
AEROM_ANG_ACCEL = bind_add_param('ANG_ACCEL', 1, 6000)


--[[
  // @Param: AEROM_ANG_TC
  // @DisplayName: Roll control filtertime constant
  // @Description: This is the time over which we filter the desired roll to smooth it
  // @Units: s
--]]
AEROM_ANG_TC = bind_add_param('ANG_TC', 2, 0.1)

-- 3 was AEROM_KE_ANG

--[[
  // @Param: AEROM_THR_PIT_FF
  // @DisplayName: Throttle feed forward from pitch
  // @Description: This controls how much extra throttle to add based on pitch ange. The value is for 90 degrees and is applied in proportion to pitch
  // @Units: %
--]]
THR_PIT_FF = bind_add_param('THR_PIT_FF', 4, 80)

--[[
  // @Param: AEROM_SPD_P
  // @DisplayName: P gain for speed controller
  // @Description: This controls how rapidly the throttle is raised to compensate for a speed error
  // @Units: %
--]]
SPD_P = bind_add_param('SPD_P', 5, 5)

--[[
  // @Param: AEROM_SPD_I
  // @DisplayName: I gain for speed controller
  // @Description: This controls how rapidly the throttle is raised to compensate for a speed error
  // @Units: %
--]]
SPD_I = bind_add_param('SPD_I', 6, 25)

--[[
  // @Param: AEROM_ROL_COR_TC
  // @DisplayName: Roll control time constant
  // @Description: This is the time constant for correcting roll errors. A smaller value leads to faster roll corrections
  // @Units: s
--]]
ROLL_CORR_TC = bind_add_param('ROL_COR_TC', 8, 0.25)

-- removed 9 and 10

--[[
  // @Param: AEROM_TIME_COR_P
  // @DisplayName: Time constant for correction of our distance along the path
  // @Description: This is the time constant for correcting path position errors
  // @Units: s
--]]
TIME_CORR_P = bind_add_param('TIME_COR_P', 11, 1.0)

--[[
  // @Param: AEROM_ERR_COR_P
  // @DisplayName: P gain for path error corrections
  // @Description: This controls how rapidly we correct back onto the desired path
--]]
ERR_CORR_P = bind_add_param('ERR_COR_P', 12, 2.0)

--[[
  // @Param: AEROM_ERR_COR_D
  // @DisplayName: D gain for path error corrections
  // @Description: This controls how rapidly we correct back onto the desired path
--]]
ERR_CORR_D = bind_add_param('ERR_COR_D', 13, 2.8)

--[[
  // @Param: AEROM_ENTRY_RATE
  // @DisplayName: The roll rate to use when entering a roll maneuver
  // @Description: This controls how rapidly we roll into a new orientation
  // @Units: deg/s
--]]
AEROM_ENTRY_RATE = bind_add_param('ENTRY_RATE', 14, 60)

--[[
  // @Param: AEROM_THR_LKAHD
  // @DisplayName: The lookahead for throttle control
  // @Description: This controls how far ahead we look in time along the path for the target throttle
  // @Units: s
--]]
AEROM_THR_LKAHD = bind_add_param('THR_LKAHD', 15, 1)

--[[
  // @Param: AEROM_DEBUG
  // @DisplayName: Debug control
  // @Description: This controls the printing of extra debug information on paths
--]]
AEROM_DEBUG = bind_add_param('DEBUG', 16, 0)

--[[
  // @Param: AEROM_THR_MIN
  // @DisplayName: Minimum Throttle
  // @Description: Lowest throttle used during maneuvers
  // @Units: %
--]]
AEROM_THR_MIN = bind_add_param('THR_MIN', 17, 0)

--[[
  // @Param: AEROM_THR_BOOST
  // @DisplayName: Throttle boost
  // @Description: This is the extra throttle added in schedule elements marked as needing a throttle boost
  // @Units: %
--]]
AEROM_THR_BOOST = bind_add_param('THR_BOOST', 18, 50)

--[[
  // @Param: AEROM_YAW_ACCEL
  // @DisplayName: Yaw acceleration
  // @Description: This is maximum yaw acceleration to use
  // @Units: deg/s/s
--]]
AEROM_YAW_ACCEL = bind_add_param('YAW_ACCEL', 19, 1500)

--[[
  // @Param: AEROM_LKAHD
  // @DisplayName: Lookahead
  // @Description: This is how much time to look ahead in the path for calculating path rates
  // @Units: s
--]]
AEROM_LKAHD = bind_add_param('LKAHD', 20, 0.5)

--[[
    // @Param: AEROM_PATH_SCALE
    // @DisplayName: Path Scale
    // @Description: Scale factor for Path/Box size. 0.5 would half the distances in maneuvers. Radii are unaffected.
    // @Range: 0.1 100
--]]
AEROM_PATH_SCALE = bind_add_param('PATH_SCALE', 21, 1.0)

--[[
    // @Param: AEROM_BOX_WIDTH
    // @DisplayName: Box Width
    // @Description: Length of aerobatic "box" 
    // @Units: m
--]]
AEROM_BOX_WIDTH = bind_add_param('BOX_WIDTH', 22, 400)

--[[
    // @Param: AEROM_STALL_THR
    // @DisplayName: Stall turn throttle
    // @Description: Amount of throttle to reduce to for a stall turn
    // @Units: %
--]]
AEROM_STALL_THR = bind_add_param('STALL_THR', 23, 40)

--[[
    // @Param: AEROM_STALL_PIT
    // @DisplayName: Stall turn pitch threshold
    // @Description: Pitch threashold for moving to final stage of stall turn
    // @Units: deg
--]]
AEROM_STALL_PIT = bind_add_param('STALL_PIT', 24, -20)

-- 25 was AEROM_KE_TC

--[[
    // @Param: AEROM_KE_RUDD
    // @DisplayName: KnifeEdge Rudder
    // @Description: Percent of rudder normally uses to sustain knife-edge at trick speed
    // @Units: %
--]]
AEROM_KE_RUDD = bind_add_param('KE_RUDD', 26, 25)

--[[
    // @Param: AEROM_KE_RUDD_LK
    // @DisplayName: KnifeEdge Rudder lookahead
    // @Description: Time to look ahead in the path to calculate rudder correction for bank angle
    // @Units: s
--]]
AEROM_KE_RUDD_LK = bind_add_param('KE_RUDD_LK', 27, 0.25)

--[[
    // @Param: AEROM_ALT_ABORT
    // @DisplayName: Altitude Abort
    // @Description: Maximum allowable loss in altitude during a trick or sequence from its starting altitude.
    // @Units: m
--]]
AEROM_ALT_ABORT = bind_add_param('ALT_ABORT',28,15)

--[[
    // @Param: AEROM_TS_P
    // @DisplayName: Timesync P gain
    // @Description: This controls how rapidly two aircraft are brought back into time sync
--]]
AEROM_TS_P = bind_add_param('TS_P', 29, 0.33)

--[[
    // @Param: AEROM_TS_I
    // @DisplayName: Timesync I gain
    // @Description: This controls how rapidly two aircraft are brought back into time sync
--]]
AEROM_TS_I = bind_add_param('TS_I', 30, 0.33)

--[[
    // @Param: AEROM_TS_SPDMAX
    // @DisplayName: Timesync speed max
    // @Description: This sets the maximum speed adjustment for time sync between aircraft
    // @Units: m/s
--]]
AEROM_TS_SPDMAX = bind_add_param('TS_SPDMAX', 31, 0.0)

--[[
    // @Param: AEROM_TS_RATE
    // @DisplayName: Timesync rate of send of NAMED_VALUE_FLOAT data
    // @Description: This sets the rate we send data for time sync between aircraft
    // @Units: Hz
--]]
AEROM_TS_RATE = bind_add_param('TS_RATE', 32, 4.0)

--[[
    // @Param: AEROM_MIS_ANGLE
    // @DisplayName: Mission angle
    // @Description: When set to a non-zero value, this is the assumed direction of the mission. Otherwise the waypoint angle is used
    // @Units: deg
--]]
AEROM_MIS_ANGLE = bind_add_param('MIS_ANGLE', 33, 0.0)

--[[
    // @Param: AEROM_OPTIONS
    // @DisplayName: Aerobatic options
    // @Description: Options to control aerobatic behavior
    // @Bitmask: 0:UseRTLOnAbort, 1:AddAtToMessages, 2:DualAircraftSynchronised
    // @Units: deg
--]]
AEROM_OPTIONS = bind_add_param('OPTIONS', 34, 0.0)

local OPTIONS = { ABORT_RTL=(1<<0), MSG_ADD_AT=(1<<1), DUAL_AIRCRAFT=(1<<2) }

--[[
   return true if an option is set
--]]
function option_set(option)
   local options = math.floor(AEROM_OPTIONS:get())
   return options & option ~= 0
end


-- cope with old param values
if AEROM_ANG_ACCEL:get() < 100 and AEROM_ANG_ACCEL:get() > 0 then
   AEROM_ANG_ACCEL:set_and_save(3000)
end
if AEROM_ANG_TC:get() > 1.0 then
   AEROM_ANG_TC:set_and_save(0.2)
end

ACRO_ROLL_RATE = Parameter("ACRO_ROLL_RATE")
ACRO_YAW_RATE = Parameter('ACRO_YAW_RATE')
AIRSPEED_MIN = Parameter("AIRSPEED_MIN")
SCALING_SPEED = Parameter("SCALING_SPEED")
MAV_SYSID = Parameter("MAV_SYSID")

GRAVITY_MSS = 9.80665

--[[
   list of attributes that can be added to a path element
--]]
local path_attribs = { "roll_ref", "set_orient", "rate_override", "thr_boost", "pos_corr", "message", "shift_xy", "timestamp", "pos_gain_mul" }

--[[
   Aerobatic tricks on a switch support - allows for tricks to be initiated outside AUTO mode
--]]
-- 2nd param table for tricks on a switch
local PARAM_TABLE_KEY2 = 71
local PARAM_TABLE_PREFIX2 = "TRIK"
assert(param:add_table(PARAM_TABLE_KEY2, PARAM_TABLE_PREFIX2, 63), 'could not add param table2')

-- add a parameter and bind it to a variable in table2
function bind_add_param2(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY2, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX2 .. name)
end
--[[
    // @Param: TRIK_ENABLE
    // @DisplayName: Tricks on Switch Enable
    // @Description: Enables Tricks on Switch. TRIK params hidden until enabled
--]]
local TRIK_ENABLE = bind_add_param2("_ENABLE", 1, 0)
local TRICKS = nil
local TRIK_SEL_FN = nil
local TRIK_ACT_FN = nil
local TRIK_COUNT  = nil


local function TrickDef(id, arg1, arg2, arg3, arg4)
   local self = {}
   self.id = id
   self.args = {arg1, arg2, arg3, arg4}
   return self
end

-- constrain a value between limits
local function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end

local function sq(x)
   return x*x
end

local last_trick_action_state = nil
if TRIK_ENABLE:get() > 0 then
--[[
    // @Param: TRIK_SEL_FN
    // @DisplayName: Trik Selection Scripting Function
    // @Description: Setting an RC channel's _OPTION to this value will use it for trick selection
    // @Range: 301 307
--]]
   TRIK_SEL_FN = bind_add_param2("_SEL_FN", 2, 301)
--[[
    // @Param: TRIK_ACT_FN
    // @DisplayName: Trik Action Scripting Function
    // @Description: Setting an RC channel's _OPTION to this value will use it for trick action (abort,announce,execute)
    // @Range: 301 307
--]]
   TRIK_ACT_FN = bind_add_param2("_ACT_FN", 3, 300)
--[[
    // @Param: TRIK_COUNT
    // @DisplayName: Trik Count
    // @Description: Number of tricks which can be selected over the range of the trik selection RC channel
    // @Range: 1 11
--]]
   TRIK_COUNT  = bind_add_param2("_COUNT",  4, 3)
   TRICKS = {}

   last_trick_action_state = rc:get_aux_cached(TRIK_ACT_FN:get())

   -- setup parameters for tricks
   local count = math.floor(constrain(TRIK_COUNT:get(),1,11))
   for i = 1, count do
      local k = 5*i
      local prefix = string.format("%u", i)
      TRICKS[i] = TrickDef(bind_add_param2(prefix .. "_ID",   k+0, -1),
                           bind_add_param2(prefix .. "_ARG1", k+1, 30),
                           bind_add_param2(prefix .. "_ARG2", k+2, 0),
                           bind_add_param2(prefix .. "_ARG3", k+3, 0),
                           bind_add_param2(prefix .. "_ARG4", k+4, 0))
   end
   gcs:send_text(MAV_SEVERITY.ALERT, string.format("Enabled %u aerobatic tricks", TRIK_COUNT:get()))
end

local NAV_SCRIPT_TIME = 42702

local MODE_AUTO = 10
local MODE_RTL = 11

local LOOP_RATE = 40
local DO_JUMP = 177
local k_throttle = 70
local NAME_FLOAT_RATE = 2

local AIRSPEED_CRUISE = Parameter("AIRSPEED_CRUISE")

local last_id = 0
local current_task = nil
local last_named_float_t = 0
local last_named_float_send_t = 0

local path_var = {}

local function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

local function wrap_180(angle)
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

local function wrap_pi(angle)
   local angle_deg = math.deg(angle)
   local angle_wrapped = wrap_180(angle_deg)
   return math.rad(angle_wrapped)
end

local function wrap_2pi(angle)
   local angle_deg = math.deg(angle)
   local angle_wrapped = wrap_360(angle_deg)
   return math.rad(angle_wrapped)
end


--[[
   calculate an alpha for a first order low pass filter
--]]
local function calc_lowpass_alpha(dt, time_constant)
   local rc = time_constant/(math.pi*2)
   return dt/(dt+rc)
end

--[[ get the c.y element of a quaternion, which gives
   the projection of the vehicle y axis in the down direction
   This is equal to sin(roll)*cos(pitch)
--]]
local function get_quat_dcm_c_y(q)
   local q1 = q:q1()
   local q2 = q:q2()
   local q3 = q:q3()
   local q4 = q:q4()
   local q3q4 = q3 * q4
   local q1q2 = q1 * q2
   return 2*(q3q4 + q1q2)
end

--[[ get the c.y element of the DCM body to earth matrix, which gives
   the projection of the vehicle y axis in the down direction
   This is equal to sin(roll)*cos(pitch)
--]]
local function get_ahrs_dcm_c_y()
   return get_quat_dcm_c_y(ahrs:get_quaternion())
end

-- a PI controller implemented as a Lua object
local function PI_controller(kP,kI,iMax,min,max)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = {}

   -- private fields as locals
   local _kP = kP or 0.0
   local _kI = kI or 0.0
   local _iMax = iMax
   local _min = min
   local _max = max
   local _last_t = nil
   local _I = 0
   local _P = 0
   local _total = 0
   local _counter = 0
   local _target = 0
   local _current = 0

   -- update the controller.
   function self.update(target, current)
      local now = millis():tofloat() * 0.001
      if not _last_t then
         _last_t = now
      end
      local dt = now - _last_t
      _last_t = now
      local err = target - current
      _counter = _counter + 1

      local P = _kP * err
      if ((_total < _max and _total > _min) or (_total >= _max and err < 0) or (_total <= _min and err > 0)) then
         _I = _I + _kI * err * dt
      end
      if _iMax then
         _I = constrain(_I, -_iMax, iMax)
      end
      local I = _I
      local ret = P + I

      _target = target
      _current = current
      _P = P

      ret = constrain(ret, _min, _max)
      _total = ret
      return ret
   end

   -- reset integrator to an initial value
   function self.reset(integrator)
      _I = integrator
   end

   function self.set_I(I)
      _kI = I
   end

   function self.set_P(P)
      _kP = P
   end
   
   function self.set_Imax(Imax)
      _iMax = Imax
   end
   
   -- log the controller internals
   function self.log(name, add_total)
      -- allow for an external addition to total
      logger.write(name,'Targ,Curr,P,I,Total,Add','ffffff',_target,_current,_P,_I,_total,add_total)
   end
   -- return the instance
   return self
end

local function speed_controller(kP_param,kI_param, kFF_pitch_param, Imax, min, max)
   local self = {}
   local kFF_pitch = kFF_pitch_param
   local PI = PI_controller(kP_param:get(), kI_param:get(), Imax, min, max)

   function self.update(target, anticipated_pitch_rad)
      local current_speed = ahrs:get_velocity_NED():length()
      local throttle = PI.update(target, current_speed)
      local FF = math.sin(anticipated_pitch_rad)*kFF_pitch:get()
      PI.log("AESP", FF)
      return throttle + FF
   end

   function self.reset()
      PI.reset(0)
      local temp_throttle = self.update(ahrs:get_velocity_NED():length(), 0)
      local current_throttle = SRV_Channels:get_output_scaled(k_throttle)
      PI.reset(current_throttle-temp_throttle)
   end

   return self
end

local speed_PI = speed_controller(SPD_P, SPD_I, THR_PIT_FF, 100.0, 0.0, 100.0)

local function speed_adjust_controller(kP_param, kI_param)
   local self = {}
   local spd_max = AEROM_TS_SPDMAX:get()
   local PI = PI_controller(kP_param:get(), kI_param:get(), spd_max, -spd_max, spd_max)

   function self.update(spd_error)
      local adjustment = PI.update(0, spd_error)
      PI.log("AESA", 0)
      return adjustment
   end

   function self.reset()
      PI.reset(0)
   end

   return self
end

local speed_adjustment_PI = speed_adjust_controller(AEROM_TS_P, AEROM_TS_I)

function sgn(x)
   local eps = 0.000001
   if (x > eps) then
      return 1.0
   elseif x < eps then
      return -1.0
   else
      return 0.0
   end
end

local function get_wp_location(i)
   local m = mission:get_item(i)
   local loc = Location()
   loc:lat(m:x())
   loc:lng(m:y())
   loc:relative_alt(true)
   loc:terrain_alt(false)
   loc:origin_alt(false)
   loc:alt(math.floor(m:z()*100))
   return loc
end

local function resolve_jump(i)
   local m = mission:get_item(i)
   while m:command() == DO_JUMP do
      i = math.floor(m:param1())
      m = mission:get_item(i)
   end
   return i
end

--[[
   Wrapper to construct a Vector3f{x, y, z} from (x, y, z)
--]]
local function makeVector3f(x, y, z)
   local vec = Vector3f()
   vec:x(x)
   vec:y(y)
   vec:z(z)
   return vec
end

--[[
   get quaternion rotation between vector1 and vector2
   with thanks to https://stackoverflow.com/questions/1171849/finding-quaternion-representing-the-rotation-from-one-vector-to-another
--]]
local function vectors_to_quat_rotation(vector1, vector2)
   local v1 = vector1:copy()
   local v2 = vector2:copy()
   v1:normalize()
   v2:normalize()
   local dot = v1:dot(v2)
   local a = v1:cross(v2)
   local w = 1.0 + dot
   local q = Quaternion()
   q:q1(w)
   q:q2(a:x())
   q:q3(a:y())
   q:q4(a:z())
   q:normalize()
   return q
end

--[[
   get path rate from two tangents and delta time
--]]
local function tangents_to_rate(t1, t2, dt)
   local q_delta = vectors_to_quat_rotation(t1, t2)
   local rate_rads = Vector3f()
   q_delta:to_axis_angle(rate_rads)
   rate_rads = rate_rads:scale(1.0/dt)
   return rate_rads
end

--[[
   create a class that inherits from a base class
--]]
local function inheritsFrom(baseClass, name_in)
    local new_class = { name = name_in }
    local class_mt = { __index = new_class }

    function new_class:create()
        local newinst = {}
        setmetatable( newinst, class_mt )
        return newinst
    end

    if nil ~= baseClass then
        setmetatable( new_class, { __index = baseClass } )
    end

    return new_class
end

--[[
   return a quaternion for a roll, pitch, yaw (321 euler sequence) attitude
--]]
function qorient(roll_deg, pitch_deg, yaw_deg)
   local q = Quaternion()
   q:from_euler(math.rad(roll_deg), math.rad(pitch_deg), math.rad(yaw_deg))
   return q
end

--[[
   rotate a vector by a quaternion
--]]
local function quat_earth_to_body(quat, v)
   local v2 = v:copy()
   quat:earth_to_body(v2)
   return v2
end

--[[
   rotate a vector by a inverse quaternion
--]]
local function quat_body_to_earth(quat, v)
   local v2 = v:copy()
   quat:inverse():earth_to_body(v2)
   return v2
end

--[[
   copy a quaternion
--]]
local function quat_copy(q)
   return q:inverse():inverse()
end


--[[
   trajectory building blocks. We have two types of building blocks,
   roll blocks and path blocks. These are combined to give composite paths
--]]


--[[
  roll component that goes through a fixed total angle at a fixed roll rate
--]]
local _roll_angle = inheritsFrom(nil, 'roll_angle')
function _roll_angle:get_roll(t)
   if self.angle == nil then
      return 0
   end
   return self.angle * t
end
function roll_angle(angle)
   local self = _roll_angle:create()
   if angle ~= 0 then
      self.angle = angle
   end
   return self
end

--[[
   roll component that banks to _angle over AEROM_ENTRY_RATE
   degrees/s, then holds that angle, then banks back to zero at
   AEROM_ENTRY_RATE degrees/s
--]]
local _roll_angle_entry_exit = inheritsFrom(nil, "roll_angle_entry_exit")
function _roll_angle_entry_exit:get_roll(t, time_s)
   local entry_s = math.abs(self.angle) / AEROM_ENTRY_RATE:get()
   local entry_t = entry_s / time_s
   if entry_t > 0.5 then
      entry_t = 0.5
   end
   if t <= 0 then
      return 0
   end
   if t < entry_t then
      return self.angle * t / entry_t
   end
   if t < 1.0 - entry_t then
      return self.angle
   end
   if self.angle == 0 or t >= 1.0 then
      return 0
   end
   return (1.0 - ((t - (1.0 - entry_t)) / entry_t)) * self.angle
end

function roll_angle_entry_exit(angle)
   local self = _roll_angle_entry_exit:create()
   self.angle = angle
   return self
end

--[[
   roll component that banks to _angle over AEROM_ENTRY_RATE
   degrees/s, then holds that angle
--]]
local _roll_angle_entry = inheritsFrom(nil, "roll_angle_entry")
function _roll_angle_entry:get_roll(t, time_s)
   local entry_s = math.abs(self.angle) / AEROM_ENTRY_RATE:get()
   local entry_t = entry_s / time_s
   if entry_t > 0.5 then
      entry_t = 0.5
   end
   if t < entry_t then
      return self.angle * t / entry_t
   end
   return self.angle
end

function roll_angle_entry(angle)
   local self = _roll_angle_entry:create()
   self.angle = angle
   return self
end

--[[
   roll component that holds angle until the end of the subpath, then
   rolls back to 0 at the AEROM_ENTRY_RATE
--]]
local _roll_angle_exit = inheritsFrom(nil, "roll_angle_exit")
function _roll_angle_exit:get_roll(t, time_s)
   local entry_s = math.abs(self.angle) / AEROM_ENTRY_RATE:get()
   local entry_t = entry_s / time_s
   if t < 1.0 - entry_t then
      return 0
   end
   if self.angle == 0 then
      return 0
   end
   return ((t - (1.0 - entry_t)) / entry_t) * self.angle
end

function roll_angle_exit(angle)
   local self = _roll_angle_exit:create()
   self.angle = angle
   return self
end

--[[
   implement a sequence of rolls, specified as a list of {proportion, roll_angle} pairs
--]]
local _roll_sequence = inheritsFrom(nil, "roll_sequence")
function _roll_sequence:get_roll(t)
   for i = 1, #self.seq do
      if t <= self.end_t[i] then
         local t2 = (t - self.start_t[i])/(self.seq[i][1]/self.total)
         return self.start_ang[i] + t2 * self.seq[i][2]
      end
   end
   -- we've gone past the end
   return self.start_ang[#self.seq] + self.seq[#self.seq][2]
end

function roll_sequence(seq)
   local self = _roll_sequence:create()
   self.seq = seq
   self.total = 0.0
   self.end_t = {}
   self.start_t = {}
   self.start_ang = {}
   for i = 1, #seq do
      self.total = self.total + seq[i][1]
   end
   local t = 0.0
   local angle = 0.0
   for i = 1, #seq do
      self.start_t[i] = t
      self.start_ang[i] = angle
      angle = angle + seq[i][2]
      t = t + seq[i][1]/self.total
      self.end_t[i] = t
   end
   return self
end

--[[ given a path function get_pos() calculate the extents of the path
   along the X axis as a tuple
--]]
local function get_extents_x(obj)
   local p = obj:get_pos(0)
   local min_x = p:x()
   local max_x = min_x
   for t=0, 1, 0.02 do
      p = obj:get_pos(t)
      min_x = math.min(min_x, p:x())
      max_x = math.max(max_x, p:x())
   end
   return { min_x, max_x }
end


--[[
  all path components inherit from PathComponent
--]]
local _PathComponent = inheritsFrom(nil)
function _PathComponent:get_pos(t)
   return makeVector3f(0, 0, 0)
end
function _PathComponent:get_length()
   return 0
end
function _PathComponent:get_final_orientation()
   return Quaternion()
end
function _PathComponent:get_roll_correction(t)
   return 0
end
function _PathComponent:get_attribute(t, attrib)
   return self[attrib]
end
function _PathComponent:get_extents_x()
   if self.extents ~= nil then
      return self.extents
   end
   self.extents = get_extents_x(self)
   return self.extents
end

--[[
   path component that does a straight horizontal line
--]]
local _path_straight = inheritsFrom(_PathComponent, "path_straight")
function _path_straight:get_pos(t)
   return makeVector3f(self.distance*t, 0, 0)
end
function _path_straight:get_length()
   return self.distance
end
function path_straight(distance)
   local self = _path_straight:create()
   self.distance = distance
   return self
end

--[[
   path component that does a straight line then reverses direction
--]]
local _path_reverse = inheritsFrom(_PathComponent, "path_reverse")
function _path_reverse:get_pos(t)
   if t < 0.5 then
      return makeVector3f(self.distance*t*2, 0, 0)
   else
      return makeVector3f(self.distance-(self.distance*(t-0.5)*2), 0, 0)
   end
end
function _path_reverse:get_length()
      return self.distance*2
end
function path_reverse(distance)
   local self = _path_reverse:create()
   self.distance = distance
   return self
end

--[[
   path component that aligns to within the aerobatic box
--]]
local _path_align_box = inheritsFrom(_PathComponent, "path_align_box")
function _path_align_box:get_pos(t)
   return makeVector3f(self.distance*t, 0, 0)
end
function _path_align_box:get_length()
   return self.distance
end
function _path_align_box:set_next_extents(extents, start_pos, start_orientation)
   local box_half = AEROM_BOX_WIDTH:get()/2
   local start_x = start_pos:x()
   local next_max_x = extents[2]
   if math.abs(math.deg(start_orientation:get_euler_yaw())) > 90 then
      -- we are on a reverse path
      self.distance = (box_half * self.alignment) + start_x - next_max_x
   else
      -- we are on a forward path
      self.distance = (box_half * self.alignment) - start_x - next_max_x
   end
   self.distance = math.max(self.distance, 0.01)
end
function path_align_box(alignment)
   local self = _path_align_box:create()
   self.distance = nil
   self.alignment = alignment
   return self
end

--[[
   path component that aligns so the center of the next maneuver is
   centered within the aerobatic box
--]]
local _path_align_center = inheritsFrom(_PathComponent, "path_align_center")
function _path_align_center:get_pos(t)
   return makeVector3f(self.distance*t, 0, 0)
end
function _path_align_center:get_length()
   return self.distance
end
function _path_align_center:set_next_extents(extents, start_pos, start_orientation)
   local start_x = start_pos:x()
   local next_mid_x = (extents[1]+extents[2])*0.5
   if math.abs(math.deg(start_orientation:get_euler_yaw())) > 90 then
      -- we are on a reverse path
      self.distance = start_x - next_mid_x
   else
      -- we are on a forward path
      self.distance = - start_x - next_mid_x
   end
   self.distance = math.max(self.distance, 0.01)
end

function path_align_center()
   local self = _path_align_center:create()
   self.distance = nil
   return self
end

--[[
   path component that does a vertical arc over a given angle
--]]
local _path_vertical_arc = inheritsFrom(_PathComponent, "path_vertical_arc")
function _path_vertical_arc:get_pos(t)
   local t2ang = wrap_2pi(t * math.rad(self.angle))
   return makeVector3f(math.abs(self.radius)*math.sin(t2ang), 0, -self.radius*(1.0 - math.cos(t2ang)))
end
function _path_vertical_arc:get_length()
   return math.abs(self.radius) * 2 * math.pi * math.abs(self.angle) / 360.0
end
function _path_vertical_arc:get_final_orientation()
   local q = Quaternion()
   q:from_axis_angle(makeVector3f(0,1,0), sgn(self.radius)*math.rad(wrap_180(self.angle)))
   q:normalize()
   return q
end
function path_vertical_arc(radius, angle)
   local self = _path_vertical_arc:create()
   self.radius = radius
   self.angle = angle
   return self
end

--[[
   path component that does a horizontal arc over a given angle
--]]
local _path_horizontal_arc = inheritsFrom(_PathComponent, "path_horizontal_arc")
function _path_horizontal_arc:get_pos(t)
   local t2ang = t * math.rad(self.angle)
   return makeVector3f(math.abs(self.radius)*math.sin(t2ang), self.radius*(1.0 - math.cos(t2ang)), -self.height_gain*t)
end
function _path_horizontal_arc:get_length()
   local circumference = 2 * math.pi * math.abs(self.radius)
   local full_circle_height_gain = self.height_gain * 360.0 / math.abs(self.angle)
   local helix_length = math.sqrt(full_circle_height_gain*full_circle_height_gain + circumference*circumference)
   return helix_length * math.abs(self.angle) / 360.0
end
function _path_horizontal_arc:get_final_orientation()
   local q = Quaternion()
   q:from_axis_angle(makeVector3f(0,0,1), sgn(self.radius)*math.rad(self.angle))
   return q
end

--[[
   roll correction for the rotation caused by height gain
--]]
function _path_horizontal_arc:get_roll_correction(t)
   if self.height_gain == 0 then
      return 0
   end
   local gamma=math.atan(self.height_gain*(360/self.angle)/(2*math.pi*self.radius))
   return -t*self.angle*math.sin(gamma)
end

function path_horizontal_arc(radius, angle, height_gain)
   local self = _path_horizontal_arc:create()
   self.radius = radius
   self.angle = angle
   self.height_gain = height_gain or 0
   return self
end

--[[
   path component that does a cylinder for a barrel roll
--]]
local _path_cylinder = inheritsFrom(_PathComponent, "path_cylinder")
function _path_cylinder:get_pos(t)
   local t2ang = t * self.num_spirals * math.pi * 2
   local v = makeVector3f(self.length*t, math.abs(self.radius)*math.sin(t2ang+math.pi), -math.abs(self.radius)*(1.0 - math.cos(t2ang)))
   local qrot = Quaternion()
   qrot:from_axis_angle(makeVector3f(0,0,1), (0.5*math.pi)-self.gamma)
   v = quat_earth_to_body(qrot, v)
   if self.radius < 0 then
      -- mirror for reverse radius
      v:y(-v:y())
   end
   return v
end

function _path_cylinder:get_length()
   local circumference = 2 * math.pi * math.abs(self.radius)
   local length_per_spiral = self.length / self.num_spirals
   local helix_length = math.sqrt(length_per_spiral*length_per_spiral + circumference*circumference)
   return helix_length * self.num_spirals
end

--[[
   roll correction for the rotation caused by the path
--]]
function _path_cylinder:get_roll_correction(t)
   return sgn(self.radius)*t*360*math.sin(self.gamma)*self.num_spirals
end

function path_cylinder(radius, length, num_spirals)
   local self = _path_cylinder:create()
   self.radius = radius
   self.length = length
   self.num_spirals = num_spirals
   self.gamma = math.atan((length/num_spirals)/(2*math.pi*math.abs(radius)))
   return self
end

--[[
   a Path has the methods of both RollComponent and
   PathComponent allowing for a complete description of a subpath
--]]
local _Path = inheritsFrom(nil)
function _Path:get_roll(t, time_s)
   return wrap_180(self.roll_component:get_roll(t, time_s))
end
function _Path:get_roll_correction(t)
   return self.path_component:get_roll_correction(t)
end
function _Path:get_pos(t)
   return self.path_component:get_pos(t)
end
function _Path:get_length()
   return self.path_component:get_length()
end
function _Path:get_final_orientation()
   return self.path_component:get_final_orientation()
end
function _Path:get_attribute(t, attrib)
   return self[attrib]
end
function _Path:set_next_extents(extents, start_pos, start_orientation)
   self.path_component:set_next_extents(extents, start_pos, start_orientation)
end
local function Path(path_component, roll_component)
   local self = _Path:create()
   self.name = string.format("%s|%s", path_component.name, roll_component.name)
   assert(path_component)
   assert(roll_component)
   self.path_component = path_component
   self.roll_component = roll_component
   return self
end


--[[
   componse multiple sub-paths together to create a full trajectory
--]]
local _path_composer = inheritsFrom(nil)
-- return the subpath with index i. Used to cope with two ways of calling path_composer
function _path_composer:subpath(i)
   if i == self.cache_i then
      return self.cache_sp
   end
   self.cache_i = i
   local sp = self.subpaths[i]
   if sp.name then
      -- we are being called with a list of Path objects
      self.cache_sp = sp
   else
      -- we are being called with a list function/argument tuples
      local args = self.subpaths[i][2]
      self.cache_sp = self.subpaths[i][1](args[1], args[2], args[3], args[4], self.start_pos[i], self.start_orientation[i])
      -- copy over path attributes
      for _, v in pairs(path_attribs) do
         self.cache_sp[v] = self.subpaths[i][v]
      end
   end
   return self.cache_sp
end

function _path_composer:end_time(i)
   local proportion = self.lengths[i] / self.total_length
   return self.start_time[i] + proportion
end

function _path_composer:get_subpath_t(t)
   if self.last_subpath_t[1] == t then
      -- use cached value
      return self.last_subpath_t[2], self.last_subpath_t[3]
   end
   local i = 1
   while t >= self:end_time(i) and i < self.num_sub_paths do
      i = i + 1
   end
   local proportion = self.lengths[i]/self.total_length
   local subpath_t = (t - self.start_time[i]) / proportion
   self.last_subpath_t = { t, subpath_t, i }
   local sp = self:subpath(i)
   if i > self.highest_i and t < 1.0 and t > 0 then
      self.highest_i = i
      if sp.message ~= nil then
         local msg = sp.message
         if option_set(OPTIONS.MSG_ADD_AT) then
            msg = "@" .. msg
         end
         gcs:send_text(MAV_SEVERITY.ALERT, msg)
      end
      if AEROM_DEBUG:get() > 0 then
         gcs:send_text(MAV_SEVERITY.ALERT, string.format("starting %s[%d] %s", self.name, i, sp.name))
      end
   end
   return subpath_t, i
end

-- return position at time t
function _path_composer:get_pos(t)
   local subpath_t, i = self:get_subpath_t(t)
   local sp = self:subpath(i)
   return quat_earth_to_body(self.start_orientation[i], sp:get_pos(subpath_t)) + self.start_pos[i]
end

-- return angle for the composed path at time t
function _path_composer:get_roll(t, time_s)
   local subpath_t, i = self:get_subpath_t(t)
   local speed = target_groundspeed()
   local sp = self:subpath(i)
   local angle = sp:get_roll(subpath_t, self.lengths[i]/speed)
   return angle + self.start_angle[i]
end

function _path_composer:get_roll_correction(t)
   local subpath_t, i = self:get_subpath_t(t)
   local sp = self:subpath(i)
   return sp:get_roll_correction(subpath_t) + (self.start_roll_correction[i] or 0)
end
   
function _path_composer:get_length()
   return self.total_length
end

function _path_composer:get_final_orientation()
   return self.final_orientation
end

function _path_composer:get_attribute(t, attrib)
   local subpath_t, i = self:get_subpath_t(t)
   local sp = self:subpath(i)
   return sp[attrib] or sp:get_attribute(subpath_t, attrib)
end

function _path_composer:get_extents_x()
   if self.extents ~= nil then
      return self.extents
   end
   self.extents = get_extents_x(self)
   return self.extents
end

function _path_composer:calculate_timestamps()
   self.timestamp_start = {}
   self.timestamp_start[1] = 0.0
   self.have_timestamps = false
   for i = 1, self.num_sub_paths do
      local sp = self:subpath(i)
      local timestamp = sp.timestamp
      if timestamp then
         self.timestamp_start[i] = timestamp
         self.have_timestamps = true
      end
   end
   if self.have_timestamps then
      local tstart = 0.0
      for i = 2, self.num_sub_paths do
         if not self.timestamp_start[i] then
            -- find the next element with a timestamp, getting total length
            local length_sum = self:subpath(i-1):get_length()
            for j = i, self.num_sub_paths do
               if self.timestamp_start[j] then
                  --gcs:send_text(MAV_SEVERITY.ALERT, string.format("found %u %u %.3f ts=%.3f", i, j, length_sum, tstart))
                  for k = i, j-1 do
                     local len = self:subpath(k):get_length()
                     self.timestamp_start[k] = tstart +  len / length_sum
                     --gcs:send_text(MAV_SEVERITY.ALERT, string.format("ts[%u] %.3f %.2f/%.2f", k, self.timestamp_start[k], len, length_sum))
                  end
                  break
               end
               length_sum = length_sum + self:subpath(j):get_length()
            end
         else
            tstart = self.timestamp_start[i]
         end
      end
      self.timestamp_start[self.num_sub_paths+1] = self.timestamp_start[self.num_sub_paths]+1.0
   end

   self.patht_start = {}
   self.patht_start[1] = 0.0
   self.patht_start[self.num_sub_paths+1] = 1.0
   local total_length = self:get_length()
   for i = 2, self.num_sub_paths do
      self.patht_start[i] = self.patht_start[i-1] + self:subpath(i-1):get_length() / total_length
   end

   if self.have_timestamps then
      gcs:send_text(MAV_SEVERITY.INFO,"Calculated timestamps")
   end
end

function _path_composer:patht_to_timestamp(path_t)
   path_t = constrain(path_t, 0.0, 1.0)
   if not self.have_timestamps then
      return path_t
   end
   for i = 1, self.num_sub_paths do
      if self.patht_start[i+1] >= path_t then
         local dt = path_t - self.patht_start[i]
         local p = dt / (self.patht_start[i+1] - self.patht_start[i])
         return self.timestamp_start[i] + p * (self.timestamp_start[i+1] - self.timestamp_start[i])
      end
   end
   return self.timestamp_start[self.num_sub_paths+1]
end

function _path_composer:timestamp_to_patht(tstamp)
   if not self.have_timestamps then
      return tstamp
   end
   tstamp = constrain(tstamp, 0.0, self.timestamp_start[self.num_sub_paths+1])
   for i = 1, self.num_sub_paths do
      if self.timestamp_start[i+1] >= tstamp then
         local dt = tstamp - self.timestamp_start[i]
         local p = dt / (self.timestamp_start[i+1] - self.timestamp_start[i])
         return self.patht_start[i] + p * (self.patht_start[i+1] - self.patht_start[i])
      end
   end
   return 1.0
end

--[[
   get the time that the next segment starts
--]]
function _path_composer:get_next_segment_start(t)
   local subpath_t, i = self:get_subpath_t(t)
   local sp = self:subpath(i)
   if sp.get_next_segment_start ~= nil then
      return self.start_time[i] + (sp:get_next_segment_start(subpath_t) * (self:end_time(i) - self.start_time[i]))
   end
   return self:end_time(i)
end

local function path_composer(name, subpaths)
   local self = _path_composer:create()
   self.name = name
   self.subpaths = subpaths
   self.lengths = {}
   self.start_time = {}
   self.start_orientation = {}
   self.start_pos = {}
   self.start_angle = {}
   self.start_roll_correction = {}
   self.total_length = 0
   self.num_sub_paths = #subpaths
   self.last_subpath_t = { -1, 0, 0 }
   self.highest_i = 0

   local orientation = Quaternion()
   local pos = makeVector3f(0,0,0)
   local angle = 0
   local roll_correction = 0
   local speed = target_groundspeed()

   for i = 1, self.num_sub_paths do
      -- accumulate orientation, position and angle
      self.start_orientation[i] = quat_copy(orientation)
      self.start_pos[i] = pos:copy()
      self.start_angle[i] = angle
      if roll_correction ~= 0 then
         self.start_roll_correction[i] = roll_correction
      end

      local sp = self:subpath(i)

      self.lengths[i] = sp:get_length()
      if self.lengths[i] == nil and i < self.num_sub_paths then
         local sp2 = self:subpath(i+1)
         local next_extents = sp2:get_extents_x()
         if next_extents ~= nil then
            sp:set_next_extents(next_extents, self.start_pos[i], self.start_orientation[i])
            self.lengths[i] = sp:get_length()
            -- solidify this subpath now that it has its length calculated
            self.subpaths[i] = sp
         end
      end

      self.total_length = self.total_length + self.lengths[i]

      local spos = quat_earth_to_body(orientation, sp:get_pos(1.0))

      pos = pos + spos
      orientation = sp:get_final_orientation() * orientation
      orientation:normalize()

      angle = angle + sp:get_roll(1.0, self.lengths[i]/speed)
      roll_correction = roll_correction + sp:get_roll_correction(1.0)

      if sp.set_orient ~= nil then
         -- override orientation at this point in the sequence
         orientation = sp.set_orient
      end

      if sp.roll_ref ~= nil then
         local q = Quaternion()
         q:from_axis_angle(makeVector3f(1,0,0), math.rad(sp.roll_ref))
         orientation = orientation * q
         orientation:normalize()
      end
   end

   -- get our final orientation, including roll
   self.final_orientation = quat_copy(orientation)
   local q = Quaternion()
   q:from_axis_angle(makeVector3f(1,0,0), math.rad(wrap_180(angle)))
   self.final_orientation = q * self.final_orientation

   -- work out the proportion of the total time we will spend in each sub path
   local total_time = 0
   for i = 1, self.num_sub_paths do
      self.start_time[i] = total_time
      local proportion = self.lengths[i]/self.total_length
      total_time = total_time + proportion
   end
   return self
end


--[[
   make a list of Path() objects from a list of PathComponent, RollComponent pairs
--]]
function make_paths(name, paths)
   local p = {}
   for i = 1, #paths do
      if paths[i][2] == nil then
         p[i] = paths[i][1]
      else
         p[i] = Path(paths[i][1], paths[i][2])
      end
      -- copy over path attributes
      for _, v in pairs(path_attribs) do
         if paths[i][v] ~= nil then
            p[i][v] = paths[i][v]
         end
      end
   end
   return path_composer(name, p)
end

--[[
   composed trajectories, does as individual aerobatic maneuvers
--]]

function climbing_circle(radius, height, bank_angle, arg4)
   return make_paths("climbing_circle", {
         { path_horizontal_arc(radius, 360, height), roll_angle_entry_exit(bank_angle) },
   })
end

function half_climbing_circle(radius, height, bank_angle, arg4)
   return make_paths("half_climbing_circle", {
         { path_horizontal_arc(radius, 180, height), roll_angle_entry_exit(bank_angle) },
   })
end

function partial_circle(radius, bank_angle, angle)
   return make_paths("partial_circle", {
         { path_horizontal_arc(radius, angle, 0), roll_angle_entry_exit(bank_angle) },
   })
end

function loop(radius, bank_angle, num_loops, arg4)
   if not num_loops or num_loops <= 0 then
      num_loops = 1
   end
   return make_paths("loop", {
         { path_vertical_arc(radius, 360*num_loops), roll_angle_entry_exit(bank_angle) },
   })
end

function straight_roll(length, num_rolls, arg3, arg4)
   return make_paths("straight_roll", {
         { path_straight(length), roll_angle(num_rolls*360) },
   })
end

--[[
   fly straight until we are distance meters from the composite path
   origin in the maneuver frame along the X axis. If we are already
   past that position then return immediately
--]]
function straight_align(distance, arg2, arg3, arg4, start_pos, start_orientation)
   local d2 = distance - start_pos:x()
   local v = quat_earth_to_body(start_orientation, makeVector3f(d2, 0, 0))
   local len = math.max(v:x(),0.01)
   return make_paths("straight_align", {
         { path_straight(len), roll_angle(0) },
   })
end

--[[
   fly straight so that the next maneuver in the sequence ends at
   the given proportion of the aerobatic box
--]]
function align_box(alignment, arg2, arg3, arg4)
   return Path(path_align_box(alignment), roll_angle(0))
end

--[[
   fly straight so that the next maneuver in the sequence is centered
   in the aerobatic box
--]]
function align_center(arg1, arg2, arg3, arg4)
   return Path(path_align_center(), roll_angle(0))
end

function immelmann_turn(r, arg2, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("immelmann_turn", {
         { path_vertical_arc(r, 180),      roll_angle(0) },
         { path_straight(rabs),            roll_angle(180) },
   })
end

-- immelmann with max roll rate
function immelmann_turn_fast(r, arg2, arg3, arg4)
   local roll_time = 180.0 / ACRO_ROLL_RATE:get()
   local roll_dist = target_groundspeed() * roll_time
   return make_paths("immelmann_turn_fast", {
         { path_vertical_arc(r, 180),      roll_angle(0) },
         { path_straight(roll_dist),       roll_angle(180) },
   })
end

function humpty_bump(r, h, arg3, arg4)
   assert(h >= 2*r)
   local rabs = math.abs(r)
   return make_paths("humpty_bump", {
            { path_vertical_arc(r, 90),             roll_angle(0) },
            { path_straight((h-2*rabs)/3),          roll_angle(0) },
            { path_straight((h-2*rabs)/3),          roll_angle(180) },
            { path_straight((h-2*rabs)/3),          roll_angle(0) },
            { path_vertical_arc(-r, 180),           roll_angle(0) },
            { path_straight(h-2*rabs),              roll_angle(0) },
            { path_vertical_arc(-r, 90),            roll_angle(0) },
            { path_straight(2*rabs),                roll_angle(0) },
   })
end

function laydown_humpty(r, h, arg3, arg4)
   assert(h >= 2*r)
   local rabs = math.abs(r)
   return make_paths("laydown_humpty", {
            { path_vertical_arc(r, 45),          roll_angle(0) },
            { path_straight((h-2*rabs)/3),       roll_angle(0) },
            { path_straight((h-2*rabs)/3),       roll_angle(-90), roll_ref=90 },
            { path_straight((h-2*rabs)/3),       roll_angle(0) },
            { path_vertical_arc(r, 180),         roll_angle(0) },
            { path_straight((h-2*rabs)/3),       roll_angle(0) },
            { path_straight((h-2*rabs)/3),       roll_angle(90),  roll_ref=-90 },
            { path_straight((h-2*rabs)/3),       roll_angle(0) },
            { path_vertical_arc(-r, 45),         roll_angle(0), roll_ref=180},
   })
end

function split_s(r, arg2, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("split_s", {
         { path_straight(rabs/2),                roll_angle(180) },
         { path_vertical_arc(-r, 180),           roll_angle(0) },
   })
end

function upline_45(r, height_gain, arg3, arg4)
   --local h = (height_gain - 2*r*(1.0-math.cos(math.rad(45))))/math.sin(math.rad(45))
   local h = (height_gain - (2 * r) + (2 * r * math.cos(math.rad(45)))) / math.cos(math.rad(45))
  assert(h >= 0)
   return make_paths("upline_45", {
         { path_vertical_arc(r, 45),  roll_angle(0) },
         { path_straight(h),          roll_angle(0) },
         { path_vertical_arc(-r, 45), roll_angle(0) },
   })
end

function upline_20(r, height_gain, arg3, arg4)
   local h = (height_gain - 2*r*(1.0-math.cos(math.rad(20))))/math.sin(math.rad(20))
   assert(h >= 0)
   return make_paths("upline_45", {
         { path_vertical_arc(r, 20),  roll_angle(0) },
         { path_straight(h),          roll_angle(0) },
         { path_vertical_arc(-r, 20), roll_angle(0) },
   })
end

function downline_45(r, height_loss, arg3, arg4)
   local h = (height_loss - 2*r*(1.0-math.cos(math.rad(45))))/math.sin(math.rad(45))
   assert(h >= 0)
   return make_paths("downline_45", {
         { path_vertical_arc(-r, 45),  roll_angle(0) },
         { path_straight(h),           roll_angle(0) },
         { path_vertical_arc(r, 45),   roll_angle(0) },
   })
end

function rolling_circle(radius, num_rolls, arg3, arg4)
   return make_paths("rolling_circle", {
         { path_horizontal_arc(radius, 360), roll_angle(360*num_rolls), thr_boost=true },
   })
end

function barrel_roll(radius, length, num_spirals, arg4)
   local gamma_deg = math.deg(math.atan((length/num_spirals)/(2*math.pi*math.abs(radius))))
   local speed = target_groundspeed()
   local bank = math.deg(math.atan((speed*speed) / (radius * GRAVITY_MSS)))
   local radius2 = radius/(1.0 - math.cos(math.rad(90-gamma_deg)))

   return make_paths("barrel_roll", {
         { path_horizontal_arc(-radius2, 90-gamma_deg, 0), roll_angle_entry_exit(-bank) },
         { path_cylinder(radius, length, num_spirals),    roll_angle(0) },
         { path_horizontal_arc(radius2, 90-gamma_deg, 0),  roll_angle_entry_exit(bank) },
   })
end

function side_step(displacement, length, arg3, arg4)
   local speed = target_groundspeed()
   local radius = (displacement*displacement + length*length)/(4*displacement)
   local angle = math.deg(2*math.atan(displacement, length))
   local sign = sgn(displacement)
   local bank = math.deg(math.atan((speed*speed) / (radius * GRAVITY_MSS)))

   return make_paths("side_step",{
      {path_horizontal_arc(sign*radius, angle, 0), roll_angle_entry_exit(sign*bank)},
      {path_horizontal_arc(-sign*radius, angle, 0) , roll_angle_entry_exit(-sign*bank)},
   })
end

function straight_flight(length, bank_angle, arg3, arg4)
   return make_paths("straight_flight", {
         { path_straight(length), roll_angle_entry_exit(bank_angle) },
   })
end

function straight_hold(length, bank_angle, arg3, arg4)
   return make_paths("straight_hold", {
         { path_straight(length), roll_angle_entry(bank_angle) },
   })
end

function scale_figure_eight(r, bank_angle, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("scale_figure_eight", {
         { path_straight(rabs),             roll_angle(0) },
         { path_horizontal_arc(r,  90),     roll_angle_entry_exit(bank_angle) },
         { path_horizontal_arc(-r, 360),    roll_angle_entry_exit(-bank_angle) },
         { path_horizontal_arc(r,  270),    roll_angle_entry_exit(bank_angle) },
         { path_straight(3*rabs),           roll_angle(0) },
   })
end

function figure_eight(r, bank_angle, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("figure_eight", {
         { path_straight(rabs*math.sqrt(2)), roll_angle(0) },
         { path_horizontal_arc(r,  225),     roll_angle_entry_exit(bank_angle) },
         { path_straight(2*rabs),            roll_angle(0) },
         { path_horizontal_arc(-r,  270),    roll_angle_entry_exit(-bank_angle) },
         { path_straight(2*rabs),            roll_angle(0) },
         { path_horizontal_arc(r,    45),    roll_angle_entry_exit(bank_angle) },
   })
end


--[[
   perform a rudder over maneuver
--]]
function rudder_over(direction, min_speed)
   local self = {}
   local reached_speed = false
   local kick_started = false
   local pitch2_done = false
   local descent_done = false
   local target_q = nil
   local initial_q = nil
   local last_t = nil
   local initial_z = nil
   local desired_direction = nil

   --[[
      the update() method is called during the rudder over, it
      should return true when the maneuver is completed
   --]]
   function self.update(path, t, target_speed)
      if descent_done then
         -- we're all done
         return true
      end

      local ahrs_quat = ahrs:get_quaternion()
      local ahrs_pos = ahrs:get_relative_position_NED_origin()
      local ahrs_gyro = ahrs:get_gyro()
      local now = millis():tofloat() * 0.001

      if target_q == nil then
         -- initialising
         initial_z = ahrs_pos:z()
         target_q = quat_copy(ahrs_quat)
         initial_q = quat_copy(target_q)
         last_t = now
      end

      local dt = now - last_t
      last_t = now

      local error_quat = ahrs_quat:inverse() * target_q
      local rate_rads = Vector3f()
      error_quat:to_axis_angle(rate_rads)
      local tc = ROLL_CORR_TC:get()
      local rate_dps = rate_rads:scale(math.deg(1)/tc)

      -- use user set throttle for achieving the stall
      local throttle = AEROM_STALL_THR:get()
      local pitch_deg = math.deg(ahrs:get_pitch_rad())
      if reached_speed and not kick_started and math.abs(math.deg(ahrs_gyro:z())) > ACRO_YAW_RATE:get()/3 then
         kick_started = true
      end
      if kick_started then
         -- when we have established some yaw rate cut the throttle to minimum
         throttle = AEROM_THR_MIN:get()
      end

      vehicle:set_target_throttle_rate_rpy(throttle, rate_dps:x(), rate_dps:y(), rate_dps:z())

      log_pose('POSM', ahrs_pos, ahrs:get_quaternion())
      log_pose('POST', ahrs_pos, target_q)

      local current_speed_up = -ahrs:get_velocity_NED():z()
      if not reached_speed and current_speed_up <= min_speed then
         reached_speed = true
      end

      if not reached_speed then
         return false
      end

      -- integrate desired attitude through yaw
      local q_rate_rads = makeVector3f(0,0,ahrs_gyro:z())
      if pitch2_done then
         -- stop adding yaw
         q_rate_rads:z(0)
      end
      local rotation = Quaternion()
      rotation:from_angular_velocity(q_rate_rads, dt)
      target_q = target_q * rotation
      target_q:normalize()

      --[[
         override rudder to maximum, basing PWM on the MIN/MAX of the channel
         according to the desired direction
      --]]
      if desired_direction == nil then
         desired_direction = direction
         if desired_direction == 0 then
            local c_y = get_ahrs_dcm_c_y()
            if c_y > 0 then
               desired_direction = 1
            else
               desired_direction = -1
            end
         end
      end
      if not pitch2_done then
         vehicle:set_rudder_offset(desired_direction * 100, false)
      else
         vehicle:set_rudder_offset(0, true)
      end
      if not kick_started then
         return false
      end

      -- see if we are nose down
      if kick_started and pitch_deg < AEROM_STALL_PIT:get() and not pitch2_done then
         -- lock onto a descent path
         pitch2_done = true
         target_q = initial_q * qorient(0, 0, 180)
         --[[ correct the attitude to the opposite correction that we
            had at the start of the slowdown, so we fight the wind on
            the way down
         --]]
         local error_q = initial_q:inverse() * qorient(0, 90, math.deg(initial_q:get_euler_yaw()))
         local error_pitch = error_q:get_euler_pitch()
         local error_yaw = error_q:get_euler_yaw()
         target_q = target_q * qorient(0, math.deg(-2*error_pitch), math.deg(2*error_yaw))
         target_q:normalize()
         return false
      end

      if not pitch2_done or ahrs_pos:z() < initial_z then
         -- haven't finished the descent
         return false
      end

      -- all done, update state
      descent_done = true
      path_var.tangent = path_var.tangent:scale(-1)
      path_var.path_t = path:get_next_segment_start(t)
      path_var.accumulated_orientation_rel_ef = path_var.accumulated_orientation_rel_ef * qorient(0,0,180)
      path_var.last_time = now
      path_var.last_ang_rate_dps = ahrs_gyro:scale(math.deg(1))
      path_var.pos = rotate_path(path, path_var.path_t, path_var.initial_ori, path_var.initial_ef_pos)
      -- ensure that the path will move fwd on the next step
      path_var.pos:z(path_var.pos:z()-10)

      return false
   end

   return self
end

--[[
   stall turn is not really correct, as we don't fully stall. Needs to be
   reworked
--]]
function stall_turn(radius, height, direction, min_speed)
   local h = height - radius
   assert(h >= 0)
   return make_paths("stall_turn", {
         { path_vertical_arc(radius, 90),          roll_angle(0) },
         { path_straight(h),                       roll_angle(0) },
         { path_reverse(h/4),                      roll_angle(0), rate_override=rudder_over(direction,min_speed), set_orient=qorient(0,-90,0) },
         { path_straight(h),                       roll_angle(0), pos_corr=0.5, shift_xy=true },
         { path_vertical_arc(-radius, 90),         roll_angle(0), set_orient=qorient(0,0,180) },
   })
end

--[[
   takeoff controller
--]]
function takeoff_controller(distance, thr_slew)
   local self = {}
   local start_time = 0
   local start_pos = nil
   local all_done = false
   local initial_yaw_deg = math.deg(ahrs:get_yaw_rad())
   local yaw_correction_tconst = 1.0
   gcs:send_text(MAV_SEVERITY.INFO,string.format("Takeoff init"))

   --[[
      the update() method is called during the rudder over, it
      should return true when the maneuver is completed
   --]]
   function self.update(path, t, target_speed)
      if all_done then
         return true
      end
      local now = millis():tofloat() * 0.001
      local ahrs_pos = ahrs:get_relative_position_NED_origin()
      if start_time == 0 then
         gcs:send_text(MAV_SEVERITY.INFO,string.format("Takeoff start"))
         start_time = now
         start_pos = ahrs_pos
      end
      local throttle = constrain(thr_slew * (now - start_time), 0, 100)

      local yaw_deg = math.deg(ahrs:get_yaw_rad())
      local yaw_err_deg = wrap_180(yaw_deg - initial_yaw_deg)
      local targ_yaw_rate = -yaw_err_deg / yaw_correction_tconst

      vehicle:set_target_throttle_rate_rpy(throttle, 0, 0, targ_yaw_rate)
      vehicle:set_rudder_offset(0, true)
      local dist_moved = (ahrs_pos - start_pos):length()
      if dist_moved > distance then
         gcs:send_text(MAV_SEVERITY.INFO,string.format("Takeoff complete dist=%.1f", dist_moved))

         path_var.path_t = path:get_next_segment_start(t)
         path_var.last_time = now
         path_var.last_ang_rate_dps = ahrs:get_gyro():scale(math.deg(1))
         path_var.pos = rotate_path(path, path_var.path_t, path_var.initial_ori, path_var.initial_ef_pos)
         all_done = true
      end
      return false
   end

   return self
end

--[[
   stall turn is not really correct, as we don't fully stall. Needs to be
   reworked
--]]
function takeoff(dist, height, thr_slew)
   local angle_deg = 20
   local dist_per_arc = 3*dist/8
   local radius = dist_per_arc / math.sin(math.rad(angle_deg))
   local h1 = dist_per_arc * (1.0 - math.cos(math.rad(angle_deg)))
   local line_h = constrain(height - 2*h1, 0, height)
   local line_len = (line_h - 2*radius*(1.0-math.cos(math.rad(angle_deg))))/math.sin(math.rad(angle_deg))

   return make_paths("takeoff", {
         { path_straight(dist/4), roll_angle(0), rate_override=takeoff_controller(dist/4, thr_slew) },
         { path_vertical_arc(radius, 20),  roll_angle(0), pos_gain_mul=0.3 },
         { path_straight(line_len), roll_angle(0), pos_gain_mul=0.5 },
         { path_vertical_arc(-radius, 20),  roll_angle(0), pos_gain_mul=0.5 },
   })
end

function half_cuban_eight(r, arg2, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("half_cuban_eight", {
         { path_straight(2*rabs*math.sqrt(2)), roll_angle(0) },
         { path_vertical_arc(r,  225),         roll_angle(0) },
         { path_straight(2*rabs/3),            roll_angle(0) },
         { path_straight(2*rabs/3),            roll_angle(180) },
         { path_straight(2*rabs/3),            roll_angle(0) },
         { path_vertical_arc(-r, 45),          roll_angle(0) },
   })
end

function cuban_eight(r, arg2, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("cuban_eight", {
         { path_straight(rabs*math.sqrt(2)), roll_angle(0) },
         { path_vertical_arc(r,  225),       roll_angle(0) },
         { path_straight(2*rabs/3),          roll_angle(0) },
         { path_straight(2*rabs/3),          roll_angle(180) },
         { path_straight(2*rabs/3),          roll_angle(0) },
         { path_vertical_arc(-r, 270),       roll_angle(0) },
         { path_straight(2*rabs/3),          roll_angle(0) },
         { path_straight(2*rabs/3),          roll_angle(180) },
         { path_straight(2*rabs/3),          roll_angle(0) },
         { path_vertical_arc(r, 45),         roll_angle(0) },
   })
end

function half_reverse_cuban_eight(r, arg2, arg3, arg4)
   local rabs = math.abs(r)
   return make_paths("half_reverse_cuban_eight", {
         { path_vertical_arc(r,  45),   roll_angle(0) },
         { path_straight(2*rabs/3),     roll_angle(0) },
         { path_straight(2*rabs/3),     roll_angle(180) },
         { path_straight(2*rabs/3),     roll_angle(0) },
         { path_vertical_arc(-r, 225),  roll_angle(0) },
   })
end

function horizontal_rectangle(total_length, total_width, r, bank_angle)
   local l = total_length - 2*r
   local w = total_width - 2*r
      
   return make_paths("horizontal_rectangle", {
         { path_straight(0.5*l),        roll_angle(0) },
         { path_horizontal_arc(r, 90),  roll_angle_entry_exit(bank_angle)},
         { path_straight(w),            roll_angle(0) },
         { path_horizontal_arc(r, 90),  roll_angle_entry_exit(bank_angle) },
         { path_straight(l),            roll_angle(0) },
         { path_horizontal_arc(r, 90),  roll_angle_entry_exit(bank_angle) },
         { path_straight(w),            roll_angle(0) },
         { path_horizontal_arc(r, 90),  roll_angle_entry_exit(bank_angle) },
         { path_straight(0.5*l),        roll_angle(0) },
   })
end

function vertical_aerobatic_box(total_length, total_width, r, bank_angle)
   local l = total_length - 2*r
   local w = total_width - 2*r
      
   return make_paths("vertical_aerobatic_box", {
         { path_straight(0.5*l),       roll_angle_entry(bank_angle) },
         { path_vertical_arc(r, 90),   roll_angle(0) },
         { path_straight(w),           roll_angle(0) },
         { path_vertical_arc(r, 90),   roll_angle(0) },
         { path_straight(l),           roll_angle(0) },
         { path_vertical_arc(r, 90),   roll_angle(0) },
         { path_straight(w),           roll_angle(0) },
         { path_vertical_arc(r, 90),   roll_angle(0) },
         { path_straight(0.5*l),       roll_angle_exit(-bank_angle) },
   })
end

--[[
   a multi-point roll
     - length = total length of straight flight
     - N = number of points of roll for full 360
     - hold_frac = proportion of each segment to hold attitude, will use 0.2 if 0
     - num_points = number of points of the N point roll to do, will use N if 0

   Note that num_points can be greater than N, for example do 6 points
   of a 4 point roll, resulting in inverted flight
--]]
function multi_point_roll(length, N, hold_frac, num_points)
   if hold_frac <= 0 then
      hold_frac = 0.2
   end
   if num_points <= 0 then
      num_points = N
   end
   --[[
      construct a roll sequence to use over the full length
   --]]
   local seq = {}
   local roll_frac = 1.0 - hold_frac
   for i = 1, num_points do
      seq[#seq+1] = { roll_frac, 360 / N }
      if i < num_points then
         seq[#seq+1] = { hold_frac, 0 }
      end
   end
   return make_paths("multi_point_roll", {{ path_straight(length), roll_sequence(seq) }})
end

function eight_point_roll(length, arg2, arg3, arg4)
   return multi_point_roll(length, 8, 0.5)
end

function procedure_turn(radius, bank_angle, step_out, arg4)
   local rabs = math.abs(radius)
   return make_paths("procedure_turn", {
            { path_horizontal_arc(radius,  90),     roll_angle_entry_exit(bank_angle) },
            { path_straight(step_out),              roll_angle(0) },
            { path_horizontal_arc(-radius,  270),   roll_angle_entry_exit(-bank_angle) },
            { path_straight(3*rabs),                roll_angle(0) },
      })
end

---------------------------------------------------

--[[
   target speed is taken as max of target airspeed and current 3D
   velocity at the start of the maneuver
--]]
function target_groundspeed()
   return math.max(ahrs:get_EAS2TAS()*AIRSPEED_CRUISE:get(), ahrs:get_velocity_NED():length())
end

--[[
   get ground course from AHRS
--]]
function get_ground_course_deg()
   local vned = ahrs:get_velocity_NED()
   return wrap_180(math.deg(math.atan(vned:y(), vned:x())))
end


--args:
--  path_f: path function returning position 
--  t: normalised [0, 1] time
--  arg1, arg2: arguments for path function
--  orientation: maneuver frame orientation
--returns: requested position, angle and speed in maneuver frame
function rotate_path(path_f, t0, orientation, offset)
   local t = constrain(t0, 0, 1)
   local point = path_f:get_pos(t)
   local angle = path_f:get_roll(t)
   local roll_correction = path_f:get_roll_correction(t)

   local attrib = {}
   for _, v in pairs(path_attribs) do
      attrib[v] = path_f:get_attribute(t, v)
   end
   point = point + path_var.path_shift
   point = quat_earth_to_body(orientation, point)

   local scale = AEROM_PATH_SCALE:get()
   point = point:scale(math.abs(scale))
   if scale < 0 then
      -- we need to mirror the path
      point:y(-point:y())
      roll_correction = -roll_correction
      angle = -angle
      -- compensate path orientation for the mirroring
      local orient = orientation:inverse()
      point = quat_body_to_earth((orient * orient), point)
   end

   return point+offset, math.rad(angle+roll_correction), attrib
end

--Given vec1, vec2, returns an (rotation axis, angle) tuple that rotates vec1 to be parallel to vec2
--If vec1 and vec2 are already parallel, returns a zero vector and zero angle
--Note that the rotation will not be unique.
function vectors_to_rotation(vector1, vector2)
   local axis = vector1:cross(vector2)
   if axis:length() < 0.00001 then
      local vec = Vector3f()
      vec:x(1)
      return vec, 0
   end
   axis:normalize()
   local angle = vector1:angle(vector2)
   return axis, angle
end

--returns Quaternion
function vectors_to_rotation_w_roll(vector1, vector2, roll)
   local axis, angle = vectors_to_rotation(vector1, vector2)
   local vector_rotation = Quaternion()
   vector_rotation:from_axis_angle(axis, angle)

   local roll_rotation = Quaternion()
   roll_rotation:from_euler(roll, 0, 0)
   
   local total_rot = vector_rotation*roll_rotation
   return to_axis_and_angle(total_rot)
end

--Given vec1, vec2, returns an angular velocity  tuple that rotates vec1 to be parallel to vec2
--If vec1 and vec2 are already parallel, returns a zero vector and zero angle 
function vectors_to_angular_rate(vector1, vector2, time_constant)
   local axis, angle = vectors_to_rotation(vector1, vector2)
   local angular_velocity = angle/time_constant
   return axis:scale(angular_velocity)
end

function vectors_to_angular_rate_w_roll(vector1, vector2, time_constant, roll)
   local axis, angle = vectors_to_rotation_w_roll(vector1, vector2, roll)
   local angular_velocity = angle/time_constant
   return axis:scale(angular_velocity)
end

-- convert a quaternion to axis angle form
function to_axis_and_angle(quat)
   local axis_angle = Vector3f()
   quat:to_axis_angle(axis_angle)
   local angle = axis_angle:length()
   if angle < 0.00001 then
      return makeVector3f(1.0, 0.0, 0.0), 0.0
   end
   return axis_angle:scale(1.0/angle), angle
end

--projects x onto the othogonal subspace of span(unit_v)
function ortho_proj(x, unit_v)
   local temp_x = unit_v:cross(x)
   return unit_v:cross(temp_x)
end

-- log a pose from position and quaternion attitude
function log_pose(logname, pos, quat)
   local loc = ahrs:get_origin():copy()
   loc:offset(pos:x(),pos:y())
   logger.write(logname, 'px,py,pz,q1,q2,q3,q4,r,p,y,Lat,Lon', 'ffffffffffLL',
                pos:x(),
                pos:y(),
                pos:z(),
                quat:q1(),
                quat:q2(),
                quat:q3(),
                quat:q4(),
                math.deg(quat:get_euler_roll()),
                math.deg(quat:get_euler_pitch()),
                math.deg(quat:get_euler_yaw()),
                loc:lat(),
                loc:lng())
end

--[[
   get GPS week and MS, coping with crossing a week boundary
--]]
function get_gps_times()
   local gps_last_fix_ms1 = gps:last_fix_time_ms(0)
   local gps_week = gps:time_week(0)
   local gps_week_ms = gps:time_week_ms(0)
   local gps_last_fix_ms2 = gps:last_fix_time_ms(0)
   local now_ms = millis()
   if gps_last_fix_ms2 ~= gps_last_fix_ms1 then
      -- we got a new fix while requesting the values. fetch again,
      -- and assume we won't get another fix during these calls
      gps_week = gps:time_week(0)
      gps_week_ms = gps:time_week_ms(0)
   end
   gps_week_ms = gps_week_ms + (now_ms - gps_last_fix_ms2)
   return gps_week, gps_week_ms
end

function log_position(logname, loc, quat)
   local gps_week, gps_week_ms = get_gps_times()

   logger.write(logname, 'I,GWk,GMS,Lat,Lon,Alt,R,P,Y',
                'BHILLffff',
                '#--DU----',
                '---GG----',
                MAV_SYSID:get(),
                gps_week,
                gps_week_ms,
                loc:lat(),
                loc:lng(),
                loc:alt()*0.01,
                math.deg(quat:get_euler_roll()),
                math.deg(quat:get_euler_pitch()),
                math.deg(quat:get_euler_yaw()))
end

--[[
   check if a number is Nan.
--]]
function isNaN(value)
   -- NaN is lua is not equal to itself
   return value ~= value
end

function Vec3IsNaN(v)
   return isNaN(v:x()) or isNaN(v:y()) or isNaN(v:z())
end

function qIsNaN(q)
   return isNaN(q:q1()) or isNaN(q:q2()) or isNaN(q:q3()) or isNaN(q:q4())
end

--[[
   return the body y projection down, this is the c.y element of the equivalent rotation matrix
--]]
function quat_projection_ground_plane(q)
   local q1q2 = q:q1() * q:q2()
   local q3q4 = q:q3() * q:q4()
   return 2.0 * (q3q4 + q1q2)
end


--[[
   calculate rudder offset
--]]
function calculate_rudder_offset(ahrs_quat, ahrs_gyro, airspeed_constrained)
   --[[
      look ahead for what our y projection will be at AEROM_KE_RUDD_LK
      seconds forward in time
   --]]
   local qchange = Quaternion()
   qchange:from_angular_velocity(ahrs_gyro, -AEROM_KE_RUDD_LK:get())
   local qnew = qchange * ahrs_quat

   local airspeed_scaling = SCALING_SPEED:get()/airspeed_constrained
   local y_projection = get_quat_dcm_c_y(qnew:inverse())
   local rudder_ofs = -y_projection * AEROM_KE_RUDD:get() * sq(airspeed_scaling)
   rudder_ofs = constrain(rudder_ofs, -100, 100)

   return rudder_ofs
end

--[[
   convert a table of bytes to a lua string
--]]
function bytes_to_string(bytes)
   local ret = {}
   for _, b in ipairs(bytes) do
      if b == 0 then
         break
      end
      table.insert(ret, string.char(b))
   end
   return table.concat(ret)
end

--[[
   a lua implementation of the jitter correction algorithm from libraries/AP_RTC

   note that the use of a 32 bit float lua number for a uint32_t
   milliseconds means we lose accuracy over time. At 9 hours we have
   an accuracy of about 1 millisecond
--]]
local function JitterCorrection(max_lag_ms, convergence_loops)
   local self = {}

   local link_offset_ms = 0
   local min_sample_ms = 0
   local initialised = false
   local min_sample_counter = 0

   function self.correct_offboard_timestamp_msec(offboard_ms, local_ms)
      local diff_ms = local_ms - offboard_ms
      if not initialised or diff_ms < link_offset_ms then
         --[[
            this message arrived from the remote system with a
            timestamp that would imply the message was from the
            future. We know that isn't possible, so we adjust down the
            correction value
         --]]
        link_offset_ms = diff_ms
        initialised = true
      end

      local estimate_ms = offboard_ms + link_offset_ms

      if estimate_ms + max_lag_ms < local_ms then
         --[[
            this implies the message came from too far in the past. clamp the lag estimate
            to assume the message had maximum lag
         --]]
         estimate_ms = local_ms - max_lag_ms
         link_offset_ms = estimate_ms - offboard_ms
      end

      if min_sample_counter == 0 then
         min_sample_ms = diff_ms
      end

      min_sample_counter = (min_sample_counter+1)
      if diff_ms < min_sample_ms then
         min_sample_ms = diff_ms
      end
      if min_sample_counter == convergence_loops then
         --[[
            we have the requested number of samples of the transport
            lag for convergence. To account for long term clock drift
            we set the diff we will use in future to this value
         --]]
         link_offset_ms = min_sample_ms
         min_sample_counter = 0
      end
    
      return estimate_ms
   end

   return self
end

--[[
   import mavlink support for NAMED_VALUE_FLOAT, only used for
   DUAL_AIRCRAFT operation
--]]
local function mavlink_receiver()
   local self = {}
   local mavlink_msgs = require("mavlink_msgs")
   local NAMED_VALUE_FLOAT_msgid = mavlink_msgs.get_msgid("NAMED_VALUE_FLOAT")
   local msg_map = {}
   local jitter_correction = JitterCorrection(5000, 100)

   msg_map[NAMED_VALUE_FLOAT_msgid] = "NAMED_VALUE_FLOAT"

   -- initialize MAVLink rx with buffer depth and number of rx message IDs to register
   mavlink.init(10, 1)

   -- register message id to receive
   mavlink.register_rx_msgid(NAMED_VALUE_FLOAT_msgid)

   --[[
      get a NAMED_VALUE_FLOAT incoming message, handling jitter correction
   --]]
   function self.get_named_value_float()
      local msg,_,timestamp_ms = mavlink.receive_chan()
      if msg then
         local parsed_msg = mavlink_msgs.decode(msg, msg_map)
         if (parsed_msg ~= nil) and (parsed_msg.msgid == NAMED_VALUE_FLOAT_msgid) then
            -- convert remote timestamp to local timestamp with jitter correction
            local time_boot_ms = jitter_correction.correct_offboard_timestamp_msec(parsed_msg.time_boot_ms, timestamp_ms:toint())
            local value = parsed_msg.value
            local name = bytes_to_string(parsed_msg.name)
            return time_boot_ms, name, value, parsed_msg.sysid
         end
      end
      return nil
   end

   return self
end

local mavlink_handler = nil
if option_set(OPTIONS.DUAL_AIRCRAFT) then
   mavlink_handler = mavlink_receiver()
end

--[[
   handle NAMED_VALUE_FLOAT from another vehicle to sync our schedules
--]]
function handle_speed_adjustment()
   local local_t = millis():tofloat() * 0.001
   local named_float_rate = AEROM_TS_RATE:get()
   local loc_timestamp = current_task.fn:patht_to_timestamp(path_var.path_t)
   if named_float_rate > 0 and loc_timestamp > 1 and local_t - last_named_float_send_t > 1.0/named_float_rate then
      last_named_float_send_t = local_t
      gcs:send_named_float("PATHT", loc_timestamp)
   end
   local time_boot_ms, name, remote_timestamp, sysid = mavlink_handler.get_named_value_float()
   if not time_boot_ms then
      return
   end
   -- gcs:send_text(MAV_SEVERITY.INFO, string.format("NVF: name='%s' value=%f sysid=%d tbm=%f", name, remote_timestamp, sysid, time_boot_ms))
   if name == "PATHT" and sysid ~= MAV_SYSID:get() then
      local remote_t = time_boot_ms * 0.001
      local dt = local_t - remote_t
      local rem_patht = current_task.fn:timestamp_to_patht(remote_timestamp)
      local adjusted_rem_path_t = rem_patht + dt / path_var.total_time
      local dist_err = (path_var.path_t - adjusted_rem_path_t) * path_var.total_time * path_var.target_speed

      if loc_timestamp > 1 and remote_timestamp > 1 then
         path_var.speed_adjustment = speed_adjustment_PI.update(dist_err)
      else
         path_var.speed_adjustment = 0.0
      end

      local gps_week, gps_week_ms = get_gps_times()
      logger.write("PTHT",
                   'SysID,GWk,GMS,RemT,LocT,TS,RTS,PT,RPT,Dt,ARPT,DE,SA',
                   'BHIffffffffff',
                   '#------------',
                   '-------------',
                   sysid,
                   gps_week, gps_week_ms,
                   remote_t, local_t,
                   loc_timestamp,
                   remote_timestamp,
                   path_var.path_t, rem_patht,
                   dt, adjusted_rem_path_t, dist_err, path_var.speed_adjustment)
   end
end

path_var.count = 0

function do_path()
   local now = millis():tofloat() * 0.001
   local ahrs_pos_NED = ahrs:get_relative_position_NED_origin()
   local ahrs_pos = ahrs:get_position()
   local ahrs_gyro = ahrs:get_gyro()
   local ahrs_velned = ahrs:get_velocity_NED()
   local ahrs_airspeed = ahrs:airspeed_estimate()
   --[[
      ahrs_quat is the quaterion which when used with quat_earth_to_body() rotates a vector
      from earth to body frame. It needs to be the inverse of ahrs:get_quaternion()
   --]]
   local ahrs_quat = ahrs:get_quaternion():inverse()

   path_var.count = path_var.count + 1
   local path = current_task.fn

   if not current_task.started then
      local initial_yaw_deg = current_task.initial_yaw_deg
      current_task.started = true

      local speed = target_groundspeed()
      path_var.target_speed = speed
      path_var.speed_adjustment = 0.0

      path_var.length = path:get_length() * math.abs(AEROM_PATH_SCALE:get())

      path_var.total_rate_rads_ef = makeVector3f(0.0, 0.0, 0.0)

      --assuming constant velocity
      path_var.total_time = path_var.length/speed

      --deliberately only want yaw component, because the maneuver should be performed relative to the earth, not relative to the initial orientation
      path_var.initial_ori = Quaternion()
      path_var.initial_ori:from_euler(0, 0, math.rad(initial_yaw_deg))
      path_var.initial_ori = path_var.initial_ori
      path_var.initial_ori:normalize()

      path_var.initial_ef_pos = ahrs_pos_NED:copy()

      path_var.start_pos = ahrs_pos:copy()
      path_var.path_int = path_var.start_pos:copy()

      speed_PI.reset()

      path_var.accumulated_orientation_rel_ef = path_var.initial_ori

      path_var.time_correction = 0.0 

      path_var.filtered_angular_velocity = Vector3f()

      path_var.last_time = now - 1.0/LOOP_RATE
      path_var.last_ang_rate_dps = ahrs_gyro:scale(math.deg(1))

      path_var.path_t = 0.0

      path_var.pos = path_var.initial_ef_pos:copy()
      path_var.roll = 0.0
      path_var.last_shift_xy = nil
      path_var.path_shift = Vector3f()

      path_var.ss_angle = 0.0
      path_var.ss_angle_filt = 0.0
      path_var.last_rate_override = 0

      path.highest_i = 0

      -- get initial tangent
      local p1, _ = rotate_path(path, path_var.path_t + 0.1/(path_var.total_time*LOOP_RATE),
                                 path_var.initial_ori, path_var.initial_ef_pos)
      path_var.tangent = p1 - path_var.pos
      return true
   end
   
   local vel_length = ahrs_velned:length()

   local actual_dt = now - path_var.last_time
   if actual_dt < 0.25 / LOOP_RATE then
      -- the update has been executed too soon
      return true
   end

   path_var.last_time = now

   local local_n_dt = (1.0/LOOP_RATE)/path_var.total_time

   if path_var.path_t + local_n_dt > 1.0 then
      -- all done
      return false
   end

   if option_set(OPTIONS.DUAL_AIRCRAFT) then
      handle_speed_adjustment()
   end

   -- airspeed, assume we don't go below min
   local airspeed_constrained = math.max(AIRSPEED_MIN:get(), ahrs_airspeed)

   --[[
      calculate positions and angles at previous, current and next time steps
   --]]

   local p0 = path_var.pos:copy()
   local r0 = path_var.roll
   local p1, _, attrib = rotate_path(path, path_var.path_t + local_n_dt,
                                      path_var.initial_ori, path_var.initial_ef_pos)

   local current_measured_pos_ef = ahrs_pos_NED:copy()

   if attrib.rate_override ~= nil then
      if not attrib.rate_override.update(path, path_var.path_t + local_n_dt, path_var.target_speed) then
         -- not done yet
         path_var.pos = current_measured_pos_ef
         path_var.last_rate_override = now
         return true
      end
   end

   --[[
      see if this path element has a shift_xy attribute
   --]]
   local shift_xy = attrib.shift_xy
   if shift_xy and not path_var.last_shift_xy then
      --[[
         we have entered a new sub-element with a shift_xy
      --]]
      local curpos_mf = quat_body_to_earth(path_var.initial_ori, current_measured_pos_ef)
      local pathpos_mf = quat_body_to_earth(path_var.initial_ori, p1)
      local shift = curpos_mf - pathpos_mf
      shift:z(0)
      path_var.path_shift = path_var.path_shift + shift
      local shift_ef = quat_earth_to_body(path_var.initial_ori, shift)
      p1 = p1 + shift_ef
      p0:y(p1:y())
      p0:x(p1:x())
   end
   path_var.last_shift_xy = shift_xy

   --[[
      get tangents to the path
   --]]
   local tangent1_ef = path_var.tangent:copy()
   local tangent2_ef = p1 - p0

   local tv_unit = tangent2_ef:copy()
   if tv_unit:length() < 0.00001 then
      gcs:send_text(MAV_SEVERITY.EMERGENCY, string.format("path not advancing %f", tv_unit:length()))
   end
   tv_unit:normalize()

   --[[
      use actual vehicle velocity to calculate how far along the
      path we have progressed
   --]]
   local v = ahrs_velned:copy()
   local path_dist = v:dot(tv_unit)*actual_dt
   if path_dist < 0 and path_var.last_rate_override > 0 and now - path_var.last_rate_override > 1 then
      gcs:send_text(MAV_SEVERITY.EMERGENCY, string.format("aborting %.2f at %d tv=(%.2f,%.2f,%.2f) vx=%.2f adt=%.2f",
                                     path_dist, path_var.count,
                                     tangent2_ef:x(),
                                     tangent2_ef:y(),
                                     tangent2_ef:z(),
                                     v:x(), actual_dt))
      if option_set(OPTIONS.ABORT_RTL) and vehicle:get_mode() == MODE_AUTO then
         vehicle:set_mode(MODE_RTL)
      end
      path_var.last_rate_override = 0
      return false
   end
   local path_t_delta = constrain(path_dist/path_var.length, 0.2*local_n_dt, 4*local_n_dt)

   --[[
      recalculate the current path position and angle based on actual delta time
   --]]
   p1, _, _ = rotate_path(path,
                          constrain(path_var.path_t + path_t_delta, 0, 1),
                          path_var.initial_ori, path_var.initial_ef_pos)
   local last_path_t = path_var.path_t
   path_var.path_t = path_var.path_t + path_t_delta

   -- tangents needs to be recalculated
   tangent2_ef = p1 - p0
   tv_unit = tangent2_ef:copy()
   tv_unit:normalize()

   -- error in position versus current point on the path
   local pos_error_ef = current_measured_pos_ef - p1

   --[[
      calculate a time correction. We first get the projection of
      the position error onto the track. This tells us how far we
      are ahead or behind on the track
   --]]
   local path_dist_err_m = tv_unit:dot(pos_error_ef)

   -- normalize against the total path length
   local path_err_t = path_dist_err_m / path_var.length

   -- don't allow the path to go backwards in time, or faster than twice the actual rate
   path_err_t = constrain(path_err_t, -0.9*path_t_delta, 2*path_t_delta)

   -- correct time to bring us back into sync
   path_var.path_t = path_var.path_t + TIME_CORR_P:get() * path_err_t

   -- get the path again with the corrected time
   local r1
   p1, r1, attrib = rotate_path(path,
                                constrain(path_var.path_t, 0, 1),
                                path_var.initial_ori, path_var.initial_ef_pos)
   -- recalculate the tangent to match the amount we advanced the path time
   tangent2_ef = p1 - p0

   -- get the real world time corresponding to the quaternion change
   local q_change_t = (path_var.path_t - last_path_t) * path_var.total_time

   -- low pass filter the demanded roll angle
   r1 = path_var.roll + wrap_pi(r1 - path_var.roll)
   local alpha = calc_lowpass_alpha(q_change_t, AEROM_ANG_TC:get())
   r1 = (1.0 - alpha) * path_var.roll + alpha * r1
   r1 = wrap_pi(r1)

   path_var.tangent = tangent2_ef:copy()
   path_var.pos = p1:copy()
   path_var.roll = r1

   
   --[[
      calculation of error correction, calculating acceleration
      needed to bring us back on the path, and body rates in pitch and
      yaw to achieve those accelerations
   --]]
   
   -- component of pos_err perpendicular to the current path tangent
   local B = ortho_proj(pos_error_ef, tv_unit)

   -- derivative of pos_err perpendicular to the current path tangent, assuming tangent is constant
   local B_dot = ortho_proj(v, tv_unit)

   -- gains for error correction.
   local acc_err_ef = B:scale(ERR_CORR_P:get()) + B_dot:scale(ERR_CORR_D:get())

   if attrib.pos_gain_mul then
      -- allow for reduced gains during some maneuvers like takeoff
      acc_err_ef = acc_err_ef:scale(attrib.pos_gain_mul)
   end

   -- scale by per-maneuver error correction scale factor
   acc_err_ef = acc_err_ef:scale(attrib.pos_corr or 1.0)

   local acc_err_bf = quat_earth_to_body(ahrs_quat, acc_err_ef)

   local TAS = constrain(ahrs:get_EAS2TAS()*airspeed_constrained, 3, 100)
   local corr_rate_bf_y_rads = -acc_err_bf:z()/TAS
   local corr_rate_bf_z_rads = acc_err_bf:y()/TAS

   local cor_ang_vel_bf_rads = makeVector3f(0.0, corr_rate_bf_y_rads, corr_rate_bf_z_rads)
   if Vec3IsNaN(cor_ang_vel_bf_rads) then
      cor_ang_vel_bf_rads = makeVector3f(0,0,0)
   end
   local cor_ang_vel_bf_dps = cor_ang_vel_bf_rads:scale(math.deg(1))

   if path_var.count < 2 then
      cor_ang_vel_bf_dps = Vector3f()
   end

   --[[
      work out body frame path rate, this is based on two adjacent tangents on the path
   --]]
   local path_rate_ef_rads = tangents_to_rate(tangent1_ef, tangent2_ef, actual_dt)
   if Vec3IsNaN(path_rate_ef_rads) then
      gcs:send_text(MAV_SEVERITY.EMERGENCY,string.format("path_rate_ef_rads: NaN"))
      path_rate_ef_rads = makeVector3f(0,0,0)
   end
   local path_rate_ef_dps = path_rate_ef_rads:scale(math.deg(1))
   if path_var.count < 3 then
      -- cope with small initial misalignment
      path_rate_ef_dps:z(0)
   end
   local path_rate_bf_dps = quat_earth_to_body(ahrs_quat, path_rate_ef_dps)

   -- set the path roll rate
   path_rate_bf_dps:x(math.deg(wrap_pi(r1 - r0)/actual_dt))


   --[[
      calculate body frame roll rate to achieved the desired roll
      angle relative to the maneuver path
   --]]
   local zero_roll_angle_delta = Quaternion()
   zero_roll_angle_delta:from_angular_velocity(path_rate_ef_rads, actual_dt)
   path_var.accumulated_orientation_rel_ef = zero_roll_angle_delta*path_var.accumulated_orientation_rel_ef
   path_var.accumulated_orientation_rel_ef:normalize()

   local mf_axis = quat_earth_to_body(path_var.accumulated_orientation_rel_ef, makeVector3f(1, 0, 0))

   local orientation_rel_mf_with_roll_angle = Quaternion()
   orientation_rel_mf_with_roll_angle:from_axis_angle(mf_axis, r1)
   orientation_rel_ef_with_roll_angle = orientation_rel_mf_with_roll_angle*path_var.accumulated_orientation_rel_ef

   --[[
      calculate the error correction for the roll versus the desired roll
   --]]
   local roll_error = orientation_rel_ef_with_roll_angle * ahrs_quat
   roll_error:normalize()
   local err_axis_ef, err_angle_rad = to_axis_and_angle(roll_error)
   local time_const_roll = ROLL_CORR_TC:get()
   local err_angle_rate_ef_rads = err_axis_ef:scale(err_angle_rad/time_const_roll)
   local err_angle_rate_bf_dps = quat_earth_to_body(ahrs_quat,err_angle_rate_ef_rads):scale(math.deg(1))
   -- zero any non-roll components
   err_angle_rate_bf_dps:y(0)
   err_angle_rate_bf_dps:z(0)

   --[[
      implement lookahead for path rates
   --]]
   if AEROM_LKAHD:get() > 0 then
      local lookahead = AEROM_LKAHD:get()
      local lookahead_vt = lookahead / path_var.total_time
      p2 = rotate_path(path,
                       constrain(path_var.path_t+lookahead_vt, 0, 1),
                       path_var.initial_ori, path_var.initial_ef_pos)
      local tangent3_ef = p2 - p1
      local lk_ef_rads = tangents_to_rate(tangent2_ef, tangent3_ef, 0.5*(lookahead+(1.0/LOOP_RATE)))

      -- scale for airspeed
      lk_ef_rads = lk_ef_rads:scale(sq(vel_length/path_var.target_speed))

      local lookahead_bf_rads = quat_earth_to_body(ahrs_quat, lk_ef_rads)
      local lookahead_bf_dps = lookahead_bf_rads:scale(math.deg(1))
      logger.write('AELK','Py,Ly,Pz,Lz', 'ffff',
                   path_rate_bf_dps:y(),
                   lookahead_bf_dps:y(),
                   path_rate_bf_dps:z(),
                   lookahead_bf_dps:z())
      if not Vec3IsNaN(lookahead_bf_dps) then
         path_rate_bf_dps:y(lookahead_bf_dps:y())
         path_rate_bf_dps:z(lookahead_bf_dps:z())
      end
   end
   
   --[[
      calculate an additional yaw rate to get us to the right angle of sideslip for knifeedge
   --]]
   -- local sideslip_rate_bf_dps = calculate_side_slip_aoa(path_rate_bf_dps, ahrs_quat, airspeed_constrained, tv_unit, ahrs_velned, actual_dt)
   local sideslip_rate_bf_dps = Vector3f()

   --[[
      total angular rate is sum of path rate, correction rate and roll correction rate
   --]]
   local tot_ang_vel_bf_dps = path_rate_bf_dps + cor_ang_vel_bf_dps + err_angle_rate_bf_dps + sideslip_rate_bf_dps

   --[[
      apply angular accel limit
   --]]
   local ang_rate_diff_dps = tot_ang_vel_bf_dps - path_var.last_ang_rate_dps
   local max_delta_dps = AEROM_ANG_ACCEL:get() * actual_dt
   local max_delta_yaw_dps = max_delta_dps
   if AEROM_YAW_ACCEL:get() > 0 and
      (AEROM_YAW_ACCEL:get() < AEROM_ANG_ACCEL:get() or AEROM_ANG_ACCEL:get() <= 0) then
      max_delta_yaw_dps = AEROM_YAW_ACCEL:get() * actual_dt
   end
   if max_delta_dps > 0 then
      ang_rate_diff_dps:x(constrain(ang_rate_diff_dps:x(), -max_delta_dps, max_delta_dps))
      ang_rate_diff_dps:y(constrain(ang_rate_diff_dps:y(), -max_delta_dps, max_delta_dps))
   end
   if max_delta_yaw_dps > 0 then
      ang_rate_diff_dps:z(constrain(ang_rate_diff_dps:z(), -max_delta_yaw_dps, max_delta_yaw_dps))
   end

   tot_ang_vel_bf_dps = path_var.last_ang_rate_dps + ang_rate_diff_dps
   path_var.last_ang_rate_dps = tot_ang_vel_bf_dps

   --[[
      calculate a rudder offset for knife-edge
   --]]
   local rudder_offset_pct = 0
   if AEROM_KE_RUDD:get() > 0 then
      rudder_offset_pct = calculate_rudder_offset(ahrs_quat, ahrs_gyro, airspeed_constrained)
   end

   --[[
      log POSM is pose-measured, POST is pose-track, POSB is pose-track without the roll
   --]]
   log_pose('POSM', current_measured_pos_ef, ahrs_quat:inverse())
   log_pose('POST', p1, orientation_rel_ef_with_roll_angle)

   logger.write('AETM', 'T,Terr,QCt,Adt','ffff',
                path_var.path_t,
                path_err_t,
                q_change_t,
                actual_dt)

   logger.write('AERT','Cx,Cy,Cz,Px,Py,Pz,Ex,Tx,Ty,Tz,Perr,Aerr,Yff,Rofs', 'ffffffffffffff',
                cor_ang_vel_bf_dps:x(), cor_ang_vel_bf_dps:y(), cor_ang_vel_bf_dps:z(),
                path_rate_bf_dps:x(), path_rate_bf_dps:y(), path_rate_bf_dps:z(),
                err_angle_rate_bf_dps:x(),
                tot_ang_vel_bf_dps:x(), tot_ang_vel_bf_dps:y(), tot_ang_vel_bf_dps:z(),
                pos_error_ef:length(),
                wrap_180(math.deg(err_angle_rad)),
                sideslip_rate_bf_dps:z(),
                rudder_offset_pct)

   --log_pose('POSB', p1, path_var.accumulated_orientation_rel_ef)

   --[[
      run the throttle based speed controller

      get the anticipated pitch at the throttle lookahead time
      we use the maximum of the current path pitch and the anticipated pitch
   --]]
   local qchange = Quaternion()
   qchange:from_angular_velocity(path_rate_ef_rads, AEROM_THR_LKAHD:get())
   local qnew = qchange * orientation_rel_ef_with_roll_angle
   local anticipated_pitch_rad = math.max(qnew:get_euler_pitch(), orientation_rel_ef_with_roll_angle:get_euler_pitch())

   local throttle = speed_PI.update(path_var.target_speed + path_var.speed_adjustment, anticipated_pitch_rad)
   local thr_min = AEROM_THR_MIN:get()
   if attrib.thr_boost then
      thr_min = math.max(thr_min, AEROM_THR_BOOST:get())
   end
   throttle = constrain(throttle, thr_min, 100.0)

   if isNaN(throttle) or Vec3IsNaN(tot_ang_vel_bf_dps) then
      gcs:send_text(MAV_SEVERITY.EMERGENCY,string.format("Path NaN - aborting"))
      return false
   end

   vehicle:set_target_throttle_rate_rpy(throttle, tot_ang_vel_bf_dps:x(), tot_ang_vel_bf_dps:y(), tot_ang_vel_bf_dps:z())
   vehicle:set_rudder_offset(rudder_offset_pct, true)

   if now - last_named_float_t > 1.0 / NAME_FLOAT_RATE then
      last_named_float_t = now
      gcs:send_named_float("PERR", pos_error_ef:length())
   end

   local alt_error = (current_measured_pos_ef - path_var.initial_ef_pos):z()
   if alt_error > AEROM_ALT_ABORT:get() then
     gcs:send_text(MAV_SEVERITY.EMERGENCY,"Too low altitude, aborting")
     return false
   end

   return true
end

--[[
   an object defining a path
--]]
function PathFunction(fn, name)
   local self = {}
   self.fn = fn
   self.name = name
   return self
end

local last_preload = nil

local command_table = {}
command_table[1] = PathFunction(figure_eight, "Figure Eight")
command_table[2] = PathFunction(loop, "Loop")
command_table[3] = PathFunction(horizontal_rectangle, "Horizontal Rectangle")
command_table[4] = PathFunction(climbing_circle, "Climbing Circle")
command_table[5] = PathFunction(vertical_aerobatic_box, "Vertical Box")
command_table[6] = PathFunction(immelmann_turn_fast, "Immelmann Fast")
command_table[7] = PathFunction(straight_roll, "Axial Roll")
command_table[8] = PathFunction(rolling_circle, "Rolling Circle")
command_table[9] = PathFunction(half_cuban_eight, "Half Cuban Eight")
command_table[10]= PathFunction(half_reverse_cuban_eight, "Half Reverse Cuban Eight")
command_table[11]= PathFunction(cuban_eight, "Cuban Eight")
command_table[12]= PathFunction(humpty_bump, "Humpty Bump")
command_table[13]= PathFunction(straight_flight, "Straight Flight")
command_table[14]= PathFunction(scale_figure_eight, "Scale Figure Eight")
command_table[15]= PathFunction(immelmann_turn, "Immelmann Turn")
command_table[16]= PathFunction(split_s, "Split-S")
command_table[17]= PathFunction(upline_45, "Upline-45")
command_table[18]= PathFunction(downline_45, "Downline-45")
command_table[19]= PathFunction(stall_turn, "Stall Turn")
command_table[20]= PathFunction(procedure_turn, "Procedure Turn")
command_table[23]= PathFunction(half_climbing_circle, "Half Climbing Circle")
command_table[25]= PathFunction(laydown_humpty, "Laydown Humpty")
command_table[26]= PathFunction(barrel_roll, "Barrel Roll")
command_table[27]= PathFunction(straight_flight, "Straight Hold")
command_table[28]= PathFunction(partial_circle, "Partial Circle")
command_table[31]= PathFunction(multi_point_roll, "Multi Point Roll")
command_table[32]= PathFunction(side_step, "Side Step")

--[[
   a table of function available in loadable tricks
--]]
local load_table = {}
load_table["loop"] = loop
load_table["horizontal_rectangle"] = horizontal_rectangle
load_table["climbing_circle"] = climbing_circle
load_table["vertical_aerobatic_box"] = vertical_aerobatic_box
load_table["immelmann_turn_fast"] = immelmann_turn_fast
load_table["straight_roll"] = straight_roll
load_table["rolling_circle"] = rolling_circle
load_table["half_cuban_eight"] = half_cuban_eight
load_table["half_reverse_cuban_eight"] = half_reverse_cuban_eight
load_table["cuban_eight"] = cuban_eight
load_table["humpty_bump"] = humpty_bump
load_table["straight_flight"] = straight_flight
load_table["scale_figure_eight"] = scale_figure_eight
load_table["immelmann_turn"] = immelmann_turn
load_table["split_s"] = split_s
load_table["upline_45"] = upline_45
load_table["upline_20"] = upline_20
load_table["takeoff"] = takeoff
load_table["downline_45"] = downline_45
load_table["stall_turn"] = stall_turn
load_table["procedure_turn"] = procedure_turn
load_table["two_point_roll"] = two_point_roll
load_table["half_climbing_circle"] = half_climbing_circle
load_table["laydown_humpty"] = laydown_humpty
load_table["straight_align"] = straight_align
load_table["figure_eight"] = figure_eight
load_table["barrel_roll"] = barrel_roll
load_table["straight_hold"] = straight_hold
load_table["partial_circle"] = partial_circle
load_table["multi_point_roll"] = multi_point_roll
load_table["side_step"] = side_step
load_table["align_box"] = align_box
load_table["align_center"] = align_center

--[[
   interpret an attribute value, coping with special cases
--]]
function interpret_attrib(v)
   if v == "true" then
      return true
   end
   if v == "false" then
      return false
   end
   -- could be a number
   local n = tonumber(v)
   if n ~= nil then
      return n
   end
   -- assume a string
   return v
end

--[[
   parse a function definition in a txt load file, adding it to the load table so
   it can be used in schedules
--]]
function parse_function(line, file)
   _, _, funcname = string.find(line, "^function%s*([%w_]+).*$")
   if not funcname then
      gcs:send_text(MAV_SEVERITY.ERROR, string.format("Parse error: %s", line))
      return
   end
   local funcstr = line .. "\n"
   while true do
      line = file:read()
      if not line then
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("Error: end of file in %s", funcname))
         break
      end
      funcstr = funcstr .. line .. "\n"
      if string.sub(line,1,3) == "end" then
         break
      end
   end
   local f, errloc, err = load(funcstr, funcname, "t", _ENV)
   if not f then
      gcs:send_text(MAV_SEVERITY.ERROR,string.format("Error %s: %s", errloc, err))
      return
   end
   -- fun the function code, which creates the function
   local success
   success, err = pcall(f)
   if not success then
      gcs:send_text(MAV_SEVERITY.ERROR,string.format("Error %s: %s", funcname, err))
   end
   load_table[funcname] = _ENV[funcname]
end

--[[
   load a trick description from a text file
--]]
function load_trick(id)
   if command_table[id] ~= nil then
      -- already have it
      return
   end
   -- look in 3 possible locations for the trick, coping with SITL and real boards
   local trickdirs = { "APM/scripts/", "scripts/", "./" }
   local file = nil
   local fname = string.format("trick%u.txt", id)
   local filename = nil
   for i = 1, #trickdirs do
      filename = trickdirs[i] .. fname
      file = io.open(filename, "r")
      if file then
         break
      end
   end
   if file == nil then
      gcs:send_text(MAV_SEVERITY.ERROR,string.format("Failed to open %s", fname))
      return
   end
   local name = string.format("Trick%u", id)
   local attrib = {}
   local paths = {}
   while true do
      local line = file:read()
      if not line then
         break
      end
      -- trim trailing spaces
      line = string.gsub(line, '^(.-)%s*$', '%1')
      local _, _, cmd, arg1, arg2, arg3, arg4 = string.find(line, "^([%w_:]+)%s*([-.%d]*)%s*([-.%d]*)%s*([-.%d]*)%s*([-.%d]*)")
      if cmd == "" or cmd == nil or string.sub(cmd,1,1) == "#" then
         -- ignore comments
         goto continue
      elseif cmd == "name:" then
         _, _, name = string.find(line, "^name:%s*([%w_]+)$")
      elseif string.sub(cmd,-1) == ":" then
         _, _, a, s = string.find(line, "^([%w_]+):%s*([%w_:%s-]+)$")
         if a ~= nil then
            attrib[a] = interpret_attrib(s)
         else
            gcs:send_text(MAV_SEVERITY.ERROR, string.format("Bad line: '%s'", line))
         end
      elseif cmd == "function" then
         parse_function(line, file)
      elseif cmd ~= nil then
         arg1 = tonumber(arg1) or 0
         arg2 = tonumber(arg2) or 0
         arg3 = tonumber(arg3) or 0
         arg4 = tonumber(arg4) or 0
         local f = load_table[cmd]
         if f == nil then
            gcs:send_text(MAV_SEVERITY.ERROR,string.format("Unknown command '%s' in %s", cmd, fname))
         else
            paths[#paths+1] = { f, { arg1, arg2, arg3, arg4 }}
            for k, v in pairs(attrib) do
               paths[#paths][k] = v
            end
            attrib = {}
         end
      end
      ::continue::
   end
   local pc = path_composer(name, paths)
   gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded trick%u '%s'", id, name))
   command_table[id] = PathFunction(pc, name)
   if logger.log_file_content then
      logger:log_file_content(filename)
   end

   calculate_timestamps(command_table[id])
end

function calculate_timestamps(pc)
   pc.fn:calculate_timestamps()
end

function PathTask(fn, name, id, initial_yaw_deg, arg1, arg2, arg3, arg4)
   local self = {}
   if type(fn) == "table" then
      self.fn = fn
   else
      self.fn = fn(arg1, arg2, arg3, arg4)
   end
   self.name = name
   self.id = id
   self.initial_yaw_deg = initial_yaw_deg
   self.started = false
   return self
end

--[[
   see if we should prepare for an upcoming trick
--]]
function check_preload_trick()
   local idx = mission:get_current_nav_index()
   if idx == last_preload then
      return
   end
   last_preload = idx
   local m = mission:get_item(idx+1)
   if not m then
      return
   end
   if m:command() ~= NAV_SCRIPT_TIME then
      return
   end
   cmdid = m:param1()
   if command_table[cmdid] == nil then
      load_trick(cmdid)
   end
end

-- see if an auto mission item needs to be run
function check_auto_mission()
   id, cmd, arg1, arg2, arg3, arg4 = vehicle:nav_script_time()
   if not id then
      check_preload_trick()
      return
   end
   if id ~= last_id then
      -- we've started a new command
      current_task = nil
      last_id = id
      local initial_yaw_deg = get_ground_course_deg()
      load_trick(cmd)
      if command_table[cmd] == nil then
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("Trick %u not found", cmd))
         return
      end
      gcs:send_text(MAV_SEVERITY.INFO, string.format("Starting %s!", command_table[cmd].name ))

      -- work out yaw between previous WP and next WP
      local cnum = mission:get_current_nav_index()

      if AEROM_MIS_ANGLE:get() == 0 then
         -- find previous nav waypoint
         local loc_prev = ahrs:get_location()
         if cnum > 1 then
            loc_prev = get_wp_location(cnum-1)
            local i= cnum-1
            while get_wp_location(i):lat() == 0 and get_wp_location(i):lng() == 0 do
               i = i-1
               loc_prev = get_wp_location(i)
            end
         end

         -- find next nav waypoint
         local loc_next = get_wp_location(cnum+1)
         i = cnum+1
         while get_wp_location(i):lat() == 0 and get_wp_location(i):lng() == 0 do
            i = i+1
            loc_next = get_wp_location(resolve_jump(i))
         end
         local wp_yaw_deg = math.deg(loc_prev:get_bearing(loc_next))
         if math.abs(wrap_180(initial_yaw_deg - wp_yaw_deg)) > 90 and cnum > 1 then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("Doing turnaround! iyaw=%.1f wyaw=%.1f", initial_yaw_deg, wp_yaw_deg))
            wp_yaw_deg = wrap_180(wp_yaw_deg + 180)
         end
         initial_yaw_deg = wp_yaw_deg
      else
         initial_yaw_deg = AEROM_MIS_ANGLE:get()
      end
      current_task = PathTask(command_table[cmd].fn, command_table[cmd].name,
                              id, initial_yaw_deg, arg1, arg2, arg3, arg4)
   end
end

local trick_sel_chan = nil
local last_trick_selection = nil

--[[
   get selected trick. Trick numbers are 1 .. TRIK_COUNT. A value of 0 is invalid
--]]
function get_trick_selection()
   if trick_sel_chan == nil then
      trick_sel_chan = rc:find_channel_for_option(TRIK_SEL_FN:get())
      if trick_sel_chan == nil then
         return 0
      end
   end
   -- get trick selection based on selection channel input and number of tricks
   local i = math.floor(TRIK_COUNT:get() * constrain(0.5*(trick_sel_chan:norm_input_ignore_trim()+1),0,0.999)+1)
   if TRICKS[i] == nil then
      return 0
   end
   return i
end

--[[
   check for running a trick
--]]
function check_trick()
   local selection = get_trick_selection()
   local action = rc:get_aux_cached(TRIK_ACT_FN:get())
   if action == 0 and current_task ~= nil then
      gcs:send_text(MAV_SEVERITY.ALERT,string.format("Trick aborted"))
      current_task = nil
      last_trick_selection = nil
      -- use invalid mode to disable script control
      vehicle:nav_scripting_enable(255)
      return
   end
   if selection == 0 then
      return
   end
   if action == 1 and selection ~= last_trick_selection then
      local id = TRICKS[selection].id:get()
         if id == -1 then
            gcs:send_text(MAV_SEVERITY.ERROR,string.format("Trick %u not setup",selection))
            last_trick_selection = selection
            return
         end
      load_trick(id)
      if command_table[id] ~= nil then
         local cmd = command_table[id]
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Trick %u selected (%s)", selection, cmd.name))
         last_trick_selection = selection
         return
      end
   end
   if current_task ~= nil then
      -- let the task finish
      return
   end
   if action ~= last_trick_action_state then
      last_trick_selection = selection
      last_trick_action_state = action
      if selection == 0 then
         gcs:send_text(MAV_SEVERITY.ALERT, string.format("No trick selected"))
         return
      end
      local id = TRICKS[selection].id:get()
      if id == -1 then
         gcs:send_text(MAV_SEVERITY.ALERT,string.format("Trick %u not setup",selection))
         last_trick_selection = selection
         return
      end
      load_trick(id)
      if command_table[id] == nil then
         gcs:send_text(MAV_SEVERITY.ALERT, string.format("Invalid trick ID %u", id))
         return
      end
      local cmd = command_table[id]
      if action == 1 then
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Trick %u selected (%s)", selection, cmd.name))
      end
      if action == 2 then
         last_trick_selection = nil
         local current_mode = vehicle:get_mode()
         if not vehicle:nav_scripting_enable(current_mode) then
            gcs:send_text(MAV_SEVERITY.ALERT, string.format("Tricks not available in mode"))
            return
         end
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Trick %u started (%s)", selection, cmd.name))
         local initial_yaw_deg = get_ground_course_deg()
         current_task = PathTask(cmd.fn,
                                 cmd.name,
                                 nil,
                                 initial_yaw_deg,
                                 TRICKS[selection].args[1]:get(),
                                 TRICKS[selection].args[2]:get(),
                                 TRICKS[selection].args[3]:get(),
                                 TRICKS[selection].args[4]:get())
      end
   end

end

function update()
   if ahrs:get_velocity_NED() == nil  or ahrs:get_EAS2TAS() == nil or ahrs:get_relative_position_NED_origin() == nil then
      -- don't start till we have valid ahrs estimates
      return update, 1000.0/LOOP_RATE
   end
   if vehicle:get_mode() == MODE_AUTO then
      if arming:is_armed() then
         log_position("VEH", ahrs:get_location(), ahrs:get_quaternion())
      end
      check_auto_mission()
   elseif TRICKS ~= nil then
      check_trick()
   end

   if current_task ~= nil then
      if not do_path() then
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Finishing %s!", current_task.name))
         if current_task.id ~= nil then
            vehicle:nav_script_time_done(current_task.id)
         else
            -- use invalid mode to disable script control
            vehicle:nav_scripting_enable(255)
         end
         current_task = nil
      end
   end
   
   return update, 1000.0/LOOP_RATE
end

gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded plane_aerobatics.lua"))
return update()



================================================
File: applets/Aerobatics/FixedWing/view_paths.py
================================================
#!/usr/bin/env python3
'''
trajectory viewer for aerobatic logs
'''

from panda3d_viewer import Viewer, ViewerConfig
from pymavlink.quaternion import QuaternionBase, Quaternion
from pymavlink.rotmat import Vector3, Matrix3
from pymavlink import mavutil
from MAVProxy.modules.lib import mp_util

import math, sys

# quaternion to rotate to fix NED to ENU conversion
q_NED_ENU = Quaternion([0, -math.sqrt(2.0)*0.5, -math.sqrt(2)*0.5, 0])

def qtuple(q):
    '''
    return a quaternion tuple. We mirror on the Z axis by changing
    the sign of two elements to cope with the different conventions
    '''
    return (q[0],q[1],q[2],q[3])

config = ViewerConfig()
config.set_window_size(320, 240)
config.enable_antialiasing(True, multisamples=4)

def view_path(viewer, path, color):
    idx = 0
    print("Plotting %u points" % len(path))
    m = Matrix3()
    m.from_euler(0, math.radians(90), 0)
    qorient = Quaternion(m)

    for i in range(1,len(path)):
        p0 = path[i-1]
        p1 = path[i]
        dx = p1.pos[0] - p0.pos[0]
        dy = p1.pos[1] - p0.pos[1]
        dz = p1.pos[2] - p0.pos[2]
        dt = p1.t - p0.t
        if dt > 0.5:
            continue
        dist = math.sqrt(dx**2+dy**2+dz**2)+0.001
        if dist <= 0:
            continue
        if math.isnan(p1.q[0]) or math.isnan(p1.q[1]) or math.isnan(p1.q[2]) or math.isnan(p1.q[3]):
            continue
        pname = 'p%u' % i
        viewer.append_box('root', pname, (dist, args.width, 0.002), frame=(p1.pos,qtuple(p1.q)))
        viewer.set_material('root', pname, color_rgba=color)

class LogPoint(object):
    def __init__(self, x,y,z,q,t):
        # convert from NED to ENU
        global q_NED_ENU
        self.pos = (y,x,-z)
        self.q = q_NED_ENU * q
        self.t = t

def offset_between(ORGN1, ORGN2):
    '''return x,y offset in meters between ORGN1 and ORGN2'''
    dist = mp_util.gps_distance(ORGN1.Lat, ORGN1.Lng, ORGN2.Lat, ORGN2.Lng)
    bearing = mp_util.gps_bearing(ORGN1.Lat, ORGN1.Lng, ORGN2.Lat, ORGN2.Lng)
    ofs_x = dist * math.cos(math.radians(bearing))
    ofs_y = dist * math.sin(math.radians(bearing))
    return ofs_x, ofs_y

def show_log(viewer,filename,reduction):
    print("Viewing %s" % filename)
    mlog = mavutil.mavlink_connection(filename)

    path_POST = []
    path_POSM = []
    path_POSB = []
    ATT = None

    scale = 0.01
    counts = {}
    ORGN = None
    ofs_x = 0
    ofs_y = 0


    while True:
        m = mlog.recv_match(type=['POST', 'POSB', 'POSM', 'ATT', 'ORGN'])
        if m is None:
            break

        mtype = m.get_type()

        if mtype == 'ORGN':
            if m.Type == 0:
                if ORGN is None:
                    ORGN = m
                else:
                    ofs_x, ofs_y = offset_between(m, ORGN)
                    ORGN = m
            continue


        if not mtype in counts:
            counts[mtype] = 0
        counts[mtype] += 1
        if counts[mtype] % int(reduction) != 0:
            continue

        if mtype != 'ATT':
            px = m.px + ofs_x
            py = m.py + ofs_y

        if mtype == 'POST' and ATT is not None:
            path_POST.append(LogPoint(px*scale, py*scale, m.pz*scale, Quaternion([m.q1, m.q2, m.q3, m.q4]), m.TimeUS*1.0e-6))
        if mtype == 'POSB' and ATT is not None:
            path_POSB.append(LogPoint(px*scale, py*scale, m.pz*scale, Quaternion([m.q1, m.q2, m.q3, m.q4]), m.TimeUS*1.0e-6))
        if mtype == 'POSM' and ATT is not None:
            path_POSM.append(LogPoint(px*scale, py*scale, m.pz*scale, Quaternion([m.q1, m.q2, m.q3, m.q4]), m.TimeUS*1.0e-6))
        if mtype == 'ATT':
            ATT = m

    view_path(viewer, path_POST, (0.7,0.1,0.1,1))
    view_path(viewer, path_POSM, (0.1,0.7,0.1,1))
    view_path(viewer, path_POSB, (0.1,0.1,0.7,1))

import argparse
parser = argparse.ArgumentParser(description='Aerobatic log viewer')
parser.add_argument('file', nargs='?', default=None, help='bin log file')
parser.add_argument('--reduce', type=int, default=1, help='reduction ratio for messages')
parser.add_argument('--width', type=float, default=0.1, help='line width')
args = parser.parse_args()

filename = args.file

viewer = Viewer(window_type='onscreen', window_title=filename, config=config)
viewer.append_group('root')
show_log(viewer, filename, args.reduce)
viewer.reset_camera(pos=(0, -6, 1), look_at=(0, 0, 1))
viewer.join()



================================================
File: applets/Aerobatics/FixedWing/RateBased/README.md
================================================
# Sport Aerobatics

The lua script "sport_aerobatics.lua" implements scripted aerobatics,
allowing fixed wing aircraft to execute a number of aerobatic
manoeuvres either in AUTO mission or by triggering using pilot commands
using RC switches.

As always, but particularly with scripted aerobatics, test in SITL until 
you understand the function and behaviour of each manouver. You will need 
an appropriate aircraft, and be ready to take manual control if necessary!

These tricks are rate-based vs the precision trajectory-based manouvers of the script in the TrajectoryBased directory above this one. However, many planes have difficulty completing those tricks unless they can sustain extended vertical climbs and knife-edges, especially in wind. These tricks do not try to maintain a geospatial track, but rather, just attitude rates. Even planes that cannot hold the 90 deg knife edge trick, will probably hold the 180 deg (inverted) one and do loops and rolls, and these tricks can be done in even strong wind, although will not be well shaped.

## Available Manoeuvres

The following table gives the available manoeuvres. Each manoeuvre has
an ID number which is used in the AUTO mission or in the TRIKn_ID
parameters (described below). The present ground track is used as the track for the trick.
The "Turnaround" column indicates if the manoeuvre results in a course reversal, which impacts how it is used in 
AUTO missions. Once the trick is completed, the mode that was being used at the start of the trick is restored. If the mode is CRUISE, its
track and altitude are reset to the values present when the mode is restored. Tricks in AUTO missions require that they be performed between two waypoints to establish
the ground track.

| ID | Name                     | Arg1            | Arg2                       | Turnaround |
| -- | ------------------------ | --------------- | -------------------------- | -----------|
| 1  | Roll(s)                  | rollrate(dps)   | num rolls                  | No         |
| 2  | Loop(s)/TurnAround       | pitchrate(dps)  | num loops or turnaround(0) | if num=0   |
| 3  | Rolling Circle           | yawrate(dps)    | rollrate(dps)              | No         |
| 4  | KnifeEdge                | roll angle(deg) | length(sec)                | No         |
| 5  | Pause                    | length(sec)     | na                         | No         |
| 6  | KnifeEdge Circle         | yawrate(dps)    | na                         | No         |
| 7  | 4 point roll             | rollrate(dps)   | pause in sec at each point | No         |
| 8  | Split-S                  | pitchrate(dps)  | rollrate(dps)              | Yes        |

note: for Rolling Circle, the time it takes to make the circle is 360/yawrate. You should make sure that an integer number of rolls is commanded by the rollrate parameter in that time, ie rollrate should be set to the number of rolls * yawrate. In most cases negative rate, reverses the direction, ie in Rolls -45 for rollrate would roll left at 45dps.

## Loading the script

Put the sport_aerobatics.lua script on your microSD card in the
APM/SCRIPTS directory. You can use MAVFtp to do this.

Then set

 - SCR_ENABLE = 1
 - SCR_HEAP_SIZE = 150000
 - SCR_VM_I_COUNT = 100000

You will need to refresh parameters after setting SCR_ENABLE. Then
reboot to start scripting.

## Aircraft Setup

The aircraft needs to be setup to perform well in ACRO mode. You need
to enable the yaw rate controller by setting if it has a rudder (even if it cannot hold a sustained 90 degree knife-edge:

 - YAW_RATE_ENABLE = 1
 - ACRO_YAW_RATE = 90

The ACRO_YAW_RATE depends on the capabilities of the aircraft, but
around 90 degrees/second is reasonable.

You need to tune the yaw rate controller by flying in AUTOTUNE mode
and moving the rudder stick from side to side until the yaw rate
tuning is reported as being finished. For optimal results, log examination and manual adjustment
of axis tuning will sometimes be required, especially pitch and yaw tuning in order to get precise rolling circles. A future video on this optimization will be produced and posted in the ArduPilot YouTube channel.

## Use In AUTO Missions

To use in an AUTO mission you can create waypoint missions containing
NAV_SCRIPT_TIME elements (shown as SCRIPT_TIME in MissionPlanner). These mission items take the following arguments:

 - the command ID from the table above
 - the timeout in seconds
 - up to two arguments as shown in the above table

The aerobatics system will use the location of the previous and next
waypoints to line up the manoeuvre. You need to plan a normal
waypoint just before the location where you want to start the
manoeuvre, then the NAV_SCRIPT_TIME with the trick or schedule ID, a timeout that is long enough to allow the trick, and then a normal waypoint after the manoeuvre. You can have consecutive tricks between waypoints. You can use the PAUSE trick after a framing waypoint to  move the location of the beginning of the trick or to put some time between consecutive tricks.

## Use with "tricks on a switch"

You can trigger the manoeuvres using RC switches (or using the GCS AUX Function tab), allowing you to have
up to 11 tricks pre-programmed on your transmitter ready for use in
fixed wing flight. You can trigger the tricks in the following flight
modes:

 - CIRCLE
 - STABILIZE
 - ACRO
 - FBWA
 - FBWB
 - CRUISE
 - LOITER

Set TRIKR_COUNT to the number of tricks you want to make available and reboot,
with a maximum of 11. (Why 11 when fewer than that are available? To allow variants, such as different knife-edges, ie 90 deg and 180 deg inverted flight)

After setting TRIKR_COUNT, reboot and refresh parameters. You will find
you will now have 5 parameters per trick,but only three are used at this time.

 - TRIKRn_ID
 - TRIKRn_ARG1
 - TRIKRn_ARG2
 - TRIKRn_ARG3 (unused, future use)
 - TRIKRn_ARG4 (unused, future use)

The ID parameter is the manoeuvre from the above table, and the arguments are the arguments to each manoeuvre.

Note: these parameters, if being loaded from a file, will not be present until scripting is enabled, the the LUA script has been
actually run, since they are created via the script, not the firmware.

Now you need to setup your two control channels. You should have one 3
position switch for activating tricks, and one knob or switch to
select tricks. It is best to use a knob for the trick selector so you can have up to 11 tricks.

Work out which RC input channel you want to use for activation (a 3 position switch) and set

 - RCn_OPTION = 300
 
Note: It is not required to setup the 300 function for activation by the Transmitter switch. You can also activate a trick via the GCS. Mission Planner has an AUX Functions tab to enable setting the "300" function from the GCS.

Then work out what RC input channel you want to use for selection and set

 - RCn_OPTION = 301
 
 TRIKR_COUNT must be non-zero and an RC channel set to function 301 for Tricks on a Switch to function.

## Flying with tricks

When the activation channel (the one assigned option 300 or set via the GCS) is in the
middle position then when you move the trick selection knob/switch, the GCS will display the
currently selected trick.

To activate a trick you move the activation channel to the top (high)
position, and the trick will run.

Moving the activation switch to the bottom position (low) cancels any
running trick and stops the trick system.

Changing flight modes will also cancel any active trick.

## Parameters

There are a number of parameters added by this script to control its control loops. The defaults should be satisfactory, but some of the key parameters are:


 - AEROR_HGT_KE_BIAS: knife-edge boost. Adds immediate rudder as the plane rolls into 90 degree positions rather than waiting of an altitude change
 - AEROR_THR_FF : modulates throttle as pitch increases or decreases

the other parameters control the height and speed PID controllers used in the script



================================================
File: applets/Aerobatics/FixedWing/RateBased/sport_aerobatics.lua
================================================
--[[ perform simple aerobatic manoeuvres in AUTO mode
cmd = 1: axial rolls, arg1 = roll rate dps, arg2 = number of rolls
cmd = 2: loops or 180deg return, arg1 = pitch rate dps, arg2 = number of loops, if zero do a 1/2 cuban8-like return
cmd = 3: rolling circle, arg1 = yaw rate, arg2 = roll rate
cmd = 4: knife edge at any angle, arg1 = roll angle to hold, arg2 = duration
cmd = 5: pause, holding heading and alt to allow stabilization after a move, arg1 = duration in seconds
]]--
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: cast-local-type

DO_JUMP = 177
k_throttle = 70
MODE_AUTO = 10
-- setup param block for aerobatics, reserving 30 params beginning with AERO_
local PARAM_TABLE_KEY = 72
local PARAM_TABLE_PREFIX = "AEROR_"
assert(param:add_table(PARAM_TABLE_KEY, "AEROR_", 30), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

local HGT_P = bind_add_param('HGT_P',1,1) -- height P gain
local HGT_I = bind_add_param("HGT_I",2,1) -- height I gain
local HGT_KE_BIAS = bind_add_param("KE_ADD",3,20) -- height knifeedge addition for pitch
local THR_PIT_FF = bind_add_param("PIT_FF",4,80) -- throttle FF from pitch
-- 5 was "SPD_P" speed P gain
-- 6 was "SPD_I" speed I gain
local TRIM_THROTTLE = Parameter("TRIM_THROTTLE")
local RLL2SRV_TCONST = Parameter("RLL2SRV_TCONST")
local PITCH_TCONST = Parameter("PTCH2SRV_TCONST")

local last_id = 0
local initial_yaw_deg = 0
local wp_yaw_deg = 0
local initial_height = 0
local repeat_count = 0
local running = false
local trick_stage = 0

local function TrickDef(id, arg1, arg2, arg3, arg4)
   local self = {}
   self.id = id
   self.args = {arg1, arg2, arg3, arg4}
   return self
end


--[[
   Aerobatic tricks on a switch support - allows for tricks to be initiated outside AUTO mode
--]]
-- 2nd param table for tricks on a switch
local PARAM_TABLE_KEY2 = 73
local PARAM_TABLE_PREFIX2 = "TRIKR"
assert(param:add_table(PARAM_TABLE_KEY2, PARAM_TABLE_PREFIX2, 63), 'could not add param table2')

-- add a parameter and bind it to a variable in table2
function bind_add_param2(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY2, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX2 .. name)
end
local TRICKS
local TRIK_SEL_FN
local TRIK_ACT_FN
local TRIK_COUNT

-- constrain a value between limits
function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end


-- setup parameters for tricks
TRIK_SEL_FN = bind_add_param2("_SEL_FN", 2, 301)
TRIK_ACT_FN = bind_add_param2("_ACT_FN", 3, 300)
TRIK_COUNT  = bind_add_param2("_COUNT",  4, 3)
TRICKS = {}
local last_trick_action_state = rc:get_aux_cached(TRIK_ACT_FN:get())


function tricks_exist()
   if rc:find_channel_for_option(TRIK_SEL_FN:get())  
            and math.floor(TRIK_COUNT:get()) then
      return true
   else
      return false
   end
end   
   
-- setup parameters for tricks
count = math.floor(TRIK_COUNT:get())
count = constrain(count,0,11)
if tricks_exist() then
   for i = 1, count do
      local k = 5*i
      local prefix = string.format("%u", i)
      TRICKS[i] = TrickDef(bind_add_param2(prefix .. "_ID",   k+0, i),
                          bind_add_param2(prefix .. "_ARG1", k+1, 30),
                           bind_add_param2(prefix .. "_ARG2", k+2, 0),
                           bind_add_param2(prefix .. "_ARG3", k+3, 0),
                           bind_add_param2(prefix .. "_ARG4", k+4, 0))
   end
   gcs:send_text(5, string.format("Enabled %u aerobatic tricks", count))   
end


-- roll angle error 180 wrap to cope with errors while in inverted segments
function roll_angle_error_wrap(roll_angle_error)
   if math.abs(roll_angle_error) > 180 then
    if roll_angle_error > 0 then
       roll_angle_error = roll_angle_error - 360
    else 
       roll_angle_error= roll_angle_error +360
    end 
   end
   return roll_angle_error
end
    
--roll controller to keep wings level in earth frame. if arg is 0 then level is at only 0 deg, otherwise its at 180/-180 roll also for loops
function earth_frame_wings_level(arg)
   local roll_deg = math.deg(ahrs:get_roll_rad())
   local roll_angle_error
   if (roll_deg > 90 or roll_deg < -90) and arg ~= 0 then
    roll_angle_error = 180 - roll_deg
   else
    roll_angle_error = - roll_deg
   end
   return roll_angle_error_wrap(roll_angle_error)/(RLL2SRV_TCONST:get())
end


function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

function wrap_180(angle) 
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

-- a PI controller implemented as a Lua object
local function PI_controller(kP,kI,iMax)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = {}

   -- private fields as locals
   local _kP = kP or 0.0
   local _kI = kI or 0.0
   local _iMax = iMax
   local _last_t = nil
   local _I = 0
   local _P = 0
   local _total = 0
   local _counter = 0
   local _target = 0
   local _current = 0

   -- update the controller.
   function self.update(target, current)
      local now = millis():tofloat() * 0.001
      if not _last_t then
         _last_t = now
      end
      local dt = now - _last_t
      _last_t = now
      local err = target - current
      _counter = _counter + 1

      local P = _kP * err
      _I = _I + _kI * err * dt
      if _iMax then
         _I = constrain(_I, -_iMax, iMax)
      end
      local I = _I
      local ret = P + I

      _target = target
      _current = current
      _P = P
      _total = ret
      return ret
   end

   -- reset integrator to an initial value
   function self.reset(integrator)
      _I = integrator
   end

   function self.set_I(I)
      _kI = I
   end

   function self.set_P(P)
      _kP = P
   end
   
   function self.set_Imax(Imax)
      _iMax = Imax
   end
   
   -- log the controller internals
   function self.log(name, add_total)
      -- allow for an external addition to total
      logger.write(name,'Targ,Curr,P,I,Total,Add','ffffff',_target,_current,_P,_I,_total,add_total)
   end
   -- return the instance
   return self
end

local function height_controller(kP_param,kI_param,KnifeEdge_param,Imax)
   local self = {}
   local kP = kP_param
   local kI = kI_param
   local KnifeEdge = KnifeEdge_param
   local PI = PI_controller(kP:get(), kI:get(), Imax)

   function self.update(target)
      local target_pitch = PI.update(target, ahrs:get_position():alt()*0.01)
      local roll_rad = ahrs:get_roll_rad()
      local ke_add = math.abs(math.sin(roll_rad)) * KnifeEdge:get()
      target_pitch = target_pitch + ke_add
      PI.log("HPI", ke_add)
      return target_pitch
   end

   function self.reset()
      PI.reset(math.max(math.deg(ahrs:get_pitch_rad()), 3.0))
      PI.set_P(kP:get())
      PI.set_I(kI:get())
   end

   return self
end

local height_PI = height_controller(HGT_P, HGT_I, HGT_KE_BIAS, 20.0)

-- a controller to target a zero pitch angle and zero heading change, used in a roll
-- output is a body frame pitch rate, with convergence over time tconst in seconds
function pitch_controller(target_pitch_deg, target_yaw_deg, tconst)
   local roll_deg = math.deg(ahrs:get_roll_rad())
   local pitch_deg = math.deg(ahrs:get_pitch_rad())
   local yaw_deg = math.deg(ahrs:get_yaw_rad())

   -- get earth frame pitch and yaw rates
   local ef_pitch_rate = (target_pitch_deg - pitch_deg) / tconst
   local ef_yaw_rate = wrap_180(target_yaw_deg - yaw_deg) / tconst

   local bf_pitch_rate = math.sin(math.rad(roll_deg)) * ef_yaw_rate + math.cos(math.rad(roll_deg)) * ef_pitch_rate
   local bf_yaw_rate   = math.cos(math.rad(roll_deg)) * ef_yaw_rate - math.sin(math.rad(roll_deg)) * ef_pitch_rate
   return bf_pitch_rate, bf_yaw_rate
end

-- a controller for throttle to account for pitch
function throttle_controller()
   local pitch_rad = ahrs:get_pitch_rad()
   local thr_ff = THR_PIT_FF:get()
   local throttle = TRIM_THROTTLE:get() + math.sin(pitch_rad) * thr_ff
   return constrain(throttle, 0, 100.0)
end

-- recover entry altitude
function recover_alt()
       local target_pitch = height_PI.update(initial_height)
       local pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
       return target_pitch, pitch_rate, yaw_rate
end

function set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
   -- we don't want a rudder offset, and we do want yaw rate
   vehicle:set_rudder_offset(0, true)
   vehicle:set_target_throttle_rate_rpy(throttle, roll_rate, pitch_rate, yaw_rate)
end

--  start of trick routines---------------------------------------------------------------------------------
function do_axial_roll(arg1, arg2)
   -- constant roll rate axial roll, arg1 roll rate, arg2 is number of rolls
   if not running then
      running = true
      roll_num = 1
      repeat_count = arg2 -1
      trick_stage = 0
      height_PI.reset()
      gcs:send_text(5, string.format("Starting %d Roll(s)", arg2))
   end
   local roll_rate = arg1
   local roll_deg = math.deg(ahrs:get_roll_rad())

   if trick_stage == 0 then
      if roll_deg > 45 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if roll_deg > -5 and roll_deg < 5 then
         -- we're done with a roll
         gcs:send_text(5, string.format("Finished Roll %d", roll_num))
         if repeat_count > 0 then
            trick_stage = 0
            repeat_count = repeat_count - 1
            roll_num = roll_num + 1
         else
         running = false
         trick = 0
         if vehicle:get_mode() == MODE_AUTO then
            vehicle:nav_script_time_done(last_id)
         else
            vehicle:nav_scripting_enable(255)
         end
         trick_stage = 2
         return
         end
      end
   end
   if trick_stage < 2 then
      throttle = throttle_controller()
      target_pitch = height_PI.update(initial_height)
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
      set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
   end
end


local target_vel

function do_loop(arg1, arg2)
   -- do one loop with controllable pitch rate arg1 is pitch rate, arg2 number of loops, 0 or less indicates 1/2 cuban8 reversal style turnaround
   if not running then
      running = true
      trick_stage = 0 
      loop_number = 1
      repeat_count = arg2 -1  
      target_vel = ahrs:get_velocity_NED():length()
      if arg2 > 0 then
         gcs:send_text(5, string.format("Starting %d Loop(s)",arg2))
      else
        gcs:send_text(5, string.format("Starting Turnaround"))
      end
   end

   local throttle = throttle_controller()
   local pitch_deg = math.deg(ahrs:get_pitch_rad())
   local roll_deg = math.deg(ahrs:get_roll_rad())
   local vel = ahrs:get_velocity_NED():length()
   local pitch_rate = arg1
   pitch_rate = pitch_rate * (1+ 2*((vel/target_vel)-1)) --increase/decrease rate based on velocity to round loop
   pitch_rate = constrain(pitch_rate,.5 * arg1, 3 * arg1)
   
   if trick_stage == 0 then
      if pitch_deg > 60 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if (math.abs(roll_deg) < 90 and pitch_deg > -5 and pitch_deg < 5 and repeat_count >= 0) then 
         -- we're done with loop
         gcs:send_text(5, string.format("Finished Loop %d", loop_number))
         trick_stage = 2  --now recover stage
         height_PI.reset()
      elseif (math.abs(roll_deg) > 90 and pitch_deg > -5 and pitch_deg < 5 and repeat_count < 0) then
         gcs:send_text(5, string.format("Finished Turnaround ")) 
         trick_stage = 2  --now recover stage
         height_PI.reset()
      end
   elseif trick_stage == 2 then
         -- recover alt if above or below start and terminate
    if math.abs(ahrs:get_position():alt()*0.01 - initial_height) > 3 then
       throttle, pitch_rate, yaw_rate = recover_alt()
    elseif repeat_count > 0 then
    trick_stage = 0
    repeat_count = repeat_count - 1
    loop_number = loop_number + 1
    else 
       running = false
       if vehicle:get_mode() == MODE_AUTO then
          vehicle:nav_script_time_done(last_id)
       else
          vehicle:nav_scripting_enable(255)
       end
       return
    end
  end
  if trick_stage == 2 or trick_stage == 0 then 
     level_type = 0
  else
     level_type = 1
  end
  if math.abs(pitch_deg) > 85 and  math.abs(pitch_deg) < 95 then
     roll_rate = 0
  else
     roll_rate = earth_frame_wings_level(level_type)
  end
  set_rate_targets(throttle, roll_rate, pitch_rate, 0)
end


local circle_yaw_deg = 0
local circle_last_ms = 0

function do_rolling_circle(arg1, arg2)
   -- constant roll rate circle roll, arg1 yaw rate, positive to right, neg to left, arg2 is roll rate
   if not running then
      running = true
      trick_stage = 0
      circle_yaw_deg = 0
      circle_last_ms = millis()
      height_PI.reset()
      gcs:send_text(5, string.format("Starting Rolling Circle"))
   end
   local yaw_rate_dps = arg1
   local roll_rate_dps = arg2
   local now_ms = millis()
   local dt = (now_ms - circle_last_ms):tofloat() * 0.001
   circle_last_ms = now_ms

   circle_yaw_deg = circle_yaw_deg + yaw_rate_dps * dt

   if trick_stage == 0 then
      if math.abs(circle_yaw_deg) > 10.0 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if math.abs(circle_yaw_deg) >= 360.0 then
         running = false
         -- we're done
         gcs:send_text(5,"Finished Rolling Circle")
         if vehicle:get_mode() == MODE_AUTO then
            vehicle:nav_script_time_done(last_id)
         else
            vehicle:nav_scripting_enable(255)
         end
         trick_stage = 2
         return
      end
   end
   if trick_stage < 2 then
      target_pitch = height_PI.update(initial_height)
      vel = ahrs:get_velocity_NED()
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wrap_360(circle_yaw_deg+initial_yaw_deg), PITCH_TCONST:get())
      throttle = throttle_controller()
      throttle = constrain(throttle, 0, 100.0)
      set_rate_targets(throttle, roll_rate_dps, pitch_rate, yaw_rate)
   end
end

local knife_edge_s = 0
function do_knife_edge(arg1,arg2)
  -- arg1 is angle +/-180, duration is arg2
    local now = millis():tofloat() * 0.001
    if not running then
        running = true
        height_PI.reset()
        knife_edge_s = now
        gcs:send_text(5, string.format("Starting %d Knife Edge", arg1))
    end
    if (now - knife_edge_s) < arg2 then
        local roll_deg = math.deg(ahrs:get_roll_rad())
        local roll_angle_error = (arg1 - roll_deg)
        if math.abs(roll_angle_error) > 180 then
         if roll_angle_error > 0 then
           roll_angle_error = roll_angle_error - 360
         else 
           roll_angle_error= roll_angle_error +360
         end 
        end
        roll_rate = roll_angle_error/RLL2SRV_TCONST:get()
        target_pitch = height_PI.update(initial_height)
        pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
        throttle = throttle_controller()
        set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
    else
        gcs:send_text(5, string.format("Finished Knife Edge", arg1))
        running = false
        if vehicle:get_mode() == MODE_AUTO then
           vehicle:nav_script_time_done(last_id)
        else
           vehicle:nav_scripting_enable(255)
        end
    return
    end
end

-- fly level for a time..allows full altitude recovery after trick
function do_pause(arg1,_)
    -- arg1 is time of pause in sec, arg2 is unused
    local now = millis():tofloat() * 0.001
    if not running then
        running = true
        height_PI.reset()
        knife_edge_s = now
        gcs:send_text(5, string.format("%d sec Pause", arg1))
    end
    if (now - knife_edge_s) < arg1 then
        roll_rate = earth_frame_wings_level(0)
        target_pitch = height_PI.update(initial_height)
        pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
        throttle = throttle_controller()
        set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
    else 
        running = false
        gcs:send_text(5, string.format("Pause Over"))
        if vehicle:get_mode() == MODE_AUTO then
           vehicle:nav_script_time_done(last_id)
        else
           vehicle:nav_scripting_enable(255)
        end
    return
    end
end

function do_knifedge_circle(arg1, _)
   -- constant roll angle circle , arg1 yaw rate, positive to right, neg to left, arg2 is not used
   if not running then
      running = true
      trick_stage = 0
      circle_yaw_deg = 0
      circle_last_ms = millis()
      height_PI.reset()
      gcs:send_text(5, string.format("Staring KnifeEdge Circle"))
   end
   local yaw_rate_dps = arg1
   local now_ms = millis()
   local dt = (now_ms - circle_last_ms):tofloat() * 0.001
   circle_last_ms = now_ms
   circle_yaw_deg = circle_yaw_deg + yaw_rate_dps * dt
   if trick_stage == 0 then
      if math.abs(circle_yaw_deg) > 10.0 then
         trick_stage = 1
      end
   elseif trick_stage == 1 then
      if math.abs(circle_yaw_deg) >= 360.0 then
         running = false
         -- we're done
         gcs:send_text(5,"Finished KnifeEdge Circle")
         if vehicle:get_mode() == MODE_AUTO then
            vehicle:nav_script_time_done(last_id)
         else
            vehicle:nav_scripting_enable(255)
         end
         trick_stage = 2
         return
      end
   end
   if trick_stage < 2 then
        local roll_deg = math.deg(ahrs:get_roll_rad())
        if arg1 >0 then
           angle = 90
        else
           angle = -90
        end
        local roll_angle_error = (angle - roll_deg)
        if math.abs(roll_angle_error) > 180 then
         if roll_angle_error > 0 then
           roll_angle_error = roll_angle_error - 360
         else 
           roll_angle_error= roll_angle_error +360
         end 
        end
      roll_rate_dps = roll_angle_error/RLL2SRV_TCONST:get()
      target_pitch = height_PI.update(initial_height)
      vel = ahrs:get_velocity_NED()
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wrap_360(circle_yaw_deg+initial_yaw_deg), PITCH_TCONST:get())
      throttle = throttle_controller()
      throttle = constrain(throttle, 0, 100.0)
      set_rate_targets(throttle, roll_rate_dps, pitch_rate, yaw_rate)
   end
end

function hold_roll_angle (angle)
   local roll_deg = math.deg(ahrs:get_roll_rad())
   local roll_angle_error = (angle - roll_deg)
   if math.abs(roll_angle_error) > 180 then
      if roll_angle_error > 0 then
         roll_angle_error = roll_angle_error - 360
      else 
         roll_angle_error= roll_angle_error +360
      end 
   end
   return roll_angle_error/RLL2SRV_TCONST:get()
end

local roll_ms = 0
function do_4point_roll(arg1, arg2)
   -- constant roll rate axial roll with pauses at 90 deg intervals, arg1 roll rate, arg2 is pause time in sec
   arg2 = arg2 * 1000
   if not running then
      running = true
      trick_stage = 0
      height_PI.reset()
      gcs:send_text(5, string.format("Starting 4pt Roll"))
   end
   local roll_deg = math.deg(ahrs:get_roll_rad())

   if trick_stage == 0 then
      roll_rate = arg1
      if roll_deg >= 90 then
         trick_stage = 1
         roll_ms = millis()
      end
   elseif trick_stage == 1 then
      roll_rate = hold_roll_angle(90)
      if (millis() - roll_ms > arg2) then
         trick_stage = 2
      end
   elseif trick_stage == 2 then
      roll_rate = arg1
      if roll_deg >= 175 or roll_deg <= -175 then
         trick_stage = 3
         roll_ms = millis()
      end
   elseif trick_stage == 3 then
      roll_rate = hold_roll_angle(180)
      if (millis() - roll_ms >arg2) then
         trick_stage = 4
      end
   elseif trick_stage == 4 then
      roll_rate = arg1
      if roll_deg >=-90 and roll_deg < 175 then
         trick_stage = 5
         roll_ms = millis()
      end
   elseif trick_stage == 5 then   
      roll_rate = hold_roll_angle(-90)
      if (millis() - roll_ms >arg2) then
         trick_stage = 6
      end
   elseif trick_stage == 6 then
      roll_rate = arg1 
      if roll_deg > -5 and roll_deg < 5 then
         -- we're done with a roll
         trick_stage = 7
         gcs:send_text(5, "Finished 4 pt Roll")
         running = false
         if vehicle:get_mode() == MODE_AUTO then
            vehicle:nav_script_time_done(last_id)
         else
            vehicle:nav_scripting_enable(255)
         end
      end
   end
   if trick_stage < 7 then
      throttle = throttle_controller()
      target_pitch = height_PI.update(initial_height)
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())
      set_rate_targets(throttle, roll_rate, pitch_rate, yaw_rate)
   end
end

function do_split_s(arg1, arg2)
   -- roll inverted at arg2 rate, then 1/2 loop at arg1 pitch rate
   if not running then
      running = true
      trick_stage = 0   --roll inverted, pitch level
      height_PI.reset()
      gcs:send_text(5, string.format("Starting Split-S"))
   end
   local pitch_deg = math.deg(ahrs:get_pitch_rad())
   local roll_deg = math.deg(ahrs:get_roll_rad())
   if trick_stage == 0 then 
      roll_rate = arg2
      wp_yaw_deg = math.deg(ahrs:get_yaw_rad())
      target_pitch = height_PI.update(initial_height)
      pitch_rate, yaw_rate = pitch_controller(target_pitch, wp_yaw_deg, PITCH_TCONST:get())   
      if roll_deg >=175 or roll_deg <= -175 then
         trick_stage = 1 --start the pitch rate, wings level
      end
   elseif trick_stage == 1 then
      if math.abs(pitch_deg) > 85 and  math.abs(pitch_deg) < 95 then
         roll_rate = 0
      else
         roll_rate = earth_frame_wings_level(1)
      end
      pitch_rate = arg1
      if (math.abs(roll_deg) < 90 and pitch_deg > -5 and pitch_deg < 5) then
          trick_stage = 2 --trick over
          gcs:send_text(5, string.format("Finished Split-S ")) 
          height_PI.reset()
          running = false
          if vehicle:get_mode() == MODE_AUTO then
             vehicle:nav_script_time_done(last_id)
          else
             vehicle:nav_scripting_enable(255)
          end
      end
   end 
   throttle = throttle_controller() 
   set_rate_targets(throttle, roll_rate, pitch_rate, 0)
end
 
function get_wp_location(i)
   local m = mission:get_item(i)
   local loc = Location()
   loc:lat(m:x())
   loc:lng(m:y())
   loc:relative_alt(false)
   loc:terrain_alt(false)
   loc:origin_alt(false)
   loc:alt(math.floor(m:z()*100))
   return loc
end

function resolve_jump(i)
   local m = mission:get_item(i)
   while m:command() == DO_JUMP do
      i = math.floor(m:param1())
      m = mission:get_item(i)
   end
   return i
end

-- see if an auto mission item needs to be run
function check_auto_mission()
   id, cmd, arg1, arg2, arg3, arg4 = vehicle:nav_script_time()
   if id then        -- we are running a scripting mission 
      if id ~= last_id then
         -- we've started a new command
         running = false
         last_id = id
         repeat_count = 0
         initial_yaw_deg = math.deg(ahrs:get_yaw_rad())
         initial_height = ahrs:get_position():alt()*0.01
         -- work out yaw between previous WP and next WP
         local cnum = mission:get_current_nav_index()
         -- find previous nav waypoint
         local loc_prev = get_wp_location(cnum-1)
         local loc_next = get_wp_location(cnum+1)
         local i= cnum-1
         while get_wp_location(i):lat() == 0 and get_wp_location(i):lng() == 0 do
             i = i-1
             loc_prev = get_wp_location(i)
         end
         -- find next nav waypoint
         i = cnum+1
         while get_wp_location(i):lat() == 0 and get_wp_location(i):lng() == 0 do
             i = i+1
             loc_next = get_wp_location(resolve_jump(i))
         end
         wp_yaw_deg = math.deg(loc_prev:get_bearing(loc_next))
      end
   do_trick(cmd,arg1,arg2)
   end
end
  
local trick_sel_chan = nil
local last_trick_selection = 0

--[[
   get selected trick. Trick numbers are 1 .. TRIK_COUNT. A value of 0 is invalid
--]]
function get_trick_selection()
   if trick_sel_chan == nil then
      trick_sel_chan = rc:find_channel_for_option(TRIK_SEL_FN:get())
      if trick_sel_chan == nil then
         return 0
      end
   end
   -- get trick selection based on selection channel input and number of tricks
   local i = math.floor(TRIK_COUNT:get() * constrain(0.5*(trick_sel_chan:norm_input_ignore_trim()+1),0,0.999)+1)
   if TRICKS[i] == nil then
      return 0
   end
   return i
end

--[[ trick name table
--]]
 local name = {}
 name[1] = "Roll(s)"
 name[2] = "Loop(s)/Turnaround"
 name[3] = "Rolling Circle"
 name[4] = "Straight Hold"
 name[5] = "Pause"
 name[6] = "Knife Edge Circle"
 name[7] = "4pt Roll"
 name[8] = "Split-S"
--[[
   check for running a trick
--]]

function check_trick()
   local selection = get_trick_selection()
   local action = rc:get_aux_cached(TRIK_ACT_FN:get())
   local id =TRICKS[selection].id:get()
   
   if action == 0 and running then
      gcs:send_text(0,string.format("Trick aborted"))
      running = false
      last_trick_selection = 0
      -- use invalid mode to disable script control
      vehicle:nav_scripting_enable(255)
      return 0
   end
   if selection == 0 then
      return 0
   end
   if action == 1 and selection ~= last_trick_selection then
         gcs:send_text(5, string.format("Trick %u selected (%s)", id, name[id]))
         last_trick_action_state = action
         last_trick_selection = selection
         return 0
   end
   if running then
      -- let the task finish
      return selection
   end
   -- trick action changed state
   if action ~= last_trick_action_state then
      last_trick_selection = selection
      last_trick_action_state = action
      if selection == 0 then
         gcs:send_text(0, string.format("No trick selected"))
         return 0
      end
      id = TRICKS[selection].id:get()
      if action == 1 then
         gcs:send_text(5, string.format("Trick %u selected (%s)", id, name[id]))
         return 0
      end
      -- action changed to execute
      if action == 2 and vehicle:get_likely_flying() then
         last_trick_selection = selection
         local current_mode = vehicle:get_mode()
         if not vehicle:nav_scripting_enable(current_mode) then
            gcs:send_text(0, string.format("Tricks not available in this mode"))
            return 0
         end
         wp_yaw_deg = math.deg(ahrs:get_yaw_rad())
         initial_height = ahrs:get_position():alt()*0.01
         return selection     
      end
   end
   return 0
end

function do_trick(cmd,arg1,arg2)
      if cmd == 1 then
         do_axial_roll(arg1, arg2)
      elseif cmd == 2 then
         do_loop(arg1, arg2)
      elseif cmd == 3 then
         do_rolling_circle(arg1, arg2)
      elseif cmd ==4 then
         do_knife_edge(arg1,arg2)
      elseif cmd == 5 then
         do_pause(arg1,arg2)
      elseif cmd == 6 then
         do_knifedge_circle(arg1,arg2)
      elseif cmd == 7 then
         do_4point_roll(arg1,arg2)
      elseif cmd == 8 then
         do_split_s(arg1,arg2)
      end
end

function update()
   if ahrs:get_velocity_NED() == nil  or ahrs:get_EAS2TAS() == nil or ahrs:get_relative_position_NED_origin() == nil then
      -- don't start till we have valid ahrs estimates
      return update, 10
   end
   if vehicle:get_mode() == MODE_AUTO then
      check_auto_mission() --run a trick mission item
   elseif tricks_exist() then
      trick = check_trick() 
      if trick ~=0 then 
      id = TRICKS[trick].id:get()
      arg1 = TRICKS[trick].args[1]:get()
      arg2 = TRICKS[trick].args[2]:get()
      do_trick(id,arg1,arg2)
      end
   end
  return update, 10
end

gcs:send_text(5, string.format("Loaded sport_aerobatics.lua"))
last_trick_selection = get_trick_selection() --prevents immediate activation on boot or restart
return update()



================================================
File: applets/Aerobatics/FixedWing/Schedules/README.md
================================================
# Scripted Aerobatics Schedules

This directory contains full aerobatic schedules for the ArduPilot
fixed wing scripted aerobatics system. If you develop your own
schedules please contribute to the project by submitting them for
inclusion in this directory.

## Usage

To use one of these schedules in SITL copy it (or use a symbolic link)
to a file called trickNN.txt in your scripts/ directory (the same
directory that plane_aerobatics.lua goes in). The NN is the trick
number used in the AUTO mission or with tricks on a switch in the
TRIKn_ID parameter.

For example, if you wanted to fly the NewZealand Clubman schedule you
could copy NZClubMan.txt to trick94.txt in your scripts
directory. Then you could set TRIK3_ID to 94 to make this schedule be
trick 3. Or you could put 94 in the NAV_SCRIPT_TIME auto-mission
command.

## Scaling

Some of these schedules are quite large and you may need to shrink
them for your model or flying field. You can use the AEROM_PATH_SCALE
parameter to adjust the size. For example, setting AEROM_PATH_SCALE to
0.5 will halve the size of the schedule. This impacts all tricks and
schedules.

You can also mirror the schedule by setting AEROM_PATH_SCALE to a
negative value. This is good if the schedule is designed to be flown
right-to-left and you want to fly it left-to-right due to the wind
direction. If you set AEROM_PATH_SCALE to -0.5 then it would do a
half-scale mirrored schedule.


## Alignment

Two commands are provided to provide alignment within the aerobatic "box":
align_center and align_box n. The start of a schedule defines the box center.
The AEROM_BOX_WIDTH defines the overall length of the box, modified by AEROM_PATH_SCALE if not "1".

align_center: Delays the start of the next trick until the center of the box.If already past it, in the direction of
travel, the trick begins immediately.

align_box n: Delays the start of the next trick until the n*(half box width-radius of trick) point of the box is reached in the direction of travel. If already past it, in the direction of travel, the trick begins immediately. So n = 1 means the end of the box for the next trick placement.

## GCS/OSD messages

name : string   displays string as the trick name when selected or executed
message: string  displays the string. Put just preceeding the trick to display it as it begins execution

## Throttle Boost

thr_boost = true command demands increased throttle output if the trick requires it for the specific vehicle.



================================================
File: applets/WebExamples/test.lua
================================================
--[[
example lua cgi file for cgi-bin/ folder
--]]
return [[
test-from-cgi

working!!
]]




================================================
File: applets/WebExamples/test.shtml
================================================
<html>
  <head>
       <meta http-equiv="refresh" content="1">
  </head>
  <body>
    <h1>Server Side Scripting Test</h1>
    <table>
      <tr><th>Roll</th><th>Pitch</th><th>Yaw</th></tr>
      <tr>
      <td><?lua return tostring(math.deg(ahrs:get_roll_rad()))?></td>
      <td><?lstr math.deg(ahrs:get_pitch_rad())?></td>
      <td><?lstr math.deg(ahrs:get_yaw_rad())?></td>
      </tr>
    </table>
  </body>
</html>



================================================
File: docs/docs.lua
================================================
---@meta
-- ArduPilot lua scripting documentation in EmmyLua Annotations
-- This file should be auto generated and then manual edited
-- generate with --scripting-docs, eg  ./waf copter --scripting-docs
-- see: https://github.com/sumneko/lua-language-server/wiki/EmmyLua-Annotations
-- luacheck: ignore 121 (Setting a read-only global variable)
-- luacheck: ignore 122 (Setting a read-only field of a global variable)
-- luacheck: ignore 212 (Unused argument)
-- luacheck: ignore 241 (Local variable is mutated but never accessed)
-- luacheck: ignore 221 (Local variable is accessed but never set.)

-- set and get for field types share function names
---@diagnostic disable: duplicate-set-field
---@diagnostic disable: missing-return

-- integer enum value unknown by docs generator
---@type integer
local enum_integer

-- manual bindings

--- Custom 32-bit unsigned integer userdata type.
-- This is used to handle large integer values that may lose precision if stored as standard Lua numbers (which are double-precision floats).
---@class (exact) uint32_t_ud
---@operator add(uint32_t_ud|integer|number): uint32_t_ud
---@operator sub(uint32_t_ud|integer|number): uint32_t_ud
---@operator mul(uint32_t_ud|integer|number): uint32_t_ud
---@operator div(uint32_t_ud|integer|number): uint32_t_ud
---@operator mod(uint32_t_ud|integer|number): uint32_t_ud
---@operator band(uint32_t_ud|integer|number): uint32_t_ud
---@operator bor(uint32_t_ud|integer|number): uint32_t_ud
---@operator shl(uint32_t_ud|integer|number): uint32_t_ud
---@operator shr(uint32_t_ud|integer|number): uint32_t_ud
local uint32_t_ud = {}

-- Create a new uint32_t userdata object with an optional initial value.
---@param value? uint32_t_ud|integer|number -- Optional initial value.
---@return uint32_t_ud
function uint32_t(value) end

-- Convert the uint32_t value to a standard Lua number (float).
---@return number
function uint32_t_ud:tofloat() end

-- Convert the uint32_t value to a standard Lua integer.
---@return integer
function uint32_t_ud:toint() end

--- Custom 64-bit unsigned integer userdata type.
-- Essential for high-resolution timestamps (like from `micros()`) or large IDs where standard Lua numbers would lose precision.
---@class (exact) uint64_t_ud
---@operator add(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator sub(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator mul(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator div(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator mod(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator band(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator bor(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator shl(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
---@operator shr(uint64_t_ud|uint32_t_ud|integer|number): uint64_t_ud
local uint64_t_ud = {}

-- Create a new uint64_t userdata object with an optional initial value.
-- Note that standard Lua numbers (floats) will lose precision with large integer values.
---@param value? uint64_t_ud|uint32_t_ud|integer|number
---@return uint64_t_ud
function uint64_t(value) end

-- Create a uint64_t userdata object from a low and high 32-bit half.
-- The final value is equivalent to `(high << 32) | low`.
---@param high uint32_t_ud|integer|number -- The most significant 32 bits.
---@param low uint32_t_ud|integer|number -- The least significant 32 bits.
---@return uint64_t_ud
function uint64_t(high, low) end

-- Convert the uint64_t value to a standard Lua number (float). Be aware that this can lose precision for large values.
---@return number
function uint64_t_ud:tofloat() end

-- Convert the uint64_t value to a standard Lua integer. Returns nil if the value is too large to be represented by a native 32-bit integer.
---@return integer|nil
function uint64_t_ud:toint() end

-- Split the 64-bit value into high and low 32-bit halves, returning each as a uint32_t userdata.
---@return uint32_t_ud -- The high 32 bits of the value (value >> 32).
---@return uint32_t_ud -- The low 32 bits of the value (value & 0xFFFFFFFF).
function uint64_t_ud:split() end

-- Returns the system time in milliseconds since the autopilot booted.
---@return uint32_t_ud -- Milliseconds since boot.
function millis() end

-- Returns the system time in microseconds since the autopilot booted.
-- This should be stored in a uint64_t_ud to avoid precision loss.
---@return uint64_t_ud -- Microseconds since boot.
function micros() end

-- Receives data from a currently running NAV_SCRIPT_TIME mission command.
-- This function is the bridge between a mission file and a script, allowing for scripted maneuvers inside an auto mission.
-- Returns nil for all values if no NAV_SCRIPT_TIME command is active.
---@return uint32_t_ud|nil -- The time the NAV_SCRIPT_TIME command started, in milliseconds.
---@return integer|nil -- The value from the mission command's 'command' (param 1) field.
---@return number|nil -- The value from the mission command's 'param 2' field.
---@return number|nil -- The value from the mission command's 'param 3' field.
---@return number|nil -- The value from the mission command's 'param 4' field.
function mission_receive() end

-- Prints text to the GCS and connected peripherals.
-- If a MAVLink GCS is connected, this is equivalent to `gcs:send_text(MAV_SEVERITY.DEBUG, text)`.
-- If the script is running on a peripheral, the text will be sent over the CAN bus.
---@param text string|number|integer -- The content to be printed. Non-string types will be converted to strings.
function print(text) end

-- Dataflash logging object for writing custom data to the vehicle's onboard log files (e.g., .bin files).
-- This is the primary method for recording script-specific data for post-flight analysis.
logger = {}

-- Writes a custom log entry to the dataflash log with full formatting options. A timestamp is automatically added.
-- Example from `revert_param.lua`: `logger:write('QUIK','SRate,Gain,Param', 'ffn', srate, P:get(), axis .. stage)`
---@param name string -- A unique name for the log entry, must be 4 characters or less to avoid conflicts.
---@param labels string -- Comma-separated labels for the data fields, up to 58 characters. E.g., "Lat,Lon,Alt".
---@param format string -- A format string defining the data types of the values. See https://ardupilot.org/dev/docs/code-overview-logger.html for format specifiers.
---@param units string -- A string defining the units for each value (e.g., 'm', 's', 'd' for meters, seconds, degrees). Use '-' for no units.
---@param multipliers string -- A string defining multipliers for each value. Use '-' for no multiplier.
---@param ... integer|number|uint32_t_ud|string|boolean -- The data values to be logged, matching the types and order in the format string.
function logger:write(name, labels, format, units, multipliers, ...) end

-- Writes a custom log entry to the dataflash log. A timestamp is automatically added. This is a simplified version without units or multipliers.
---@param name string -- A unique name for the log entry, must be 4 characters or less.
---@param labels string -- Comma-separated labels for the data fields, up to 58 characters.
---@param format string -- A format string defining the data types of the values.
---@param ... integer|number|uint32_t_ud|string|boolean -- The data values to be logged.
function logger:write(name, labels, format, ...) end

-- Logs the entire content of a specified file to the onboard log. Useful for saving configuration or mission files with the flight data for debugging.
---@param filename string -- The name of the file to log (e.g., "mission.txt").
function logger:log_file_content(filename) end

-- I2C bus interaction object. Provides low-level access for communicating with I2C peripherals.
i2c = {}

-- Gets a device handler for a specific I2C bus and address. This is the first step for any I2C communication.
-- Example from `RM3100_self_test.lua`: `local rm3100 = i2c:get_device(0, 0x20)`
---@param bus integer -- The I2C bus number (e.g., 0 for the first bus, corresponding to I2C1 on the flight controller).
---@param address integer -- The 7-bit I2C device address (0 to 127).
---@param clock? uint32_t_ud|integer|number -- Optional bus clock speed in Hz (e.g., 400000 for 400kHz). Defaults to 400000.
---@param smbus? boolean -- Optional flag to indicate if SMBus protocol should be used. Defaults to false.
---@return AP_HAL__I2CDevice_ud -- Returns an I2C device object used for subsequent read/write operations.
function i2c:get_device(bus, address, clock, smbus) end

-- EFI (Electronic Fuel Injection) state structure. A container for all telemetry data from an EFI system.
-- Scripts typically receive this object from `efi:get_state()` or populate it to send to an EFI backend.
---@class (exact) EFI_State_ud
local EFI_State_ud = {}

---@return EFI_State_ud
function EFI_State() end

-- get field: Pressure/Temperature compensation for the engine.
---@return number
function EFI_State_ud:pt_compensation() end

-- set field
---@param value number
function EFI_State_ud:pt_compensation(value) end

-- get field: The throttle output percentage being sent to the engine.
---@return number
function EFI_State_ud:throttle_out() end

-- set field
---@param value number
function EFI_State_ud:throttle_out(value) end

-- get field: The voltage being supplied to the ignition system.
---@return number
function EFI_State_ud:ignition_voltage() end

-- set field
---@param value number
function EFI_State_ud:ignition_voltage(value) end

-- get field: A sub-object containing status for individual engine cylinders.
---@return Cylinder_Status_ud
function EFI_State_ud:cylinder_status() end

-- set field
---@param value Cylinder_Status_ud
function EFI_State_ud:cylinder_status(value) end

-- get field: The index of the Electronic Control Unit (ECU) providing the data.
---@return integer
function EFI_State_ud:ecu_index() end

-- set field
---@param value integer
function EFI_State_ud:ecu_index(value) end

-- get field: The physical position of the throttle plate as a percentage (0-100).
---@return integer
function EFI_State_ud:throttle_position_percent() end

-- set field
---@param value integer
function EFI_State_ud:throttle_position_percent(value) end

-- get field: The total volume of fuel consumed since boot, in cubic centimeters.
---@return number
function EFI_State_ud:estimated_consumed_fuel_volume_cm3() end

-- set field
---@param value number
function EFI_State_ud:estimated_consumed_fuel_volume_cm3(value) end

-- get field: The current rate of fuel consumption in cubic centimeters per minute.
---@return number
function EFI_State_ud:fuel_consumption_rate_cm3pm() end

-- set field
---@param value number
function EFI_State_ud:fuel_consumption_rate_cm3pm(value) end

-- get field: The current fuel pressure, typically in kPa.
---@return number
function EFI_State_ud:fuel_pressure() end

-- set field
---@param value number
function EFI_State_ud:fuel_pressure(value) end

-- get field: The status of the fuel pressure sensor.
---@return integer
---| '0' # Not supported
---| '1' # Ok
---| '2' # Below nominal
---| '3' # Above nominal
function EFI_State_ud:fuel_pressure_status() end

-- set field
---@param status integer
---| '0' # Not supported
---| '1' # Ok
---| '2' # Below nominal
---| '3' # Above nominal
function EFI_State_ud:fuel_pressure_status(status) end

-- get field: The engine oil temperature, typically in degrees Celsius.
---@return number
function EFI_State_ud:oil_temperature() end

-- set field
---@param value number
function EFI_State_ud:oil_temperature(value) end

-- get field: The engine oil pressure, typically in kPa.
---@return number
function EFI_State_ud:oil_pressure() end

-- set field
---@param value number
function EFI_State_ud:oil_pressure(value) end

-- get field: The engine coolant temperature, typically in degrees Celsius.
---@return number
function EFI_State_ud:coolant_temperature() end

-- set field
---@param value number
function EFI_State_ud:coolant_temperature(value) end

-- get field: The temperature of the air in the intake manifold, typically in degrees Celsius.
---@return number
function EFI_State_ud:intake_manifold_temperature() end

-- set field
---@param value number
function EFI_State_ud:intake_manifold_temperature(value) end

-- get field: The pressure in the intake manifold, in kilopascals (kPa).
---@return number
function EFI_State_ud:intake_manifold_pressure_kpa() end

-- set field
---@param value number
function EFI_State_ud:intake_manifold_pressure_kpa(value) end

-- get field: The current atmospheric pressure, in kilopascals (kPa).
---@return number
function EFI_State_ud:atmospheric_pressure_kpa() end

-- set field
---@param value number
function EFI_State_ud:atmospheric_pressure_kpa(value) end

-- get field: The duration of the spark dwell time, in milliseconds.
---@return number
function EFI_State_ud:spark_dwell_time_ms() end

-- set field
---@param value number
function EFI_State_ud:spark_dwell_time_ms(value) end

-- get field: The rotational speed of the engine, in revolutions per minute (RPM).
---@return uint32_t_ud
function EFI_State_ud:engine_speed_rpm() end

-- set field
---@param value uint32_t_ud|integer|number
function EFI_State_ud:engine_speed_rpm(value) end

-- get field: The current engine load as a percentage (0-100).
---@return integer
function EFI_State_ud:engine_load_percent() end

-- set field
---@param value integer
function EFI_State_ud:engine_load_percent(value) end

-- get field: A boolean flag indicating a general error state in the EFI system.
---@return boolean
function EFI_State_ud:general_error() end

-- set field
---@param value boolean
function EFI_State_ud:general_error(value) end

-- get field: The system timestamp (in milliseconds) of the last EFI data update.
---@return uint32_t_ud
function EFI_State_ud:last_updated_ms() end

-- set field
---@param value uint32_t_ud|integer|number
function EFI_State_ud:last_updated_ms(value) end


-- EFI Cylinder_Status structure. Contains detailed information for a single engine cylinder.
---@class (exact) Cylinder_Status_ud
local Cylinder_Status_ud = {}

---@return Cylinder_Status_ud
function Cylinder_Status() end

-- get field: The lambda coefficient (air-fuel ratio). A value of 1.0 is stoichiometric.
---@return number
function Cylinder_Status_ud:lambda_coefficient() end

-- set field
---@param value number
function Cylinder_Status_ud:lambda_coefficient(value) end

-- get field: The exhaust gas temperature (EGT), typically in degrees Celsius.
---@return number
function Cylinder_Status_ud:exhaust_gas_temperature() end

-- set field
---@param value number
function Cylinder_Status_ud:exhaust_gas_temperature(value) end

-- get field: The EGT of a second sensor, if available.
---@return number
function Cylinder_Status_ud:exhaust_gas_temperature2() end

-- set field
---@param value number
function Cylinder_Status_ud:exhaust_gas_temperature2(value) end

-- get field: The cylinder head temperature (CHT), typically in degrees Celsius.
---@return number
function Cylinder_Status_ud:cylinder_head_temperature() end

-- set field
---@param value number
function Cylinder_Status_ud:cylinder_head_temperature(value) end

-- get field: The CHT of a second sensor, if available.
---@return number
function Cylinder_Status_ud:cylinder_head_temperature2() end

-- set field
---@param value number
function Cylinder_Status_ud:cylinder_head_temperature2(value) end

-- get field: The duration of the fuel injection pulse, in milliseconds.
---@return number
function Cylinder_Status_ud:injection_time_ms() end

-- set field
---@param value number
function Cylinder_Status_ud:injection_time_ms(value) end

-- get field: The ignition timing advance, in degrees.
---@return number
function Cylinder_Status_ud:ignition_timing_deg() end

-- set field
---@param value number
function Cylinder_Status_ud:ignition_timing_deg(value) end

-- Main EFI interface object. Used to get data from and send data to an EFI system.
efi = {}

-- Returns the most recent, complete state of the EFI system.
-- Example from `efi_speed_check.lua`: `local efi_state = efi:get_state()`
---@return EFI_State_ud -- An `EFI_State_ud` object containing the latest telemetry.
function efi:get_state() end

-- Returns the system timestamp of the last successful EFI data update.
-- Useful for checking if the connection to the EFI is alive.
---@return uint32_t_ud -- Milliseconds since boot.
function efi:get_last_update_ms() end

-- Gets a handle to the EFI backend driver for a specific instance.
-- This is used by custom EFI driver scripts (like EFI_HFE.lua) to push data into the ArduPilot EFI system.
---@param instance integer -- The EFI instance number (0 for the first).
---@return AP_EFI_Backend_ud|nil -- The backend object, or nil if not found.
function efi:get_backend(instance) end

-- CAN bus interaction object. Provides an interface for sending and receiving raw CAN frames.
-- This is a low-level interface and should be used when you need to implement a custom CAN protocol.
-- For the DroneCAN protocol, it is recommended to use the higher-level DroneCAN bindings.
CAN = {}

-- Gets a device handler for the first CAN scripting driver.
-- The corresponding CAN_P1_PROTOCOL parameter must be set to 'Scripting' (28) for this to succeed.
---@param buffer_len uint32_t_ud|integer|number -- The number of CAN frames to buffer (1 to 25). Frames will be dropped if not read before the buffer is full.
---@return ScriptingCANBuffer_ud|nil -- Returns a buffer object for sending/receiving frames, or nil if the driver is not enabled.
function CAN:get_device(buffer_len) end

-- Gets a device handler for the second CAN scripting driver.
-- The corresponding CAN_P2_PROTOCOL parameter must be set to 'Scripting' (28) for this to succeed.
---@param buffer_len uint32_t_ud|integer|number -- The number of CAN frames to buffer (1 to 25).
---@return ScriptingCANBuffer_ud|nil -- Returns a buffer object for sending/receiving frames, or nil if the driver is not enabled.
function CAN:get_device2(buffer_len) end


-- Gets the latest FlexDebug message from a specific DroneCAN node.
-- This is a utility for receiving custom debug information from a DroneCAN peripheral that is transmitting `uavcan.debug.KeyValue` messages.
---@param bus number -- The CAN bus number (0 for the first bus/CAN1, 1 for the second/CAN2).
---@param node number -- The DroneCAN node ID of the peripheral to listen to.
---@param id number -- The specific FlexDebug message ID (the 'key' from the KeyValue pair) to filter for.
---@param last_us uint32_t_ud|integer|number -- The timestamp of the last message you received. The function will only return a new message if its timestamp is different. Pass 0 to get the first message.
---@return uint32_t_ud|nil -- The timestamp (in microseconds) of the new message, or nil if no new message has arrived.
---@return string|nil -- The message payload as a raw string (up to 255 bytes), or nil.
function DroneCAN_get_FlexDebug(bus,node,id,last_us) end

-- Auto generated binding

-- Represents a single, raw CAN frame.
-- This object is used with the low-level CAN scripting driver to send and receive data.
---@class (exact) CANFrame_ud
local CANFrame_ud = {}

---@return CANFrame_ud
function CANFrame() end

-- Get the Data Length Code (DLC) of the frame.
---@return integer -- The number of data bytes in the payload (0-8 for classic CAN).
function CANFrame_ud:dlc() end

-- Set the Data Length Code (DLC) of the frame.
---@param value integer -- The number of data bytes in the payload.
function CANFrame_ud:dlc(value) end

-- Get a byte from the data payload array.
---@param index integer -- The index of the byte to retrieve (1-8 for classic CAN).
---@return integer -- The byte value (0-255).
function CANFrame_ud:data(index) end

-- Set a byte in the data payload array.
---@param index integer -- The index of the byte to set (1-8 for classic CAN).
---@param value integer -- The byte value to set (0-255).
function CANFrame_ud:data(index, value) end

-- Get the CAN frame ID.
---@return uint32_t_ud -- The frame ID (11-bit for standard, 29-bit for extended).
function CANFrame_ud:id() end

-- Set the CAN frame ID.
---@param value uint32_t_ud|integer|number -- The frame ID to set.
function CANFrame_ud:id(value) end

-- Check if the frame is an error frame.
---@return boolean
function CANFrame_ud:isErrorFrame() end

-- Check if the frame is a Remote Transmission Request (RTR).
---@return boolean
function CANFrame__ud:isRemoteTransmissionRequest() end

-- Check if the frame uses an extended (29-bit) ID.
---@return boolean
function CANFrame_ud:isExtended() end

-- Get the CAN frame ID as a signed integer.
---@return integer
function CANFrame_ud:id_signed() end

-- Represents the motor mixing factors table.
-- This is an advanced structure that provides insight into how the flight controller allocates motor power for attitude control.
---@class (exact) motor_factor_table_ud
local motor_factor_table_ud = {}

---@return motor_factor_table_ud
function motor_factor() end

-- Get the throttle factor for a specific motor.
---@param index integer -- The motor number (e.g., 1 for motor 1).
---@return number -- The throttle mixing factor for this motor.
function motor_factor_table_ud:throttle(index) end

-- Set the throttle factor for a specific motor.
---@param index integer
---@param value number
function motor_factor_table_ud:throttle(index, value) end

-- Get the yaw factor for a specific motor.
---@param index integer -- The motor number.
---@return number -- The yaw mixing factor for this motor.
function motor_factor_table_ud:yaw(index) end

-- Set the yaw factor for a specific motor.
---@param index integer
---@param value number
function motor_factor_table_ud:yaw(index, value) end

-- Get the pitch factor for a specific motor.
---@param index integer -- The motor number.
---@return number -- The pitch mixing factor for this motor.
function motor_factor_table_ud:pitch(index) end

-- Set the pitch factor for a specific motor.
---@param index integer
---@param value number
function motor_factor_table_ud:pitch(index, value) end

-- Get the roll factor for a specific motor.
---@param index integer -- The motor number.
---@return number -- The roll mixing factor for this motor.
function motor_factor_table_ud:roll(index) end

-- Set the roll factor for a specific motor.
---@param index integer
---@param value number
function motor_factor_table_ud:roll(index, value) end

-- Represents a network socket for TCP or UDP communication.
-- This class provides the low-level functions needed to create network clients and servers.
-- The `net_webserver.lua` example demonstrates a practical use case for this class.
---@class (exact) SocketAPM_ud
local SocketAPM_ud = {}

-- Creates a new socket object.
---@param datagram integer -- Set to 1 for a UDP (datagram) socket, or 0 for a TCP (stream) socket.
---@return SocketAPM_ud -- The new socket object.
function Socket(datagram) end

-- Converts a string representation of an IPv4 address to its 32-bit unsigned integer format.
---@param str_address string -- The IPv4 address as a string (e.g., "192.168.1.1").
---@return uint32_t_ud -- The IPv4 address as a 32-bit integer.
function string_to_ipv4_addr(str_address) end

-- Converts a 32-bit unsigned integer representation of an IPv4 address back to its string format.
---@param addr uint32_t_ud|integer|number -- The IPv4 address as a 32-bit integer.
---@return string -- The string representation of the address (e.g., "192.168.1.1").
function ipv4_addr_to_string(addr) end

-- Returns true if the socket is currently connected to a remote endpoint.
---@return boolean
function SocketAPM_ud:is_connected() end

-- Sets the blocking or non-blocking state of the socket.
-- In blocking mode (true), send/recv calls will wait until the operation is complete.
-- In non-blocking mode (false), they return immediately.
---@param blocking boolean -- true for blocking, false for non-blocking.
---@return boolean
function SocketAPM_ud:set_blocking(blocking) end

-- Puts a TCP socket into a listening state, ready to accept incoming connections.
-- This must be called before `accept()`.
---@param backlog integer -- The maximum number of pending connections to queue.
---@return boolean -- True on success.
function SocketAPM_ud:listen(backlog) end

-- Sends data over a connected TCP socket.
---@param str string -- The data to send, which can be a binary string.
---@param len uint32_t_ud|integer|number -- The number of bytes to send from the string.
---@return integer -- The number of bytes actually sent, which may be less than `len` if the send buffer is full.
function SocketAPM_ud:send(str, len) end

-- Sends data over a UDP socket to a specific destination.
---@param str string -- The data to send, which can be a binary string.
---@param len uint32_t_ud|integer|number -- The number of bytes to send.
---@param ipaddr uint32_t_ud|integer|number -- The destination IPv4 address as a 32-bit integer.
---@param port integer -- The destination port number.
---@return integer -- The number of bytes sent.
function SocketAPM_ud:sendto(str, len, ipaddr, port) end

-- Binds the socket to a specific local IP address and port.
-- For a server, this is typically used to listen on a specific port for incoming connections or datagrams.
---@param IP_address string -- The local IP address to bind to. Use "0.0.0.0" to bind to all available network interfaces.
---@param port integer -- The local port number to bind to.
---@return boolean -- True on success.
function SocketAPM_ud:bind(IP_address, port) end

-- Connects a TCP socket to a remote server.
---@param IP_address string -- The IP address of the remote server.
---@param port integer -- The port number of the remote server.
---@return boolean -- True on success.
function SocketAPM_ud:connect(IP_address, port) end

-- Accepts a new incoming connection on a listening TCP socket.
-- This function will block until a new connection arrives if the socket is in blocking mode.
---@return SocketAPM_ud|nil -- A new socket object for the accepted connection, or nil if no connection is pending (in non-blocking mode).
function SocketAPM_ud:accept() end

-- Receives data from a socket.
---@param length integer -- The maximum number of bytes to receive.
---@return string|nil -- The received data as a string, or nil on error.
---@return uint32_t_ud|nil -- For UDP sockets, the source IP address of the received packet.
---@return integer|nil -- For UDP sockets, the source port of the received packet.
function SocketAPM_ud:recv(length) end

-- Checks if there is incoming data available to be read from the socket.
---@param timeout_ms uint32_t_ud|integer|number -- The time to wait in milliseconds.
---@return boolean -- True if data is available for reading.
function SocketAPM_ud:pollin(timeout_ms) end

-- Checks if the socket is ready to accept data for writing without blocking.
---@param timeout_ms uint32_t_ud|integer|number -- The time to wait in milliseconds.
---@return boolean -- True if the socket is ready for writing.
function SocketAPM_ud:pollout(timeout_ms) end

-- Closes the socket.
-- Note: Lua does not automatically garbage collect sockets. You must explicitly close a socket when you are finished with it to free up system resources.
function SocketAPM_ud:close() end

-- Efficiently sends the contents of a file over a socket.
-- This offloads the file transfer to the underlying operating system, which is much faster than reading and sending in chunks within the script.
-- The socket and file handle are closed automatically upon completion.
---@param filehandle string -- The handle of the file to send.
---@return boolean -- True on success.
function SocketAPM_ud:sendfile(filehandle) end

-- Enables the SO_REUSEADDR socket option.
-- This allows a server to bind to a port that is in a TIME_WAIT state, which can be useful when restarting a server script quickly.
---@return boolean -- True on success.
function SocketAPM_ud:reuseaddress() end

-- Represents a PWM input source. Used for reading PWM signals from auxiliary input pins.
---@class (exact) AP_HAL__PWMSource_ud
local AP_HAL__PWMSource_ud = {}

-- Creates a new PWMSource object.
---@return AP_HAL__PWMSource_ud
function PWMSource() end

-- Gets the average PWM pulse width since the last call.
---@return integer -- The average pulse width in microseconds (us).
function AP_HAL__PWMSource_ud:get_pwm_avg_us() end

-- Gets the latest PWM pulse width reading.
---@return integer -- The latest pulse width in microseconds (us).
function AP_HAL__PWMSource_ud:get_pwm_us() end

-- Sets the physical pin to be used for this PWM input source.
-- The pin must be configured as a PWM input.
---@param pin_number integer -- The pin number (e.g., 50 for AUX1).
---@return boolean -- True on success.
function AP_HAL__PWMSource_ud:set_pin(pin_number) end

-- Represents a single mission command, mirroring the MAVLink MAV_CMD definitions and the MAVLink Mission Item Protocol.
-- This object is the fundamental building block for creating and modifying autonomous missions.
-- Scripts can get this object using `mission:get_item()` and modify its fields before writing it back with `mission:set_item()`.
---@class (exact) mavlink_mission_item_int_t_ud
local mavlink_mission_item_int_t_ud = {}

-- Creates a new, empty mavlink_mission_item_int_t object. All fields will be initialized to zero.
---@return mavlink_mission_item_int_t_ud
function mavlink_mission_item_int_t() end

-- Get the 'current' field. A value of 1 indicates this is the active command in the mission.
---@return integer
function mavlink_mission_item_int_t_ud:current() end

-- Set the 'current' field.
---@param value integer
function mavlink_mission_item_int_t_ud:current(value) end

-- Get the coordinate frame for this mission item. The frame determines how the x, y, and z values are interpreted.
-- Common values: 3 (MAV_FRAME_GLOBAL_RELATIVE_ALT), 10 (MAV_FRAME_GLOBAL_TERRAIN_ALT).
---@return integer
function mavlink_mission_item_int_t_ud:frame() end

-- Set the coordinate frame.
---@param value integer -- The frame enum value.
function mavlink_mission_item_int_t_ud:frame(value) end

-- Get the command ID (MAV_CMD). This defines the action to be performed.
-- E.g., 16 for MAV_CMD_NAV_WAYPOINT, 21 for MAV_CMD_NAV_LAND, 22 for MAV_CMD_NAV_TAKEOFF.
---@return integer
function mavlink_mission_item_int_t_ud:command() end

-- Set the command ID.
---@param value integer -- The MAV_CMD enum value.
function mavlink_mission_item_int_t_ud:command(value) end

-- Get the sequence number of this command in the mission.
---@return integer
function mavlink_mission_item_int_t_ud:seq() end

-- Set the sequence number.
---@param value integer
function mavlink_mission_item_int_t_ud:seq(value) end

-- Get the 'z' field, which typically represents altitude.
---@return number -- The meaning depends on the command and frame, but it is usually altitude in meters.
function mavlink_mission_item_int_t_ud:z() end

-- Set the 'z' field.
---@param value number -- Altitude in meters.
function mavlink_mission_item_int_t_ud:z(value) end

-- Get the 'y' field, which typically represents longitude for geographic commands.
---@return integer -- Longitude in degrees * 1e7.
function mavlink_mission_item_int_t_ud:y() end

-- Set the 'y' field.
---@param value integer -- Longitude in degrees * 1e7.
function mavlink_mission_item_int_t_ud:y(value) end

-- Get the 'x' field, which typically represents latitude for geographic commands.
---@return integer -- Latitude in degrees * 1e7.
function mavlink_mission_item_int_t_ud:x() end

-- Set the 'x' field.
---@param value integer -- Latitude in degrees * 1e7.
function mavlink_mission_item_int_t_ud:x(value) end

-- Get the 'param4' field. The meaning is specific to the command ID.
---@return number
function mavlink_mission_item_int_t_ud:param4() end

-- Set the 'param4' field.
---@param value number
function mavlink_mission_item_int_t_ud:param4(value) end

-- Get the 'param3' field. The meaning is specific to the command ID (e.g., radius for loiter commands).
---@return number
function mavlink_mission_item_int_t_ud:param3() end

-- Set the 'param3' field.
---@param value number
function mavlink_mission_item_int_t_ud:param3(value) end

-- Get the 'param2' field. The meaning is specific to the command ID (e.g., acceptance radius for waypoints).
---@return number
function mavlink_mission_item_int_t_ud:param2() end

-- Set the 'param2' field.
---@param value number
function mavlink_mission_item_int_t_ud:param2(value) end

-- Get the 'param1' field. The meaning is specific to the command ID (e.g., hold time for waypoints).
---@return number
function mavlink_mission_item_int_t_ud:param1() end

-- Set the 'param1' field.
---@param value number
function mavlink_mission_item_int_t_ud:param1(value) end

-- A helper object for dynamically accessing and modifying an ArduPilot parameter.
-- This object is created empty and then bound to a parameter using the `:init(name)` function.
-- This is useful when the parameter name is not known at the start of the script or may change.
---@class (exact) Parameter_ud
local Parameter_ud = {}

-- Creates a new, unbound parameter helper. You must call :init(name) on this object before it can be used.
---@return Parameter_ud
function Parameter() end

-- Sets the default value of this parameter in the vehicle's parameter metadata.
-- If the parameter has not been configured by the user, its value will be updated to this new default.
---@param value number -- The new default value.
---@return boolean -- True on success.
function Parameter_ud:set_default(value) end

-- Returns true if the parameter has been configured by the user away from its default value.
---@return boolean
function Parameter_ud:configured() end

-- Sets the parameter to the given value and saves it to permanent storage (EEPROM).
-- The value will persist after a reboot. Use this with caution, especially on critical parameters.
---@param value number -- The value to set.
---@return boolean -- True on success.
function Parameter_ud:set_and_save(value) end

-- Sets the parameter to the given value for the current session.
-- The value will NOT persist after a reboot.
---@param value number -- The value to set.
---@return boolean -- True on success.
function Parameter_ud:set(value) end

-- Gets the current value of the parameter.
---@return number|nil -- The parameter's current value, or nil if `:init()` has not been called or the parameter was not found.
function Parameter_ud:get() end

-- Initializes the parameter helper from its internal key information.
-- This is an advanced function that allows a script to load old parameters that may have been removed from the main code.
---@param key integer -- The parameter's internal key.
---@param group_element uint32_t_ud|integer|number
---@param type integer -- The AP_Param type enum.
---| '1' # AP_PARAM_INT8
---| '2' # AP_PARAM_INT16
---| '3' # AP_PARAM_INT32
---| '4' # AP_PARAM_FLOAT
---@return boolean
function Parameter_ud:init_by_info(key, group_element, type) end

-- Initializes (binds) this parameter helper to a parameter specified by name. This must be called before get/set.
---@param name string -- The name of the parameter (e.g., "ANGLE_MAX").
---@return boolean -- True if the parameter was found and successfully initialized.
function Parameter_ud:init(name) end

-- A helper object for accessing and modifying a statically defined ArduPilot parameter.
-- The parameter name is provided at creation and cannot be changed. This is generally safer and more efficient than the dynamic `Parameter_ud`.
-- Example from `Param_Controller.lua`: `local my_param = Parameter("MY_PARAM_NAME")`
---@class (exact) Parameter_ud_const
local Parameter_ud_const = {}

-- Creates a new parameter helper and binds it to the specified parameter name.
-- This will cause a script error if no parameter with the given name is found.
---@param name string -- The name of the parameter (e.g., "ANGLE_MAX").
---@return Parameter_ud_const
function Parameter(name) end

-- Sets the default value of this parameter in the vehicle's parameter metadata.
---@param value number
---@return boolean
function Parameter_ud_const:set_default(value) end

-- Returns true if the parameter has been configured by the user away from its default value.
---@return boolean
function Parameter_ud_const:configured() end

-- Sets the parameter to the given value and saves it to permanent storage (EEPROM). Persists after reboot.
---@param value number
---@return boolean
function Parameter_ud_const:set_and_save(value) end

-- Sets the parameter to the given value for the current session. Does not persist after reboot.
---@param value number
---@return boolean
function Parameter_ud_const:set(value) end

-- Gets the current value of the parameter.
---@return number -- The parameter's current value.
function Parameter_ud_const:get() end

-- Represents a 2D vector with x and y floating point components.
---@class (exact) Vector2f_ud
---@operator add(Vector2f_ud): Vector2f_ud
---@operator sub(Vector2f_ud): Vector2f_ud
local Vector2f_ud = {}

-- Creates a new Vector2f object, initialized to (0,0).
---@return Vector2f_ud
function Vector2f() end

-- Creates a copy of this Vector2f, returning a new object.
---@return Vector2f_ud
function Vector2f_ud:copy() end

-- Gets the y component of the vector.
---@return number
function Vector2f_ud:y() end

-- Sets the y component of the vector.
---@param value number
function Vector2f_ud:y(value) end

-- Gets the x component of the vector.
---@return number
function Vector2f_ud:x() end

-- Sets the x component of the vector.
---@param value number
function Vector2f_ud:x(value) end

-- Rotates the vector in-place by the specified angle.
---@param angle_rad number -- The angle to rotate by, in radians.
function Vector2f_ud:rotate(angle_rad) end

-- Checks if both components of the vector are zero.
---@return boolean
function Vector2f_ud:is_zero() end

-- Checks if either component of the vector is infinite.
---@return boolean
function Vector2f_ud:is_inf() end

-- Checks if either component of the vector is Not a Number (NaN).
---@return boolean
function Vector2f_ud:is_nan() end

-- Normalizes the vector to a unit length (magnitude of 1). The vector is modified in-place.
function Vector2f_ud:normalize() end

-- Calculates the length (magnitude) of this vector: sqrt(x^2 + y^2).
---@return number
function Vector2f_ud:length() end

-- Calculates the angle of this vector from North, in radians.
---@return number -- Angle in radians, in the range of -PI to +PI.
function Vector2f_ud:angle() end

-- Represents a 3D vector with x, y, and z floating point components.
-- Often used to represent positions, velocities, and attitudes in the North-East-Down (NED) frame.
---@class (exact) Vector3f_ud
---@operator add(Vector3f_ud): Vector3f_ud
---@operator sub(Vector3f_ud): Vector3f_ud
local Vector3f_ud = {}

-- Creates a new Vector3f object, initialized to (0,0,0).
---@return Vector3f_ud
function Vector3f() end

-- Creates a copy of this Vector3f, returning a new object.
---@return Vector3f_ud
function Vector3f_ud:copy() end

-- Gets the z component of the vector (typically Down).
---@return number
function Vector3f_ud:z() end

-- Sets the z component of the vector.
---@param value number
function Vector3f_ud:z(value) end

-- Gets the y component of the vector (typically East).
---@return number
function Vector3f_ud:y() end

-- Sets the y component of the vector.
---@param value number
function Vector3f_ud:y(value) end

-- Gets the x component of the vector (typically North).
---@return number
function Vector3f_ud:x() end

-- Sets the x component of the vector.
---@param value number
function Vector3f_ud:x(value) end

-- Returns a new Vector3f with the same direction but scaled length.
---@param scale_factor number
---@return Vector3f_ud
function Vector3f_ud:scale(scale_factor) end

-- Calculates the cross product of this vector and another. The result is a new vector perpendicular to both original vectors.
---@param vector Vector3f_ud -- The other vector.
---@return Vector3f_ud -- The resulting vector.
function Vector3f_ud:cross(vector) end

-- Calculates the dot product of this vector and another.
---@param vector Vector3f_ud -- The other vector.
---@return number -- The resulting scalar value.
function Vector3f_ud:dot(vector) end

-- Checks if all components of the vector are zero.
---@return boolean
function Vector3f_ud:is_zero() end

-- Checks if any component of the vector is infinite.
---@return boolean
function Vector3f_ud:is_inf() end

-- Checks if any component of the vector is Not a Number (NaN).
---@return boolean
function Vector3f_ud:is_nan() end

-- Normalizes the vector to a unit length (magnitude of 1). The vector is modified in-place.
function Vector3f_ud:normalize() end

-- Calculates the length (magnitude) of this vector: sqrt(x^2 + y^2 + z^2).
---@return number
function Vector3f_ud:length() end

-- Computes the angle between this vector and another vector.
---@param v2 Vector3f_ud -- The other vector.
---@return number -- The angle in radians.
function Vector3f_ud:angle(v2) end

-- Rotates the vector in the XY (North-East) plane, leaving the Z (Down) component untouched. The vector is modified in-place.
---@param param1 number -- The rotation angle in radians.
function Vector3f_ud:rotate_xy(param1) end

-- Returns the x and y components of this vector as a new Vector2f object.
---@return Vector2f_ud
function Vector3f_ud:xy() end

-- Represents a 3D rotation in space. Quaternions are used internally for attitude representation as they avoid issues like gimbal lock.
---@class (exact) Quaternion_ud
---@operator mul(Quaternion_ud): Quaternion_ud
local Quaternion_ud = {}

---@return Quaternion_ud
function Quaternion() end

-- Gets the q4 component of the quaternion.
---@return number
function Quaternion_ud:q4() end

-- Sets the q4 component.
---@param value number
function Quaternion_ud:q4(value) end

-- Gets the q3 component of the quaternion.
---@return number
function Quaternion_ud:q3() end

-- Sets the q3 component.
---@param value number
function Quaternion_ud:q3(value) end

-- Gets the q2 component of the quaternion.
---@return number
function Quaternion_ud:q2() end

-- Sets the q2 component.
---@param value number
function Quaternion_ud:q2(value) end

-- Gets the q1 component of the quaternion.
---@return number
function Quaternion_ud:q1() end

-- Sets the q1 component.
---@param value number
function Quaternion_ud:q1(value) end

-- Rotates the provided Vector3f from the earth frame (e.g., NED) to the vehicle's body frame using this quaternion's rotation. The vector is modified in-place.
---@param vec Vector3f_ud
function Quaternion_ud:earth_to_body(vec) end

-- Returns a new quaternion representing the opposite rotation.
---@return Quaternion_ud
function Quaternion_ud:inverse() end

-- Integrates an angular velocity over a small time delta to update this quaternion's rotation.
---@param angular_velocity Vector3f_ud -- The angular velocity in radians/second.
---@param time_delta number -- The time step in seconds.
function Quaternion_ud:from_angular_velocity(angular_velocity, time_delta) end

-- Constructs this quaternion from a rotation axis and an angle.
---@param axis Vector3f_ud -- The axis of rotation.
---@param angle number -- The angle of rotation in radians.
function Quaternion_ud:from_axis_angle(axis, angle) end

-- Converts this quaternion to an axis-angle representation. The provided vector is modified in-place.
---@param axis_angle Vector3f_ud -- A Vector3f that will be populated with the axis-angle data.
function Quaternion_ud:to_axis_angle(axis_angle) end

-- Constructs this quaternion from roll, pitch, and yaw Euler angles.
---@param roll number -- Roll angle in radians.
---@param pitch number -- Pitch angle in radians.
---@param yaw number -- Yaw angle in radians.
function Quaternion_ud:from_euler(roll, pitch, yaw) end

-- Returns the yaw component of this quaternion's rotation in radians.
---@return number
function Quaternion_ud:get_euler_yaw() end

-- Returns the pitch component of this quaternion's rotation in radians.
---@return number
function Quaternion_ud:get_euler_pitch() end

-- Returns the roll component of this quaternion's rotation in radians.
---@return number
function Quaternion_ud:get_euler_roll() end

-- Normalizes the quaternion to have a length of 1. This is important to prevent floating-point drift from accumulating and creating invalid rotations.
function Quaternion_ud:normalize() end

-- Returns the length (norm) of the quaternion. Should be 1.0 for a valid rotation quaternion.
---@return number
function Quaternion_ud:length() end

-- A userdata object that holds a geographic coordinate, including latitude, longitude, and altitude.
-- This object is fundamental for any navigation or position-aware scripting.
-- It's crucial to be aware of the altitude frame (e.g., relative to home, absolute, terrain) for safe operation.
---@class (exact) Location_ud
local Location_ud = {}

-- Creates a new, empty Location object. All fields will be uninitialized.
---@return Location_ud
function Location() end

-- Creates a new Location object that is a deep copy of this one.
-- This is important to avoid modifying the original object when you only intend to work with a temporary copy.
---@return Location_ud -- A new Location object with the same latitude, longitude, and altitude values.
function Location_ud:copy() end

-- Gets whether the location is a loiter point that requires cross-track tracking from the center.
---@return boolean -- True if the aircraft should track from the center point, false if it should track from the exit location.
function Location_ud:loiter_xtrack() end

-- Sets the loiter cross-track behavior for this location.
---@param value boolean -- Set to true to track from the center, false to track from the exit.
function Location_ud:loiter_xtrack(value) end

-- Gets whether the altitude for this location is relative to the EKF origin.
---@return boolean -- True if altitude is relative to the EKF origin.
function Location_ud:origin_alt() end

-- Sets the altitude frame to be relative to the EKF origin.
---@param value boolean -- Set to true to make the altitude relative to the EKF origin.
function Location_ud:origin_alt(value) end

-- Gets whether the altitude for this location is relative to the terrain height.
---@return boolean -- True if altitude is relative to terrain.
function Location_ud:terrain_alt() end

-- Sets the altitude frame to be relative to terrain height.
---@param value boolean -- Set to true to make the altitude relative to terrain.
function Location_ud:terrain_alt(value) end

-- Gets whether the altitude for this location is relative to the home position.
---@return boolean -- True if altitude is relative to home.
function Location_ud:relative_alt() end

-- Sets the altitude frame to be relative to the home position.
---@param value boolean -- Set to true to make the altitude relative to home.
function Location_ud:relative_alt(value) end

-- Gets the altitude component of the location.
---@return integer -- Altitude in **centimeters**. The frame (e.g., AMSL, relative to home) must be checked separately using `get_alt_frame()`.
function Location_ud:alt() end

-- Sets the altitude component of the location.
---@param value integer -- Altitude in **centimeters**.
function Location_ud:alt(value) end

-- Gets the longitude component of the location.
---@return integer -- Longitude in degrees, multiplied by 1e7.
function Location_ud:lng() end

-- Sets the longitude component of the location.
---@param value integer -- Longitude in degrees, multiplied by 1e7.
function Location_ud:lng(value) end

-- Gets the latitude component of the location.
---@return integer -- Latitude in degrees, multiplied by 1e7.
function Location_ud:lat() end

-- Sets the latitude component of the location.
---@param value integer -- Latitude in degrees, multiplied by 1e7.
function Location_ud:lat(value) end

-- Gets the altitude frame of this location. It is critical to check this to understand what the `alt()` value represents.
---@return integer -- The altitude frame enum value.
---| '0' # ABSOLUTE (Above Mean Sea Level)
---| '1' # ABOVE_HOME
---| '2' # ABOVE_ORIGIN (EKF Origin)
---| '3' # ABOVE_TERRAIN
function Location_ud:get_alt_frame() end

-- Changes the altitude frame of this location, automatically converting the altitude value.
---@param desired_frame integer  -- The target altitude frame enum value.
---| '0' # ABSOLUTE
---| '1' # ABOVE_HOME
---| '2' # ABOVE_ORIGIN
---| '3' # ABOVE_TERRAIN
---@return boolean -- True on success.
function Location_ud:change_alt_frame(desired_frame) end

-- Calculates the North and East distance from this location to another.
---@param loc Location_ud -- The other location to compare against.
---@return Vector2f_ud -- A Vector2f object where x=North, y=East, in meters.
function Location_ud:get_distance_NE(loc) end

-- Calculates the North, East, and Down distance from this location to another. A very common function for relative position calculations.
-- Example from `copter_pingpong.lua`: `local vec_from_home = home:get_distance_NED(curr_loc)`
---@param loc Location_ud -- The other location to compare against.
---@return Vector3f_ud -- A Vector3f object where x=North, y=East, z=Down, in meters.
function Location_ud:get_distance_NED(loc) end

-- Calculates the relative bearing from this location to another.
---@param loc Location_ud -- The target location.
---@return number -- The bearing in **radians**.
function Location_ud:get_bearing(loc) end

-- Returns the offset from the EKF origin to this location in the North-East-Up (NEU) frame.
-- Returns nil if the EKF origin is not available.
---@return Vector3f_ud|nil -- A Vector3f where x=North, y=East, z=Up, in **centimeters**.
function Location_ud:get_vector_from_origin_NEU_cm() end

-- Returns the offset from the EKF origin to this location in the North-East-Up (NEU) frame.
-- Returns nil if the EKF origin is not available.
---@return Vector3f_ud|nil -- A Vector3f where x=North, y=East, z=Up, in **meters**.
function Location_ud:get_vector_from_origin_NEU_m() end

--- Deprecated method returning offset from EKF origin. Use `get_vector_from_origin_NEU_cm` or `get_vector_from_origin_NEU_m` instead.
---@return Vector3f_ud|nil -- Vector between origin and location north east up in centimetres.
---@deprecated
function Location_ud:get_vector_from_origin_NEU() end

-- Modifies this location in-place by moving it a specified distance along a given bearing.
---@param bearing_deg number -- The bearing in degrees (0-360).
---@param distance number -- The distance to move in meters.
function Location_ud:offset_bearing(bearing_deg, distance) end

-- Modifies this location in-place by moving it a specified distance along a given bearing and pitch angle.
---@param bearing_deg number -- The bearing in degrees (0-360).
---@param pitch_deg number -- The pitch angle in degrees.
---@param distance number -- The distance to move in meters.
function Location_ud:offset_bearing_and_pitch(bearing_deg, pitch_deg, distance) end

-- Modifies this location in-place by moving it by the specified North and East distances.
---@param ofs_north number -- The North offset in meters.
---@param ofs_east number -- The East offset in meters.
function Location_ud:offset(ofs_north, ofs_east) end

-- Calculates the horizontal (2D) distance between this location and another.
---@param loc Location_ud -- The other location to compare against.
---@return number -- The horizontal distance in meters.
function Location_ud:get_distance(loc) end

-- Represents a scripting backend for an EFI (Electronic Fuel Injection) system.
-- This is an advanced object used by custom EFI driver scripts (like `EFI_HFE.lua`) to feed EFI data into the main ArduPilot system.
---@class (exact) AP_EFI_Backend_ud
local AP_EFI_Backend_ud = {}

-- Pushes a populated EFI_State object into the ArduPilot EFI system.
-- This function is called by a custom EFI driver script after it has received and decoded data from the physical EFI unit.
---@param state EFI_State_ud -- The EFI_State object containing the latest telemetry data to be processed by ArduPilot.
---@return boolean -- True on success.
function AP_EFI_Backend_ud:handle_scripting(state) end

-- Represents a buffered interface to a raw CAN bus, used for sending and receiving CAN frames.
---@class (exact) ScriptingCANBuffer_ud
local ScriptingCANBuffer_ud = {}

-- Reads a single CAN frame from the buffer if one is available.
---@return CANFrame_ud|nil -- A CANFrame object, or nil if the buffer is empty.
function ScriptingCANBuffer_ud:read_frame() end

-- Adds a filter to the CAN buffer to only receive specific CAN frames.
-- The mask is bitwise ANDed with an incoming frame's ID, and the result is compared to the value. If they match, the frame is buffered.
-- By default, no filters are added, and all frames are buffered. Writing is not affected by filters.
---@param mask uint32_t_ud|integer|number -- The bitmask to apply to incoming frame IDs.
---@param value uint32_t_ud|integer|number -- The value to compare against after masking.
---@return boolean -- Returns true if the filter was added successfully (max 8 filters).
function ScriptingCANBuffer_ud:add_filter(mask, value) end

-- Writes a CAN frame to the bus.
---@param frame CANFrame_ud -- The CANFrame object to be sent.
---@param timeout_us uint32_t_ud|integer|number -- The time to wait in microseconds if the send buffer is full.
---@return boolean -- True if the frame was sent successfully.
function ScriptingCANBuffer_ud:write_frame(frame, timeout_us) end


-- Represents a single analog input pin, used for reading voltages.
---@class (exact) AP_HAL__AnalogSource_ud
local AP_HAL__AnalogSource_ud = {}

-- Returns the ratiometric voltage average, scaled against the board's VCC.
---@return number -- The ratiometric voltage.
function AP_HAL__AnalogSource_ud:voltage_average_ratiometric() end

-- Returns the most recent single raw voltage reading from the pin.
---@return number -- The latest voltage reading.
function AP_HAL__AnalogSource_ud:voltage_latest() end

-- Returns a low-pass filtered average of the voltage readings from the pin.
---@return number -- The averaged voltage.
function AP_HAL__AnalogSource_ud:voltage_average() end

-- Sets the physical pin to be used for this analog input source.
---@param pin_number integer -- The pin number (e.g., 15 for a Pixhawk's ADC 3.3V pin).
---@return boolean -- True on success.
function AP_HAL__AnalogSource_ud:set_pin(pin_number) end


-- Represents a specific device on the I2C bus.
-- This object is obtained from `i2c:get_device()` and is used for all subsequent communication with that device.
---@class (exact) AP_HAL__I2CDevice_ud
local AP_HAL__I2CDevice_ud = {}

-- Sets the address for this I2C device handle.
---@param address integer -- The new 7-bit I2C device address.
function AP_HAL__I2CDevice_ud:set_address(address) end

-- Performs a combined write/read I2C transaction.
-- This is a flexible, low-level function for complex interactions that are not simple register reads/writes.
---@param data_str string -- A binary string of bytes to write to the device.
---@param read_length integer -- The number of bytes to read back from the device after the write.
---@return string|nil -- A binary string of the bytes read, or nil on error.
function AP_HAL__I2CDevice_ud:transfer(data_str, read_length) end

-- Reads one or more registers from the I2C device.
---@param register_num integer -- The starting register address to read from.
---@param read_length? integer -- Optional. The number of registers to read. If not provided, a single register is read.
---@return integer|table|nil -- If `read_length` is omitted, returns a single integer value. If `read_length` is provided, returns a table of integer values. Returns nil on error.
function AP_HAL__I2CDevice_ud:read_registers(register_num, read_length) end

-- Writes a single byte to a specific register on the I2C device.
---@param register_num integer -- The register address to write to.
---@param value integer -- The single byte value (0-255) to write.
---@return boolean -- True on success.
function AP_HAL__I2CDevice_ud:write_register(register_num, value) end

-- Sets the number of times to retry a transaction on a bus error.
---@param retries integer -- The number of retries.
function AP_HAL__I2CDevice_ud:set_retries(retries) end


-- Provides an interface for reading from and writing to a serial port (UART).
-- This can be used to communicate with external sensors or devices like GPS, Lidar, or companion computers.
---@class (exact) AP_Scripting_SerialAccess_ud
local AP_Scripting_SerialAccess_ud = {}

-- Initializes the serial port with a given baud rate. This must be called before any other operations.
---@param baud_rate uint32_t_ud|integer|number -- The desired baud rate (e.g., 57600, 115200).
function AP_Scripting_SerialAccess_ud:begin(baud_rate) end

-- Configures the parity for the serial port.
---@param parity integer -- 0 for None, 1 for Odd, 2 for Even.
function AP_Scripting_SerialAccess_ud:configure_parity(parity) end

-- Configures the number of stop bits for the serial port.
---@param stop_bits integer -- 1 or 2.
function AP_Scripting_SerialAccess_ud:set_stop_bits(stop_bits) end

-- Writes a single byte to the serial port.
---@param value integer -- The byte to write (0-255).
---@return uint32_t_ud -- 1 if the byte was successfully written to the buffer, 0 otherwise.
function AP_Scripting_SerialAccess_ud:write(value) end

-- Writes a string of bytes to the serial port.
---@param data string -- The string of bytes to write.
---@return integer -- The number of bytes actually written, which may be less than the string length if the buffer is full.
function AP_Scripting_SerialAccess_ud:writestring(data) end

-- Reads a single byte from the serial port's receive buffer.
---@return integer -- The byte read (0-255), or -1 if no byte is available.
function AP_Scripting_SerialAccess_ud:read() end

-- Reads multiple bytes from the serial port's receive buffer.
---@param count integer -- The maximum number of bytes to read.
---@return string|nil -- A string containing the bytes actually read (which may be 0-length), or nil on error.
function AP_Scripting_SerialAccess_ud:readstring(count) end

-- Returns the number of bytes available to be read from the serial port's receive buffer.
---@return uint32_t_ud
function AP_Scripting_SerialAccess_ud:available() end

-- Configures hardware flow control (RTS/CTS) for the serial port.
---@param flow_control_setting integer
---| '0' # Disabled
---| '1' # Enabled
---| '2' # Auto
function AP_Scripting_SerialAccess_ud:set_flow_control(flow_control_setting) end


-- Represents a single RC input channel.
---@class (exact) RC_Channel_ud
local RC_Channel_ud = {}

-- Returns the normalized input (-1 to 1) of the channel, ignoring the trim value.
---@return number
function RC_Channel_ud:norm_input_ignore_trim() end

-- Overrides the channel's output with a specific PWM value. This is used for scripting-based control.
---@param PWM integer -- The PWM value to send (typically 1000-2000).
function RC_Channel_ud:set_override(PWM) end

-- For channels configured as switches, this returns the switch position.
---@return integer -- 0 for low, 1 for middle, 2 for high position.
function RC_Channel_ud:get_aux_switch_pos() end

-- Returns the normalized input (-1 to 1) of the channel, centered on the trim value and ignoring the deadzone.
---@return number
function RC_Channel_ud:norm_input() end

-- Returns the normalized input (-1 to 1) of the channel, centered on the trim value. Returns zero when the stick is within the deadzone.
---@return number
function RC_Channel_ud:norm_input_dz() end

-- Interface for controlling a winch peripheral.
winch = {}

-- Gets the maximum configured rate for the winch.
---@return number -- The maximum rate.
function winch:get_rate_max() end

-- Sets the desired rate of the winch.
---@param param1 number -- The desired rate.
function winch:set_desired_rate(param1) end

-- Commands the winch to release a specific length of line.
---@param param1 number -- The length to release in meters.
function winch:release_length(param1) end

-- Commands the winch to relax, releasing tension.
function winch:relax() end

-- Returns true if the winch is healthy and responding.
---@return boolean
function winch:healthy() end

-- Interface for interacting with the I/O MCU (if present).
iomcu = {}

-- Checks if the I/O MCU is healthy and communicating with the main flight controller.
---@return boolean
function iomcu:healthy() end

-- Interface for accessing compass (magnetometer) data.
compass = {}

-- Checks if a specific compass instance is healthy.
---@param instance integer -- The 0-based index of the compass instance to check (e.g., 0 for the first compass).
---@return boolean -- True if the compass is healthy.
function compass:healthy(instance) end

-- The main interface for interacting with a camera connected to the autopilot.
-- This object allows for triggering the shutter, starting/stopping video recording, and querying the camera's state.
-- It operates on the MAVLink camera protocol, so the connected camera must support it.
camera = {}

-- Sets the distance the vehicle must travel before the camera is triggered again. Used for distance-based survey missions.
---@param instance integer -- The 0-indexed camera instance.
---@param distance_m number -- The distance in meters.
function camera:set_trigger_distance(instance, distance_m) end

-- Starts or stops video recording.
---@param instance integer -- The 0-indexed camera instance.
---@param start_recording boolean -- True to start recording, false to stop.
---@return boolean -- True on success.
function camera:record_video(instance, start_recording) end

-- Commands the camera to take a single picture.
---@param instance integer -- The 0-indexed camera instance.
function camera:take_picture(instance) end

-- A data structure holding a snapshot of the camera's current state.
---@class (exact) AP_Camera__camera_state_t_ud
local AP_Camera__camera_state_t_ud = {}

-- get field: The top-left point of the tracking rectangle.
---@return Vector2f_ud
function AP_Camera__camera_state_t_ud:tracking_p1() end

-- get field: The bottom-right point of the tracking rectangle.
---@return Vector2f_ud
function AP_Camera__camera_state_t_ud:tracking_p2() end

-- get field: The type of tracking mode (e.g., pointing, tracking rectangle).
---@return integer
function AP_Camera__camera_state_t_ud:tracking_type() end

-- get field: The current focus value.
---@return number
function AP_Camera__camera_state_t_ud:focus_value() end

-- get field: The type of focus (e.g., auto, manual, percentage).
---@return integer
function AP_Camera__camera_state_t_ud:focus_type() end

-- get field: The current zoom value.
---@return number
function AP_Camera__camera_state_t_ud:zoom_value() end

-- get field: The type of zoom (e.g., optical, digital, percentage).
---@return integer
function AP_Camera__camera_state_t_ud:zoom_type() end

-- get field: True if the camera is currently recording video.
---@return boolean
function AP_Camera__camera_state_t_ud:recording_video() end

-- get field: A counter that increments each time a picture is taken.
---@return integer
function AP_Camera__camera_state_t_ud:take_pic_incr() end

-- Gets a snapshot of the camera's current state.
---@param instance integer -- The 0-indexed camera instance.
---@return AP_Camera__camera_state_t_ud|nil -- A camera state object, or nil if the camera is not available.
function camera:get_state(instance) end

-- Changes a specific camera setting. This is typically used for thermal cameras or other advanced payloads.
---@param instance integer -- The 0-indexed camera instance.
---@param setting integer -- The setting to change, based on the `AP_Camera::Camera_Setting` enum.
---| '0' # THERMAL_PALETTE
---| '1' # THERMAL_GAIN
---| '2' # THERMAL_RAW_DATA
---@param value number -- The new value for the setting.
---@return boolean -- True on success.
function camera:change_setting(instance, setting, value) end

-- A data structure representing the MAVLink CAMERA_INFORMATION message.
-- Used by custom camera driver scripts to define a camera's capabilities to the GCS.
---@class (exact) mavlink_camera_information_t_ud
local mavlink_camera_information_t_ud = {}

---@return mavlink_camera_information_t_ud
function mavlink_camera_information_t() end

-- get field
---@return uint32_t_ud
function mavlink_camera_information_t_ud:time_boot_ms() end

-- set field
---@param value uint32_t_ud|integer|number
function mavlink_camera_information_t_ud:time_boot_ms(value) end

-- get field
---@return uint32_t_ud
function mavlink_camera_information_t_ud:firmware_version() end

-- set field
---@param value uint32_t_ud|integer|number
function mavlink_camera_information_t_ud:firmware_version(value) end

-- get field
---@return number
function mavlink_camera_information_t_ud:focal_length() end

-- set field
---@param value number
function mavlink_camera_information_t_ud:focal_length(value) end

-- get field
---@return number
function mavlink_camera_information_t_ud:sensor_size_h() end

-- set field
---@param value number
function mavlink_camera_information_t_ud:sensor_size_h(value) end

-- get field
---@return number
function mavlink_camera_information_t_ud:sensor_size_v() end

-- set field
---@param value number
function mavlink_camera_information_t_ud:sensor_size_v(value) end

-- get field
---@return uint32_t_ud
function mavlink_camera_information_t_ud:flags() end

-- set field
---@param value uint32_t_ud|integer|number
function mavlink_camera_information_t_ud:flags(value) end

-- get field
---@return integer
function mavlink_camera_information_t_ud:resolution_h() end

-- set field
---@param value integer
function mavlink_camera_information_t_ud:resolution_h(value) end

-- get field
---@return integer
function mavlink_camera_information_t_ud:resolution_v() end

-- set field
---@param value integer
function mavlink_camera_information_t_ud:resolution_v(value) end

-- get field
---@return integer
function mavlink_camera_information_t_ud:cam_definition_version() end

-- set field
---@param value integer
function mavlink_camera_information_t_ud:cam_definition_version(value) end

-- get array field: Vendor name as a C-style string (array of ASCII bytes).
---@param index integer
---@return integer
function mavlink_camera_information_t_ud:vendor_name(index) end

-- set array field
---@param index integer
---@param value integer
function mavlink_camera_information_t_ud:vendor_name(index, value) end

-- get array field: Model name as a C-style string (array of ASCII bytes).
---@param index integer
---@return integer
function mavlink_camera_information_t_ud:model_name(index) end

-- set array field
---@param index integer
---@param value integer
function mavlink_camera_information_t_ud:model_name(index, value) end

-- get field
---@return integer
function mavlink_camera_information_t_ud:lens_id() end

-- set field
---@param value integer
function mavlink_camera_information_t_ud:lens_id(value) end

-- get array field: URI of the camera definition file.
---@param index integer
---@return integer
function mavlink_camera_information_t_ud:cam_definition_uri(index) end

-- set array field
---@param index integer
---@param value integer
function mavlink_camera_information_t_ud:cam_definition_uri(index, value) end

-- get field
---@return integer
function mavlink_camera_information_t_ud:gimbal_device_id() end

-- set field
---@param value integer
function mavlink_camera_information_t_ud:gimbal_device_id(value) end

-- Populates and sends the CAMERA_INFORMATION message for a custom camera driver.
---@param instance integer -- The 0-indexed camera instance.
---@param cam_info mavlink_camera_information_t_ud -- The populated camera information object.
function camera:set_camera_information(instance, cam_info) end

-- A data structure representing the MAVLink VIDEO_STREAM_INFORMATION message.
-- Used by custom camera driver scripts to define a video stream's properties.
---@class (exact) mavlink_video_stream_information_t_ud
local mavlink_video_stream_information_t_ud = {}

---@return mavlink_video_stream_information_t_ud
function mavlink_video_stream_information_t() end

-- get field
---@return number
function mavlink_video_stream_information_t_ud:framerate() end

-- set field
---@param value number
function mavlink_video_stream_information_t_ud:framerate(value) end

-- get field
---@return uint32_t_ud
function mavlink_video_stream_information_t_ud:bitrate() end

-- set field
---@param value uint32_t_ud|integer|number
function mavlink_video_stream_information_t_ud:bitrate(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:flags() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:flags(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:resolution_h() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:resolution_h(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:resolution_v() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:resolution_v(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:rotation() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:rotation(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:hfov() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:hfov(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:stream_id() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:stream_id(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:count() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:count(value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:type() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:type(value) end

-- get array field
---@param index integer
---@return integer
function mavlink_video_stream_information_t_ud:name(index) end

-- set array field
---@param index integer
---@param value integer
function mavlink_video_stream_information_t_ud:name(index, value) end

-- get array field
---@param index integer
---@return integer
function mavlink_video_stream_information_t_ud:uri(index) end

-- set array field
---@param index integer
---@param value integer
function mavlink_video_stream_information_t_ud:uri(index, value) end

-- get field
---@return integer
function mavlink_video_stream_information_t_ud:encoding() end

-- set field
---@param value integer
function mavlink_video_stream_information_t_ud:encoding(value) end

-- Populates and sends the VIDEO_STREAM_INFORMATION message for a custom camera driver.
---@param instance integer -- The 0-indexed camera instance.
---@param stream_info mavlink_video_stream_information_t_ud -- The populated stream information object.
function camera:set_stream_information(instance, stream_info) end

-- Main interface for controlling a camera gimbal/mount.
mount = {}

-- Sets the attitude of the mount using Euler angles. This is a deprecated function.
-- Prefer `set_angle_target` for more explicit control over the yaw frame.
---@param instance integer -- The 0-indexed mount instance.
---@param roll_deg number -- Roll angle in degrees.
---@param pitch_deg number -- Pitch angle in degrees.
---@param yaw_deg number -- Yaw angle in degrees, relative to the vehicle's body frame (nose is 0).
function mount:set_attitude_euler(instance, roll_deg, pitch_deg, yaw_deg) end

-- Gets the geographic location the mount is currently pointing at (if in ROI mode).
---@param instance integer -- The 0-indexed mount instance.
---@return Location_ud|nil -- A Location object, or nil if not in ROI mode.
function mount:get_location_target(instance) end

-- Gets the current angle target of the mount.
---@param instance integer -- The 0-indexed mount instance.
---@return number|nil roll_deg -- Target roll angle in degrees.
---@return number|nil pitch_deg -- Target pitch angle in degrees.
---@return number|nil yaw_deg -- Target yaw angle in degrees.
---@return boolean|nil yaw_is_earth_frame -- True if yaw is a compass heading, false if it's relative to the vehicle.
function mount:get_angle_target(instance) end

-- Gets the current angular rate target of the mount.
---@param instance integer -- The 0-indexed mount instance.
---@return number|nil roll_degs -- Target roll rate in degrees/second.
---@return number|nil pitch_degs -- Target pitch rate in degrees/second.
---@return number|nil yaw_degs -- Target yaw rate in degrees/second.
---@return boolean|nil yaw_is_earth_frame -- True if yaw rate is in the earth frame, false if in the body frame.
function mount:get_rate_target(instance) end

-- Commands the mount to point at and track a specific geographic location (Region of Interest).
---@param instance integer -- The 0-indexed mount instance.
---@param target_loc Location_ud -- A Location object representing the ROI.
function mount:set_roi_target(instance, target_loc) end

-- Commands the mount to move at a specific angular rate.
---@param instance integer -- The 0-indexed mount instance.
---@param roll_degs number -- Target roll rate in degrees/second.
---@param pitch_degs number -- Target pitch rate in degrees/second.
---@param yaw_degs number -- Target yaw rate in degrees/second.
---@param yaw_is_earth_frame boolean -- If true, yaw_degs is a rate of change of a compass heading. If false, it's relative to the vehicle's frame.
function mount:set_rate_target(instance, roll_degs, pitch_degs, yaw_degs, yaw_is_earth_frame) end

-- Commands the mount to move to a specific angle.
---@param instance integer -- The 0-indexed mount instance.
---@param roll_deg number -- Target roll angle in degrees.
---@param pitch_deg number -- Target pitch angle in degrees.
---@param yaw_deg number -- Target yaw angle in degrees.
---@param yaw_is_earth_frame boolean -- If true, yaw_deg is a compass heading (earth frame). If false, it is relative to the vehicle's nose (body frame).
function mount:set_angle_target(instance, roll_deg, pitch_deg, yaw_deg, yaw_is_earth_frame) end

-- Sets the operational mode of the mount.
---@param instance integer -- The 0-indexed mount instance.
---@param mode integer -- The MAV_MOUNT_MODE enum value (e.g., 0:Retract, 1:Neutral, 2:MAVLink Targeting, 3:RC Targeting, 4:GPS Point).
function mount:set_mode(instance, mode) end

-- Gets the current operational mode of the mount.
---@param instance integer -- The 0-indexed mount instance.
---@return integer -- The current MAV_MOUNT_MODE enum value.
function mount:get_mode(instance) end

-- Gets the current attitude of the mount as Euler angles.
---@param instance integer -- The 0-indexed mount instance.
---@return number|nil roll_deg -- Current roll angle in degrees.
---@return number|nil pitch_deg -- Current pitch angle in degrees.
---@return number|nil yaw_bf_deg -- Current yaw angle in degrees, relative to the vehicle's body frame.
function mount:get_attitude_euler(instance) end

-- The main interface for controlling the vehicle's motors.
-- This provides access to the final mixed outputs for throttle, attitude control, and more.
-- It is vehicle-specific and applies to Copter and QuadPlane VTOL motors, not fixed-wing forward motors.
motors = {}

-- Gets the motor interlock state. The interlock is a safety feature that prevents motors from spinning.
-- It is different from the arming state; motors can be armed but not interlocked (e.g., on the ground before throttle is raised).
---@return boolean
---| true  # Motors are active and can spin.
---| false # Motors are inactive and cannot spin.
function motors:get_interlock() end

-- Gets the final commanded lateral (right/left) motor output.
---@return number -- The normalized output, typically -1 to 1.
function motors:get_lateral() end

-- Sets external limits on the attitude controllers.
-- This is an advanced function used to prevent integrator windup when an external system (like a script) is controlling the vehicle's attitude.
---@param roll boolean -- True to limit the roll controller.
---@param pitch boolean -- True to limit the pitch controller.
---@param yaw boolean -- True to limit the yaw controller.
---@param throttle_lower boolean -- True to limit the throttle from going lower.
---@param throttle_upper boolean -- True to limit the throttle from going higher.
function motors:set_external_limits(roll, pitch, yaw, throttle_lower, throttle_upper) end

-- Gets the final commanded forward motor output.
---@return number -- The normalized output, typically -1 to 1.
function motors:get_forward() end

-- Gets the final commanded collective throttle output.
---@return number -- The normalized output, typically 0 to 1.
function motors:get_throttle() end

-- Gets the current spool state of the motors. This is particularly relevant for helicopters and vehicles with complex startup procedures.
---@return integer -- The spool state enum value.
---| '0' # Shut down
---| '1' # Ground idle
---| '2' # Spooling up
---| '3' # Throttle unlimited
---| '4' # Spooling down
function motors:get_spool_state() end

-- Sets the frame string displayed in some GCS interfaces. Useful for custom motor mixers.
---@param param1 string -- The string to display (e.g., "Dynamic example").
function motors:set_frame_string(param1) end

-- Gets the desired spool state requested by the flight controller.
---@return integer -- The desired spool state enum value.
function motors:get_desired_spool_state() end

-- Gets the feedforward component of the yaw controller output.
---@return number
function motors:get_yaw_ff() end

-- Gets the combined P, I, and D components of the yaw controller output.
---@return number
function motors:get_yaw() end

-- Gets the feedforward component of the pitch controller output.
---@return number
function motors:get_pitch_ff() end

-- Gets the combined P, I, and D components of the pitch controller output.
---@return number
function motors:get_pitch() end

-- Gets the feedforward component of the roll controller output.
---@return number
function motors:get_roll_ff() end

-- Gets the combined P, I, and D components of the roll controller output.
---@return number
function motors:get_roll() end

-- Provides information about the currently running ArduPilot firmware version.
FWVersion = {}

-- Gets the git hash of the firmware build.
---@return string
function FWVersion:hash() end

-- Gets the patch version number of the firmware (e.g., the '2' in 4.3.2).
---@return integer
function FWVersion:patch() end

-- Gets the minor version number of the firmware (e.g., the '3' in 4.3.2).
---@return integer
function FWVersion:minor() end

-- Gets the major version number of the firmware (e.g., the '4' in 4.3.2).
---@return integer
function FWVersion:major() end

-- Gets the vehicle type for which the firmware was built. This is critical for scripts that are vehicle-specific.
---@return integer -- The vehicle type enum value.
---| '1' # Rover
---| '2' # ArduCopter
---| '3' # ArduPlane
---| '4' # AntennaTracker
---| '7' # ArduSub
---| '9' # AP_Periph
---| '12' # Blimp
---| '13' # Heli
function FWVersion:type() end

-- Gets the full firmware version string (e.g., "ArduCopter V4.3.2").
---@return string
function FWVersion:string() end


-- Interface for AP_Periph CAN peripheral devices. Allows a peripheral to get information about the main vehicle.
periph = {}

-- Gets the vehicle's state bitmask from the peripheral's point of view.
---@return uint32_t_ud
function periph:get_vehicle_state() end

-- Gets the vehicle's yaw in the earth frame (compass heading).
---@return number
function periph:get_yaw_earth() end

-- Prints a debug message over the CAN bus.
---@param text string
function periph:can_printf(text) end

-- Reboots the peripheral device.
---@param hold_in_bootloader boolean -- If true, the device will reboot into the bootloader for firmware updates.
function periph:reboot(hold_in_bootloader) end

-- Interface for the Inertial Navigation System (INS), providing access to raw sensor data.
ins = {}

-- Gets the temperature of a specific IMU instance.
---@param instance integer -- The 0-indexed IMU instance.
---@return number -- Temperature in degrees Celsius.
function ins:get_temperature(instance) end

-- Checks if the gyroscopes are consistent with each other.
---@param threshold integer -- The allowed threshold in degrees per second.
---@return boolean -- True if the gyros are consistent.
function ins:gyros_consistent(threshold) end

-- Checks if a specific gyroscope sensor is healthy.
---@param instance integer -- The 0-indexed gyroscope instance.
---@return boolean
function ins:get_gyro_health(instance) end

-- Checks if the accelerometers are consistent with each other.
---@param threshold number -- The threshold allowed before returning false.
---@return boolean -- True if the accelerometers are consistent.
function ins:accels_consistent(threshold) end

-- Checks if a specific accelerometer sensor is healthy.
---@param instance integer -- The 0-indexed accelerometer instance.
---@return boolean
function ins:get_accel_health(instance) end

-- Returns true if the INS is currently undergoing calibration.
---@return boolean
function ins:calibrating() end

-- Gets the raw rotational rates from a specific gyroscope.
---@param instance integer -- The 0-indexed gyroscope instance.
---@return Vector3f_ud -- A Vector3f of angular velocities in radians/second.
function ins:get_gyro(instance) end

-- Gets the raw acceleration values from a specific accelerometer.
---@param instance integer -- The 0-indexed accelerometer instance.
---@return Vector3f_ud -- A Vector3f of accelerations in meters/second^2.
function ins:get_accel(instance) end

-- Interface for the dynamic, scriptable motor mixer. Allows for real-time changes to the motor mixing logic.
Motors_dynamic = {}

-- Loads a new set of motor factors into the dynamic mixer.
---@param factor_table motor_factor_table_ud -- A table of motor factors to apply.
function Motors_dynamic:load_factors(factor_table) end

-- Adds a motor to the dynamic mixer configuration.
---@param motor_num integer -- The motor number (0-indexed).
---@param testing_order integer -- The order in which this motor should be tested in the motor test sequence.
function Motors_dynamic:add_motor(motor_num, testing_order) end

-- Initializes the dynamic motor mixer with the specified number of motors. Must be called after adding all motors.
---@param expected_num_motors integer -- The total number of motors in the configuration.
---@return boolean -- True on success.
function Motors_dynamic:init(expected_num_motors) end


-- Interface for the flight controller's analog input pins.
analog = {}

-- Returns the temperature of the main flight controller MCU.
---@return number -- MCU temperature in degrees Celsius.
function analog:mcu_temperature() end

-- Returns the current voltage being supplied to the MCU.
---@return number -- MCU voltage.
function analog:mcu_voltage() end

-- Gets a handle to an analog input channel.
---@return AP_HAL__AnalogSource_ud|nil -- An analog source object, or nil if none are available.
function analog:channel() end


-- Interface for controlling General Purpose Input/Output (GPIO) pins.
gpio = {}

-- Sets the mode of a specific GPIO pin.
---@param pin_number integer -- The GPIO pin number.
---@param mode integer
---| '0' # Input
---| '1' # Output
function gpio:pinMode(pin_number, mode) end

-- Toggles the state of a GPIO pin configured as an output.
---@param pin_number integer
function gpio:toggle(pin_number) end

-- Writes a value to a GPIO pin configured as an output.
---@param pin_number integer
---@param value integer
---| '0' # Low
---| '1' # High
function gpio:write(pin_number, value) end

-- Reads the state of a GPIO pin configured as an input.
---@param pin_number integer
---@return boolean -- The pin's state (true for high, false for low).
function gpio:read(pin_number) end

-- Sets the full pin mode, including options like pull-up/pull-down resistors. (Advanced)
---@param pin_number integer
---@param mode uint32_t_ud|integer|number -- The full mode value (platform-specific).
function gpio:set_mode(pin_number, mode) end

-- Gets the full pin mode. (Advanced)
---@param pin_number integer
---@return uint32_t_ud|nil -- The full pin mode value.
function gpio:get_mode(pin_number) end

-- Deprecated alias for set_mode.
---@param pin_number integer
---@param mode uint32_t_ud|integer|number
function gpio:setPinFullMode(pin_number, mode) end

-- Deprecated alias for get_mode.
---@param pin_number integer
---@return uint32_t_ud|nil
function gpio:getPinFullMode(pin_number) end


-- Interface for the 6-Degrees-of-Freedom (6DoF) motor mixer.
-- Used for advanced vehicle types like omnidirectional copters.
Motors_6DoF = {}

-- Adds a motor to the 6DoF mixer, defining its contribution to each axis of control.
---@param motor_num integer
---@param roll_factor number
---@param pitch_factor number
---@param yaw_factor number
---@param throttle_factor number
---@param forward_factor number
---@param right_factor number
---@param reversible boolean
---@param testing_order integer
function Motors_6DoF:add_motor(motor_num, roll_factor, pitch_factor, yaw_factor, throttle_factor, forward_factor, right_factor, reversible, testing_order) end

-- Initializes the 6DoF motor mixer.
---@param expected_num_motors integer -- The total number of motors.
---@return boolean -- True on success.
function Motors_6DoF:init(expected_num_motors) end


-- Interface for direct interaction with the attitude controller.
attitude_control = {}

-- Sets a persistent roll and pitch offset to the attitude controller.
-- Useful for compensating for a known center of gravity offset.
---@param roll_deg number -- Roll offset in degrees.
---@param pitch_deg number -- Pitch offset in degrees.
function attitude_control:set_offset_roll_pitch(roll_deg, pitch_deg) end

-- Enables or disables the forward/backward (pitch) component of the 6DoF controller.
---@param bool boolean
function attitude_control:set_forward_enable(bool) end

-- Enables or disables the lateral (roll) component of the 6DoF controller.
---@param bool boolean
function attitude_control:set_lateral_enable(bool) end


-- Interface for sending FrSky S.Port telemetry data.
frsky_sport = {}

-- Prepares a number for transmission over S.Port by packing it into the required format.
---@param number integer
---@param digits integer
---@param power integer
---@return integer
function frsky_sport:prep_number(number, digits, power) end

-- Pushes a telemetry packet onto the S.Port bus.
---@param sensor integer -- The sensor ID to send from.
---@param frame integer -- The data frame type.
---@param appid integer -- The application ID (data ID).
---@param data integer -- The 32-bit data value to send.
---@return boolean -- True on success.
function frsky_sport:sport_telemetry_push(sensor, frame, appid, data) end


-- Interface for the static, scriptable motor mixer.
-- This allows a script to define a custom, fixed motor layout at startup.
MotorsMatrix = {}

-- Sets the throttle factor for a specific motor in the matrix.
---@param motor_num integer -- The motor number (0-indexed).
---@param throttle_factor number -- The new throttle factor.
---@return boolean -- True on success.
function MotorsMatrix:set_throttle_factor(motor_num, throttle_factor) end

-- Adds a motor to the static mixer, defining its roll, pitch, and yaw factors.
---@param motor_num integer -- The motor number (0-indexed).
---@param roll_factor number
---@param pitch_factor number
---@param yaw_factor number
---@param testing_order integer -- The order for the motor test sequence.
function MotorsMatrix:add_motor_raw(motor_num, roll_factor, pitch_factor, yaw_factor, testing_order) end

-- Initializes the static motor mixer with the specified number of motors. Must be called after adding all motors.
---@param expected_num_motors integer -- The total number of motors.
---@return boolean -- True on success.
function MotorsMatrix:init(expected_num_motors) end

-- Gets the index (0-based) of a motor that has been identified as failed by the flight controller.
---@return integer -- -1 if no motor has failed.
function MotorsMatrix:get_lost_motor() end

-- Returns true if the flight controller has boosted thrust to compensate for a potential motor failure.
---@return boolean
function MotorsMatrix:get_thrust_boost() end

-- Interface for ArduSub specific functionality.
sub = {}

-- Returns true if a specific joystick button is currently pressed.
---@param index integer -- The 1-indexed button number.
---@return boolean
function sub:is_button_pressed(index) end

-- Gets the number of times a joystick button has been pressed since the last call, then clears the count.
---@param index integer -- The 1-indexed button number.
---@return integer -- The number of presses.
function sub:get_and_clear_button_count(index) end

-- Returns true if the downward-facing rangefinder is healthy and providing a good quality signal.
-- This is a key safety check for altitude-holding modes like Depth Hold.
---@return boolean
function sub:rangefinder_alt_ok() end

-- In SURFTRAK mode, this returns the current target altitude above the seafloor.
---@return number -- Target altitude in centimeters.
function sub:get_rangefinder_target_cm() end

-- In SURFTRAK mode, this sets a new target altitude above the seafloor.
---@param new_target_cm number -- The new target altitude in centimeters.
---@return boolean -- True on success.
function sub:set_rangefinder_target_cm(new_target_cm) end


-- Interface for QuadPlane specific states and actions.
quadplane = {}

-- Returns true if the vehicle is in an assisted flight mode where the quad motors are active to provide stability or lift.
---@return boolean
function quadplane:in_assisted_flight() end

-- Returns true if the vehicle is currently in a VTOL mode (e.g., QLOITER, QHOVER, QLAND).
---@return boolean
function quadplane:in_vtol_mode() end

-- Returns true if the vehicle is in the final descent phase of a VTOL landing.
---@return boolean
function quadplane:in_vtol_land_descent() end

-- Commands the vehicle to abort a VTOL landing and climb back up.
---@return boolean -- True if the abort was successfully initiated.
function quadplane:abort_landing() end


-- Interface to control the primary RGB notify LED.
LED = {}

-- Gets the current color of the notify LED.
---@return integer -- Red component (0-255).
---@return integer -- Green component (0-255).
---@return integer -- Blue component (0-255).
function LED:get_rgb() end


-- Interface for reading the state of physical buttons connected to the flight controller's GPIO pins.
button = {}

-- Returns the state of a specific button.
---@param button_number integer -- The 1-indexed button number.
---@return boolean -- True if the button is currently pressed.
function button:get_button_state(button_number) end


-- Interface for reading data from RPM sensors.
RPM = {}

-- Returns the RPM of a specific sensor instance.
---@param instance integer -- The 1-indexed RPM sensor instance.
---@return number|nil -- The current RPM value, or nil if the sensor is not available or healthy.
function RPM:get_rpm(instance) end


-- The main interface for interacting with the autonomous mission.
-- Allows for reading, modifying, and controlling the mission flow.
mission = {}
mission.MISSION_COMPLETE = enum_integer
mission.MISSION_RUNNING = enum_integer
mission.MISSION_STOPPED = enum_integer

-- Clears all commands from the current mission.
---@return boolean -- True on success.
function mission:clear() end

-- Sets or updates a single mission command at a specific index.
---@param index integer -- The index to write the item to.
---@param item mavlink_mission_item_int_t_ud -- The mission item object to set.
---@return boolean -- True on success.
function mission:set_item(index, item) end

-- Gets a single mission command from a specific index.
---@param index integer -- The index of the item to retrieve.
---@return mavlink_mission_item_int_t_ud|nil -- The mission item object, or nil if the index is invalid.
function mission:get_item(index) end

-- Returns the total number of commands in the mission, including the home location at index 0.
---@return integer
function mission:num_commands() end

-- Returns the command ID of the active "do" command (a non-navigation command).
---@return integer
function mission:get_current_do_cmd_id() end

-- Returns the command ID of the current navigation command.
---@return integer
function mission:get_current_nav_id() end

-- Returns the command ID of the previously executed navigation command.
---@return integer -- Returns 0 (AP_MISSION_CMD_ID_NONE) if there was no previous navigation command.
function mission:get_prev_nav_cmd_id() end

-- Jumps the mission execution to the command at the specified index.
---@param index integer -- The index of the command to jump to.
---@return boolean -- True on success.
function mission:set_current_cmd(index) end

-- Returns the index of the current navigation command.
---@return integer -- Returns 0 if no command is active.
function mission:get_current_nav_index() end

-- Returns the current status of the mission execution.
---@return integer -- The mission state enum value (MISSION_RUNNING, MISSION_COMPLETE, etc.).
function mission:state() end

-- Returns true if the specified command ID involves a geographic location.
---@param cmd integer -- The MAV_CMD ID to check.
---@return boolean
function mission:cmd_has_location(cmd)end

-- Finds the first JUMP_TAG command with the specified tag and jumps the mission execution to it.
---@param tag integer -- The tag value to search for.
---@return boolean -- True on success, false if no matching tag is found.
function mission:jump_to_tag(tag) end

-- Returns the index of the first JUMP_TAG command with the specified tag.
---@param tag integer -- The tag value to search for.
---@return integer -- The index of the command, or 0 if not found.
function mission:get_index_of_jump_tag(tag) end

-- Gets the most recently executed JUMP_TAG and its age.
-- The age is the number of navigation commands that have been completed since the tag was seen.
---@return integer|nil -- The tag value.
---@return integer|nil -- The age of the tag.
function mission:get_last_jump_tag() end


-- Finds the closest landing sequence in the mission and jumps execution to it.
---@return boolean -- True if a landing sequence was found and the jump was successful.
function mission:jump_to_landing_sequence() end

-- Jumps mission execution to the landing abort sequence.
---@return boolean
function mission:jump_to_abort_landing_sequence() end

-- A simple, direct interface for getting and setting parameters by name.
param = {}

-- Sets a parameter's value and saves it to permanent storage (EEPROM). The value will persist after reboot.
---@param name string -- The parameter name (e.g., "ANGLE_MAX").
---@param value number -- The value to set and save.
---@return boolean -- True if the parameter was found.
function param:set_and_save(name, value) end

-- Sets a parameter's value for the current session only. The value will NOT persist after reboot.
---@param name string -- The parameter name.
---@param value number -- The value to set.
---@return boolean -- True if the parameter was found.
function param:set(name, value) end

-- Gets a parameter's current value.
---@param name string -- The parameter name.
---@return number|nil -- The parameter's value, or nil if the name was not found.
function param:get(name) end

-- Sets a parameter's default value. If the user has not changed the parameter, it will be set to this value.
---@param name string -- The parameter name.
---@param value number -- The default value to set.
---@return boolean -- True if the parameter was found.
function param:set_default(name, value) end

-- Creates a new table of script-specific parameters that can be accessed from a GCS.
---@param table_key integer -- A unique key for the table.
---@param prefix string -- The prefix for the parameter names in this table.
---@param num_params integer -- The number of parameters in the table.
---@return boolean -- True on success.
function param:add_table(table_key, prefix, num_params) end

-- Adds a single parameter to a previously created script parameter table.
---@param table_key integer -- The key of the table to add to.
---@param param_num integer -- The 1-indexed number of this parameter within the table.
---@param name string -- The name of the parameter.
---@param default_value number -- The default value.
---@return boolean -- True on success.
function param:add_param(table_key, param_num, name, default_value) end

-- A data structure for holding telemetry data from a single ESC.
---@class (exact) ESCTelemetryData_ud
local ESCTelemetryData_ud = {}

---@return ESCTelemetryData_ud
function ESCTelemetryData() end

-- set motor temperature
---@param value integer -- Temperature in degrees centi-grade * 10
function ESCTelemetryData_ud:motor_temp_cdeg(value) end

-- set consumption
---@param value number -- Consumed energy in mAh.
function ESCTelemetryData_ud:consumption_mah(value) end

-- set current
---@param value number -- Current in Amps.
function ESCTelemetryData_ud:current(value) end

-- set voltage
---@param value number -- Voltage in Volts.
function ESCTelemetryData_ud:voltage(value) end

-- set temperature
---@param value integer -- Temperature in degrees centi-grade * 10
function ESCTelemetryData_ud:temperature_cdeg(value) end

-- Interface for reading and providing ESC (Electronic Speed Controller) telemetry data.
esc_telem = {}

-- Updates the telemetry data for a specific ESC instance. Used by custom ESC driver scripts.
---@param instance integer -- The 0-indexed ESC instance.
---@param telemdata ESCTelemetryData_ud -- The populated telemetry data object.
---@param data_mask integer -- A bitmask indicating which fields in the `telemdata` object are valid.
function esc_telem:update_telem_data(instance, telemdata, data_mask) end

-- Returns an individual ESC’s usage time in seconds.
---@param instance integer -- The 0-indexed ESC instance.
---@return uint32_t_ud|nil -- Usage time in seconds, or nil if not available.
function esc_telem:get_usage_seconds(instance) end

-- Returns the consumed energy for a specific ESC.
---@param instance integer -- The 0-indexed ESC instance.
---@return number|nil -- Consumption in mAh, or nil if not available.
function esc_telem:get_consumption_mah(instance) end

-- Returns the voltage for a specific ESC.
---@param instance integer -- The 0-indexed ESC instance.
---@return number|nil -- Voltage in Volts, or nil if not available.
function esc_telem:get_voltage(instance) end

-- Returns the current for a specific ESC.
---@param instance integer -- The 0-indexed ESC instance.
---@return number|nil -- Current in Amps, or nil if not available.
function esc_telem:get_current(instance) end

-- Returns the motor temperature for a specific ESC.
---@param instance integer -- The 0-indexed ESC instance.
---@return integer|nil -- Temperature in degrees Celsius, or nil if not available.
function esc_telem:get_motor_temperature(instance) end

-- Returns the ESC temperature.
---@param instance integer -- The 0-indexed ESC instance.
---@return integer|nil -- Temperature in degrees Celsius, or nil if not available.
function esc_telem:get_temperature(instance) end

-- Returns the RPM for a specific ESC.
---@param instance integer -- The 0-indexed ESC instance.
---@return number|nil -- RPM, or nil if not available.
function esc_telem:get_rpm(instance) end

-- Updates the RPM for an ESC. Used by custom ESC driver scripts.
---@param esc_index integer -- The 0-indexed ESC instance.
---@param rpm integer -- The new RPM value.
---@param error_rate number -- The error rate.
function esc_telem:update_rpm(esc_index, rpm, error_rate) end

-- Sets the RPM scaling factor for a motor.
---@param esc_index integer -- The 0-indexed ESC instance.
---@param scale_factor number -- The scaling factor.
function esc_telem:set_rpm_scale(esc_index, scale_factor) end

-- Gets the timestamp of the last telemetry data received from an ESC.
---@param esc_index integer
---@return uint32_t_ud
function esc_telem:get_last_telem_data_ms(esc_index) end

-- Interface for the optical flow sensor.
optical_flow = {}

-- Returns the quality metric of the optical flow sensor. Higher numbers are better.
---@return integer -- Quality metric (0-255).
function optical_flow:quality() end

-- Returns true if the optical flow sensor is healthy and providing data.
---@return boolean
function optical_flow:healthy() end

-- Returns true if the optical flow sensor is enabled in parameters.
---@return boolean
function optical_flow:enabled() end

--- Interface for the barometer sensor(s).
baro = {}

-- Gets the temperature from an external barometer sensor, if available.
---@return number -- Temperature in degrees Celsius.
function baro:get_external_temperature() end

-- Gets the temperature from the primary internal barometer sensor.
---@return number -- Temperature in degrees Celsius.
function baro:get_temperature() end

-- Returns the current atmospheric pressure.
---@return number -- Pressure in Pascals. Divide by 100 for millibars or hPa.
function baro:get_pressure() end

-- Gets the current altitude relative to the altitude at the time of the last calibration (typically at boot).
---@return number -- Altitude in meters.
function baro:get_altitude() end

-- Checks if a specific barometer sensor is healthy.
---@param instance integer -- The 0-based index of the barometer instance to check.
---@return boolean -- True if the sensor is healthy.
function baro:healthy(instance) end

-- Calculates the altitude difference between two pressure readings.
---@param base_pressure number -- The first reference pressure in Pascals.
---@param pressure number -- The second pressure in Pascals.
---@return number -- The resulting altitude difference in meters.
function baro:get_altitude_difference(base_pressure,pressure) end

-- Interface for hardware serial ports (UARTs).
serial = {}

-- Returns a serial access object for a port configured for scripting.
-- The corresponding SERIALx_PROTOCOL parameter must be set to 28 (Scripting).
---@param instance integer -- The 0-based index of the scripting port to access.
---@return AP_Scripting_SerialAccess_ud|nil -- An access object for that instance, or nil if not found.
function serial:find_serial(instance) end

-- Returns a serial access object to simulate a device attached via a specific protocol.
-- This allows a script to act as a device (e.g., a GPS) for testing or custom integrations. SCR_SDEV_EN must be enabled.
---@param protocol integer -- The protocol to simulate (e.g., 5 for GPS).
---@param instance integer -- The 0-based index of the protocol instance.
---@return AP_Scripting_SerialAccess_ud|nil -- An access object for that instance, or nil if not found.
function serial:find_simulated_device(protocol, instance) end


-- Interface for the Radio Control (RC) receiver inputs.
rc = {}

-- Gets a specific RC channel object.
---@param chan_num integer -- The 1-indexed channel number.
---@return RC_Channel_ud|nil -- The channel object, or nil if the channel is invalid.
function rc:get_channel(chan_num) end

-- Returns true if the RC receiver has valid input and is not in failsafe.
---@return boolean
function rc:has_valid_input() end

-- Gets the cached state of an auxiliary function switch.
---@param aux_fn integer -- The auxiliary function number.
---@return integer|nil -- The cached switch position (0: low, 1: middle, 2: high).
function rc:get_aux_cached(aux_fn) end

-- Manually triggers an auxiliary function.
---@param aux_fun integer -- The auxiliary function to trigger.
---@param ch_flag integer -- The switch position to simulate (0: low, 1: middle, 2: high).
---@return boolean -- True on success.
function rc:run_aux_function(aux_fun, ch_flag) end

-- Finds the RC channel object assigned to a specific RC_xOPTION.
---@param aux_fun integer -- The RC_xOPTION number to find.
---@return RC_Channel_ud|nil -- The corresponding RC channel object, or nil if none is assigned.
function rc:find_channel_for_option(aux_fun) end

-- Returns the raw PWM input value for a specific channel.
---@param chan_num integer -- The 1-indexed input channel number.
---@return integer|nil -- The raw PWM value in microseconds, or nil if the channel is not available.
function rc:get_pwm(chan_num) end


-- Interface for controlling servo and relay outputs. This is distinct from the RC input object.
SRV_Channels = {}

-- Gets the emergency stop state. If true, all motors are inactive.
---@return boolean
---| true # E-Stop is active.
---| false # E-Stop is not active.
function SRV_Channels:get_emergency_stop() end

-- Gets the safety state (from the safety switch).
---@return boolean
---| true # Disarmed, outputs are inactive.
---| false # Armed, outputs are live.
function SRV_Channels:get_safety_state() end

-- Sets the output range for a servo function.
---@param function_num integer -- The servo function number (from the SERVOx_FUNCTION parameter list).
---@param range integer -- The output range in degrees.
function SRV_Channels:set_range(function_num, range) end

-- Sets the output angle for a servo function.
---@param function_num integer -- The servo function number.
---@param angle integer -- The output angle in degrees.
function SRV_Channels:set_angle(function_num, angle) end

-- Sets a normalized output value (-1 to 1) for a channel assigned the specified servo function.
---@param function_num integer -- The servo function number.
---@param value number -- The normalized output value from -1.0 to 1.0.
function SRV_Channels:set_output_norm(function_num, value) end

-- Gets the scaled output value (typically -1 to 1) for a given servo function.
---@param function_num integer -- The servo function number.
---@return number -- The current scaled output value.
function SRV_Channels:get_output_scaled(function_num) end

-- Returns the raw PWM value of the first output assigned the specified servo function.
---@param function_num integer -- The servo function number.
---@return integer|nil -- The output PWM in microseconds, or nil if no output is assigned that function.
function SRV_Channels:get_output_pwm(function_num) end

-- Sets the scaled output value for a given servo function. The scale is determined by the range set with `set_range` or `set_angle`.
---@param function_num integer -- The servo function number.
---@param value number -- The scaled output value.
function SRV_Channels:set_output_scaled(function_num, value) end

-- Overrides a specific servo output channel with a PWM value for a limited time.
---@param chan integer -- The 0-indexed servo output channel number (e.g., 0 for SERVO1).
---@param pwm integer -- The PWM value to set.
---@param timeout_ms integer -- The duration of the override in milliseconds.
function SRV_Channels:set_output_pwm_chan_timeout(chan, pwm, timeout_ms) end

-- Sets the raw PWM value for a specific servo output channel.
---@param chan integer -- The 0-indexed servo output channel number.
---@param pwm integer -- The PWM value to set.
function SRV_Channels:set_output_pwm_chan(chan, pwm) end

-- Gets the raw PWM value for a specific servo output channel.
---@param chan integer -- The 0-indexed servo output channel number.
---@return integer|nil -- The current output PWM, or nil if not available.
function SRV_Channels:get_output_pwm_chan(chan) end

-- Sets the raw PWM value for a given servo output function.
---@param function_num integer -- The servo function number.
---@param pwm integer -- The PWM value to set.
function SRV_Channels:set_output_pwm(function_num, pwm) end

-- Finds the first servo output channel (0-indexed) assigned to a specific function.
---@param function_num integer -- The servo function number.
---@return integer|nil -- The output channel number (e.g., 0 for SERVO1), or nil if none is assigned.
function SRV_Channels:find_channel(function_num) end


-- This library allows the control of RGB LED strings (like NeoPixel) via a servo output reserved for scripting.
-- The corresponding SERVOx_FUNCTION must be set to a Scripting output (94-109).
serialLED = {}

-- Sends the currently configured RGB values to the physical LED string. This must be called to see any changes made with `set_RGB`.
---@param chan integer -- The scripting output number (1-16) the LEDs are attached to.
---@return boolean -- True if successful.
function serialLED:send(chan) end

-- Sets the color for a single LED or all LEDs in the string.
---@param chan integer -- The scripting output number (1-16).
---@param led_index integer -- The 0-indexed LED number. Use -1 to set all LEDs to the same color.
---@param red integer -- The red component (0-255).
---@param green integer -- The green component (0-255).
---@param blue integer -- The blue component (0-255).
---@return boolean -- True if successful.
function serialLED:set_RGB(chan, led_index, red, green, blue) end

-- Configures the number of LEDs in a 'Profiled' type string.
---@param chan integer -- The scripting output number (1-16).
---@param num_leds integer -- The number of LEDs in the string.
---@return boolean -- True if successful.
function serialLED:set_num_profiled(chan, num_leds) end

-- Configures the number of LEDs in a 'NeoPixel' type string.
---@param chan integer -- The scripting output number (1-16).
---@param num_leds integer -- The number of LEDs in the string.
---@return boolean -- True if successful.
function serialLED:set_num_neopixel(chan, num_leds) end

-- Configures the number of LEDs in an 'RGB NeoPixel' type string.
---@param chan integer -- The scripting output number (1-16).
---@param num_leds integer -- The number of LEDs in the string.
---@return boolean -- True if successful.
function serialLED:set_num_neopixel_rgb(chan, num_leds) end

-- The main vehicle object, providing high-level control and status information.
vehicle = {}

-- Overrides the landing descent rate for 1 second.
---@param rate number -- The descent rate in cm/s.
---@return boolean
function vehicle:set_land_descent_rate(rate) end

-- Sets a rudder offset. (Rover specific)
---@param rudder_pct number -- Rudder offset percentage.
---@param run_yaw_rate_control boolean -- True to run the yaw rate controller.
function vehicle:set_rudder_offset(rudder_pct, run_yaw_rate_control) end

-- Returns true if the EKF has entered a failsafe state.
---@return boolean
function vehicle:has_ekf_failsafed() end

-- Gets the normalized pan and tilt values.
---@return number|nil
---@return number|nil
function vehicle:get_pan_tilt_norm() end

-- Gets the cross-track error from the current waypoint track.
---@return number|nil -- The error in meters.
function vehicle:get_wp_crosstrack_error_m() end

-- Gets the bearing to the current navigation target waypoint.
---@return number|nil -- The bearing in degrees.
function vehicle:get_wp_bearing_deg() end

-- Gets the distance to the current navigation target waypoint.
---@return number|nil -- The distance in meters.
function vehicle:get_wp_distance_m() end

-- Sets the steering and throttle outputs. (Rover specific)
---@param steering number -- Normalized steering (-1 to 1).
---@param throttle number -- Normalized throttle (-1 to 1).
---@return boolean
function vehicle:set_steering_and_throttle(steering, throttle) end

-- Gets the current steering and throttle outputs. (Rover specific)
---@return number|nil -- Steering.
---@return number|nil -- Throttle.
function vehicle:get_steering_and_throttle() end

-- Sets the turn rate for circle mode.
---@param rate_dps number -- The rate of turn in degrees per second.
---@return boolean
function vehicle:set_circle_rate(rate_dps) end

-- Gets the radius of the current circle mode flight path.
---@return number|nil -- The radius in meters.
function vehicle:get_circle_radius() end

-- Sets a target attitude and climb rate.
---@param roll_deg number
---@param pitch_deg number
---@param yaw_deg number
---@param climb_rate_ms number -- Climb rate in m/s.
---@param use_yaw_rate boolean -- True to use yaw_rate_degs instead of yaw_deg.
---@param yaw_rate_degs number -- Target yaw rate in degrees/second.
---@return boolean
function vehicle:set_target_angle_and_climbrate(roll_deg, pitch_deg, yaw_deg, climb_rate_ms, use_yaw_rate, yaw_rate_degs) end

-- Sets target roll, pitch, and yaw rates along with a collective throttle value in guided mode.
---@param roll_rate_dps number -- Target roll rate in degrees per second.
---@param pitch_rate_dps number -- Target pitch rate in degrees per second.
---@param yaw_rate_dps number -- Target yaw rate in degrees per second.
---@param throttle number -- Throttle demand from 0.0 to 1.0.
---@return boolean -- True if successful.
function vehicle:set_target_rate_and_throttle(roll_rate_dps, pitch_rate_dps, yaw_rate_dps, throttle) end

-- Sets the target velocity in the North-East-Down frame for guided modes.
---@param vel_ned Vector3f_ud -- A Vector3f where x=North, y=East, z=Down, in meters/second.
---@return boolean -- True on success.
function vehicle:set_target_velocity_NED(vel_ned) end

-- Sets a target velocity and acceleration in the NED frame.
---@param target_vel Vector3f_ud
---@param target_accel Vector3f_ud
---@param use_yaw boolean
---@param yaw_deg number
---@param use_yaw_rate boolean
---@param yaw_rate_degs number
---@param yaw_relative boolean
---@return boolean
function vehicle:set_target_velaccel_NED(target_vel, target_accel, use_yaw, yaw_deg, use_yaw_rate, yaw_rate_degs, yaw_relative) end

-- Sets a target position, velocity, and acceleration in the NED frame.
---@param target_pos Vector3f_ud
---@param target_vel Vector3f_ud
---@param target_accel Vector3f_ud
---@param use_yaw boolean
---@param yaw_deg number
---@param use_yaw_rate boolean
---@param yaw_rate_degs number
---@param yaw_relative boolean
---@return boolean
function vehicle:set_target_posvelaccel_NED(target_pos, target_vel, target_accel, use_yaw, yaw_deg, use_yaw_rate, yaw_rate_degs, yaw_relative) end

-- Sets a target position and velocity in the NED frame.
---@param target_pos Vector3f_ud
---@param target_vel Vector3f_ud
---@return boolean
function vehicle:set_target_posvel_NED(target_pos, target_vel) end

-- Sets a target position in the NED frame.
---@param target_pos Vector3f_ud
---@param use_yaw boolean
---@param yaw_deg number
---@param use_yaw_rate boolean
---@param yaw_rate_degs number
---@param yaw_relative boolean
---@param terrain_alt boolean -- If true, the z-component of target_pos is an altitude above terrain.
---@return boolean
function vehicle:set_target_pos_NED(target_pos, use_yaw, yaw_deg, use_yaw_rate, yaw_rate_degs, yaw_relative, terrain_alt) end

-- Updates the target location.
---@param current_target Location_ud -- The current target location, from `get_target_location()`.
---@param new_target Location_ud -- The new target location.
---@return boolean
function vehicle:update_target_location(current_target, new_target) end

-- Gets the current target location if the vehicle is in a mode that uses one.
---@return Location_ud|nil -- The target Location object.
function vehicle:get_target_location() end

-- Sets the target vehicle location for a guided mode.
---@param target_loc Location_ud -- The target Location object.
---@return boolean -- True on success.
function vehicle:set_target_location(target_loc) end

-- Initiates a takeoff in an auto or guided mode. Not supported by all vehicle types.
---@param alt number -- Takeoff altitude in meters.
---@return boolean -- True on success.
function vehicle:get_control_output(control_output) end

-- Returns the time in milliseconds since the autopilot determined it started flying.
---@return uint32_t_ud
function vehicle:get_time_flying_ms() end

-- Returns true if the autopilot believes the vehicle is flying. This is not always guaranteed to be accurate.
---@return boolean
function vehicle:get_likely_flying() end

-- Gets the reason for the current control mode.
---@return integer
function vehicle:get_control_mode_reason() end

-- Returns the current vehicle flight mode number. See https://mavlink.io/en/messages/ardupilotmega.html for vehicle-specific mode enums.
---@return integer
function vehicle:get_mode() end

-- Attempts to change the vehicle's flight mode. Returns true on success.
---@param mode_number integer -- The target mode number.
---@return boolean
function vehicle:set_mode(mode_number) end

-- Sets a target velocity to match.
---@param param1 Vector2f_ud
---@return boolean
function vehicle:set_velocity_match(param1) end

-- Enables or disables navigation control by a script.
---@param param1 integer -- 1 to enable, 0 to disable.
---@return boolean
function vehicle:nav_scripting_enable(param1) end

-- Sets the desired speed for Copter and Rover in navigation modes.
---@param param1 number -- Speed in m/s.
---@return boolean
function vehicle:set_desired_speed(param1) end

-- Sets the desired turn rate and speed. (Rover specific)
---@param param1 number -- Turn rate.
---@param param2 number -- Speed.
---@return boolean
function vehicle:set_desired_turn_rate_and_speed(param1, param2) end

-- Sets the target throttle and attitude rates.
---@param param1 number -- Throttle percentage.
---@param param2 number -- Roll rate in deg/s.
---@param param3 number -- Pitch rate in deg/s.
---@param param4 number -- Yaw rate in deg/s.
function vehicle:set_target_throttle_rate_rpy(param1, param2, param3, param4) end

-- Informs the mission planner that a NAV_SCRIPT_TIME command has completed.
---@param param1 integer -- The unique ID of the completed command.
function vehicle:nav_script_time_done(param1) end

-- Gets the parameters for a currently running NAV_SCRIPT_TIME command.
---@return integer|nil id -- The unique ID of the command.
---@return integer|nil cmd -- The 'command' (param1) field.
---@return number|nil arg1 -- The 'param2' field.
---@return number|nil arg2 -- The 'param3' field.
---@return integer|nil arg3 -- The 'param4' field (x_lat).
---@return integer|nil arg4 -- The 'param4' field (y_lon).
function vehicle:nav_script_time() end

-- Reboots the flight controller.
---@param hold_in_bootloader boolean -- If true, the device will reboot into the bootloader.
function vehicle:reboot(hold_in_bootloader) end

-- Returns true if the vehicle is in the takeoff portion of a mission.
---@return boolean
function vehicle:is_taking_off() end

-- Returns true if the vehicle is in the landing portion of a mission.
---@return boolean
function vehicle:is_landing() end

-- Sets the start point of the current navigation leg for crosstrack calculations.
---@param new_start_location Location_ud -- The new start location.
---@return boolean -- True on success.
function vehicle:set_crosstrack_start(new_start_location) end

-- Registers a custom flight mode. This behaves like a guided mode but will report a custom name and number to the GCS.
---@param number integer -- The custom mode number to use (should be > 100).
---@param full_name string -- The full name of the mode.
---@param short_name string -- A short name for the mode (max 4 characters).
---@return AP_Vehicle__custom_mode_state_ud|nil -- Returns a state object to customize behavior, or nil if registration fails.
function vehicle:register_custom_mode(number, full_name, short_name) end

-- A state object for a registered custom mode, allowing customization of its behavior.
---@class (exact) AP_Vehicle__custom_mode_state_ud
local AP_Vehicle__custom_mode_state_ud = {}

-- Gets whether the vehicle is allowed to enter this custom mode.
---@return boolean
function AP_Vehicle__custom_mode_state_ud:allow_entry() end

-- Sets whether the vehicle is allowed to enter this custom mode.
---@param value boolean
function AP_Vehicle__custom_mode_state_ud:allow_entry(value) end

-- Interface for controlling ONVIF-compliant IP cameras.
-- Allows for network-based control of camera Pan, Tilt, and Zoom (PTZ).
-- See the `ONVIF_Camera_Control.lua` script for a practical example.
onvif = {}

-- Gets the maximum pan and tilt limits of the camera.
---@return Vector2f_ud -- A Vector2f where x is the max pan and y is the max tilt.
function onvif:get_pan_tilt_limit_max() end

-- Gets the minimum pan and tilt limits of the camera.
---@return Vector2f_ud -- A Vector2f where x is the min pan and y is the min tilt.
function onvif:get_pan_tilt_limit_min() end

-- Commands the camera to move to an absolute pan, tilt, and zoom position.
---@param pan number -- The target pan position.
---@param tilt number -- The target tilt position.
---@param zoom number -- The target zoom position.
---@return boolean -- True on success.
function onvif:set_absolutemove(pan, tilt, zoom) end

-- Starts and initializes the connection to the ONVIF camera.
---@param username string -- The username for camera authentication.
---@param password string -- The password for camera authentication.
---@param httphostname string -- The IP address or hostname of the camera.
---@return boolean -- True on success.
function onvif:start(username, password, httphostname) end


-- MAVLink interaction with the Ground Control Station (GCS).
gcs = {}

-- Sends a named float value using the NAMED_VALUE_FLOAT MAVLink message.
-- This is useful for sending custom debug values or telemetry to a GCS that can display them.
---@param name string -- The name of the value, up to 10 characters long.
---@param value number -- The floating-point value to send.
function gcs:send_named_float(name, value) end

-- Sets the message interval for a specific MAVLink message on a given serial port.
-- This is a powerful tool for managing telemetry bandwidth. Use with caution.
---@param port_num integer -- The serial port number (0 for Serial0, 1 for Serial1, etc.).
---@param msg_id uint32_t_ud|integer|number -- The MAVLink message ID to configure (e.g., 33 for GLOBAL_POSITION_INT).
---@param interval_us integer -- The desired interval in microseconds. Set to -1 to restore the default rate.
---@return integer
---| '0' # Accepted
---| '4' # Failed
function gcs:set_message_interval(port_num, msg_id, interval_us) end

-- Gets the MAV_TYPE of the vehicle.
---@return integer -- The MAV_TYPE enum value (e.g., 2 for QUADROTOR, 10 for GROUND_ROVER).
function gcs:frame_type() end

-- Gets the throttle value as a percentage (0-100) as displayed on the GCS HUD.
---@return integer
function gcs:get_hud_throttle() end

-- Enables or disables high latency mode for MAVLink communications.
---@param enabled boolean -- True to enable, false to disable.
function gcs:enable_high_latency_connections(enabled) end

-- Gets the current status of high latency mode.
---@return boolean -- True if high latency mode is enabled.
function gcs:get_high_latency_status() end

-- Sends a text message to the GCS. This is the primary method for providing script feedback to the user.
---@param severity integer -- The severity level of the message (see MAV_SEVERITY enum).
---@param text string -- The text string to send (max 50 characters).
function gcs:send_text(severity, text) end

-- Returns the system time when the primary GCS was last seen.
---@return uint32_t_ud -- System time in milliseconds.
function gcs:last_seen() end

-- Returns true if the GCS is currently allowed to set parameters.
---@return boolean
function gcs:get_allow_param_set() end

-- Sets whether the GCS is allowed to set parameters.
---@param new_allow_value boolean
function gcs:set_allow_param_set(new_allow_value) end

-- Executes a MAVLink command using the COMMAND_INT interface, as if it were sent from a GCS.
---@param command integer -- The MAV_CMD_xxx command ID.
---@param params table -- A table of parameters: {p1, p2, p3, p4, x, y, z, frame}. Any omitted parameters are treated as zero.
---@return integer -- The MAV_RESULT enum value (e.g., 0 for accepted).
function gcs:run_command_int(command, params) end

-- The relay library provides a simple interface for controlling relay outputs.
relay = {}

-- Toggles the state of a specific relay (on to off, or off to on).
---@param instance integer -- The 0-indexed relay instance.
function relay:toggle(instance) end

-- Returns true if the specified relay is enabled (i.e., its RELAY_PIN parameter is not -1).
---@param instance integer -- The 0-indexed relay instance.
---@return boolean
function relay:enabled(instance) end

-- Gets the current state of a relay.
---@param instance integer -- The 0-indexed relay instance.
---@return integer -- 1 if on, 0 if off.
function relay:get(instance) end

-- Turns the specified relay off.
---@param instance integer -- The 0-indexed relay instance.
function relay:off(instance) end

-- Turns the specified relay on.
---@param instance integer -- The 0-indexed relay instance.
function relay:on(instance) end


-- The terrain library provides access to checking heights against the onboard terrain database.
-- Requires a terrain database to be present on the SD card.
terrain = {}
terrain.TerrainStatusOK = enum_integer
terrain.TerrainStatusUnhealthy = enum_integer
terrain.TerrainStatusDisabled = enum_integer

-- Returns the vehicle's current height above the terrain (AGL).
---@param extrapolate boolean -- If true, allows the return of an extrapolated altitude if the vehicle is outside the known terrain data area.
---@return number|nil -- The height above terrain in meters, or nil if not available.
function terrain:height_above_terrain(extrapolate) end

-- Returns the difference in terrain height between the vehicle's current location and its home position.
---@param extrapolate boolean
---@return number|nil -- Height difference in meters (positive means current location is higher), or nil if unavailable.
function terrain:height_terrain_difference_home(extrapolate) end

-- Looks up the terrain height (above mean sea level) at a specific geographic location.
---@param loc Location_ud -- The location at which to look up the terrain altitude.
---@param corrected boolean -- If true, the terrain altitude will be corrected based on the difference between the database and measured altitude at home.
---@return number|nil -- The AMSL altitude of the terrain in meters, or nil if unavailable.
function terrain:height_amsl(loc, corrected) end

-- Returns the current status of the terrain database.
---@return integer -- The terrain status enum value (e.g., terrain.TerrainStatusOK).
function terrain:status() end

-- Returns true if terrain following is enabled in the parameters.
---@return boolean
function terrain:enabled() end


-- A data structure for holding a single reading from a rangefinder.
---@class (exact) RangeFinder_State_ud
local RangeFinder_State_ud = {}

---@return RangeFinder_State_ud
function RangeFinder_State() end

-- get system time (ms) of the last successful update from this sensor
---@return uint32_t_ud
function RangeFinder_State_ud:last_reading() end
-- set system time (ms)
---@param value uint32_t_ud|integer|number
function RangeFinder_State_ud:last_reading(value) end

-- get sensor status
---@return integer
function RangeFinder_State_ud:status() end

-- set sensor status
---@param value integer
function RangeFinder_State_ud:status(value) end

-- get number of consecutive valid readings (maxes out at 10)
---@return integer
function RangeFinder_State_ud:range_valid_count() end

-- set number of consecutive valid readings
---@param value integer
function RangeFinder_State_ud:range_valid_count(value) end

-- get distance in meters
---@return number
function RangeFinder_State_ud:distance() end

-- set distance in meters
---@param value number
function RangeFinder_State_ud:distance(value) end

-- get measurement quality in percent (0-100). -1 means quality is unknown.
---@return integer
function RangeFinder_State_ud:signal_quality() end

-- set measurement quality
---@param value integer
function RangeFinder_State_ud:signal_quality(value) end

-- get voltage in millivolts, if applicable.
---@return integer
function RangeFinder_State_ud:voltage() end

-- set voltage in millivolts
---@param value integer
function RangeFinder_State_ud:voltage(value) end


-- Represents a scripting backend for a rangefinder. Used to create custom rangefinder drivers.
---@class (exact) AP_RangeFinder_Backend_ud
local AP_RangeFinder_Backend_ud = {}

-- Sends a rangefinder measurement from a script into the ArduPilot system.
---@param state RangeFinder_State_ud -- The populated state object containing the measurement.
---@return boolean -- True on success.
function AP_RangeFinder_Backend_ud:handle_script_msg(state) end

-- Status of this rangefinder instance
---@return integer
function AP_RangeFinder_Backend_ud:status() end

-- Type of rangefinder of this instance
---@return integer
function AP_RangeFinder_Backend_ud:type() end

-- Orientation of the rangefinder of this instance
---@return integer
function AP_RangeFinder_Backend_ud:orientation() end

-- Current distance of the sensor instance
---@return number
function AP_RangeFinder_Backend_ud:distance() end

-- Current distance measurement signal quality of the sensor instance
---@return number
function AP_RangeFinder_Backend_ud:signal_quality() end

-- State of the most recent rangefinder measurement
---@return RangeFinder_State_ud
function AP_RangeFinder_Backend_ud:get_state() end


-- The main interface for accessing rangefinder data.
rangefinder = {}

-- Gets a backend handle for a specific rangefinder instance. Used for custom rangefinder drivers.
---@param rangefinder_instance integer -- The 0-indexed rangefinder instance.
---@return AP_RangeFinder_Backend_ud|nil -- The backend object, or nil if not found.
function rangefinder:get_backend(rangefinder_instance) end

-- Gets the configured position offset for a sensor with a specific orientation.
---@param orientation integer -- The sensor orientation enum value.
---@return Vector3f_ud -- The position offset vector.
function rangefinder:get_pos_offset_orient(orientation) end

-- Returns true if there is data from a sensor with the specified orientation.
---@param orientation integer
---@return boolean
function rangefinder:has_data_orient(orientation) end

-- Returns the status of the sensor with the specified orientation.
---@param orientation integer
---@return integer
function rangefinder:status_orient(orientation) end

---@param orientation integer
---@return integer
---@deprecated Use ground_clearance_orient (in meters).
function rangefinder:ground_clearance_cm_orient(orientation) end

---@param orientation integer
---@return integer
---@deprecated Use min_distance_orient (in meters).
function rangefinder:min_distance_cm_orient(orientation) end

---@param orientation integer
---@return integer
---@deprecated Use max_distance_orient (in meters).
function rangefinder:max_distance_cm_orient(orientation) end

---@param orientation integer
---@return integer
---@deprecated Use distance_orient (in meters).
function rangefinder:distance_cm_orient(orientation) end

-- Gets the configured ground clearance for a rangefinder with a specific orientation.
---@param orientation integer
---@return number -- Ground clearance in meters.
function rangefinder:ground_clearance_orient(orientation) end

-- Gets the configured minimum measurable distance for a rangefinder with a specific orientation.
---@param orientation integer
---@return number -- Minimum distance in meters.
function rangefinder:min_distance_orient(orientation) end

-- Gets the configured maximum measurable distance for a rangefinder with a specific orientation.
---@param orientation integer
---@return number -- Maximum distance in meters.
function rangefinder:max_distance_orient(orientation) end

-- Gets the current measured distance from a rangefinder with a specific orientation.
---@param orientation integer
---@return number -- Current distance in meters.
function rangefinder:distance_orient(orientation) end

-- Gets the current signal quality for a rangefinder with a specific orientation.
---@param orientation integer
---@return integer -- Signal quality percentage (0-100).
function rangefinder:signal_quality_pct_orient(orientation) end

-- Returns true if a rangefinder with the specified orientation is configured.
---@param orientation integer
---@return boolean
function rangefinder:has_orientation(orientation) end

-- Returns the total number of configured rangefinder sensors.
---@return integer
function rangefinder:num_sensors() end

-- Represents a scripting backend for a proximity sensor. Used to create custom avoidance sensors.
---@class (exact) AP_Proximity_Backend_ud
local AP_Proximity_Backend_ud = {}

-- Pushes the virtual proximity boundary into the actual boundary used by the avoidance system.
---@return boolean
function AP_Proximity_Backend_ud:update_virtual_boundary() end

-- Sets the minimum and maximum detection distance for the virtual sensor.
---@param min number -- Minimum distance in meters.
---@param max number -- Maximum distance in meters.
---@return boolean
function AP_Proximity_Backend_ud:set_distance_min_max(min, max) end

-- Gets the type of the backend.
---@return integer
function AP_Proximity_Backend_ud:type() end

-- Sends a 3D object detection from a script into the proximity system using a vector.
---@param vector_3d Vector3f_ud -- A vector representing the detected object.
---@param update_boundary boolean -- If true, updates the avoidance boundary immediately.
---@return boolean
function AP_Proximity_Backend_ud:handle_script_3d_msg(vector_3d, update_boundary) end

-- Sends a 3D object detection from a script into the proximity system using angles and distance.
---@param dist_m number -- The distance to the object in meters.
---@param yaw_deg number -- The yaw angle to the object in degrees.
---@param pitch_deg number -- The pitch angle to the object in degrees.
---@param update_boundary boolean -- If true, updates the avoidance boundary immediately.
---@return boolean
function AP_Proximity_Backend_ud:handle_script_distance_msg(dist_m, yaw_deg, pitch_deg, update_boundary) end

-- The main interface for accessing proximity sensor data for object avoidance.
proximity = {}

-- Gets a backend handle for a specific proximity sensor instance. Used for custom drivers.
---@param instance integer
---@return AP_Proximity_Backend_ud|nil
function proximity:get_backend(instance) end

-- Gets the angle and distance to a specific detected object.
---@param object_number integer
---@return number|nil -- Angle
---@return number|nil -- Distance
function proximity:get_object_angle_and_distance(object_number) end

-- Gets the angle and distance to the closest detected object.
---@return number|nil -- Angle
---@return number|nil -- Distance
function proximity:get_closest_object() end

-- Gets the total number of objects currently being tracked by the proximity sensor.
---@return integer
function proximity:get_object_count() end

-- Returns the total number of configured proximity sensors.
---@return integer
function proximity:num_sensors() end

-- Gets the current status of the proximity sensor system.
---@return integer
function proximity:get_status() end

-- The main interface for user notification, controlling onboard LEDs and the buzzer.
notify = {}

-- Sets the color of a specific notify LED instance.
---@param red integer -- The red component (0-255).
---@param green integer -- The green component (0-255).
---@param blue integer -- The blue component (0-255).
---@param id integer -- The 0-indexed LED instance.
function notify:handle_rgb_id(red, green, blue, id) end

-- Sets the color and blink rate of the primary notify LED.
---@param red integer -- The red component (0-255).
---@param green integer -- The green component (0-255).
---@param blue integer -- The blue component (0-255).
---@param rate_hz integer -- The blink rate in Hz.
function notify:handle_rgb(red, green, blue, rate_hz) end

-- Plays a tune through the vehicle's buzzer using the MML (Music Macro Language) format.
-- An online tune tester can be found here: https://firmware.ardupilot.org/Tools/ToneTester/
---@param tune string -- The MML tune string.
function notify:play_tune(tune) end

-- Displays text on a notify display (e.g., an OLED screen). Text that is too long to fit will be automatically scrolled.
---@param text string -- The text to display (up to 50 characters).
---@param row integer -- The row number to display on, where 0 is the top row.
function notify:send_text(text, row) end

-- Releases a row on the notify display, allowing it to be used by other system messages.
---@param row integer -- The row number to release.
function notify:release_text(row) end

-- The GPS library provides access to information about the GPS receivers on the vehicle.
gps = {}
gps.GPS_OK_FIX_3D_RTK_FIXED = 6
gps.GPS_OK_FIX_3D_RTK_FLOAT = 5
gps.GPS_OK_FIX_3D_DGPS = 4
gps.GPS_OK_FIX_3D = 3
gps.GPS_OK_FIX_2D = 2
gps.NO_FIX = 1
gps.NO_GPS = 0

-- Gets the UTC time from the GPS as a Unix epoch timestamp.
---@param instance integer -- The 0-indexed GPS instance.
---@return uint64_t_ud -- The time in microseconds since 1/1/1970.
function gps:time_epoch_usec(instance) end

-- Gets the yaw from a GPS with dual antennas (if available).
---@param instance integer -- The 0-indexed GPS instance.
---@return number|nil -- The yaw angle in degrees.
---@return number|nil -- The yaw accuracy estimate in degrees.
---@return uint32_t_ud|nil -- The system time of the last yaw reading in milliseconds.
function gps:gps_yaw_deg(instance) end

-- Returns the instance number of the first GPS that has not been fully configured. Returns nil if all are configured.
---@return integer|nil
function gps:first_unconfigured_gps() end

-- Returns a Vector3f containing the configured antenna offsets from the vehicle's center of gravity.
---@param instance integer -- The 0-indexed GPS instance.
---@return Vector3f_ud -- The antenna offset vector (forward, right, down) in meters.
function gps:get_antenna_offset(instance) end

-- Returns true if the GPS instance can report vertical velocity.
---@param instance integer -- The 0-indexed GPS instance.
---@return boolean -- True if vertical velocity is available.
function gps:have_vertical_velocity(instance) end

-- Returns the system time of the last message received from the GPS.
---@param instance integer -- The 0-indexed GPS instance.
---@return uint32_t_ud -- The time in milliseconds.
function gps:last_message_time_ms(instance) end

-- Returns the system time of the last valid position fix.
---@param instance integer -- The 0-indexed GPS instance.
---@return uint32_t_ud -- The time in milliseconds.
function gps:last_fix_time_ms(instance) end

-- Returns the vertical dilution of precision (VDOP) of the GPS instance. Lower is better.
---@param instance integer -- The 0-indexed GPS instance.
---@return integer -- The VDOP value.
function gps:get_vdop(instance) end

-- Returns the horizontal dilution of precision (HDOP) of the GPS instance. Lower is better.
---@param instance integer -- The 0-indexed GPS instance.
---@return integer -- The HDOP value.
function gps:get_hdop(instance) end

-- Returns the number of milliseconds into the current GPS week.
---@param instance integer -- The 0-indexed GPS instance.
---@return uint32_t_ud -- The time in milliseconds.
function gps:time_week_ms(instance) end

-- Returns the GPS week number.
---@param instance integer -- The 0-indexed GPS instance.
---@return integer -- The week number.
function gps:time_week(instance) end

-- Returns the number of satellites the GPS is currently tracking.
---@param instance integer -- The 0-indexed GPS instance.
---@return integer -- The number of satellites.
function gps:num_sats(instance) end

-- Returns the ground course (direction of travel) of the vehicle.
---@param instance integer -- The 0-indexed GPS instance.
---@return number -- The ground course in degrees.
function gps:ground_course(instance) end

-- Returns the ground speed of the vehicle.
---@param instance integer -- The 0-indexed GPS instance.
---@return number -- The ground speed in meters per second.
function gps:ground_speed(instance) end

-- Returns a Vector3f containing the velocity as observed by the GPS in the NED frame.
---@param instance integer -- The 0-indexed GPS instance.
---@return Vector3f_ud -- A 3D velocity vector in m/s.
function gps:velocity(instance) end

-- Returns the vertical accuracy estimate of the GPS, if available.
---@param instance integer -- The 0-indexed GPS instance.
---@return number|nil -- The vertical accuracy in meters.
function gps:vertical_accuracy(instance) end

-- Returns the horizontal RMS accuracy estimate of the GPS.
---@param instance integer -- The 0-indexed GPS instance.
---@return number|nil -- The horizontal accuracy in meters.
function gps:horizontal_accuracy(instance) end

-- Returns the speed accuracy estimate of the GPS, if available.
---@param instance integer -- The 0-indexed GPS instance.
---@return number|nil -- The 3D velocity RMS accuracy estimate in m/s.
function gps:speed_accuracy(instance) end

-- Returns a Location object for the last known GPS position.
-- It is critical to check `gps:status()` to ensure the returned location is current and valid.
---@param instance integer -- The 0-indexed GPS instance.
---@return Location_ud -- The GPS location.
function gps:location(instance) end

-- Returns the current GPS fix status. This should always be checked before using GPS location data.
---@param instance integer -- The 0-indexed GPS instance.
---@return integer -- The status enum value (e.g., `gps.GPS_OK_FIX_3D_RTK_FIXED`).
function gps:status(instance) end

-- Returns which GPS instance is currently being used as the primary source for navigation.
---@return integer -- The primary sensor instance index.
function gps:primary_sensor() end

-- Returns the total number of connected GPS devices. This may include a blended GPS instance if enabled.
---@return integer -- The number of sensors.
function gps:num_sensors() end

-- A data structure for holding the state of a battery. Used by custom battery monitor drivers.
---@class (exact) BattMonitorScript_State_ud
local BattMonitorScript_State_ud = {}

---@return BattMonitorScript_State_ud
function BattMonitorScript_State() end

-- set field
---@param value number
function BattMonitorScript_State_ud:temperature(value) end

-- set field
---@param value number
function BattMonitorScript_State_ud:consumed_wh(value) end

-- set field
---@param value number
function BattMonitorScript_State_ud:consumed_mah(value) end

-- set field
---@param value number
function BattMonitorScript_State_ud:current_amps(value) end

-- set field
---@param value integer
function BattMonitorScript_State_ud:cycle_count(value) end

-- set array field
---@param index integer
---@param value integer
function BattMonitorScript_State_ud:cell_voltages(index, value) end

-- set field
---@param value integer
function BattMonitorScript_State_ud:capacity_remaining_pct(value) end

-- set field
---@param value integer
function BattMonitorScript_State_ud:cell_count(value) end

-- set field
---@param value number
function BattMonitorScript_State_ud:voltage(value) end

-- set field
---@param value boolean
function BattMonitorScript_State_ud:healthy(value) end
-- set state of health, 255 if not available (this is the default)
---@param value integer
function BattMonitorScript_State_ud:state_of_health_pct(value) end

-- The temperature library provides access to information about connected temperature sensors.
temperature_sensor = {}

-- Returns the temperature from a specific sensor instance.
---@param instance integer -- The 1-indexed temperature sensor instance.
---@return number|nil -- Temperature in degrees Celsius, or nil if not available.
function temperature_sensor:get_temperature(instance) end

-- The battery library provides access to information about the connected batteries.
battery = {}

-- Pushes a populated battery state into the ArduPilot system. Used by custom battery monitor driver scripts.
---@param idx integer -- The 0-indexed battery instance.
---@param state BattMonitorScript_State_ud -- The populated state object.
---@return boolean
function battery:handle_scripting(idx, state) end

-- Resets the remaining capacity of a battery to a specific percentage.
---@param instance integer -- The 1-indexed battery instance.
---@param percentage number -- The percentage (0-100) to set as the remaining capacity.
---@return boolean
function battery:reset_remaining(instance, percentage) end

-- Returns the cycle count of the battery, if available.
---@param instance integer -- The 1-indexed battery instance.
---@return integer|nil
function battery:get_cycle_count(instance) end

-- Returns the temperature of the battery, if available.
---@param instance integer -- The 1-indexed battery instance.
---@return number|nil -- Temperature in degrees Celsius.
function battery:get_temperature(instance) end

-- Returns true if the battery is currently in an overpower condition.
---@param instance integer -- The 1-indexed battery instance.
---@return boolean
function battery:overpower_detected(instance) end

-- Returns true if any battery has triggered a failsafe condition.
---@return boolean
function battery:has_failsafed() end

-- Returns the full pack capacity of the battery.
---@param instance integer -- The 1-indexed battery instance.
---@return integer -- Capacity in mAh.
function battery:pack_capacity_mah(instance) end

-- Returns the remaining battery capacity as a percentage.
---@param instance integer -- The 1-indexed battery instance.
---@return integer|nil -- Remaining capacity (0-100), or nil if not available.
function battery:capacity_remaining_pct(instance) end

-- Returns the consumed energy from the battery in Watt-hours.
---@param instance integer -- The 1-indexed battery instance.
---@return number|nil
function battery:consumed_wh(instance) end

-- Returns the consumed capacity from the battery in milliamp-hours.
---@param instance integer -- The 1-indexed battery instance.
---@return number|nil
function battery:consumed_mah(instance) end

-- Returns the current being drawn from the battery.
---@param instance integer -- The 1-indexed battery instance.
---@return number|nil -- Current in Amps.
function battery:current_amps(instance) end

-- Returns the estimated resting voltage of the battery (voltage without load).
---@param instance integer -- The 1-indexed battery instance.
---@return number
function battery:voltage_resting_estimate(instance) end

-- Returns the estimated internal resistance of the battery.
---@param instance integer -- The 1-indexed battery instance.
---@return number -- Resistance in Ohms.
function battery:get_resistance(instance) end

-- Returns the current voltage of the battery.
---@param instance integer -- The 1-indexed battery instance.
---@return number -- Voltage.
function battery:voltage(instance) end

-- Returns true if the battery monitor is healthy and providing data.
---@param instance integer -- The 1-indexed battery instance.
---@return boolean
function battery:healthy(instance) end

-- Returns the total number of configured battery instances.
---@return integer
function battery:num_instances() end

-- Gets the voltage of an individual cell in the battery pack.
---@param instance integer -- The 1-indexed battery instance.
---@param cell integer -- The 1-indexed cell number.
---@return number|nil -- The cell voltage, or nil if not available.
function battery:get_cell_voltage(instance, cell) end


-- The Arming library provides access to arming status and commands.
arming = {}

-- Sets an auxiliary authorization to a failed state, preventing arming.
---@param auth_id integer -- The auxiliary authorization ID.
---@param fail_msg string -- The failure message to be displayed.
function arming:set_aux_auth_failed(auth_id, fail_msg) end

-- Sets an auxiliary authorization to a passed state.
---@param auth_id integer -- The auxiliary authorization ID.
function arming:set_aux_auth_passed(auth_id) end

-- Gets the ID of the current auxiliary authorization check being performed.
---@return integer|nil
function arming:get_aux_auth_id() end

-- Attempts to arm the vehicle, running all pre-arm checks.
---@return boolean -- True if armed successfully.
function arming:arm() end

-- Forcefully arms the vehicle, skipping some pre-arm checks. Use with extreme caution.
---@return boolean -- True if armed.
function arming:arm_force() end

-- Returns true if the vehicle is currently armed.
---@return boolean
function arming:is_armed() end

-- Runs the pre-arm checks and returns true if they all pass.
---@return boolean
function arming:pre_arm_checks() end

-- Disarms the vehicle.
---@return boolean -- True if disarmed successfully, false if already disarmed.
function arming:disarm() end

-- The AHRS (Attitude and Heading Reference System) library is the core of the autopilot's state estimation.
-- It provides the best available estimate for the vehicle's attitude, position, and velocity.
ahrs = {}

-- Supplies an external position estimate to the EKF. This is used for external navigation sources like visual odometry.
---@param location Location_ud -- The estimated location object. The altitude component is ignored.
---@param accuracy number -- The 1-sigma accuracy of the position estimate in meters.
---@param timestamp_ms uint32_t_ud|integer|number -- The timestamp of the reading in milliseconds since boot.
---@return boolean -- True if the estimate was successfully passed to the EKF.
function ahrs:handle_external_position_estimate(location, accuracy, timestamp_ms) end

-- Gets the vehicle's attitude as a quaternion.
---@return Quaternion_ud|nil -- The quaternion representing the vehicle's attitude, or nil if not available.
function ahrs:get_quaternion() end

-- Gets the currently active EKF source set (primary, secondary, etc.).
---@return integer
function ahrs:get_posvelyaw_source_set() end

-- Returns true if the AHRS has completed its initialization.
---@return boolean
function ahrs:initialised() end

-- Sets the EKF origin to a specific location.
---@param loc Location_ud -- The Location object to set as the origin.
---@return boolean
function ahrs:set_origin(loc) end

-- Gets the current EKF origin location.
---@return Location_ud|nil
function ahrs:get_origin() end

-- Sets the home position to a specific location.
---@param loc Location_ud -- The Location object to set as home.
---@return boolean
function ahrs:set_home(loc) end

-- Gets the velocity innovations and variances for a specific EKF source. (Advanced)
---@param source integer
---@return Vector3f_ud|nil
---@return Vector3f_ud|nil
function ahrs:get_vel_innovations_and_variances_for_source(source) end

-- Sets the active EKF source set.
---@param source_set_idx integer
---| '0' # PRIMARY
---| '1' # SECONDARY
---| '2' # TERTIARY
function ahrs:set_posvelyaw_source_set(source_set_idx) end

-- Gets the EKF's internal state variances. (Advanced)
---@return number|nil
---@return number|nil
---@return number|nil
---@return Vector3f_ud|nil
---@return number|nil
function ahrs:get_variances() end

-- Gets the ratio of Equivalent Airspeed (EAS) to True Airspeed (TAS).
---@return number
function ahrs:get_EAS2TAS() end

-- Rotates a vector from the vehicle's body frame to the earth frame (NED).
---@param vector Vector3f_ud -- The vector in the body frame to be rotated. The vector is modified in-place.
---@return Vector3f_ud -- The rotated vector in the earth frame.
function ahrs:body_to_earth(vector) end

-- Rotates a vector from the earth frame (NED) to the vehicle's body frame.
---@param vector Vector3f_ud -- The vector in the earth frame to be rotated. The vector is modified in-place.
---@return Vector3f_ud -- The rotated vector in the body frame.
function ahrs:earth_to_body(vector) end

-- Gets a metric for the vehicle's current vibration levels.
---@return Vector3f_ud
function ahrs:get_vibration() end

-- Returns the estimated true airspeed of the vehicle, if available.
---@return number|nil -- Airspeed in meters/second.
function ahrs:airspeed_estimate() end

-- Returns true if the AHRS system is healthy and providing reliable data. This should be checked before trusting any AHRS data.
---@return boolean
function ahrs:healthy() end

-- Returns true if the home position has been set.
---@return boolean
function ahrs:home_is_set() end

-- Gets the vehicle's altitude relative to the home position.
---@return number -- Altitude in meters (down is positive).
function ahrs:get_relative_position_D_home() end

-- Gets the vehicle's position relative to the EKF origin in the NED frame.
---@return Vector3f_ud|nil -- A Vector3f of North, East, Down positions in meters.
function ahrs:get_relative_position_NED_origin() end

-- Gets the vehicle's position relative to its home position in the NED frame.
---@return Vector3f_ud|nil -- A Vector3f of North, East, Down positions in meters.
function ahrs:get_relative_position_NED_home() end

-- Returns a Vector3f containing the current vehicle velocity in the NED frame.
---@return Vector3f_ud|nil -- North, East, Down velocity in meters/second, or nil if not available.
function ahrs:get_velocity_NED() end

-- Gets the current ground speed as a 2D vector.
---@return Vector2f_ud -- A Vector2f where x=North speed, y=East speed, in meters/second.
function ahrs:groundspeed_vector() end

-- Returns a Vector3f containing the current wind estimate.
---@return Vector3f_ud -- A Vector3f of wind velocity (North, East, Down) in meters/second.
function ahrs:wind_estimate() end

-- Determines how aligned a given heading is with the wind.
---@param heading_deg number -- The heading to check, in degrees.
---@return number -- Returns 1.0 for a perfect headwind, -1.0 for a perfect tailwind, and 0 for a perfect crosswind.
function ahrs:wind_alignment(heading_deg) end

-- Returns the forward headwind component.
---@return number -- The headwind component in m/s (negative means tailwind).
function ahrs:head_wind() end

-- Returns the latest altitude estimate above ground level (AGL). Requires a valid terrain or rangefinder source.
---@return number|nil -- Height above ground level in meters.
function ahrs:get_hagl() end

-- Gets the current accelerometer readings.
---@return Vector3f_ud -- A Vector3f of accelerations in m/s^2.
function ahrs:get_accel() end

-- Returns a Vector3f containing the current smoothed and filtered gyro rates.
---@return Vector3f_ud -- Roll, pitch, yaw gyro rates in radians/second.
function ahrs:get_gyro() end

-- Returns a Location object representing the vehicle's home position.
---@return Location_ud
function ahrs:get_home() end

-- Returns a Location object of the vehicle's current estimated position.
-- Note: This will only return a Location if the system's position estimate is considered valid.
---@return Location_ud|nil
function ahrs:get_location() end

-- Deprecated alias for `get_location`.
---@return Location_ud|nil
---@deprecated Use get_location()
function ahrs:get_position() end

-- Deprecated alias for `get_yaw_rad`.
---@return number
---@deprecated Use get_yaw_rad()
function ahrs:get_yaw() end

-- Deprecated alias for `get_pitch_rad`.
---@return number
---@deprecated Use get_pitch_rad()
function ahrs:get_pitch() end

-- Deprecated alias for `get_roll_rad`.
---@return number
---@deprecated Use get_roll_rad()
function ahrs:get_roll() end

-- Returns the current vehicle yaw angle.
---@return number -- Yaw angle in radians (0 to 2*PI).
function ahrs:get_yaw_rad() end

-- Returns the current vehicle pitch angle.
---@return number -- Pitch angle in radians.
function ahrs:get_pitch_rad() end

-- Returns the current vehicle roll angle.
---@return number -- Roll angle in radians.
function ahrs:get_roll_rad() end

-- Copter-specific attitude controller interface.
AC_AttitudeControl = {}

-- Returns the attitude slew rates for the VTOL controller.
---@return number -- Roll slew rate.
---@return number -- Pitch slew rate.
---@return number -- Yaw slew rate.
function AC_AttitudeControl:get_rpy_srate() end

-- Returns the angle between the target thrust vector and the current thrust vector.
---@return number -- The attitude error in degrees.
function AC_AttitudeControl:get_att_error_angle_deg() end

-- Rover-specific attitude controller interface.
AR_AttitudeControl = {}

-- Returns the slew rates for the rover's steering and speed controllers.
---@return number -- Steering slew rate.
---@return number -- Speed slew rate.
function AR_AttitudeControl:get_srate() end

-- Copter-specific position controller interface.
poscontrol = {}

-- Adds a temporary offset to the position controller's target.
---@param pos_offset_NED Vector3f_ud -- Position offset in the NED frame (meters).
---@param vel_offset_NED Vector3f_ud -- Velocity offset in the NED frame (m/s).
---@param accel_offset_NED Vector3f_ud -- Acceleration offset in the NED frame (m/s/s).
---@return boolean
function poscontrol:set_posvelaccel_offset(pos_offset_NED, vel_offset_NED, accel_offset_NED) end

-- Gets the current position, velocity, and acceleration offsets from the position controller.
---@return Vector3f_ud|nil -- Position offset.
---@return Vector3f_ud|nil -- Velocity offset.
---@return Vector3f_ud|nil -- Acceleration offset.
function poscontrol:get_posvelaccel_offset() end

-- Gets the position controller's current velocity target in the NED frame.
---@return Vector3f_ud|nil -- Velocity target in m/s.
function poscontrol:get_vel_target() end

-- Gets the position controller's current acceleration target in the NED frame.
---@return Vector3f_ud|nil -- Acceleration target in m/s/s.
function poscontrol:get_accel_target() end

-- Interface for the precision landing system.
precland = {}

-- Gets the location of the precision landing target, if acquired.
---@return Location_ud|nil
function precland:get_target_location() end

-- Gets the velocity of the precision landing target in the North-East frame, if available.
---@return Vector2f_ud|nil -- Velocity in m/s.
function precland:get_target_velocity() end

-- Gets the system time of the last valid target update.
---@return uint32_t_ud -- Time in milliseconds.
function precland:get_last_valid_target_ms() end

-- Returns true if a precision landing target has been acquired.
---@return boolean
function precland:target_acquired() end

-- Returns true if the precision landing system is healthy.
---@return boolean
function precland:healthy() end

-- Interface for the follow-me mode.
follow = {}

-- Gets the heading of the follow-me target.
---@return number|nil -- Heading in degrees.
function follow:get_target_heading_deg() end

-- Gets the target's location and velocity offset.
---@return Location_ud|nil
---@return Vector3f_ud|nil
function follow:get_target_location_and_velocity_ofs() end

-- Gets the target's location and velocity.
---@return Location_ud|nil
---@return Vector3f_ud|nil
function follow:get_target_location_and_velocity() end

-- Gets the system time of the last update from the follow-me target.
---@return uint32_t_ud -- Time in milliseconds.
function follow:get_last_update_ms() end

-- Returns true if the vehicle currently has a follow-me target.
---@return boolean
function follow:have_target() end

-- General scripting utilities.
scripting = {}

-- Restarts all running Lua scripts.
function scripting:restart_all() end

-- Lists the contents of a directory on the SD card.
---@param directoryname string -- The path of the directory to list (e.g., "/APM/scripts/").
---@return table|nil -- A table of filenames.
---@return string|nil -- An error string if the operation fails.
function dirlist(directoryname) end

-- Removes (deletes) a file from the SD card.
---@param filename string -- The path of the file to remove.
---@return boolean|nil -- True on success.
---@return nil|string -- An error string on failure.
---@return integer -- An error number on failure.
function remove(filename) end

-- MAVLink message interface for sending and receiving binary MAVLink messages.
mavlink = {}

-- Initializes the scripting MAVLink buffer. This must be called before sending or receiving MAVLink messages.
---@param msg_queue_length uint32_t_ud|integer|number -- The maximum number of incoming messages to queue.
---@param num_rx_msgid uint32_t_ud|integer|number -- The number of unique message IDs you intend to receive.
function mavlink:init(msg_queue_length, num_rx_msgid) end

-- Registers a specific MAVLink message ID to be received by the script.
---@param msg_id number -- The message ID to register (e.g., from `mavlink_msgs.get_msgid("HEARTBEAT")`).
---@return boolean -- False if the ID has already been registered.
function mavlink:register_rx_msgid(msg_id) end

-- Receives a MAVLink message that has been registered for reception.
---@return string -- The raw message payload as a binary string.
---@return number -- The MAVLink channel it was received on.
---@return uint32_t_ud -- The timestamp of reception.
function mavlink:receive_chan() end

-- Sends a pre-encoded MAVLink message.
-- Example: `mavlink:send_chan(chan, mavlink_msgs.encode("HEARTBEAT", {params...}))`
---@param chan integer -- The MAVLink channel to send on.
---@param msgid integer -- The message ID.
---@param message string -- The encoded message payload as a binary string.
---@return boolean -- True on success.
function mavlink:send_chan(chan, msgid, message) end

-- Blocks a specific MAV_CMD from being processed by the autopilot's main command handler.
---@param comand_id integer -- The MAV_CMD ID to block.
---@return boolean
function mavlink:block_command(comand_id) end

-- Interface for the geofence system.
fence = {}

-- Gets the system time at which the current geofence breach started.
---@return uint32_t_ud -- Time in milliseconds.
function fence:get_breach_time() end

-- Gets the system time at which the geofence margin was first breached.
---@return uint32_t_ud -- Time in milliseconds.
function fence:get_margin_breach_time() end

-- Gets a bitmask of all currently breached fences.
---@return integer -- The breach bitmask.
---| 1 # Maximum altitude
---| 2 # Circle
---| 4 # Polygon
---| 8 # Minimum altitude
function fence:get_breaches() end

-- Gets a bitmask of all currently breached fence margins.
---@return integer -- The margin breach bitmask.
function fence:get_margin_breaches() end

-- Gets the shortest distance to a specific type of geofence.
---@param fence_type integer -- The fence type bitmask.
---@return number -- The distance in meters.
function fence:get_breach_distance(fence_type) end

-- A data structure for holding file system statistics, similar to a Unix `stat` struct.
---@class (exact) stat_t_ud
local stat_t_ud = {}

---@return stat_t_ud
function stat_t() end

-- get creation time
---@return uint32_t_ud -- Time in seconds since the Unix epoch.
function stat_t_ud:ctime() end
-- get last access time
---@return uint32_t_ud -- Time in seconds since the Unix epoch.
function stat_t_ud:atime() end
-- get last modification time
---@return uint32_t_ud -- Time in seconds since the Unix epoch.
function stat_t_ud:mtime() end
-- get file mode
---@return integer
function stat_t_ud:mode() end
-- get file size in bytes
---@return uint32_t_ud
function stat_t_ud:size() end
-- return true if this is a directory
---@return boolean
function stat_t_ud:is_directory() end

-- Interface for the Real-Time Clock (RTC).
rtc = {}

-- Converts GMT date and time fields to a Unix epoch timestamp.
---@param year integer -- e.g., 2023
---@param month integer -- 1-12
---@param day integer -- 1-31
---@param hour integer -- 0-23
---@param min integer -- 0-59
---@param sec integer -- 0-59
---@return uint32_t_ud -- Time in seconds since 1970.
function rtc:date_fields_to_clock_s(year, month, day, hour, min, sec) end

-- Breaks a Unix epoch timestamp into its GMT date and time components.
---@param param1 uint32_t_ud|integer|number -- Time in seconds since 1970.
---@return integer|nil year
---@return integer|nil month
---@return integer|nil day
---@return integer|nil hour
---@return integer|nil min
---@return integer|nil sec
---@return integer|nil weekday (0-6, Sunday is 0)
function rtc:clock_s_to_date_fields(param1) end

-- File system interface.
fs = {}

-- Gets statistics for a specific file or directory.
---@param param1 string -- The path to the file or directory.
---@return stat_t_ud|nil -- A stat object, or nil on error.
function fs:stat(param1) end

-- Formats the SD card. This is an asynchronous operation. Use `get_format_status()` to check its progress.
---@return boolean
function fs:format() end

-- Gets the current status of an SD card format operation.
---@return integer -- 0=NOT_STARTED, 1=PENDING, 2=IN_PROGRESS, 3=SUCCESS, 4=FAILURE
function fs:get_format_status() end

-- Calculates the CRC32 checksum of a file.
---@param file_name string
---@return uint32_t_ud|nil
function fs:crc32(file_name) end

-- Networking utilities.
networking = {}

-- Converts a 32-bit integer IPv4 address to its string representation.
---@param ip4addr uint32_t_ud|integer|number
---@return string
function networking:address_to_str(ip4addr) end

-- Gets the active network gateway address.
---@return uint32_t_ud
function networking:get_gateway_active() end

-- Gets the active network subnet mask.
---@return uint32_t_ud
function networking:get_netmask_active() end

-- Gets the active network IP address.
---@return uint32_t_ud
function networking:get_ip_active() end

-- Visual odometry interface.
visual_odom = {}

-- Returns true if the visual odometry system is healthy.
---@return boolean
function visual_odom:healthy() end

-- Returns the quality of the visual odometry system.
---@return integer -- Quality as a percentage (1-100), or 0 if unknown.
function visual_odom:quality() end

-- Interface for smart servo telemetry.
servo_telem = {}

-- Gets the telemetry data for a specific servo.
---@param servo_index integer -- The 0-indexed servo number.
---@return AP_Servo_Telem_Data_ud|nil -- The telemetry data object, or nil if not available.
function servo_telem:get_telem(servo_index) end

-- A data structure for holding telemetry data from a single smart servo.
---@class AP_Servo_Telem_Data_ud
local AP_Servo_Telem_Data_ud = {}

-- Get timestamp of last telemetry update
---@return uint32_t_ud -- milliseconds since boot
function AP_Servo_Telem_Data_ud:last_update_ms() end
-- Get type-specific status flags
---@return integer|nil -- flags or nil if not available
function AP_Servo_Telem_Data_ud:status_flags() end
-- Get PCB temperature
---@return integer|nil -- temperature in centidegrees or nil if not available
function AP_Servo_Telem_Data_ud:pcb_temperature_cdeg() end
-- Get motor temperature
---@return integer|nil -- temperature in centidegrees or nil if not available
function AP_Servo_Telem_Data_ud:motor_temperature_cdeg() end
-- Get duty cycle
---@return integer|nil -- duty cycle 0% to 100% or nil if not available
function AP_Servo_Telem_Data_ud:duty_cycle() end
-- get current
---@return number|nil -- current in amps or nil if not available
function AP_Servo_Telem_Data_ud:current() end
-- get voltage
---@return number|nil -- voltage in volts or nil if not available
function AP_Servo_Telem_Data_ud:voltage() end
-- get speed
---@return number|nil -- speed in degrees per second or nil if not available
function AP_Servo_Telem_Data_ud:speed() end
-- get force
---@return number|nil -- force in newton meters or nil if not available
function AP_Servo_Telem_Data_ud:force() end
-- get measured position
---@return number|nil -- measured position in degrees or nil if not available
function AP_Servo_Telem_Data_ud:measured_position() end
-- get commanded position
---@return number|nil -- commanded position in degrees or nil if not available
function AP_Servo_Telem_Data_ud:command_position() end

-- Simulator-specific bindings for SITL.
sim = {}

-- Sets the pose of a simulated vehicle. Requires `AHRS_EKF_TYPE=10` (SITL).
---@param instance integer -- 0 for the first vehicle.
---@param loc Location_ud -- The new location.
---@param orient Quaternion_ud -- The new orientation.
---@param velocity_bf Vector3f_ud -- The new body frame velocity.
---@param gyro_rads Vector3f_ud -- The new gyro body rate in rad/s.
---@return boolean
function sim:set_pose(instance, loc, orient, velocity_bf, gyro_rads) end

-- A data structure representing a parameter in a CRSF menu.
---@class (exact) CRSFParameter_ud
local CRSFParameter_ud = {}

-- Creates a new CRSF menu parameter object.
---@return CRSFParameter_ud
function CRSFParameter() end

-- Gets the ID of the parameter.
---@return integer
function CRSFParameter_ud:id() end
-- Gets the contents of the parameter as a packed binary string.
---@return string
function CRSFParameter_ud:data() end

-- A data structure representing a menu in the CRSF system.
---@class (exact) CRSFMenu_ud
local CRSFMenu_ud = {}

-- Creates a new CRSF menu object with a pre-sized capacity.
---@param size integer -- The number of parameters this menu will hold.
---@return CRSFMenu_ud
function CRSFMenu(size) end

-- Gets the ID of the menu.
---@return integer
function CRSFMenu_ud:id() end
-- Gets the name of the menu.
---@return string
function CRSFMenu_ud:name() end
-- Gets the number of parameters in the menu.
---@return integer
function CRSFMenu_ud:num_params() end
-- Adds a new parameter to the menu.
---@param data string -- The binary encoded parameter data.
---@return CRSFParameter_ud|nil -- The newly created parameter object.
function CRSFMenu_ud:add_parameter(data) end
-- Adds a new sub-menu to this menu.
---@param name string -- The name for the new sub-menu.
---@return CRSFMenu_ud|nil -- The newly created menu object.
function CRSFMenu_ud:add_menu(name) end

-- Interface for creating and managing CRSF (Crossfire) menus.
-- This allows scripts to create custom menus that can be accessed and modified from a compatible remote control.
crsf = {}

-- Adds a new top-level CRSF menu.
---@param name string -- The name of the menu to add.
---@return CRSFMenu_ud|nil -- The new CRSF menu object.
function crsf:add_menu(name) end

-- Gets a pending CRSF menu event (e.g., a user changing a parameter value from their radio).
---@param events integer -- A bitmask of events to listen for.
---| '1' # PARAMETER READ
---| '2' # PARAMETER WRITE
---@return integer -- The parameter ID of the event.
---@return string -- The binary encoded response payload.
---@return integer -- The bitmask of triggered events.
function crsf:get_menu_event(events) end

-- Sends a response to a CRSF parameter write request.
---@param data string -- The binary encoded response payload.
---@return boolean -- True if the response was sent successfully.
function crsf:send_write_response(data) end

-- The DroneCAN_Handle object is the primary tool for interacting with the DroneCAN bus.
-- It allows for creating subscriptions to specific message types and for sending messages.
---@class DroneCAN_Handle_ud
local DroneCAN_Handle_ud = {}

-- Creates a DroneCAN_Handle, which is required for all other DroneCAN message operations.
-- This object encapsulates the necessary information to send or receive a specific DroneCAN message.
-- Example from DroneCAN_test.lua: `local dc_handle = DroneCAN_Handle(0, SIGNATURE, ID, true)`
---@param driver_index number -- DroneCAN driver index (e.g., 0 for CAN1, 1 for CAN2). This must correspond to a driver enabled with CAN_Dx_PROTOCOL = 10 or 12.
---@param signature uint64_t_ud -- The unique 64-bit signature of the message type.
---@param data_type number -- The data type ID of the message.
---@param canfd? boolean -- Optional. If true, messages will be sent as CAN FD frames, which allows for larger payloads. Defaults to false.
---@return DroneCAN_Handle_ud -- The created DroneCAN handle object.
function DroneCAN_Handle(driver_index, signature, data_type, canfd) end

-- Subscribes the handle to receive messages that match its signature and data type.
-- This must be called before `check_message` will return any broadcast or request messages for this handle.
-- Example: `nodestatus_handle:subscribe()`
---@return boolean -- Returns true on success.
function DroneCAN_Handle_ud:subscribe() end

-- Checks if a new message has been received for a subscribed handle.
-- This function is non-blocking and should be polled periodically in your script's main loop to process incoming data.
-- Example: `local payload, nodeid = airspeed_handle:check_message()`
---@return string|nil payload -- The raw payload of the message as a binary string, or nil if no new message is available.
---@return number|nil nodeid -- The node ID of the device that sent the message, or nil.
---@return uint64_t_ud|nil timestamp -- The timestamp of the message in microseconds since 1/1/1970, or nil.
---@return boolean|nil canfd -- True if the message was received as a CANFD frame, or nil.
function DroneCAN_Handle_ud:check_message() end

-- Sends a DroneCAN request (a unicast message) to a specific target node.
-- This is used for point-to-point communication. The target node is expected to send a response.
-- Example: `param_handle:request(TARGET_NODE:get(), payload)`
---@param target_node number -- The node ID of the device to send the request to.
---@param payload string -- The payload for the message, packed as a binary string.
---@return boolean -- Returns true if the request was sent successfully.
function DroneCAN_Handle_ud:request(target_node, payload) end

-- Sends a DroneCAN broadcast message to all nodes on the bus.
-- This is used for one-to-many communication where no response is expected.
-- Example: `dc_handle:broadcast(payload)`
---@param payload string -- The payload for the message, packed as a binary string.
---@return boolean -- Returns true if the broadcast was sent successfully.
function DroneCAN_Handle_ud:broadcast(payload) end




================================================
File: drivers/BattMon_ANX.lua
================================================
--[[ 
 device driver for ANX CAN battery monitor
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 45
local PARAM_TABLE_PREFIX = "BATT_ANX_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Type conversion functions, little endian
function get_uint16(frame, ofs)
    return frame:data(ofs) + (frame:data(ofs + 1) << 8)
end

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add param table')

--[[
  // @Param: BATT_ANX_ENABLE
  // @DisplayName: Enable ANX battery support
  // @Description: Enable ANX battery support
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local BATT_ANX_ENABLE = bind_add_param('ENABLE', 1, 0)

--[[
  // @Param: BATT_ANX_CANDRV
  // @DisplayName: Set ANX CAN driver
  // @Description: Set ANX CAN driver
  // @Values: 0:None,1:1stCANDriver,2:2ndCanDriver
  // @User: Standard
--]]
local BATT_ANX_CANDRV     = bind_add_param('CANDRV',     2, 1)

--[[
  // @Param: BATT_ANX_INDEX
  // @DisplayName: ANX CAN battery index
  // @Description: ANX CAN battery index
  // @Range: 1 10
  // @User: Standard
--]]
local BATT_ANX_INDEX     = bind_add_param('INDEX',     3, 1)

--[[
  // @Param: BATT_ANX_OPTIONS
  // @DisplayName: ANX CAN battery options
  // @Description: ANX CAN battery options
  // @Bitmask: 0:LogAllFrames
  // @User: Advanced
--]]
local BATT_ANX_OPTIONS   = bind_add_param('OPTIONS',    4, 0)

local OPTION_LOGALLFRAMES = 0x01

if BATT_ANX_ENABLE:get() == 0 then
   gcs:send_text(0, string.format("BATT_ANX: disabled"))
   return
end

-- Register for the CAN drivers
local driver

local CAN_BUF_LEN = 25
if BATT_ANX_CANDRV:get() == 1 then
   driver = CAN.get_device(CAN_BUF_LEN)
elseif BATT_ANX_CANDRV:get() == 2 then
   driver = CAN.get_device2(CAN_BUF_LEN)
end

if not driver then
    gcs:send_text(0, string.format("BATT_ANX: Failed to load driver"))
    return
end

local assembly = {}
assembly.num_frames = 0
assembly.frames = {}

--[[
   xmodem CRC implementation thanks to https://github.com/cloudwu/skynet
   under MIT license
--]]
local XMODEMCRC16Lookup = {
   0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
   0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
   0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
   0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
   0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
   0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
   0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
   0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
   0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
   0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
   0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
   0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
   0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
   0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
   0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
   0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
   0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
   0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
   0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
   0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
   0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
   0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
   0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
   0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
   0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
   0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
   0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
   0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
   0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
   0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
   0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
   0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
}

local function crc_ANX(bytes)
   -- ANX CRC uses xmodem with a seed of 0xa635
   local crc = 0xa635
	for i=1,#bytes do
		local b = string.byte(bytes,i,i)
		crc = ((crc<<8) & 0xffff) ~ XMODEMCRC16Lookup[(((crc>>8)~b) & 0xff) + 1]
	end
    return crc
end

local frame_count = 0

local function log_can_frame(frame)
   logger.write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                frame:id(),
                frame:dlc(),
                frame_count,
                frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                frame:data(4), frame:data(5), frame:data(6), frame:data(7))
   frame_count = frame_count + 1
end
 

local function parse_volt_frame(payload)
   if #payload < 12 then
      -- invalid length
      return
   end
   local total_volt, current, rem_cap, temperature, _ = string.unpack("<HhHhH", string.sub(payload, 1, 10))
   total_volt = total_volt * 0.01
   -- it is a discharge, so use minus current
   current = -current * 0.01
   rem_cap = rem_cap * 0.1
   temperature = temperature * 0.1
   local num_cells = (#payload - 10) / 2
   local cells = {}
   for i = 1, num_cells do
      cells[i] = string.unpack("<H", string.sub(payload, 11+(i-1)*2, 11+i*2))
      cells[i] = cells[i]
   end
   -- API allows for up to 32 cells, but battery backend is more limited
   if num_cells > 32 then
      num_cells = 32
   end

   local state = BattMonitorScript_State()
   state:healthy(true)
   state:voltage(total_volt)
   state:cell_count(num_cells)
   state:capacity_remaining_pct(math.floor(rem_cap))
   for i = 1, num_cells do
      state:cell_voltages(i-1, cells[i])
   end
   state:current_amps(current)
   state:temperature(temperature)

   battery:handle_scripting(BATT_ANX_INDEX:get()-1, state)
end


--[[
   process a set of frames for a whole packet
--]]
local function process_frames(msg_type_id)
   local bytes = ""
   for i = 1, assembly.num_frames do
      local dlc = assembly.frames[i]:dlc()
      for ofs = 1, dlc do
         bytes = bytes .. string.char(assembly.frames[i]:data(ofs-1))
      end
   end
   local crc = string.unpack("<H", string.sub(bytes, 1, 2))
   local payload = string.sub(bytes, 3, #bytes)
   if crc ~= crc_ANX(payload) then
      return
   end
   -- message types with cell voltages are from 721 to 727
   if msg_type_id >= 721 and msg_type_id <= 727 then
      parse_volt_frame(payload)
   end
end

--[[
   read from CAN bus, updating battery backend
--]]
local function read_can()
   while true do
      local frame = driver:read_frame()
      if not frame then
         return
      end
      if BATT_ANX_OPTIONS:get() & OPTION_LOGALLFRAMES ~= 0 then
         log_can_frame(frame)
      end
      if not frame:isExtended() then
         -- only want extended frames
         break
      end
      local id = frame:id_signed()
      -- local sender_id = id&0x7
      local last_pkt_id = (id>>3) & 1
      local pkt_count = (id>>4) & 0x3F
      -- local pkt_id = (id>>10) & 0x7f
      -- local trans_type = (id>>17) & 0x03
      local msg_type_id = (id>>19) & 0x3FF

      if pkt_count ~= assembly.num_frames then
         -- reset, non-contiguous packets
         assembly.num_frames = 0
      end

      assembly.num_frames = assembly.num_frames + 1
      assembly.frames[assembly.num_frames] = frame
      if last_pkt_id == 1 then
         process_frames(msg_type_id)
         -- reset for next frame
         assembly.num_frames = 0
      end
   end
end

function update()
   read_can()
   return update,10
end

gcs:send_text(MAV_SEVERITY.INFO, "BATT_ANX: Started")

return update()



================================================
File: drivers/BattMon_ANX.md
================================================
# ANX Battery Driver

This driver implements support for the ANX CAN battery protocol

# Parameters

The script used the following parameters:

## BATT_ANX_ENABLE

this must be set to 1 to enable the driver

## BATT_ANX_CANDRV

This sets the scripting CAN driver to use, this should be 1 or 2.

## BATT_ANX_INDEX

This sets the battery monitor index to use. Set to 1 for BATT1, 2 for
BATT2 etc



================================================
File: drivers/EFI_DLA.lua
================================================
--[[
 DLA serial EFI protocol

 Note that this protocol is gap framed, no CRC

 https://www.austars-model.com/dla-232cc-uavuas-engine-optional-one-key-startauto-startergenerator_g17937.html
--]]

local PARAM_TABLE_KEY = 41
local PARAM_TABLE_PREFIX = "EFI_DLA_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: EFI_DLA_ENABLE
  // @DisplayName: EFI DLA enable
  // @Description: Enable EFI DLA driver
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
EFI_DLA_ENABLE = bind_add_param("ENABLE", 1, 0)

--[[
  // @Param: EFI_DLA_LPS
  // @DisplayName: EFI DLA fuel scale
  // @Description: EFI DLA litres of fuel per second of injection time
  // @Range: 0.00001 1
  // @Units: litres
  // @User: Standard
--]]
EFI_DLA_LPS = bind_add_param("LPS", 2, 0.001)

if EFI_DLA_ENABLE:get() ~= 1 then
   return
end

local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_DLA: unable to find scripting serial")
   return
end
uart:begin(115200)

local efi_backend = efi:get_backend(0)
if not efi_backend then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_DLA: unable to find EFI backend")
   return
end

--[[
   discard n bytes
--]]
local function discard_bytes(n)
   for _ = 1, n do
      uart:read()
   end
end

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      ret = ret .. string.char(uart:read())
   end
   return ret
end

local state = {}
state.last_read_us = uint32_t(0)
state.total_fuel_cm3 = 0.0

--[[
   check for input and parse data
--]]
local function check_input()
   local n_bytes = uart:available():toint()
   --gcs:send_text(MAV_SEVERITY.INFO, string.format("n_bytes=%u %.2f", n_bytes, millis():tofloat()*0.001))
   if n_bytes < 82 then
      return
   end
   if n_bytes > 82 then
      discard_bytes(n_bytes)
      return
   end

   state.seconds, state.pw1, state.pw2 = string.unpack("<HHH", read_bytes(6))
   state.rpm, state.adv_deg, state.squirt = string.unpack("<HhB", read_bytes(5))
   state.engine, state.afrtgt1, state.afrtgt2 = string.unpack("<BBB", read_bytes(3))
   state.wbo2_en1, state.wbo2_en2, state.baro = string.unpack("<BBh", read_bytes(4))
   state.map, state.mat, state.clt = string.unpack("<hhh", read_bytes(6))
   state.tps, state.batt = string.unpack("<hh", read_bytes(4))

   state.last_read_us = micros()

   -- discard the rest
   discard_bytes(uart:available():toint())
end

--[[
   request more data
--]]
local function request_data()
   --uart:write(string.byte("a"))
   uart:write(0x61)
end

local function farenheight_to_C(v)
   return (v + 459.67) * 0.55556
end

--[[
   update EFI state
--]]
local function update_EFI()
   if state.last_read_us == uint32_t(0) then
      return
   end
   local cylinder_state = Cylinder_Status()
   local efi_state = EFI_State()

   -- 4.3.x incorrectly uses C instead of kelvin
   -- local C_TO_KELVIN = 273.2

   cylinder_state:cylinder_head_temperature(farenheight_to_C(state.clt*0.1))
   cylinder_state:exhaust_gas_temperature(farenheight_to_C(state.mat*0.1))
   cylinder_state:ignition_timing_deg(state.adv_deg*0.1)

   local inj_time_ms = (state.pw1+state.pw2)*0.001
   cylinder_state:injection_time_ms(inj_time_ms)

   efi_state:engine_speed_rpm(state.rpm)

   efi_state:atmospheric_pressure_kpa(state.baro*0.1)
   efi_state:intake_manifold_pressure_kpa(state.map*0.1)
   efi_state:intake_manifold_temperature(farenheight_to_C(state.mat*0.1))
   efi_state:throttle_position_percent(math.floor(state.tps*0.1))
   efi_state:ignition_voltage(state.batt*0.1)

   local now_us = micros()
   local dt = (now_us - state.last_read_us):tofloat()*1.0e-6
   state.last_read_us = now_us

   local revs = state.rpm * 60.0 * dt
   local inj_time = revs * inj_time_ms * 0.001
   local fuel_used_cm3 = EFI_DLA_LPS:get() * 0.001 * inj_time

   state.total_fuel_cm3 = state.total_fuel_cm3 + fuel_used_cm3

   efi_state:fuel_consumption_rate_cm3pm((fuel_used_cm3 / dt) * 60.0)
   efi_state:estimated_consumed_fuel_volume_cm3(state.total_fuel_cm3)
   
   efi_state:cylinder_status(cylinder_state)
   efi_state:last_updated_ms(millis())

   -- Set the EFI_State into the EFI scripting driver
   efi_backend:handle_scripting(efi_state)
end


--[[
   main update function
--]]
local function update()
   check_input()
   update_EFI()
   request_data()

   return update, 100
end

gcs:send_text(MAV_SEVERITY.INFO, "EFI_DLA: loaded")

return update()



================================================
File: drivers/EFI_DLA.md
================================================
# EFI DLA Driver

This driver implements support for the DLA EFI serial protocol for
this system:

https://www.austars-model.com/dla-232cc-uavuas-engine-optional-one-key-startauto-startergenerator_g17937.html

# Parameters

The script used the following parameters:

## EFI_DLA_ENABLE

this must be set to 1 to enable the driver

## EFI_DLA_LPS

This sets the fuel consumption rate in litres per second of injector
time. This will need to be tuned per engine to give the right value
for fuel usage and total fuel

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7
 - EFI_DLA_ENABLE should be set to 1
 - SERIALn_PROTOCOL should be set to 28 for the connected EFI serial
 - RPM_TYPE1 should be set to 3
 - ICE_ENABLE should be set to 1

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_DLA parameters will appear and should be set
according to the parameter list above.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature, injection timing, engine load, fuel
consumption rate, throttle position atmospheric pressure and ECU
voltage.

Note that this EFI system only sends data when the enable PWM enable
signal is high. If that is hooked to the ignition control in ArduPilot
ICE system then you won't see any data until you start the engine.





================================================
File: drivers/EFI_HFE.lua
================================================
--[[ 
  EFI Scripting backend driver for HFE based on HFEDCN0191 Rev E
--]]
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: undefined-field
---@diagnostic disable: missing-parameter
---@diagnostic disable: need-check-nil


-- Check Script uses a miniumum firmware version
local SCRIPT_AP_VERSION = 4.3
local SCRIPT_NAME       = "EFI: HFE CAN"

local VERSION = FWVersion:major() + (FWVersion:minor() * 0.1)

assert(VERSION >= SCRIPT_AP_VERSION, string.format('%s Requires: %s:%.1f. Found Version: %s', SCRIPT_NAME, FWVersion:type(), SCRIPT_AP_VERSION, VERSION))

local MAV_SEVERITY_ERROR = 3

PARAM_TABLE_KEY = 37
PARAM_TABLE_PREFIX = "EFI_HFE_"

K_THROTTLE = 70
K_IGNITION = 67

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

function get_time_sec()
    return millis():tofloat() * 0.001
end

-- Type conversion functions
function get_uint8(frame, ofs)
    return frame:data(ofs)
end

function get_uint16(frame, ofs)
    return frame:data(ofs+1) + (frame:data(ofs) << 8)
end

function constrain(v, vmin, vmax)
    if v < vmin then
        v = vmin
    end
    if v > vmax then
        v = vmax
    end
    return v
end

local efi_backend = nil

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'could not add EFI_HFE param table')

local EFI_HFE_ENABLE = bind_add_param('ENABLE',  1, 0)
local EFI_HFE_RATE_HZ  = bind_add_param('RATE_HZ',  2, 200)    -- Script update frequency in Hz
local EFI_HFE_ECU_IDX = bind_add_param('ECU_IDX',  3, 0)   -- ECU index on CAN bus, 0 for automatic
local EFI_HFE_FUEL_DTY = bind_add_param('FUEL_DTY',  4, 740)   -- fuel density, g/litre
local EFI_HFE_REL_IDX = bind_add_param('REL_IDX',  5, 0)   -- relay number for engine enable
local EFI_HFE_CANDRV = bind_add_param('CANDRV',  6, 0)   -- CAN driver number

local ICE_PWM_IGN_ON = bind_param("ICE_PWM_IGN_ON")

if EFI_HFE_ENABLE:get() == 0 then
   return
end

-- Register for the CAN drivers
local CAN_BUF_LEN = 25
if EFI_HFE_CANDRV:get() == 1 then
   driver1 = CAN.get_device(CAN_BUF_LEN)
elseif EFI_HFE_CANDRV:get() == 2 then
   driver1 = CAN.get_device2(CAN_BUF_LEN)
end

if not driver1 then
    gcs:send_text(0, string.format("EFI_HFE: Failed to load driver"))
    return
end


local now_s = get_time_sec()

--[[
   EFI Engine Object
--]]
local function engine_control(driver)
    local self = {}

    -- Build up the EFI_State that is passed into the EFI Scripting backend
    local efi_state = EFI_State()
    local cylinder_state = Cylinder_Status()

    -- private fields as locals
    local rpm = 0
    local air_pressure = 0
    local map_ratio = 0.0
    local last_rpm_t = get_time_sec()
    local last_state_update_t = get_time_sec()
    local throttle_pos = 0.0
    local last_thr_t = get_time_sec()
    local C_TO_KELVIN = 273.2
    local fuel_flow_gph = 0.0
    local fuel_total_g = 0.0
    local fuel_press = 0.0
    local last_fuel_s = 0.0
    local ecu_voltage = 0.0
    local injector_duty = 0.0
    local ignition_angle = 0.0

    -- Temperature Data Structure
    local temps = {}
    temps.egt = 0.0        -- Engine Gas Temperature
    temps.iat = 0.0        -- inlet air temperature
    temps.mat = 0.0        -- manifold air temperature
    temps.cht = 0.0        -- cylinder head temperature

    -- read telemetry packets
    function self.update_telemetry()
        local max_packets = 25
        local count = 0
        while count < max_packets do
            frame = driver:read_frame()
            count = count + 1
            if not frame then
                break
            end

            -- All Frame IDs for this EFI Engine are in the 29-bit extended address space
            if frame:isExtended() then
                self.handle_EFI_packet(frame)
            end
        end
        if last_rpm_t > last_state_update_t then
           -- update state if we have an updated RPM
           last_state_update_t = last_rpm_t
           self.set_EFI_State()
        end
    end

    -- handle an EFI packet
    function self.handle_EFI_packet(frame)
       local id = frame:id_signed()
       if id >> 24 ~= 0x08 then
          -- not from ECU
          return
       end
       local ecu = id & 0xff
       if ecu ~= 0 and EFI_HFE_ECU_IDX:get() == 0 then
          EFI_HFE_ECU_IDX:set(ecu)
          gcs:send_text(0, string.format("EFI_HFE: found ECU %u", ecu))
       end
       if ecu ~= EFI_HFE_ECU_IDX:get() then
          -- not from correct ECU
          return
       end
       local cmd = (id >> 16) & 0xff
       if cmd == 0x0 then
          -- fast telemetry
          throttle_pos = get_uint8(frame, 0)
          rpm = get_uint16(frame, 1)
          last_rpm_t = get_time_sec()
       elseif cmd == 0x01 then
          -- slow telem0
          air_pressure = get_uint16(frame, 5) * 2
          map_ratio = get_uint8(frame, 7) * 0.01
          temps.cht = get_uint8(frame,3) - 10.0
       elseif cmd == 0x02 then
          -- slow telem1
          temps.iat = get_uint8(frame, 0)
          ecu_voltage = get_uint8(frame, 6) * 0.1
          fuel_press = get_uint16(frame,1)*20.0
       elseif cmd == 0x03 then
          -- slow telem2
          temps.mat = (1.5*get_uint8(frame, 1)) - 128
          fuel_flow_gph = get_uint16(frame, 6)
          if last_fuel_s > 0 then
             local dt = now_s - last_fuel_s
             local fuel_gps = fuel_flow_gph / 3600.0
             fuel_total_g = fuel_total_g + fuel_gps * dt
          end
          injector_duty = get_uint16(frame,2)
          last_fuel_s = now_s
          ignition_angle = get_uint8(frame,4)*2.0
       end
    end

    -- Build and set the EFI_State that is passed into the EFI Scripting backend
    function self.set_EFI_State()
       -- Cylinder_Status
       cylinder_state:cylinder_head_temperature(temps.cht + C_TO_KELVIN)
       cylinder_state:exhaust_gas_temperature(temps.mat)
       cylinder_state:ignition_timing_deg(ignition_angle)
       if rpm > 0 then
          cylinder_state:injection_time_ms((60.0/rpm)*1000*injector_duty)
       else
          cylinder_state:injection_time_ms(0)
       end

       efi_state:engine_speed_rpm(uint32_t(rpm))

       efi_state:atmospheric_pressure_kpa(air_pressure*0.001)
       efi_state:intake_manifold_pressure_kpa(air_pressure*0.001*map_ratio)
       efi_state:intake_manifold_temperature(temps.mat + C_TO_KELVIN)
       efi_state:throttle_position_percent(math.floor((throttle_pos*100/255)+0.5))
       efi_state:ignition_voltage(ecu_voltage)
       efi_state:fuel_pressure(fuel_press*0.001)
       efi_state:fuel_pressure_status(1) -- Fuel_Pressure_Status::OK

       local gram_to_cm3 = EFI_HFE_FUEL_DTY:get() * 0.001
       efi_state:fuel_consumption_rate_cm3pm((fuel_flow_gph/60.0) * gram_to_cm3)
       efi_state:estimated_consumed_fuel_volume_cm3(fuel_total_g * gram_to_cm3)

       -- copy cylinder_state to efi_state
       efi_state:cylinder_status(cylinder_state)

       efi_state:last_updated_ms(millis())

        -- Set the EFI_State into the EFI scripting driver
        efi_backend:handle_scripting(efi_state)
    end

    -- send throttle
    function self.send_throttle()
       if now_s - last_thr_t < 0.02 then
          -- limit to 50Hz
          return
       end
       last_thr_t = now_s
       local thr = SRV_Channels:get_output_scaled(K_THROTTLE)
       local msg = CANFrame()
       msg:id(uint32_t(0x89060000 | EFI_HFE_ECU_IDX:get()))
       msg:data(0,math.floor((thr*255/100)+0.5))
       msg:dlc(2)
       driver:write_frame(msg, 10000)

       -- throttle calibration request, for debug
       --msg = CANFrame()
       --msg:id(uint32_t(0x89050000 | EFI_HFE_ECU_IDX:get()))
       --msg:dlc(0)
       --driver:write_frame(msg, 10000)

       -- map K_IGNITION to relay for enable of engine
       local relay_idx = EFI_HFE_REL_IDX:get()
       if relay_idx > 0 then
          local ignition_pwm = SRV_Channels:get_output_pwm(K_IGNITION)
          if ignition_pwm == ICE_PWM_IGN_ON:get() then
             relay:on(relay_idx-1)
          else
             relay:off(relay_idx-1)
          end
       end
    end
    
    -- return the instance
    return self
end -- end function engine_control(driver)

local engine1 = engine_control(driver1)

function update()
   now_s = get_time_sec()

   if not efi_backend then
      efi_backend = efi:get_backend(0)
      if not efi_backend then
         return
      end
   end

   -- Parse Driver Messages
   engine1.update_telemetry()
   engine1.send_throttle()
end

gcs:send_text(0, SCRIPT_NAME .. string.format(" loaded"))

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, 1000 / EFI_HFE_RATE_HZ:get()
end

-- start running update loop
return protected_wrapper()



================================================
File: drivers/EFI_HFE.md
================================================
# EFI HFE Driver

This driver implements support for the HFE International range of EFI
CAN engine control units. It supports monitoring and control of HFE
engines on fixed wing aircraft. This driver assumes you are using the
ICE subsystem in fixed wing aircraft for engine control.

# Parameters

The script used the following parameters:

## EFI_HFE_ENABLE

this must be set to 1 to enable the driver

## EFI_HFE_CANDRV

This sets the CAN scripting driver number to attach to. This is
normally set to 1 to use a CAN driver with CAN_Dx_PROTOCOL=10. To use
the 2nd scripting CAN driver set this to 2 and set CAN_Dx_PROTOCOL=12.

## EFI_HFE_ECU_IDX

This sets the ECU number on the CAN bus. A value of zero means that
the ECU number is auto-detected based on the first ECU seen on the
bus.

## EFI_HFE_RATE_HZ

This sets the update rate of the driver. A value of 200 is reasonable

## EFI_HFE_FUEL_DTY

This sets the fuel density in grams per litre, for fuel consumption
calculations

## EFI_HFE_REL_IDX

This sets a relay number to use for the ECU enable function. if the
ECU requires a high voltage GPIO to enable then you should set a
RELAY_PIN that the ECU enable is attached to and set the relay number
here.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7
 - ICE_ENABLE should be set to 1

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_HFE parameters will appear and should be set
according to the parameter list above.

The ICE start channel will be monitored for starter control.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature, injection timing, engine load, fuel
consumption rate, throttle position atmospheric pressure and ECU
voltage.



================================================
File: drivers/EFI_Halo6000.lua
================================================
--[[ 
  EFI Scripting backend driver for Halo6000 generator
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: undefined-field
---@diagnostic disable: missing-parameter
---@diagnostic disable: need-check-nil

-- Check Script uses a miniumum firmware version
local SCRIPT_AP_VERSION = 4.3
local SCRIPT_NAME       = "EFI: Halo6000 CAN"

local VERSION = FWVersion:major() + (FWVersion:minor() * 0.1)

assert(VERSION >= SCRIPT_AP_VERSION, string.format('%s Requires: %s:%.1f. Found Version: %s', SCRIPT_NAME, FWVersion:type(), SCRIPT_AP_VERSION, VERSION))

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

PARAM_TABLE_KEY = 40
PARAM_TABLE_PREFIX = "EFI_H6K_"

UPDATE_RATE_HZ = 40

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

function get_time_sec()
    return millis():tofloat() * 0.001
end

-- Type conversion functions
function get_uint8(frame, ofs)
    return frame:data(ofs)
end

function get_uint16(frame, ofs)
    return frame:data(ofs) + (frame:data(ofs+1) << 8)
end

function constrain(v, vmin, vmax)
   return math.max(math.min(v,vmax),vmin)
end

local efi_backend = nil

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add EFI_H6K param table')

--[[
  // @Param: EFI_H6K_ENABLE
  // @DisplayName: Enable Halo6000 EFI driver
  // @Description: Enable Halo6000 EFI driver
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local EFI_H6K_ENABLE = bind_add_param('ENABLE',  1, 0)

--[[
  // @Param: EFI_H6K_CANDRV
  // @DisplayName: Halo6000 CAN driver
  // @Description: Halo6000 CAN driver. Use 1 for first CAN scripting driver, 2 for 2nd driver
  // @Values: 0:Disabled,1:FirstCAN,2:SecondCAN
  // @User: Standard
--]]
local EFI_H6K_CANDRV = bind_add_param('CANDRV',  2, 0)   -- CAN driver number

--[[
  // @Param: EFI_H6K_START_FN
  // @DisplayName: Halo6000 start auxilliary function
  // @Description: The RC auxilliary function number for start/stop of the generator. Zero to disable start function
  // @Values: 0:Disabled,300:300,301:301,302:302,303:303,304:304,305:305,306:306,307:307
  // @User: Standard
--]]
local EFI_H6K_START_FN = bind_add_param('START_FN', 3, 0)

--[[
  // @Param: EFI_H6K_TELEM_RT
  // @DisplayName: Halo6000 telemetry rate
  // @Description: The rate that additional generator telemetry is sent
  // @Units: Hz
  // @User: Standard
--]]
local EFI_H6K_TELEM_RT = bind_add_param('TELEM_RT', 4, 2)

--[[
  // @Param: EFI_H6K_FUELTOT
  // @DisplayName: Halo6000 total fuel capacity
  // @Description: The capacity of the tank in litres
  // @Units: litres
  // @User: Standard
--]]
local EFI_H6K_FUELTOT = bind_add_param('FUELTOT', 5, 20)

--[[
  // @Param: EFI_H6K_OPTIONS
  // @DisplayName: Halo6000 options
  // @Description: Halo6000 options
  // @Bitmask: 0:LogAllCanPackets
  // @User: Standard
--]]
local EFI_H6K_OPTIONS = bind_add_param('OPTIONS', 6, 0)

local OPTION_LOGALLFRAMES = 0x01

if EFI_H6K_ENABLE:get() == 0 then
   return
end

-- Register for the CAN drivers
local CAN_BUF_LEN = 25
if EFI_H6K_CANDRV:get() == 1 then
   gcs:send_text(0, string.format("EFI_H6K: attaching to CAN1"))
   driver1 = CAN.get_device(CAN_BUF_LEN)
elseif EFI_H6K_CANDRV:get() == 2 then
   gcs:send_text(0, string.format("EFI_H6K: attaching to CAN2"))
   driver1 = CAN.get_device2(CAN_BUF_LEN)
end

if not driver1 then
    gcs:send_text(0, string.format("EFI_H6K: Failed to load driver"))
    return
end

local frame_count = 0

--[[
   frame logging - can be replayed with Tools/scripts/CAN/CAN_playback.py
--]]
local function log_can_frame(frame)
   logger.write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                frame:id(),
                frame:dlc(),
                frame_count,
                frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                frame:data(4), frame:data(5), frame:data(6), frame:data(7))
   frame_count = frame_count + 1
end

--[[
   EFI Engine Object
--]]
local function engine_control()
    local self = {}

    -- Build up the EFI_State that is passed into the EFI Scripting backend
    local efi_state = EFI_State()
    local cylinder_state = Cylinder_Status()

    -- private fields as locals
    local rpm = 0
    local throttle_pos = 0
    local fuel_pct = 0
    local cyl_temp = 0
    local cool_temp = 0
    local out_volt = 0
    local out_current = 0
    local last_state_update_t = 0
    local last_rpm_t = 0
    local last_telem_update_t = 0
    local last_stop_message_t = 0
    local C_TO_KELVIN = 273.2
    local engine_started = false

    -- read telemetry packets
    function self.update_telemetry()
        local max_packets = 25
        local count = 0
        while count < max_packets do
            frame = driver1:read_frame()
            count = count + 1
            if not frame then
                break
            end

            if EFI_H6K_OPTIONS:get() & OPTION_LOGALLFRAMES ~= 0 then
               log_can_frame(frame)
            end

            -- All Frame IDs for this EFI Engine are in the 11-bit address space
            if not frame:isExtended() then
                self.handle_packet(frame)
            end
        end
        if last_rpm_t > last_state_update_t then
           -- update state if we have an updated RPM
           last_state_update_t = last_rpm_t
           self.set_EFI_State()
        end
    end

    -- handle an EFI packet
    function self.handle_packet(frame)
       local id = frame:id_signed()
       if id == 0x1c1 then
          -- 20Hz telem
          rpm = get_uint16(frame, 0)
          last_rpm_t = get_time_sec()
          throttle_pos = get_uint16(frame, 2)*0.1
          fuel_pct = get_uint8(frame, 4)*0.5
          cyl_temp = get_uint8(frame, 5) - 40
          cool_temp = get_uint8(frame, 6) - 40
       elseif id == 0x1c2 then
          -- 20Hz telem2
          out_volt = get_uint16(frame, 0)*0.2
          out_current = get_uint16(frame, 2)*0.2 - 200.0
       end
    end

    -- Build and set the EFI_State that is passed into the EFI Scripting backend
    function self.set_EFI_State()
       -- Cylinder_Status
       cylinder_state:cylinder_head_temperature(cyl_temp + C_TO_KELVIN)
       cylinder_state:exhaust_gas_temperature(cool_temp + C_TO_KELVIN)
       efi_state:engine_speed_rpm(uint32_t(rpm))
       efi_state:intake_manifold_temperature(cool_temp + C_TO_KELVIN)
       efi_state:throttle_position_percent(math.floor(throttle_pos))
       efi_state:ignition_voltage(out_volt)
       efi_state:estimated_consumed_fuel_volume_cm3((100.0-fuel_pct)*0.01*EFI_H6K_FUELTOT:get()*1000)

       -- copy cylinder_state to efi_state
       efi_state:cylinder_status(cylinder_state)
       
       efi_state:last_updated_ms(millis())

       -- Set the EFI_State into the EFI scripting driver
       efi_backend:handle_scripting(efi_state)

       logger.write('H6K','Curr,Volt,CoolT,CylT,FuelPct', 'fffff',
                    out_current, out_volt, cool_temp, cyl_temp, fuel_pct)
    end

    -- update telemetry output for extra telemetry values
    function self.update_telem_out()
       local rate = EFI_H6K_TELEM_RT:get()
       if rate <= 0 then
          return
       end
       local now = get_time_sec()
       if now - last_telem_update_t < 1.0 / rate then
          return
       end
       last_telem_update_t = now
       gcs:send_named_float('H6K_FUEL', fuel_pct)
       gcs:send_named_float('H6K_CYLT', cyl_temp)
       gcs:send_named_float('H6K_COOLT', cool_temp)
       gcs:send_named_float('H6K_AMPS', out_current)
    end

    -- send a frame with checksum
    function self.write_frame_checksum(msg)
        local sum = 0
        for i = 0, 6 do
        sum = sum + msg:data(i)
        end
        local checksum = (0 - sum) % 0x100
        msg:data(7, checksum)
        msg:dlc(8)
        driver1:write_frame(msg, 10000)
    end

    -- send an engine start command
    function self.send_engine_start()
       local msg = CANFrame()
       msg:id(0x1A0)
       msg:data(0,1)
       msg:data(7,1)
       self.write_frame_checksum(msg)
    end

    -- send an engine stop command
    function self.send_engine_stop()
       local msg = CANFrame()
       msg:id(0x1A0)
       msg:data(0,0)
       self.write_frame_checksum(msg)
       local now = get_time_sec()
       if now - last_stop_message_t > 0.5 then
          last_stop_message_t = now
          gcs:send_text(0, string.format("EFIH6K: stopping generator"))
       end
    end

    -- update starter control
    function self.update_starter()
       local start_fn = EFI_H6K_START_FN:get()
       if start_fn == 0 then
          return
       end
       local start_state = rc:get_aux_cached(start_fn)
       if start_state == nil then
          start_state = 0
       end
       local should_be_running = false
       if start_state == 0 and engine_started then
          engine_started = false
          engine_start_t = 0
          self.send_engine_stop()
       end
       if start_state == 2 and not engine_started then
          engine_started = true
          gcs:send_text(0, string.format("EFIH6K: starting generator"))
          engine_start_t = get_time_sec()
          self.send_engine_start()
          should_be_running = true
       end
       if start_state > 0 and engine_started then
          should_be_running = true
       end
       local min_rpm = 500
       if min_rpm > 0 and engine_started and rpm < min_rpm then
          local now = get_time_sec()
          local dt = now - engine_start_t
          if dt > 2.0 then
             gcs:send_text(0, string.format("EFIH6K: re-starting generator"))
             self.send_engine_start()
             engine_start_t = get_time_sec()
          end
       end
       --[[
          cope with lost engine stop packets
       --]]
       if rpm > min_rpm and not should_be_running then
          engine_started = false
          engine_start_t = 0
          self.send_engine_stop()
       end
    end
    
    -- return the instance
    return self
end -- end function engine_control()

local engine1 = engine_control()

function update()
   if not efi_backend then
      efi_backend = efi:get_backend(0)
      if not efi_backend then
         return
      end
   end

   -- Parse Driver Messages
   engine1.update_telemetry()
   engine1.update_telem_out()
   engine1.update_starter()
end

gcs:send_text(0, SCRIPT_NAME .. string.format(" loaded"))

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY.ERROR, "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, 1000 / UPDATE_RATE_HZ
end

-- start running update loop
return protected_wrapper()



================================================
File: drivers/EFI_Halo6000.md
================================================
# EFI Halo6000 Driver

This driver implements support for the Halo6000 generator for hybrid
multicopters, using CAN protocol.

# Parameters

The script used the following parameters:

## EFI_H6K_ENABLE

this must be set to 1 to enable the driver

## EFI_H6K_CANDRV

This sets the CAN scripting driver number to attach to. This is
normally set to 1 to use a CAN driver with CAN_Dx_PROTOCOL=10. To use
the 2nd scripting CAN driver set this to 2 and set CAN_Dx_PROTOCOL=12.

## EFI_H6K_START_FN

This is the RC option to use to monitor start control. This should be
set to one of the scripting RC options (from 300 to 307). Then an
RCn_OPTION should be set to the same value. When this switch goes high
the generator start function will be sent to the ECU. When this switch
goes low a generator stop will be sent. A value of 0 disables the starter
control.

## EFI_H6K_TELEM_RT

This is the rate in Hz at which NAMED_VALUE_FLOAT messages are used to
send additional telemetry data to the GCS for display to the operator.

## EFI_H6K_FUELTOT

This is the total fuel tank capacity in litres

## EFI_H6K_OPTIONS

This provides additional options. Currently just one option is
available. If you set EFI_H6K_OPTIONS to 1 then all CAN frames will be
logged in the message CANF.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_H6K parameters will appear and should be set
according to the parameter list above.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
and temperatures.



================================================
File: drivers/EFI_NMEA2k.lua
================================================
--[[
   EFI driver using NMEA 2000 marine CAN protocol
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

PARAM_TABLE_KEY = 48
PARAM_TABLE_PREFIX = "EFI_2K_"

local efi_backend = nil
local efi_state = EFI_State()
local cylinder_state = Cylinder_Status()
if not efi_state or not cylinder_state then
   return
end

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter(name)
    assert(p, string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add EFI_2K param table')

--[[
  // @Param: EFI_2K_ENABLE
  // @DisplayName: Enable NMEA 2000 EFI driver
  // @Description: Enable NMEA 2000 EFI driver
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local EFI_2K_ENABLE = bind_add_param('ENABLE',  1, 1)
if EFI_2K_ENABLE:get() < 1 then
   return
end

--[[
  // @Param: EFI_2K_CANDRV
  // @DisplayName: NMEA 2000 CAN driver
  // @Description: NMEA 2000 CAN driver. Use 1 for first CAN scripting driver, 2 for 2nd driver
  // @Values: 0:Disabled,1:FirstCAN,2:SecondCAN
  // @User: Standard
--]]
local EFI_2K_CANDRV = bind_add_param('CANDRV',  2, 0)   -- CAN driver number

--[[
  // @Param: EFI_2K_OPTIONS
  // @DisplayName: NMEA 2000 options
  // @Description: NMEA 2000 driver options
  // @Bitmask: 0:EnableLogging
  // @User: Standard
--]]
EFI_2K_OPTIONS = bind_add_param("OPTIONS", 3, 0)

local OPTION_LOGGING = (1<<0)

--[[
   return true if an option is enabled
--]]
local function option_enabled(option)
   return (EFI_2K_OPTIONS:get() & option) ~= 0
end

-- Register for the CAN drivers
local CAN_BUF_LEN = 25
local can_driver = nil

if EFI_2K_CANDRV:get() == 1 then
   gcs:send_text(MAV_SEVERITY.INFO, string.format("EFI_2K: attaching to CAN1"))
   can_driver = CAN:get_device(CAN_BUF_LEN)
elseif EFI_2K_CANDRV:get() == 2 then
   gcs:send_text(MAV_SEVERITY.INFO, string.format("EFI_2K: attaching to CAN2"))
   can_driver = CAN:get_device2(CAN_BUF_LEN)
end

if not can_driver then
   gcs:send_text(MAV_SEVERITY.ERROR, string.format("EFI_2K: invalid CAN driver"))
   return
end

-- load NMEA_2000 module
local NMEA_2000 = require("NMEA_2000")
if not NMEA_2000 then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_2K: Unable to load NMEA_2000.lua module")
   return
end

--[[
   create PGN table
--]]
local PGN_ENGINE_PARAM_RAPID = 0x1F200
local PGN_ENGINE_PARAM_DYNAMIC = 0x1F201

local PGN_TABLE = {
   [PGN_ENGINE_PARAM_RAPID] = 8,
   [PGN_ENGINE_PARAM_DYNAMIC] = 26
}

NMEA_2000.set_PGN_table(PGN_TABLE)

local frame_count = 0
local state = {}

local function log_frame(frame)
   local id = frame:id()
   logger:write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                id,
                frame:dlc(),
                frame_count,
                frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                frame:data(4), frame:data(5), frame:data(6), frame:data(7))
   frame_count = frame_count + 1
end

--[[
   parse the higher rate engine data, giving RPM and pressure
--]]
local function parse_engine_param_rapid(data)
   state.instance, state.speed, state.boost_presssure, state.tilt, _ = string.unpack("<BHHbH", data)
   if not state.instance then
      return
   end

   efi_state:engine_speed_rpm(uint32_t(state.speed/4))
   efi_state:atmospheric_pressure_kpa(state.boost_presssure*0.001)
   efi_state:cylinder_status(cylinder_state)
   efi_state:last_updated_ms(millis())

   -- Set the EFI_State into the EFI scripting driver
   if efi_backend then
      efi_backend:handle_scripting(efi_state)
   end
end

--[[
   parse the lower rate engine data, giving other engine data
--]]
local function parse_engine_param_dynamic(data)
   state.instance, state.oil_press, state.oil_temp, state.temp_K, state.alt_V, state.fuel_rate, state.engine_s, state.cool_press,
      state.fuel_press, state.res1, state.dstat1, state.dstat2, state.eload, state.etorque = string.unpack("<BHHHhhIHHBHHbb", data)
   if not state.instance then
      return
   end
   efi_state:intake_manifold_temperature(state.temp_K*0.01)
   efi_state:oil_pressure(state.oil_press*0.01*0.001)
   efi_state:oil_temperature(state.oil_temp*0.1)
   cylinder_state:cylinder_head_temperature(state.temp_K*0.01)
   efi_state:ignition_voltage(state.alt_V*0.01)
   efi_state:fuel_consumption_rate_cm3pm(state.fuel_rate*0.1*1000.0/3600.0)
   efi_state:intake_manifold_pressure_kpa(state.cool_press*100*0.001)
   efi_state:fuel_pressure(state.fuel_press)
   efi_state:engine_load_percent(state.eload)
end

function update()
   if EFI_2K_ENABLE:get() < 1 then
      return update, 500
   end
   if not efi_backend then
      efi_backend = efi:get_backend(0)
   end
   if not efi_backend then
      return update, 500
   end

   -- read up to 25 frames per update() call
   for _ = 1, 25 do
      local frame = can_driver:read_frame()
      if not frame then
         break
      end
      if option_enabled(OPTION_LOGGING) then
         log_frame(frame)
      end
      pgn, data = NMEA_2000.parse(frame)
      if pgn then
         if pgn == PGN_ENGINE_PARAM_RAPID then
            parse_engine_param_rapid(data)
         elseif pgn == PGN_ENGINE_PARAM_DYNAMIC then
            parse_engine_param_dynamic(data)
         end
      end
   end

   return update, 2
end

return update()



================================================
File: drivers/EFI_NMEA2k.md
================================================
# NMEA 2000 EFI driver

This driver implements support for marine EFI systems using NMEA 2000
CAN messages.

# Parameters

The script used the following parameters:

## EFI_2K_ENABLE

this must be set to 1 to enable the driver

## EFI_2K_OPTIONS

This sets options for the driver. Currently the only option is to set
EFI_2K_OPTIONS to 1 to enable logging of the raw CAN frames for
debugging purposes.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The NMEA_2000.lua module from
AP_Scripting/modules/ also needs to be put in the APM/SCRIPTS/MODULES directory.

The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7
 - EFI_2K_ENABLE should be set to 1
 - EFI_2K_CANDRV needs to be set to the CAN driver number
 - CAN_Pn_BITRATE needs to be set to 250000
 - CAN_Dn_PROTOOCOL needs to be set to 10 for scripting

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_2K_ENABLE parameters will appear and should be set
according to the parameter list above.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature, exhaust gas temperature, injection timing,
engine load, fuel consumption rate, throttle position atmospheric
pressure and ignition voltage.



================================================
File: drivers/EFI_SkyPower.lua
================================================
--[[ 
Name: EFI Scripting backend driver for SkyPower
Authors: Andrew Tridgell & Josh Henderson

The protocol has high CAN utilization due to CAN packets that are used
internal to the enigne being published externally, as well as being
limited to 500 kbit/s.

CAN_D1_PROTOCOL 10 (Scripting Driver 1)
CAN_P1_DRIVER 1 (First driver)
CAN_D1_BITRATE 500000 (500 kbit/s)

--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: undefined-field
---@diagnostic disable: missing-parameter


-- Check Script uses a miniumum firmware version
local SCRIPT_AP_VERSION = 4.3
local SCRIPT_NAME       = "EFI: Skypower CAN"

local VERSION = FWVersion:major() + (FWVersion:minor() * 0.1)

assert(VERSION >= SCRIPT_AP_VERSION, string.format('%s Requires: %s:%.1f. Found Version: %s', SCRIPT_NAME, FWVersion:type(), SCRIPT_AP_VERSION, VERSION))


local MAV_SEVERITY_ERROR = 3

local K_THROTTLE = 70
local K_HELIRSC = 31

local MODEL_SRE_180 = 0
local MODEL_SP_275 = 1
local MODEL_DEFAULT = MODEL_SRE_180

PARAM_TABLE_KEY = 36
PARAM_TABLE_PREFIX = "EFI_SP_"

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

function get_time_sec()
    return millis():tofloat() * 0.001
end

-- Type conversion functions
function get_uint16(frame, ofs)
    return frame:data(ofs) + (frame:data(ofs + 1) << 8)
end

function constrain(v, vmin, vmax)
    if v < vmin then
        v = vmin
    end
    if v > vmax then
        v = vmax
    end
    return v
end

local efi_backend = nil

-- Setup EFI Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add EFI_SP param table')

--[[
  // @Param: EFI_SP_ENABLE
  // @DisplayName: Enable SkyPower EFI support
  // @Description: Enable SkyPower EFI support
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local EFI_SP_ENABLE     = bind_add_param('ENABLE',     1, 0)

--[[
  // @Param: EFI_SP_CANDRV
  // @DisplayName: Set SkyPower EFI CAN driver
  // @Description: Set SkyPower EFI CAN driver
  // @Values: 0:None,1:1stCANDriver,2:2ndCanDriver
  // @User: Standard
--]]
local EFI_SP_CANDRV     = bind_add_param('CANDRV',     2, 1)    -- CAN driver to use

--[[
  // @Param: EFI_SP_UPDATE_HZ
  // @DisplayName: SkyPower EFI update rate
  // @Description: SkyPower EFI update rate
  // @Range: 10 200
  // @Units: Hz
  // @User: Advanced
--]]
local EFI_SP_UPDATE_HZ  = bind_add_param('UPDATE_HZ',  3, 200)  -- Script update frequency in Hz

--[[
  // @Param: EFI_SP_THR_FN
  // @DisplayName: SkyPower EFI throttle function
  // @Description: SkyPower EFI throttle function. This sets which SERVOn_FUNCTION to use for the target throttle. This should be 70 for fixed wing aircraft and 31 for helicopter rotor speed control
  // @Values: 0:Disabled,70:FixedWing,31:HeliRSC
  // @User: Standard
--]]
local EFI_SP_THR_FN     = bind_add_param('THR_FN',     4, 0)    -- servo function for throttle

--[[
  // @Param: EFI_SP_THR_RATE
  // @DisplayName: SkyPower EFI throttle rate
  // @Description: SkyPower EFI throttle rate. This sets rate at which throttle updates are sent to the engine
  // @Range: 10 100
  // @Units: Hz
  // @User: Advanced
--]]
local EFI_SP_THR_RATE   = bind_add_param('THR_RATE',   5, 50)   -- throttle update rate

--[[
  // @Param: EFI_SP_START_FN
  // @DisplayName: SkyPower EFI start function
  // @Description: SkyPower EFI start function. This is the RCn_OPTION value to use to find the R/C channel used for controlling engine start
  // @Values: 0:Disabled,300:300,301:301,302:302,303:303,304:304,305:305,306:306,307:307
  // @User: Standard
--]]
local EFI_SP_START_FN   = bind_add_param('START_FN',   6, 0)    -- start control function (RC option)

--[[
  // @Param: EFI_SP_GEN_FN
  // @DisplayName: SkyPower EFI generator control function
  // @Description: SkyPower EFI generator control function. This is the RCn_OPTION value to use to find the R/C channel used for controlling generator start/stop
  // @Values: 0:Disabled,300:300,301:301,302:302,303:303,304:304,305:305,306:306,307:307
  // @User: Standard
--]]
local EFI_SP_GEN_FN     = bind_add_param('GEN_FN',     7, 0)    -- generator control function (RC option)

--[[
  // @Param: EFI_SP_MIN_RPM
  // @DisplayName: SkyPower EFI minimum RPM
  // @Description: SkyPower EFI minimum RPM. This is the RPM below which the engine is considered to be stopped
  // @Range: 1 1000
  // @User: Advanced
--]]
local EFI_SP_MIN_RPM    = bind_add_param('MIN_RPM',    8, 100)  -- min RPM, for engine restart

--[[
  // @Param: EFI_SP_TLM_RT
  // @DisplayName: SkyPower EFI telemetry rate
  // @Description: SkyPower EFI telemetry rate. This is the rate at which extra telemetry values are sent to the GCS
  // @Range: 1 10
  // @Units: Hz
  // @User: Advanced
--]]
local EFI_SP_TLM_RT     = bind_add_param('TLM_RT',     9, 0)    -- rate for extra telemetry values

--[[
  // @Param: EFI_SP_LOG_RT
  // @DisplayName: SkyPower EFI log rate
  // @Description: SkyPower EFI log rate. This is the rate at which extra logging of the SkyPower EFI is performed
  // @Range: 1 50
  // @Units: Hz
  // @User: Advanced
--]]
local EFI_SP_LOG_RT     = bind_add_param('LOG_RT',    10, 10)   -- rate for logging

--[[
  // @Param: EFI_SP_ST_DISARM
  // @DisplayName: SkyPower EFI allow start disarmed
  // @Description: SkyPower EFI allow start disarmed. This controls if starting the engine while disarmed is allowed
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local EFI_SP_ST_DISARM  = bind_add_param('ST_DISARM', 11, 0)    -- allow start when disarmed

--[[
  // @Param: EFI_SP_MODEL
  // @DisplayName: SkyPower EFI ECU model
  // @Description: SkyPower EFI ECU model
  // @Values: 0:SRE_180,1:SP_275
  // @User: Standard
--]]
local EFI_SP_MODEL  = bind_add_param('MODEL', 12, MODEL_DEFAULT)

--[[
  // @Param: EFI_SP_GEN_CTRL
  // @DisplayName: SkyPower EFI enable generator control
  // @Description: SkyPower EFI enable generator control
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local EFI_SP_GEN_CTRL  = bind_add_param('GEN_CRTL', 13, 1)

--[[
  // @Param: EFI_SP_RST_TIME
  // @DisplayName: SkyPower EFI restart time
  // @Description: SkyPower EFI restart time. If engine should be running and it has stopped for this amount of time then auto-restart. To disable this feature set this value to zero.
  // @Range: 0 10
  // @User: Standard
  // @Units: s
--]]
local EFI_SP_RST_TIME  = bind_add_param('RST_TIME', 14, 2)

if EFI_SP_ENABLE:get() == 0 then
   gcs:send_text(0, string.format("EFISP: disabled"))
   return
end

-- Register for the CAN drivers
local driver1

local CAN_BUF_LEN = 25
if EFI_SP_CANDRV:get() == 1 then
   driver1 = CAN.get_device(CAN_BUF_LEN)
elseif EFI_SP_CANDRV:get() == 2 then
   driver1 = CAN.get_device2(CAN_BUF_LEN)
end

if not driver1 then
    gcs:send_text(0, string.format("EFISP: Failed to load driver"))
    return
end

local now_s = get_time_sec()

function C_TO_KELVIN(temp)
   return temp + 273.15
end

--[[
   we allow the engine to run if either armed or the EFI_SP_ST_DISARM parameter is 1
--]]
function allow_run_engine()
  return arming:is_armed() or EFI_SP_ST_DISARM:get() == 1
end

--[[
   EFI Engine Object
--]]
local function engine_control(driver)
    local self = {}

    -- Build up the EFI_State that is passed into the EFI Scripting backend
    local efi_state = EFI_State()
    local cylinder_state = Cylinder_Status()

    -- private fields as locals
    local rpm = 0
    local air_pressure = 0
    local inj_time = 0
    local target_load = 0
    local current_load = 0
    local throttle_angle = 0
    local ignition_angle = 0
    local supply_voltage = 0
    local supply_voltage2 = 0
    local fuel_consumption_lph = 0
    local fuel_total_l = 0
    local last_fuel_s = 0
    local last_rpm_t = get_time_sec()
    local last_state_update_t = get_time_sec()
    local last_thr_update = get_time_sec()
    local last_telem_update = get_time_sec()
    local last_log_t = get_time_sec()
    local last_stop_message_t = get_time_sec()
    local engine_started = false
    local generator_started = false
    local engine_start_t = 0.0
    local last_throttle = 0.0
    local sensor_error_flags = 0
    local thermal_limit_flags = 0
    local starter_rpm = 0

    -- frames for sending commands
    local FRM_500 = uint32_t(0x500)
    local FRM_505 = uint32_t(0x505)
    local FRM_506 = uint32_t(0x506)

    -- Generator Data Structure
    local gen        = {}
    gen.amps         = 0.0
    gen.rpm          = 0.0
    gen.batt_current = 0.0

    -- Temperature Data Structure
    local temps = {}
    temps.egt = 0.0        -- Exhaust Gas Temperature
    temps.cht = 0.0        -- Cylinder Head Temperature
    temps.imt = 0.0        -- intake manifold temperature
    temps.oilt = 0.0        -- oil temperature
    temps.cht2 = 0.0
    temps.egt2 = 0.0
    temps.imt2 = 0.0
    temps.oil2 = 0.0

    -- read telemetry packets
    function self.update_telemetry()
        local max_packets = 25
        local count = 0
        while count < max_packets do
            frame = driver:read_frame()
            count = count + 1
            if not frame then
                break
            end

            --[[
               note that some SkyPower setups use extended and some
               11-bit CAN frames
            --]]
            self.handle_EFI_packet(frame)
        end
        if last_rpm_t > last_state_update_t then
           -- update state if we have an updated RPM
           last_state_update_t = last_rpm_t
           self.set_EFI_State()
        end
    end

    -- handle an EFI packet
    function self.handle_EFI_packet(frame)
       local id = frame:id_signed()
       if EFI_SP_MODEL:get() == MODEL_SP_275 then
          -- updated telemetry for SP-275 ECU
          if id == 0x100 then
             rpm = get_uint16(frame, 0)
             ignition_angle = get_uint16(frame, 2) * 0.1
             throttle_angle = get_uint16(frame, 4) * 0.1
             last_rpm_t = get_time_sec()
          elseif id == 0x101 then
             air_pressure = get_uint16(frame, 4)
          elseif id == 0x102 then
             inj_time = get_uint16(frame, 4)
             -- inj_ang = get_uint16(frame, 2) * 0.1
          elseif id == 0x104 then
             supply_voltage = get_uint16(frame, 0) * 0.1
          elseif id == 0x105 then
             temps.cht = get_uint16(frame, 0) * 0.1
             temps.imt = get_uint16(frame, 2) * 0.1
             temps.egt = get_uint16(frame, 4) * 0.1
             temps.oilt = get_uint16(frame, 6) * 0.1
          elseif id == 0x107 then
             sensor_error_flags = get_uint16(frame, 0)
             thermal_limit_flags = get_uint16(frame, 2)
          elseif id == 0x107 then
             target_load = get_uint16(frame, 6) * 0.1
          elseif id == 0x10C then
             temps.cht2 = get_uint16(frame, 4) * 0.1
             temps.egt2 = get_uint16(frame, 6) * 0.1
          elseif id == 0x10D then
             current_load = get_uint16(frame, 2) * 0.1
          elseif id == 0x113 then
             gen.amps = get_uint16(frame, 2)
          elseif id == 0x114 then
             supply_voltage2 = get_uint16(frame, 4) * 0.01
          elseif id == 0x2E0 then
             starter_rpm = get_uint16(frame, 4)
          elseif id == 0x10B then
             fuel_consumption_lph = get_uint16(frame,6)*0.001
             if last_fuel_s > 0 then
                local dt = now_s - last_fuel_s
                local fuel_lps = fuel_consumption_lph / 3600.0
                fuel_total_l = fuel_total_l + fuel_lps * dt
             end
             last_fuel_s = now_s
          end
       else
          assert(EFI_SP_MODEL:get() == MODEL_SRE_180, string.format('%s Invalid EFI_SP_MODEL', SCRIPT_NAME))
          -- original SkyPower driver, SRE_180
          if id == 0x100 then
             rpm = get_uint16(frame, 0)
             ignition_angle = get_uint16(frame, 2) * 0.1
             throttle_angle = get_uint16(frame, 4) * 0.1
             last_rpm_t = get_time_sec()
          elseif id == 0x101 then
             current_load = get_uint16(frame, 0) * 0.1
             target_load = get_uint16(frame, 2) * 0.1
             inj_time = get_uint16(frame, 4)
             -- inj_ang = get_uint16(frame, 6) * 0.1
          elseif id == 0x104 then
             supply_voltage = get_uint16(frame, 0) * 0.1
             ecu_temp = get_uint16(frame, 2) * 0.1
             air_pressure = get_uint16(frame, 4)
             fuel_consumption_lph = get_uint16(frame,6)*0.001
             if last_fuel_s > 0 then
                local dt = now_s - last_fuel_s
                local fuel_lps = fuel_consumption_lph / 3600.0
                fuel_total_l = fuel_total_l + fuel_lps * dt
             end
             last_fuel_s = now_s
          elseif id == 0x105 then
             temps.cht = get_uint16(frame, 0) * 0.1
             temps.imt = get_uint16(frame, 2) * 0.1
             temps.egt = get_uint16(frame, 4) * 0.1
             temps.oilt = get_uint16(frame, 6) * 0.1
          elseif id == 0x178 then
             supply_voltage2 = get_uint16(frame, 4) * 0.01
          end
       end
    end

    -- Build and set the EFI_State that is passed into the EFI Scripting backend
    function self.set_EFI_State()
       -- Cylinder_Status
       cylinder_state:cylinder_head_temperature(C_TO_KELVIN(temps.cht))
       cylinder_state:exhaust_gas_temperature(C_TO_KELVIN(temps.egt))
       cylinder_state:ignition_timing_deg(ignition_angle)
       cylinder_state:injection_time_ms(inj_time*0.001)

       efi_state:engine_speed_rpm(uint32_t(rpm))
       efi_state:engine_load_percent(math.floor(current_load))

       efi_state:fuel_consumption_rate_cm3pm(fuel_consumption_lph * 1000.0 / 60.0)
       efi_state:estimated_consumed_fuel_volume_cm3(fuel_total_l * 1000.0)
       efi_state:throttle_position_percent(math.floor(throttle_angle*100.0/90.0+0.5))
       efi_state:atmospheric_pressure_kpa(air_pressure*0.1)
       efi_state:ignition_voltage(supply_voltage)
       efi_state:intake_manifold_temperature(C_TO_KELVIN(temps.imt))
       efi_state:throttle_out(last_throttle * 100)

       -- copy cylinder_state to efi_state
       efi_state:cylinder_status(cylinder_state)

       local last_efi_state_time = millis()
       efi_state:last_updated_ms(last_efi_state_time)


        -- Set the EFI_State into the EFI scripting driver
        efi_backend:handle_scripting(efi_state)
    end

    --- send throttle command, thr is 0 to 1
    function self.send_throttle(thr)
       last_throttle = thr
       local msg = CANFrame()
       msg:id(FRM_500)
       msg:data(0,1)
       msg:data(1,0)
       thr = math.floor(thr*1000)
       msg:data(2,thr&0xFF)
       msg:data(3,thr>>8)
       msg:dlc(8)
       driver:write_frame(msg, 10000)
    end

    -- send an engine start command
    function self.send_engine_start()
       if EFI_SP_MODEL:get() == MODEL_SP_275 then
          -- the SP-275 needs a stop before a start will work
          self.send_engine_stop()
       end
       local msg = CANFrame()
       msg:id(FRM_505)
       msg:data(0,10)
       msg:dlc(8)
       driver:write_frame(msg, 10000)
    end

    -- send an engine stop command
    function self.send_engine_stop()
       local msg = CANFrame()
       msg:id(FRM_505)
       msg:data(7,10)
       msg:dlc(8)
       driver:write_frame(msg, 10000)
       local now = get_time_sec()
       if now - last_stop_message_t > 0.5 then
          last_stop_message_t = now
          gcs:send_text(0, string.format("EFISP: stopping engine"))
       end
    end

    -- start generator
    function self.send_generator_start()
       local msg = CANFrame()
       msg:id(FRM_506)
       msg:data(2,10)
       msg:dlc(8)
       driver:write_frame(msg, 10000)
    end

    -- stop generator
    function self.send_generator_stop()
       local msg = CANFrame()
       msg:id(FRM_506)
       msg:data(2,0)
       msg:dlc(8)
       driver:write_frame(msg, 10000)
    end
    
    -- update starter control
    function self.update_starter()
       local start_fn = EFI_SP_START_FN:get()
       if start_fn == 0 then
          return
       end
       local start_state = rc:get_aux_cached(start_fn)
       if start_state == nil then
          start_state = 0
       end
       local should_be_running = false
       if start_state == 0 and engine_started then
          engine_started = false
          engine_start_t = 0
          self.send_engine_stop()
       end
       if start_state == 2 and not engine_started and allow_run_engine() then
          engine_started = true
          gcs:send_text(0, string.format("EFISP: starting engine"))
          engine_start_t = get_time_sec()
          self.send_engine_start()
          should_be_running = true
       end
       if start_state > 0 and engine_started and allow_run_engine() then
          should_be_running = true
       end
       local min_rpm = EFI_SP_MIN_RPM:get()
       if min_rpm > 0 and engine_started and rpm < min_rpm and allow_run_engine() then
          local now = get_time_sec()
          local dt = now - engine_start_t
          if EFI_SP_RST_TIME:get() > 0 and dt > EFI_SP_RST_TIME:get() then
             gcs:send_text(0, string.format("EFISP: re-starting engine"))
             self.send_engine_start()
             engine_start_t = get_time_sec()
          end
       end
       --[[
          cope with lost engine stop packets
       --]]
       if rpm > min_rpm and not should_be_running then
          engine_started = false
          engine_start_t = 0
          self.send_engine_stop()
       end
    end

    -- update generator control
    function self.update_generator()
       if EFI_SP_GEN_CTRL:get() == 0 then
          return
       end
       local gen_state = rc:get_aux_cached(EFI_SP_GEN_FN:get())
       if gen_state == 0 and generator_started then
          generator_started = false
          gcs:send_text(0, string.format("EFISP: stopping generator"))
          self.send_generator_stop()
       end
       if gen_state == 2 and not generator_started then
          generator_started = true
          gcs:send_text(0, string.format("EFISP: starting generator"))
          self.send_generator_start()
       end
    end
    
    -- update throttle output
    function self.update_throttle()
       local thr_func = EFI_SP_THR_FN:get()
       local thr_rate = EFI_SP_THR_RATE:get()
       if thr_func == 0 or thr_rate == 0 then
          return
       end
       local now = get_time_sec()
       if now - last_thr_update < 1.0 / thr_rate then
          return
       end
       last_thr_update = now
       local thr = 0.0
       local scaled = SRV_Channels:get_output_scaled(thr_func)
       if thr_func == K_THROTTLE then
          thr = scaled * 0.01
       elseif thr_func == K_HELIRSC then
          thr = scaled * 0.001
       end
       self.send_throttle(thr)
    end

    -- update telemetry output for extra telemetry values
    function self.update_telem_out()
       local rate = EFI_SP_TLM_RT:get()
       if rate <= 0 then
          return
       end
       local now = get_time_sec()
       if now - last_telem_update < 1.0 / rate then
          return
       end
       last_telem_update = now
       gcs:send_named_float('EFI_OILTMP', temps.oilt)
       gcs:send_named_float('EFI_TRLOAD', target_load)
       gcs:send_named_float('EFI_VOLTS', supply_voltage)
       gcs:send_named_float('EFI_VOLTS2', supply_voltage2)
       gcs:send_named_float('EFI_GEN_AMPS', gen.amps)
       gcs:send_named_float('EFI_CHT2', temps.cht2)
       gcs:send_named_float('EFI_STARTRPM', starter_rpm)
    end

    -- update custom logging
    function self.update_logging()
       local rate = EFI_SP_LOG_RT:get()
       if rate <= 0 then
          return
       end
       local now = get_time_sec()
       if now - last_log_t < 1.0 / rate then
          return
       end
       last_log_t = now
       logger.write('EFSP','Thr,CLoad,TLoad,OilT,RPM,gRPM,gAmp,gCur,SErr,TLim,STRPM', 'ffffffffHHH',
                    last_throttle, current_load, target_load, temps.oilt, rpm,
                    gen.rpm, gen.amps, gen.batt_current,
                    sensor_error_flags, thermal_limit_flags,
                    starter_rpm)
    end
    
    -- return the instance
    return self
end -- end function engine_control

local engine1 = engine_control(driver1)

function update()
   now_s = get_time_sec()

   if not efi_backend then
      efi_backend = efi:get_backend(0)
      if not efi_backend then
         return
      end
   end

   -- Parse Driver Messages
   engine1.update_telemetry()
   engine1.update_starter()
   engine1.update_generator()
   engine1.update_throttle()
   engine1.update_telem_out()
   engine1.update_logging()
end

gcs:send_text(0, SCRIPT_NAME .. string.format(" loaded"))

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, 1000 / EFI_SP_UPDATE_HZ:get()
end

-- start running update loop
return protected_wrapper()



================================================
File: drivers/EFI_SkyPower.md
================================================
# EFI SkyPower Driver

This driver implements support for the SkyPower range of EFI engine
control units. It supports monitoring and control of SkyPower engines.

# Parameters

The script used the following parameters:

## EFI_SP_ENABLE

this must be set to 1 to enable the driver

## EFI_SP_CANDRV

This sets the CAN scripting driver number to attach to. This is
normally set to 1 to use a CAN driver with CAN_Dx_PROTOCOL=10. To use
the 2nd scripting CAN driver set this to 2 and set CAN_Dx_PROTOCOL=12.

## EFI_SP_UPDATE_HZ

This sets the update rate of the script in Hz (how often it checks for
new data from the ECU). A value of 200 is reasonable.

## EFI_SP_THR_FN

This sets the SERVOn_FUNCTION number to monitor for throttle
command. For fixed wing forward throttle this should be set to 70. For
heli RSC control this should be set to 31. If set to zero then no
throttle control will be done by the driver.

## EFI_SPI_THR_RATE

This is the throttle output rate in Hz. A value of zero will disable
throttle control. A typical rate would be 50Hz.

## EFI_SP_START_FN

This is the RC option to use to monitor start control. This should be
set to one of the scripting RC options (from 300 to 307). Then an
RCn_OPTION should be set to the same value. When this switch goes high
the engine start function will be sent to the ECU. When this switch
goes low a engine stop will be sent. A value of 0 disables the starter
control.

## EFI_SP_GEN_FN

This is the RC option (auxiliary function) to use for generator
control. This should be set to one of the scripting RC options (from
300 to 307) if generator control is needed. Then an RCn_OPTION should
be set to the same value. When this switch goes high the generator
start function will be sent to the ECU. When this switch goes low a
generator stop will be sent. A value of 0 disables the generator
control.

## EFI_SP_MIN_RPM

This is the minimum running RPM. When set to a positive value then the
driver will monitor engine RPM when the engine is started and if it
drops below this value then an engine start will be sent to restart
the engine.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_SP parameters will appear and should be set
according to the parameter list above.

A 2 position RC switch should be setup with RCn_OPTION=300 (or the
value of EFI_SP_START_FN) to enable starter control. When that switch
goes high the engine will be started. When it goes low the engine will
be stopped.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature, exhaust gas temperature, injection timing,
engine load, fuel consumption rate, throttle position atmospheric
pressure and ignition voltage.

Setting EFI_SP_RPM_MIN allows for automatic in-flight engine
restart. If the engine RPM drops below this EFI_SP_RPM_MIN for 2
seconds while the engine should be started then an engine start
command will be sent to restart the engine.



================================================
File: drivers/Generator_SVFFI.lua
================================================
--[[
   SVFFI serial protocol for generator support
   See http://www.svffi.com/en/
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter

local PARAM_TABLE_KEY = 42
local PARAM_TABLE_PREFIX = "EFI_SVF_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: EFI_SVF_ENABLE
  // @DisplayName: Generator SVFFI enable
  // @Description: Enable SVFFI generator support
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
EFI_SVF_ENABLE = bind_add_param("ENABLE", 1, 0)

--[[
  // @Param: EFI_SVF_ARMCHECK
  // @DisplayName: Generator SVFFI arming check
  // @Description: Check for Generator ARM state before arming
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
EFI_SVF_ARMCHECK = bind_add_param("ARMCHECK", 2, 1)

if EFI_SVF_ENABLE:get() ~= 1 then
   return
end

local auth_id = arming:get_aux_auth_id()
arming:set_aux_auth_failed(auth_id, "GEN: not in ARM state")


local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "GEN_SVF: unable to find serial port")
   return
end
uart:begin(115200)

local efi_backend = efi:get_backend(0)
if not efi_backend then
   gcs:send_text(MAV_SEVERITY.ERROR, "GEN_SVF: unable to find EFI backend")
   return
end

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      ret = ret .. string.char(uart:read())
   end
   return ret
end

local auchCRCHi = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40
}

local auchCRCLo = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38,
    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB,
    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
    0x41, 0x81, 0x80, 0x40
}

--[[
   calculate crc16
--]]
local function get_crc16(s)
   local uchCRCHi = 0xFF
   local uchCRCLo = 0xFF
   for i = 1, #s do
      local b = string.byte(string.sub(s, i, i))
      local uIndex = uchCRCLo ~ b
      --gcs:send_text(MAV_SEVERITY.INFO, string.format("uIndex=%u", uIndex))
      uchCRCLo = uchCRCHi ~ auchCRCHi[uIndex+1]
      uchCRCHi = auchCRCLo[uIndex+1]
   end
   return (uchCRCHi << 8 | uchCRCLo)
end

local state = {}
state.last_read_us = uint32_t(0)
state.last_status = -1


--[[
   check for input and parse data
--]]
local function check_input()
   local n_bytes = uart:available():toint()
   --gcs:send_text(MAV_SEVERITY.INFO, string.format("n_bytes=%u %.2f", n_bytes, millis():tofloat()*0.001))
   if n_bytes < 31 then
      return
   end

   local s = read_bytes(n_bytes)
   local prefix, len = string.unpack("<HB", s, 1)
   if prefix ~= 0xa55a then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("bad prefix 0x%x", prefix))
      return
   end
   if len+5 ~= n_bytes then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("bad len %u %u", n_bytes, len))
      return
   end
   local crc = string.unpack("<H", s, 4+len)
   local s2 = string.sub(s,1,n_bytes-2)
   --gcs:send_text(MAV_SEVERITY.INFO, string.format("s2 n_bytes=%u len1=%u len2=%u", n_bytes, #s, #s2))
   local crc2 = get_crc16(s2)
   if crc ~= crc2 then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("bad crc %x %x", crc, crc2))
      return
   end

   state.version, state.rpm, state.throttle = string.unpack("<BHH", string.sub(s,4,8))
   state.voltage, state.current, state.runtime = string.unpack("<HHI", string.sub(s,9,16))
   state.maint_time, state.lock_time, state.status = string.unpack("<HHB", string.sub(s,17,21))
   state.alarm, state.fuellevel, state.cht1 = string.unpack("<HBH", string.sub(s,22,26))
   state.cht2, state.pcb_temp = string.unpack("<HB", string.sub(s,27,29))

   if state.status ~= state.last_status then
      state.last_status = state.status
      local states = {"STOP", "IDLE", "RUN", "3", "CHARGE" }
      local name = states[state.status+1]
      if not name then
         name = string.format("Unknown%u", state.status)
      end
      gcs:send_text(MAV_SEVERITY.WARNING, string.format("Generator state: %s", name))
      if name ~= "RUN" and EFI_SVF_ARMCHECK:get() == 1 then
         arming:set_aux_auth_failed(auth_id, string.format("GEN: not in ARM state (%s)", name))
      else
         arming:set_aux_auth_passed(auth_id)
      end

   end

   state.last_read_us = micros()
end

--[[
   update EFI state
--]]
local function update_EFI()
   if state.last_read_us == uint32_t(0) then
      return
   end
   local cylinder_state = Cylinder_Status()
   local efi_state = EFI_State()
   local C_TO_KELVIN = 273.2

   cylinder_state:cylinder_head_temperature(state.cht1+C_TO_KELVIN)
   efi_state:engine_speed_rpm(state.rpm)

   efi_state:throttle_position_percent(state.throttle)
   efi_state:ignition_voltage(state.voltage*0.1)

   efi_state:cylinder_status(cylinder_state)
   efi_state:last_updated_ms(millis())

   -- Set the EFI_State into the EFI scripting driver
   efi_backend:handle_scripting(efi_state)

   gcs:send_named_float('GEN_VOLT', state.voltage*0.1)
   gcs:send_named_float('GEN_AMPS', state.current*0.1)
   gcs:send_named_float('GEN_STAT', state.status)
   logger.write('SVF','Curr,Volt,Status', 'ffB',
                state.current*0.1,
                state.voltage*0.1,
                state.status)


end


--[[
   main update function
--]]
local function update()
   check_input()
   update_EFI()

   return update, 100
end

gcs:send_text(MAV_SEVERITY.INFO, "GEN_SVF: loaded")

return update()



================================================
File: drivers/Generator_SVFFI.md
================================================
# SVFFI Generator Driver

This driver implements support for the SVFFI generator serial protocol for
this system http://www.svffi.com/en/

# Parameters

The script used the following parameters:

## EFI_SVF_ENABLE

this must be set to 1 to enable the driver

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - EFI_TYPE should be set to 7
 - EFI_SVF_ENABLE should be set to 1
 - SERIALn_PROTOCOL should be set to 28 for the connected serial port
 - RPM_TYPE1 should be set to 3

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the GEN_SVF parameters will appear and should be set
according to the parameter list above.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature and throttle position. It will also receive
GEN_FUEL and GEN_AMPS named value float messages which give generator
fuel level percentage and current.



================================================
File: drivers/Hobbywing_DataLink.lua
================================================
--[[
   driver for HobbyWing DataLink ESC telemetry
--]]

---@diagnostic disable: param-type-mismatch

local PARAM_TABLE_KEY = 44
local PARAM_TABLE_PREFIX = "ESC_HW_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: ESC_HW_ENABLE
  // @DisplayName: Hobbywing ESC Enable
  // @Description: Enable Hobbywing ESC telemetry
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
ESC_HW_ENABLE = bind_add_param("ENABLE", 1, 0)

--[[
  // @Param: ESC_HW_POLES
  // @DisplayName: Hobbywing ESC motor poles
  // @Description: Number of motor poles for eRPM scaling
  // @Range: 1 50
  // @User: Standard
--]]
ESC_HW_POLES = bind_add_param("POLES", 2, 14)

--[[
  // @Param: ESC_HW_OFS
  // @DisplayName: Hobbywing ESC motor offset
  // @Description: Motor number offset of first ESC
  // @Range: 0 31
  // @User: Standard
--]]
ESC_HW_OFS = bind_add_param("OFS", 3, 0)

if ESC_HW_ENABLE:get() ~= 1 then
   gcs:send_text(MAV_SEVERITY.INFO, "ESC_HW: disabled")
   return
end

local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "ESC_HW: unable to find serial port")
   return
end
uart:begin(115200)

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      ret = ret .. string.char(uart:read())
   end
   return ret
end

--[[
   discard pending bytes
--]]
local function discard_pending()
   local n = uart:available():toint()
   for _ = 1, n do
      uart:read()
   end
end

--[[
   xmodem CRC implementation thanks to https://github.com/cloudwu/skynet
   under MIT license
--]]
local XMODEMCRC16Lookup = {
	0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
	0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,
	0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,
	0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,
	0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,
	0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,
	0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,
	0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,
	0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,
	0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,
	0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,
	0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,
	0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,
	0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,
	0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,
	0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,
	0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,
	0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,
	0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,
	0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,
	0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,
	0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,
	0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,
	0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,
	0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,
	0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,
	0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,
	0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,
	0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,
	0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,
	0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,
	0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0
}

local function crc_xmodem(bytes)
	local crc = 0
	for i=1,#bytes do
		local b = string.byte(bytes,i,i)
		crc = ((crc<<8) & 0xffff) ~ XMODEMCRC16Lookup[(((crc>>8)~b) & 0xff) + 1]
	end
    return crc
end

local temp_table = {
    { 241, 	0}, 	{ 240, 	1}, 	{ 239, 	2}, 	{ 238, 	3}, 	{ 237, 	4}, 	{ 236, 	5}, 	{ 235, 	6}, 	{ 234, 	7}, 	{ 233, 	8}, 	{ 232, 	9},
    { 231, 	10}, 	{ 230, 	11}, 	{ 229, 	12}, 	{ 228, 	13}, 	{ 227, 	14}, 	{ 226, 	15}, 	{ 224, 	16}, 	{ 223, 	17}, 	{ 222, 	18}, 	{ 220, 	19},
    { 219, 	20}, 	{ 217, 	21}, 	{ 216, 	22}, 	{ 214, 	23}, 	{ 213, 	24}, 	{ 211, 	25}, 	{ 209, 	26}, 	{ 208, 	27}, 	{ 206, 	28}, 	{ 204, 	29},
    { 202, 	30}, 	{ 201, 	31}, 	{ 199, 	32}, 	{ 197, 	33}, 	{ 195, 	34}, 	{ 193, 	35}, 	{ 191, 	36}, 	{ 189, 	37}, 	{ 187, 	38}, 	{ 185, 	39},
    { 183, 	40}, 	{ 181, 	41}, 	{ 179, 	42}, 	{ 177, 	43}, 	{ 174, 	44}, 	{ 172, 	45}, 	{ 170, 	46}, 	{ 168, 	47}, 	{ 166, 	48}, 	{ 164, 	49},
    { 161, 	50}, 	{ 159, 	51}, 	{ 157, 	52}, 	{ 154, 	53}, 	{ 152, 	54}, 	{ 150, 	55}, 	{ 148, 	56}, 	{ 146, 	57}, 	{ 143, 	58}, 	{ 141, 	59},
    { 139, 	60}, 	{ 136, 	61}, 	{ 134, 	62}, 	{ 132, 	63}, 	{ 130, 	64}, 	{ 128, 	65}, 	{ 125, 	66}, 	{ 123, 	67}, 	{ 121, 	68}, 	{ 119, 	69},
    { 117, 	70}, 	{ 115, 	71}, 	{ 113, 	72}, 	{ 111, 	73}, 	{ 109, 	74}, 	{ 106, 	75}, 	{ 105, 	76}, 	{ 103, 	77}, 	{ 101, 	78}, 	{ 99, 	79},
    { 97, 	80}, 	{ 95, 	81}, 	{ 93, 	82}, 	{ 91, 	83}, 	{ 90, 	84}, 	{ 88, 	85}, 	{ 85, 	86}, 	{ 84, 	87}, 	{ 82, 	88}, 	{ 81, 	89},
    { 79, 	90}, 	{ 77, 	91}, 	{ 76, 	92}, 	{ 74, 	93}, 	{ 73, 	94}, 	{ 72, 	95}, 	{ 69, 	96}, 	{ 68, 	97}, 	{ 66, 	98}, 	{ 65, 	99},
    { 64, 	100}, 	{ 62, 	101}, 	{ 62, 	102}, 	{ 61, 	103}, 	{ 59, 	104}, 	{ 58, 	105}, 	{ 56, 	106}, 	{ 54, 	107}, 	{ 54, 	108}, 	{ 53, 	109},
    { 51, 	110}, 	{ 51, 	111}, 	{ 50, 	112}, 	{ 48, 	113}, 	{ 48, 	114}, 	{ 46, 	115}, 	{ 46, 	116}, 	{ 44, 	117}, 	{ 43, 	118}, 	{ 43, 	119},
    { 41, 	120}, 	{ 41, 	121}, 	{ 39, 	122}, 	{ 39, 	123}, 	{ 39, 	124}, 	{ 37, 	125}, 	{ 37, 	126}, 	{ 35, 	127}, 	{ 35, 	128}, 	{ 33, 	129},
}

local function temperature_decode(temp_raw)
   if temp_raw == 0 then
      return 0
   end
   for i = 1, #temp_table do
      if temp_table[i][1] <= temp_raw then
         return temp_table[i][2]
      end
   end
   return 130
end

local function decode_current(curr)
   return curr / 64.0
end

local telem_data = ESCTelemetryData()

--[[
   check for input and parse data
--]]
local function check_input()
   local n_bytes = uart:available():toint()
   if n_bytes < 160 then
      return
   end
   --gcs:send_text(0,string.format("n_bytes=%u", n_bytes))
   if n_bytes > 160 then
      discard_pending()
      return
   end

   local s = read_bytes(n_bytes)
   local head, frame_len, ver, cmd, _ = string.unpack(">BBBBH", string.sub(s,1,6))
   if head ~= 0x9B or frame_len ~= 158 or ver ~= 1 or cmd ~= 2 then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("bad frame %x %x %x %x", head, frame_len, ver, cmd))
      return
   end
   local crc1 = string.unpack("<H", string.sub(s,159,160))
   local crc2 = crc_xmodem(string.sub(s,1,158))
   if crc1 ~= crc2 then
      -- gcs:send_text(MAV_SEVERITY.INFO, string.format("bad crc %x %x", crc1, crc2))
      return
   end
   for i = 0, 7 do
      local e = string.sub(s,7+i*19,25+i*19)
      local _, pnum, in_thr, out_thr, eRPM, volt, curr, pcurr, mos_temp, cap_temp, status = string.unpack(">BHHHHHhhBBH", e)
      local RPM = math.floor(eRPM*10.0/ESC_HW_POLES:get())
      if volt > 0 or curr > 0 or RPM > 0 or pnum > 1 then
         -- we have valid ESC data
         local ofs = ESC_HW_OFS:get()
         curr = decode_current(curr)
         pcurr = decode_current(pcurr)
         volt = volt * 0.1
         in_thr = in_thr / 32768.0
         out_thr = out_thr / 32768.0
         mos_temp = temperature_decode(mos_temp)
         cap_temp = temperature_decode(cap_temp)
         telem_data:voltage(volt)
         telem_data:current(curr)
         telem_data:temperature_cdeg(math.floor(mos_temp*100))
         esc_telem:update_rpm(ofs+i, math.floor(eRPM*10.0/ESC_HW_POLES:get()), 0)
         -- 0x0D is temperature + voltage + current
         esc_telem:update_telem_data(ofs+i, telem_data, 0x0D)
         logger.write('HWES','I,PNum,RPM,Curr,Volt,InT,OutT,PCurr,MosT,CapT,Status',
                      'BHHfffffBBH', '#-qAv--AOO-', '--00000000-',
                      ofs+i, pnum, RPM, curr, volt, in_thr, out_thr, pcurr, mos_temp, cap_temp, status)
      end
   end
end

--[[
   main update function
--]]
local function update()
   check_input()
   return update, 10
end

gcs:send_text(MAV_SEVERITY.ALERT, "ESC_HW: loaded")

return update, 100



================================================
File: drivers/Hobbywing_DataLink.md
================================================
# HobbyWing ESC DataLink Driver

https://www.hobbywing.com/en/products?id=59

This driver implements support the HobbyWing DataLink for HobbyWing
ESCs connected via a UART to an ArduPilot serial port. It supports up
to 8 ESCs.

# Parameters

The script used the following parameters:

## ESC_HW_ENABLE

this must be set to 1 to enable the driver

## ESC_HW_POLES

this should be set to the number of motor poles for eRPM to RPM
scaling. Please confirm the correct RPM using a tachometer

## ESC_HW_OFS

this parameter sets an offset for the first ESC number. It is useful
on vehicles where the first ESC is not the first SERVOn output, for
example on quadplanes. Set to zero for no offset.

# Hardware Setup

Connect the TX1 pin on the DataLink V2 to a RX pin on an ArduPilot
serial port and the GND pin on the DataLink V2 to the GND pin on the
ArduPilot UART.

Connect your ESCs into the 8 ESC connectors marked D1 to D8.

Power the DataLink V2 with a battery as indicated in the DataLink V2 manual.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - ESC_HW_ENABLE should be set to 1
 - SERIALn_PROTOCOL should be set to 28 for the connected serial port

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the ESC_HW_ parameters will appear and should be
configured as per the above documentation.

Note that the DataLink does not provide any data unless the motor is
running, so you cannot see any valid data at all until you arm the
motors and they start spinning.




================================================
File: drivers/INF_Inject.lua
================================================
--[[
 Driver for INF_Inject EFI system

 https://innoflighttechnology.com/efi/
--]]

local PARAM_TABLE_KEY = 43
local PARAM_TABLE_PREFIX = "EFI_INF_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local CMD_CDI1 = 1
local CMD_CDI2 = 2
local CMD_OIL_PUMP = 3
-- local CMD_SHUTDOWN = 4
-- local CMD_PRE_INJECTION = 5
local CMD_THROTTLE = 6

local K_THROTTLE = 70

-- bind a parameter to a variable given
local function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: EFI_INF_ENABLE
  // @DisplayName: EFI INF-Inject enable
  // @Description: Enable EFI INF-Inject driver
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
EFI_INF_ENABLE = bind_add_param("ENABLE", 1, 1)

--[[
  // @Param: EFI_INF_OPTIONS
  // @DisplayName: EFI INF-Inject options
  // @Description: EFI INF driver options
  // @Bitmask: 0:EnableLogging
  // @User: Standard
--]]
EFI_INF_OPTIONS = bind_add_param("OPTIONS", 2, 0)

--[[
  // @Param: EFI_INF_THR_HZ
  // @DisplayName: EFI INF-Inject throttle rate
  // @Description: EFI INF throttle output rate
  // @Range: 0 50
  // @Units: Hz
  // @User: Standard
--]]
EFI_INF_THR_HZ = bind_add_param("THR_HZ", 3, 0)

--[[
  // @Param: EFI_INF_IGN_AUX
  // @DisplayName: EFI INF-Inject ignition aux function
  // @Description: EFI INF throttle ignition aux function
  // @User: Standard
--]]
EFI_INF_IGN_AUX = bind_add_param("IGN_AUX", 4, 300)

local OPTION_LOGGING = (1<<0)

--[[
   return true if an option is enabled
--]]
local function option_enabled(option)
   return (EFI_INF_OPTIONS:get() & option) ~= 0
end

if EFI_INF_ENABLE:get() ~= 1 then
   return
end

local EFI_FUEL_DENS = bind_param("EFI_FUEL_DENS")
local SCR_VM_I_COUNT = bind_param("SCR_VM_I_COUNT")

local uart = serial:find_serial(0) -- first scripting serial
if not uart then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_INF: unable to find scripting serial")
   return
end
uart:begin(9600)

local efi_backend = efi:get_backend(0)
if not efi_backend then
   gcs:send_text(MAV_SEVERITY.ERROR, "EFI_INF: unable to find EFI backend")
   return
end

--[[
   we need a bit more time in this driver
--]]
if SCR_VM_I_COUNT:get() < 50000 then
   gcs:send_text(MAV_SEVERITY.INFO, "EFI_INF: raising SCR_VM_I_COUNT to 50000")
   SCR_VM_I_COUNT:set_and_save(50000)
end

local state = {}
state.last_read_us = uint32_t(0)
state.chk0 = 0
state.chk1 = 0
state.total_fuel_g = 0.0

local last_throttle_send_ms = uint32_t(0)
local last_ignition_send_ms = uint32_t(0)
local last_ign_sw_pos = -1

local file_handle = nil
local efi_device_id = nil

--[[
   log a set of bytes
--]]
local function log_bytes(s)
   if not file_handle then
      file_handle = io.open("INF_Inject.log", "w")
   end
   if file_handle then
      local magic = 0x7fe53b04
      local now_ms = millis():toint()
      local hdr = string.pack("<III", magic, now_ms, string.len(s))
      file_handle:write(hdr)
      file_handle:write(s)
   end
end

local function read_bytes(n)
   local ret = ""
   for _ = 1, n do
      local b = uart:read()
      state.chk0 = state.chk0 ~ b
      state.chk1 = state.chk1 ~ state.chk0
      ret = ret .. string.char(b)
   end
   if option_enabled(OPTION_LOGGING) then
      log_bytes(ret)
   end
   return ret
end

--[[
   convert grams of fuel to cm3
--]]
local function gram_to_cm3(g)
   local kg = g * 0.001
   local kg_per_m3 = EFI_FUEL_DENS:get()
   if kg_per_m3 <= 0 then
      kg_per_m3 = 742.9
   end
   local m3 = kg / kg_per_m3
   return m3 * 1.0e6
end

--[[
   check for input and parse data
--]]
local function check_input()
   local packet_size = 83
   local n_bytes = uart:available():toint()
   if n_bytes < packet_size then
      return false
   end

   local tus = micros()

   -- sync on header start
   local header_ok = false
   while n_bytes >= packet_size and not header_ok do
      state.chk0 = 0
      state.chk1 = 0
      local header0 = string.unpack("<B", read_bytes(1))
      n_bytes = n_bytes - 1
      if header0 == 0xB5 then
         local header1 = string.unpack("<B", read_bytes(1))
         n_bytes = n_bytes - 1
         if header1 == 0x62 then
            header_ok = true
         end
      end
   end
   if not header_ok or n_bytes < packet_size-2 then
      return false
   end

   -- look for basic data table 2
   local _, _, dtype, num, device_id, ack = string.unpack("<BBBBIB", read_bytes(9))
   if dtype ~= 0x02 then
      return false
   end
   if ack ~= 0x50 then
      return false
   end
   if num < packet_size then
      return false
   end

   --gcs:send_text(MAV_SEVERITY.INFO, string.format("packet start"))

   state.mode, state.sta, state.sta1, state.bus_thr = string.unpack("<BBBB", read_bytes(4))
   state.bus_thr = state.bus_thr * 0.1
   state.svr_pwm, state.rpm_out, state.rpm1, state.rpm2 = string.unpack("<BHHH", read_bytes(7))
   state.svr_pwm = state.svr_pwm * 0.1
   state.tmp_env, state.tmp0, state.tmp1, state.tmp2, state.tmp3 = string.unpack("<hhhhh", read_bytes(10))
   state.vol_power, state.vol_svr, state.vol_pump, state.amp_pump = string.unpack("<HBBB", read_bytes(5))
   state.vol_power = state.vol_power * 0.1
   state.vol_svr = state.vol_svr * 0.1
   state.vol_pump = state.vol_pump * 0.1
   state.amp_pump = state.amp_pump * 0.1
   state.ADC1, state.ADC2, state.pre_gas, state.pre_alt = string.unpack("<BBfh", read_bytes(8))
   state.ADC1 = state.ADC1 * 0.1
   state.ADC2 = state.ADC2 * 0.1
   state.PWM_IN1, state.PWM_IN2, state.PWM_IN3 = string.unpack("<BBB", read_bytes(3))
   state.PWM_IN1 = state.PWM_IN1 * 10
   state.PWM_IN2 = state.PWM_IN2 * 10
   state.PWM_IN3 = state.PWM_IN3 * 10
   state.PWM_OUT1, state.PWM_OUT2, state.PWM_OUT3 = string.unpack("<BBB", read_bytes(3))
   state.pre_oil, state.inj1_ms, state.inj2_ms = string.unpack("<fhh", read_bytes(8))
   state.inj1_mg, state.inj2_mg = string.unpack("<hh", read_bytes(4))
   state.adc1_thr, state.adc2_thr = string.unpack("<BB", read_bytes(2))
   state.adc1_thr = state.adc1_thr * 10
   state.adc2_thr = state.adc2_thr * 10
   state.ecu_run_time, state.err_flg = string.unpack("<IH", read_bytes(6))
   state.oil1_thr, state.oil2_thr = string.unpack("<BB", read_bytes(2))
   state.oil1_thr = state.oil1_thr * 10
   state.oil2_thr = state.oil2_thr * 10
   state.reserve1, state.reserve2 = string.unpack("<BB", read_bytes(2))
   state.tmp4, state.tmp5 = string.unpack("<hh", read_bytes(4))

   local chk0 = state.chk0
   local chk1 = state.chk1
   state.check0, state.check1 = string.unpack("<BB", read_bytes(2))

   --[[
      the device will sometimes use 0 for the 2nd 8 bits of the checksum
      we will accept these packets, relying on the other header checks
   --]]
   local checksum_ok = chk0 == state.check0 and (chk1 == state.check1 or state.check1 == 0)
   if not checksum_ok then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("chksum wrong (0x%02x,0x%02x) (0x%02x,0x%02x)", chk0, chk1, state.check0, state.check1))
      return false
   end
   state.end0, state.end1 = string.unpack("<BB", read_bytes(2))

   if state.end0 ~= 0x0d or state.end1 ~= 0x0a then
      return false
   end

   local dt = (tus - state.last_read_us):tofloat()*1.0e-6

   local fuel_g_rev = (state.inj1_mg + state.inj2_mg)
   state.fuel_g_per_min = fuel_g_rev * state.rpm1
   state.total_fuel_g = state.total_fuel_g + (state.fuel_g_per_min * dt / 60.0)

   state.last_read_us = micros()

   gcs:send_named_float('VOL_SRV', state.vol_svr)
   gcs:send_named_float('VOL_PUMP', state.vol_pump)
   gcs:send_named_float('AMP_PUMP', state.amp_pump)
   gcs:send_named_float('PWM_OUT2', state.PWM_OUT2)
   gcs:send_named_float('INF_ETEMP', state.tmp_env)
   gcs:send_named_float('INF_TEMP1', state.tmp0)
   gcs:send_named_float('INF_TEMP2', state.tmp1)

   if not efi_device_id then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("EFI DeviceID: %u", device_id))
      efi_device_id = device_id
   end

   return true
end

--[[
   update EFI state
--]]
local function update_EFI()
   if state.last_read_us == uint32_t(0) then
      return
   end
   local cylinder_state = Cylinder_Status()
   local efi_state = EFI_State()

   cylinder_state:cylinder_head_temperature(state.tmp0)
   cylinder_state:exhaust_gas_temperature(state.tmp1)
   cylinder_state:injection_time_ms(state.inj1_ms)

   efi_state:engine_speed_rpm(state.rpm_out)

   efi_state:atmospheric_pressure_kpa(state.pre_gas*0.01)
   efi_state:intake_manifold_temperature(state.tmp2)
   efi_state:throttle_position_percent(math.floor(state.bus_thr*0.1))
   efi_state:ignition_voltage(state.vol_power)

   efi_state:cylinder_status(cylinder_state)
   efi_state:last_updated_ms(millis())
   efi_state:fuel_pressure(state.pre_oil)

   efi_state:fuel_consumption_rate_cm3pm(gram_to_cm3(state.fuel_g_per_min))
   efi_state:estimated_consumed_fuel_volume_cm3(gram_to_cm3(state.total_fuel_g))

   -- Set the EFI_State into the EFI scripting driver
   efi_backend:handle_scripting(efi_state)
end

local function get_checksum(pkt)
   local chk0 = 0
   local chk1 = 0
   for i=1,#pkt do
      local b = string.byte(pkt,i,i)
      chk0 = chk0 ~ b
      chk1 = chk1 ~ chk0
    end
   return (chk1 << 8) | chk0
end

--[[
   send command packet
--]]
local function send_packet(cmd, content)
   local pkt = string.pack("<BBBBBBIBBI",
                           0xB5, 0x62,
                           0xc3, 0xa1, 18, 20,
                           efi_device_id, 0x50,
                           cmd, content)
   local crc = get_checksum(pkt)
   pkt = pkt .. string.pack("<HBB", crc, 0x0d, 0x0a)
   for i=1,#pkt do
      local b = string.byte(pkt,i,i)
      uart:write(b)
   end
end

--[[
   send throttle commands
--]]
local function update_throttle()
   if EFI_INF_THR_HZ:get() <= 0 then
      return
   end
   local now_ms = millis()
   local rate_ms = 1000.0 / EFI_INF_THR_HZ:get()
   if now_ms - last_throttle_send_ms < rate_ms then
      return
   end
   last_throttle_send_ms = now_ms
   local thr_k = SRV_Channels:get_output_scaled(K_THROTTLE)*10

   send_packet(CMD_THROTTLE, thr_k)
end

--[[
   send ignition commands
--]]
local function update_ignition()
   local aux_fn = EFI_INF_IGN_AUX:get()
   if not aux_fn then
      return
   end
   local sw_pos = rc:get_aux_cached(aux_fn)
   if not sw_pos then
      return
   end
   local now_ms = millis()
   if sw_pos == last_ign_sw_pos and now_ms - last_ignition_send_ms < 1000 then
      return
   end
   last_ignition_send_ms = now_ms
   local command = 0
   if sw_pos >= 1 then
      command = 1
   end
   if sw_pos ~= last_ign_sw_pos then
      onoff = "OFF"
      if command == 1 then
         onoff = "ON"
      end
      gcs:send_text(MAV_SEVERITY.INFO, string.format("EFI_INF: ignition %s", onoff))
   end
   last_ign_sw_pos = sw_pos
   send_packet(CMD_CDI1, command)
   send_packet(CMD_CDI2, command)
   send_packet(CMD_OIL_PUMP, command)
end


--[[
   main update function
--]]
local function update()
   if check_input() then
      update_EFI()
   end
   if efi_device_id then
      update_throttle()
      update_ignition()
   end
   return update, 10
end

gcs:send_text(MAV_SEVERITY.INFO, "EFI_INF: loaded")

return update()



================================================
File: drivers/INF_Inject.md
================================================
# INF Inject Driver

This driver implements support for the INF Inject EFI engine
control units.

 https://innoflighttechnology.com/efi/

# Parameters

The script used the following parameters:

## EFI_INF_ENABLE

this must be set to 1 to enable the driver

## EFI_INF_OPTIONS

This sets options for the driver. Currently the only option is to set
EFI_INF_OPTIONS to 1 to enable logging of the raw serial bytes to a
file called INF_Inject.log

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - SCR_VM_I_COUNT should be set to at least 50000
 - EFI_TYPE should be set to 7
 - EFI_INF_ENABLE should be set to 1
 - SERIALn_PROTOCOL should be set to 28 for the connected EFI serial
 - RPM_TYPE1 should be set to 3
 - ICE_ENABLE should be set to 1

then the flight controller should rebooted and parameters should be
refreshed.

Once loaded the EFI_INF_ENABLE parameters will appear and should be set
according to the parameter list above.

The GCS will receive EFI_STATUS MAVLink messages which includes RPM,
cylinder head temperature, exhaust gas temperature, injection timing,
engine load, fuel consumption rate, throttle position atmospheric
pressure and ignition voltage.



================================================
File: drivers/LTE_modem.lua
================================================
--[[
    driver for LTE modems with AT command set
    supported chipsets:
      - SIM7600
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 106
local PARAM_TABLE_PREFIX = "LTE_"

-- local MAVLINK2 = 2
local PPP = 48

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Setup Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 20), 'LTE_modem: could not add param table')

--[[
    // @Param: LTE_ENABLE
    // @DisplayName: LTE Enable
    // @Description: Enable or disable the LTE modem driver
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
--]]
local LTE_ENABLE = bind_add_param('ENABLE',  1, 1)

--[[
    // @Param: LTE_SERPORT
    // @DisplayName: Serial Port
    // @Description: Serial port to use for the LTE modem. This is the index of the SERIALn_ ports that are set to 28 for "scripting"
    // @Range: 0 8
    // @User: Standard
--]]
local LTE_SERPORT = bind_add_param('SERPORT',  2, 0)

--[[
    // @Param: LTE_SCRPORT
    // @DisplayName: Scripting Serial Port
    // @Description: Scripting Serial port to use for the LTE modem. This is the index of the SCR_SDEV ports that are set to 2 for "MAVLink2"
    // @Range: 0 8
    // @User: Standard
--]]
local LTE_SCRPORT = bind_add_param('SCRPORT',  3, 0)

--[[
    // @Param: LTE_SERVER_IP0
    // @DisplayName: Server IP 0
    // @Description: First octet of the server IP address to connect to
    // @Range: 0 255
    // @User: Standard
--]]
local LTE_SERVER_IP0  = bind_add_param('SERVER_IP0',  4, 0)

--[[
    // @Param: LTE_SERVER_IP1
    // @DisplayName: Server IP 1
    // @Description: Second octet of the server IP address to connect to
    // @Range: 0 255
    // @User: Standard
--]]
local LTE_SERVER_IP1  = bind_add_param('SERVER_IP1',  5, 0)

--[[
    // @Param: LTE_SERVER_IP2
    // @DisplayName: Server IP 2
    // @Description: Third octet of the server IP address to connect to
    // @Range: 0 255
    // @User: Standard
--]]
local LTE_SERVER_IP2  = bind_add_param('SERVER_IP2',  6, 0)

--[[
    // @Param: LTE_SERVER_IP3
    // @DisplayName: Server IP 3
    // @Description: Fourth octet of the server IP address to connect to
    // @Range: 0 255
    // @User: Standard
--]]
local LTE_SERVER_IP3  = bind_add_param('SERVER_IP3',  7, 0)

--[[
    // @Param: LTE_SERVER_PORT
    // @DisplayName: Server Port
    // @Description: IPv4 Port of the server to connect to
    // @Range: 1 65525
    // @User: Standard
--]]
local LTE_SERVER_PORT = bind_add_param('SERVER_PORT',  8, 0)

--[[
    // @Param: LTE_BAUD
    // @DisplayName: Serial Baud Rate
    // @Description: Baud rate for the serial port to the LTE modem when connected. Initial power on baudrate is in LTE_IBAUD
    // @Values: 19200:19200,38400:38400,57600:57600,115200:115200,230400:230400,460800:460800,921600:921600,3686400:3686400
    // @User: Standard
--]]
local LTE_BAUD        = bind_add_param('BAUD',  9, 921600)

--[[
    // @Param: LTE_TIMEOUT
    // @DisplayName: Timeout
    // @Description: Timeout in seconds for the LTE connection. If no data is received for this time, the connection will be reset.
    // @Range: 1 60
    // @Units: s
    // @User: Standard
--]]
local LTE_TIMEOUT     = bind_add_param('TIMEOUT', 10, 10)

--[[
    // @Param: LTE_PROTOCOL
    // @DisplayName: LTE protocol
    // @Description: The protocol that we will use in communication with the LTE modem. If this is PPP then the LTE_SERVER parameters are not used and instead a PPP connection will be established and you should use the NET_ parameters to enable network ports. If this is MAVLink2 then the LTE_SERVER parameters are used to create a TCP connection to a single TCP server.
    // @Values: 2:MavLink2,48:PPP
    // @User: Standard
--]]
local LTE_PROTOCOL     = bind_add_param('PROTOCOL', 11, 48)

--[[
    // @Param: LTE_OPTIONS
    // @DisplayName: LTE options
    // @Description: Options to control the LTE modem driver. If VerboseSignalInfoGCS is set then additional NAMED_VALUE_FLOAT values are sent with verbose signal information
    // @Bitmask: 0:LogAllData,1:VerboseSignalInfoGCS
    // @User: Standard
--]]
local LTE_OPTIONS     = bind_add_param('OPTIONS', 12, 0)

--[[
    // @Param: LTE_IBAUD
    // @DisplayName: LTE initial baudrate
    // @Description: This is the initial baud rate on power on for the modem. This is set in the modem with the AT+IREX=baud command
    // @Values: 19200:19200,38400:38400,57600:57600,115200:115200,230400:230400,460800:460800,921600:921600,3686400:3686400
    // @User: Standard
--]]
local LTE_IBAUD       = bind_add_param('IBAUD', 13, 115200)

local LTE_OPTIONS_LOGALL = (1<<0)
local LTE_OPTIONS_SIGNALS = (1<<1)

--[[
    return true if an option is enabled
--]]
local function option_enabled(option)
    return (LTE_OPTIONS:get() & option) ~= 0
end

if LTE_ENABLE:get() == 0 then
    -- disabled
    return
end

local uart = serial:find_serial(LTE_SERPORT:get())
if not uart then
    gcs:send_text(MAV_SEVERITY.ERROR, 'LTE_modem: could not find serial port')
    return
end

local ser_device = serial:find_simulated_device(LTE_PROTOCOL:get(), LTE_SCRPORT:get())
if not ser_device then
    gcs:send_text(MAV_SEVERITY.ERROR, 'LTE_modem: could not find SCR_SDEV device')
    return
end

local step = "ATI"

local stats = { bytes_in = 0, bytes_out = 0 }

uart:begin(LTE_IBAUD:get())

--[[
    Open a log file to log the output from the modem
    This is useful for debugging the connection process
--]]
local log_file = io.open('LTE_modem.log', 'w')

--[[
    log data to log_file
--]]
local function log_data(s, marker)
    if s and #s > 0 and log_file then
        log_file:write(marker .. '[' .. s .. ']\n')
        log_file:flush()
    end
end

--[[
    Function to read from the UART and log the output
    This function reads up to 512 bytes at a time and writes it to the log file
    returns the string read or nil
--]]
local function uart_read()
    local s = uart:readstring(512)
    log_data(s, '<<<')
    stats.bytes_in = stats.bytes_in + #s
    return s
end

--[[
    Function to write to the UART and log the command
--]]
local function uart_write(s)
    uart:writestring(s)
    log_data(s, '>>>')
    stats.bytes_out = stats.bytes_out + #s
    return #s
end

-- Constants for GSM 07.10 CMUX framing
local FLAG = 0xF9
local UIH = 0xEF
local SABM = 0x2F
--local UA = 0x63
local EA = 0x01
local CR_SEND = 0x02

-- CMUX buffer state
local cmux = {}
cmux.buffers = {[1] = "", [2] = ""} -- DLC1=AT, DLC2=DATA(PPP or TCP)

--[[
    FCS lookup table for polynomial x^8 + x^2 + x^1 + 1 (0x07)
    This is the reverse of the standard CRC-8 table
--]]
local fcs_table = {
    0x00, 0x91, 0xe3, 0x72, 0x07, 0x96, 0xe4, 0x75,
    0x0e, 0x9f, 0xed, 0x7c, 0x09, 0x98, 0xea, 0x7b,
    0x1c, 0x8d, 0xff, 0x6e, 0x1b, 0x8a, 0xf8, 0x69,
    0x12, 0x83, 0xf1, 0x60, 0x15, 0x84, 0xf6, 0x67,
    0x38, 0xa9, 0xdb, 0x4a, 0x3f, 0xae, 0xdc, 0x4d,
    0x36, 0xa7, 0xd5, 0x44, 0x31, 0xa0, 0xd2, 0x43,
    0x24, 0xb5, 0xc7, 0x56, 0x23, 0xb2, 0xc0, 0x51,
    0x2a, 0xbb, 0xc9, 0x58, 0x2d, 0xbc, 0xce, 0x5f,
    0x70, 0xe1, 0x93, 0x02, 0x77, 0xe6, 0x94, 0x05,
    0x7e, 0xef, 0x9d, 0x0c, 0x79, 0xe8, 0x9a, 0x0b,
    0x6c, 0xfd, 0x8f, 0x1e, 0x6b, 0xfa, 0x88, 0x19,
    0x62, 0xf3, 0x81, 0x10, 0x65, 0xf4, 0x86, 0x17,
    0x48, 0xd9, 0xab, 0x3a, 0x4f, 0xde, 0xac, 0x3d,
    0x46, 0xd7, 0xa5, 0x34, 0x41, 0xd0, 0xa2, 0x33,
    0x54, 0xc5, 0xb7, 0x26, 0x53, 0xc2, 0xb0, 0x21,
    0x5a, 0xcb, 0xb9, 0x28, 0x5d, 0xcc, 0xbe, 0x2f,
    0xe0, 0x71, 0x03, 0x92, 0xe7, 0x76, 0x04, 0x95,
    0xee, 0x7f, 0x0d, 0x9c, 0xe9, 0x78, 0x0a, 0x9b,
    0xfc, 0x6d, 0x1f, 0x8e, 0xfb, 0x6a, 0x18, 0x89,
    0xf2, 0x63, 0x11, 0x80, 0xf5, 0x64, 0x16, 0x87,
    0xd8, 0x49, 0x3b, 0xaa, 0xdf, 0x4e, 0x3c, 0xad,
    0xd6, 0x47, 0x35, 0xa4, 0xd1, 0x40, 0x32, 0xa3,
    0xc4, 0x55, 0x27, 0xb6, 0xc3, 0x52, 0x20, 0xb1,
    0xca, 0x5b, 0x29, 0xb8, 0xcd, 0x5c, 0x2e, 0xbf,
    0x90, 0x01, 0x73, 0xe2, 0x97, 0x06, 0x74, 0xe5,
    0x9e, 0x0f, 0x7d, 0xec, 0x99, 0x08, 0x7a, 0xeb,
    0x8c, 0x1d, 0x6f, 0xfe, 0x8b, 0x1a, 0x68, 0xf9,
    0x82, 0x13, 0x61, 0xf0, 0x85, 0x14, 0x66, 0xf7,
    0xa8, 0x39, 0x4b, 0xda, 0xaf, 0x3e, 0x4c, 0xdd,
    0xa6, 0x37, 0x45, 0xd4, 0xa1, 0x30, 0x42, 0xd3,
    0xb4, 0x25, 0x57, 0xc6, 0xb3, 0x22, 0x50, 0xc1,
    0xba, 0x2b, 0x59, 0xc8, 0xbd, 0x2c, 0x5e, 0xcf
}

--[[
    Calculate FCS for a byte array
    data: table of bytes (numbers 0-255) or string
    Returns: FCS value (0-255)
--]]
local function fcs_calc(data)
    local fcs = 0xff  -- Initial value
    
    for i = 1, #data do
        local byte = string.byte(data, i)
        fcs = fcs_table[((fcs ~ byte) & 0xff) + 1] ~ (fcs >> 8)
    end

    return (~fcs) & 0xff
end

-- Construct a CMUX frame for a given DLC, data type and data
function cmux.encode_cmux_frame(dlc, dtype, data)
    local addr = string.char((dlc << 2) | EA | CR_SEND)
    local ctrl = string.char(dtype | 0x10)
    local len = #data
    local len_byte = string.char((len << 1) | EA)
    local header = addr .. ctrl .. len_byte
    local fcs = string.char(fcs_calc(header))
    return string.char(FLAG) .. header .. data .. fcs .. string.char(FLAG)
end

--[[
    send an AT command string with CMUX framing
--]]
local function cmux_AT_send(atcmd)
    local s = cmux.encode_cmux_frame(1, UIH, atcmd)
    return uart_write(s) == #s
end

--[[
    send an appropriate data reset for the protocol
--]]
local function send_data_reset()
    if LTE_PROTOCOL:get() == PPP then
        cmux_AT_send('ATH\r\n')
    else
        cmux_AT_send('AT+CRESET\r\n')
    end
end

--[[
    Function to handle errors in the response from the modem
    If an error is detected, it resets the modem
    returns true if an error was detected
--]]
local function handle_error(s)
    if s and s:find('\nERROR\r\n') then
        gcs:send_text(MAV_SEVERITY.ERROR, 'LTE_modem: error response from modem')
        send_data_reset()
        step = "ATI"
        return true
    end
    return false
end

-- Send SABM (Set Asynchronous Balanced Mode) for all DLCs
function cmux.send_sabm()
    uart_write(cmux.encode_cmux_frame(0, SABM, ""))
    uart_write(cmux.encode_cmux_frame(1, SABM, ""))
    uart_write(cmux.encode_cmux_frame(2, SABM, ""))
end

--[[
 Parses a single CMUX frame from a byte buffer.
 Returns: DLC number, extracted payload, and remaining buffer (or nils on failure)
--]]
function cmux.parse_cmux_frame(buf)
    local start_idx = buf:find(string.char(FLAG))
    if not start_idx then
        --gcs:send_text(MAV_SEVERITY.INFO, "no start idx")
        return nil, nil, nil
    end
    local end_idx = buf:find(string.char(FLAG), start_idx + 1)
    if not end_idx then
        --gcs:send_text(MAV_SEVERITY.INFO, "no end idx")
        return nil, nil, nil, "short"
    end

    local frame = buf:sub(start_idx + 1, end_idx - 1)
    if #frame < 4 then
        --gcs:send_text(MAV_SEVERITY.INFO, "too short")
        return nil, nil, nil
    end

    local addr = frame:byte(1)
    local ctrl = frame:byte(2)

    --gcs:send_text(MAV_SEVERITY.INFO, string.format("addr=0x%02x ctrl=0x%02x", addr, ctrl))

    if ctrl == SABM then
        return nil, nil, buf:sub(end_idx + 1)
    end

    if (ctrl & 0xef) ~= UIH then
        return nil, nil, nil
    end

    local len_byte = frame:byte(3)
    if (len_byte & EA) == 0 then
        gcs:send_text(MAV_SEVERITY.INFO, "mux multibyte")
        return nil, nil, nil -- we don't handle multi-byte length yet
    end
    local len = len_byte >> 1
    if #frame < 3 + len + 1 then return nil, nil, nil end

    local data = frame:sub(4, 3 + len)
    local fcs_field = frame:byte(3 + len + 1)
    local header = frame:sub(1, 3)
    local calc_fcs = fcs_calc(header)
    if calc_fcs ~= fcs_field then
        gcs:send_text(MAV_SEVERITY.INFO, "FCS mismatch")
        return nil, nil, nil -- FCS mismatch
    end

    local dlc = (addr >> 2) & 0x3F
    local remainder = buf:sub(end_idx + 1)
    --gcs:send_text(MAV_SEVERITY.INFO, string.format("CMUX got: dlc=%d ldata=%d lrem=%d", dlc, #data, #remainder))
    return dlc, data, remainder
end

-- Feeds raw UART data into CMUX frame parser and routes payloads to DLC buffers
function cmux.feed_uart_in(raw)
    while #raw > 0 do
        local dlc, data, rest, err = cmux.parse_cmux_frame(raw)
        if not dlc or not data or not rest then
            if err == "short" then
                return raw
            end
            -- discard
            return ""
        end
        if cmux.buffers[dlc] then
            cmux.buffers[dlc] = cmux.buffers[dlc] .. data
        end
        raw = rest
    end
    return raw
end

--[[
    send data with CMUX framing
--]]
local function cmux_data_send(data)
    local s = cmux.encode_cmux_frame(2, UIH, data)
    return uart_write(s) == #s
end

--[[
    send data with CMUX framing when connected (logging only if data
    logging enabled)
--]]
local function cmux_data_send_connected(data)
    local s = cmux.encode_cmux_frame(2, UIH, data)
    if option_enabled(LTE_OPTIONS_LOGALL) then
        log_data(s, '>>>')
    end
    local n = uart:writestring(s)
    stats.bytes_out = stats.bytes_out + n
    return n == #s
end

local ati_sequence = 0

--[[
    Function to confirm the connection to the modem
    it uses AIT command to get the modem info

    when we enter the ATI step the modem could be in one of several states:

    - in AT command mode
    - in muxed mode
    - in muxed mode at higher baudrate
--]]
local function step_ATI()
    local s = uart_read()
    if s and s:find('IMEI: ') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: found modem')
        if cmux.parse_cmux_frame(s) then
            -- already in CMUX mode
            cmux.send_sabm()
            send_data_reset()
            step = "BAUD"
        else
            step = "CMUX"
        end
        return
    end
    if s and #s >= 4 and s:byte(1) == FLAG and s:byte(-1) == FLAG then
        -- already in mux mode
        send_data_reset()
        cmux_AT_send('ATI\r\n')
        return
    end
    if ati_sequence % 2 == 1 then
        uart_write('+++')
    else
        uart_write('\r\nATI\r\n')
    end
    if ati_sequence % 10 == 5 then
        uart:begin(LTE_BAUD:get())
    end
    if ati_sequence % 10 == 9 then
        uart:begin(LTE_IBAUD:get())
    end
    ati_sequence = ati_sequence + 1
end

local change_baud = nil

--[[
    change baud rate
--]]
local function step_BAUD()
    cmux_AT_send(string.format('AT+IPR=%u\r\n', LTE_BAUD:get()))
    step = "CREG"
    change_baud = LTE_BAUD:get()
end

--[[
    confirm we are registered on the network
--]]
local function step_CREG()
    local s = uart_read()
    if handle_error(s) then
        return
    end
    if s and s:find('CREG: 0,1\r\n') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: CREG OK')
        if LTE_PROTOCOL:get() == PPP then
            step = "PPPOPEN"
        else
            step = "CIPMODE"
        end
        return
    end
    cmux_AT_send('AT+CREG?\r\n')
end

--[[
    set the modem to transparent mode
--]]
local function step_CIPMODE()
    local s = uart_read()
    if handle_error(s) then
        return
    end
    if s and s:find('CIPMODE=1\r') and s:find('\r\r\nOK\r') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: transparent mode set')
        step = "NETOPEN"
        return
    end
    cmux_data_send('AT+CIPMODE=1\r\n')
end

--[[
    setup CMUX multiplexing mode
--]]
local function step_CMUX()
    local s = uart_read()
    if handle_error(s) then
        return
    end
    if s and s:find('CMUX=0\r\r\nOK\r') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: CMUX mode set')
        -- send SABM frames to establish the DLCs
        send_data_reset()
        cmux.send_sabm()
        step = "BAUD"
        return
    end
    uart_write('AT+CMUX=0\r\n')
end

--[[
    open the network stack
    needed to be able to open a TCP connection
--]]
local function step_NETOPEN()
    local s = uart_read()
    if handle_error(s) then
        return
    end
    if s and s:find('NETOPEN\r') and s:find('\r\r\nOK\r\n') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: network opened')
        step = "CIPOPEN"
        return
    end
    cmux_data_send('AT+NETOPEN\r\n')
end

local last_data_ms = millis()
local pending_to_modem = ""
local pending_to_fc = ""
local pending_to_parse = ""

--[[
    open PPP mode
--]]
local function step_PPPOPEN()
    local s = uart_read()
    if handle_error(s) then
        return
    end

    if s and s:find('CONNECT ') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: connected')
        last_data_ms = millis()
        pending_to_modem = ""
        pending_to_fc = ""
        pending_to_parse = ""
        step = "CONNECTED"
        return
    end
    cmux_data_send('AT+CGDATA="PPP",1\r\n')
end

--[[
    open a TCP connection to the server
    the server IP and port are defined in the parameters
--]]
local function step_CIPOPEN()
    local s = uart_read()
    if handle_error(s) then
        return
    end

    if s and s:find('CONNECT ') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: connected')
        last_data_ms = millis()
        pending_to_modem = ""
        pending_to_fc = ""
        pending_to_parse = ""
        step = "CONNECTED"
        return
    end
    if LTE_SERVER_PORT:get() <= 0 then
        gcs:send_text(MAV_SEVERITY.ERROR, "Must set LTE_SERVER_PORT")
        return
    end
    cmux_data_send(string.format('AT+CIPOPEN=0,"TCP","%d.%d.%d.%d",%d\r\n',
                                 LTE_SERVER_IP0:get(), LTE_SERVER_IP1:get(), LTE_SERVER_IP2:get(), LTE_SERVER_IP3:get(),
                                 LTE_SERVER_PORT:get()))
end

--[[
    handle AT replies in CMUX mode
--]]
local function handle_AT_reply(s)
    -- check for CSQ reply
    local rssi_raw, ber_raw = s:match("%+CSQ:%s*(%d+),(%d+)")
    if rssi_raw then
        gcs:send_named_float('LTE_RSSI', rssi_raw)
        logger:write("LTE",'RSSI,BER,Bin,Bout','iiII',
                     rssi_raw,
                     ber_raw,
                     stats.bytes_in,
                     stats.bytes_out)
        -- gcs:send_text(MAV_SEVERITY.INFO, string.format("RSSI:%d BER:%d", rssi_raw, ber_raw))
        return
    end
    -- check for CSPI reply
    -- example: +CPSI: LTE,Online,505-02,0xCBE8,36519691,101,EUTRAN-BAND3,1800,5,5,-147,-1143,-764,11
    local system_mode, operation_mode, mcc_mnc, tac_str, scell_id_str, pcid_str, earfcn_band, ul_freq_str, dl_freq_str, tdd_cfg_str, rsrp_str, rsrq_str, rssi_str, sinr_str =
    s:match("%+CPSI:%s*([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([%-]?%d+),([%-]?%d+),([%-]?%d+),([%-]?%d+)")

    if system_mode then
        -- Convert strings to numbers
        local tac = tonumber(tac_str:match("0x(%w+)"), 16) or tonumber(tac_str) or 0
        local scell_id = tonumber(scell_id_str) or 0
        local pcid = tonumber(pcid_str) or 0
        local ul_freq = tonumber(ul_freq_str) or 0
        local dl_freq = tonumber(dl_freq_str) or 0
        local tdd_cfg = tonumber(tdd_cfg_str) or 0
        local rsrp = tonumber(rsrp_str) or 0
        local rsrq = tonumber(rsrq_str) or 0
        local rssi = tonumber(rssi_str) or 0
        local sinr = tonumber(sinr_str) or 0
        local band = earfcn_band:match("[^%d]+(%d+)") or -1
        logger:write("LTES",'Md,Op,MCC,TAC,CID,PID,BND,F,DF,TDD,RP,RQ,RS,SR','nNNIIINHhhhhhh',
                     system_mode, operation_mode, mcc_mnc, tac, scell_id, pcid, earfcn_band,
                     ul_freq, dl_freq, tdd_cfg, rsrp, rsrq, rssi, sinr)
        if option_enabled(LTE_OPTIONS_SIGNALS) then
            gcs:send_named_float('LTE_RSRP', rsrp)
            gcs:send_named_float('LTE_RSRQ', rsrq)
            gcs:send_named_float('LTE_SINR', sinr)
            gcs:send_named_float('LTE_BAND', band)
            gcs:send_named_float('LTE_FREQ', ul_freq)
            gcs:send_named_float('LTE_CID', scell_id)
        end
        return
    end

    if s:find("PPPD: DISCONNECTED") then
        step = "PPPOPEN"
    end
end

local last_CSQ_ms = millis()
local last_CSQ_reply_ms = uint32_t(0)
local last_parse_ms = uint32_t(0)

--[[
    handle data while connected
--]]
local function step_CONNECTED()
    local s = uart:readstring(512)
    stats.bytes_in = stats.bytes_in + #s
    if option_enabled(LTE_OPTIONS_LOGALL) then
        log_data(s, '<<<')
    end
    if s and s:find('\r\nCLOSED\r\n') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: connection closed, reconnecting')
        step = "CIPOPEN"
        return
    end
    if s and s:find('PPPD: DISCONNECTED\r\n') then
        gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: PPP closed, reconnecting')
        step = "PPPOPEN"
        return
    end
    local now_ms = millis()
    if s and #s > 0 then
        pending_to_parse = pending_to_parse .. s
        pending_to_parse = cmux.feed_uart_in(pending_to_parse)
        if now_ms - last_parse_ms > 1000 then
            pending_to_parse = ""
        end
        if #cmux.buffers[1] > 0 then
            last_parse_ms = now_ms
            --gcs:send_text(MAV_SEVERITY.INFO, string.format("AT reply %d", #cmux.buffers[1]))
            handle_AT_reply(cmux.buffers[1])
            cmux.buffers[1] = ""
        end
        if #cmux.buffers[2] > 0 then
            last_data_ms = now_ms
            -- gcs:send_text(MAV_SEVERITY.INFO, string.format("data input %d", #cmux.buffers[2]))
            last_parse_ms = now_ms
            pending_to_fc = pending_to_fc .. cmux.buffers[2]
            cmux.buffers[2] = ""
        end
    elseif now_ms - last_data_ms > uint32_t(LTE_TIMEOUT:get() * 1000) then
        gcs:send_text(MAV_SEVERITY.ERROR, 'LTE_modem: timeout')
        step = "ATI"
        return
    end
    s = ser_device:readstring(512)
    if s then
        pending_to_modem = pending_to_modem .. s
    end

    --[[
        going via these pending buffers allows for rapid bursts of data and takes advantage
        of the hardware flow control
    --]]
    local buffer_limit = 10240 -- so we don't run out of memory
    if #pending_to_modem > buffer_limit then
        pending_to_modem = ""
    end
    if #pending_to_fc > buffer_limit then
        pending_to_fc = ""
    end
    
    while #pending_to_modem > 0 do
        local n = #pending_to_modem
        if n > 127 then
            n = 127
        end
        -- gcs:send_text(MAV_SEVERITY.INFO, string.format("data output %d", n))
        if not cmux_data_send_connected(pending_to_modem:sub(1, n)) then
            break
        end
        pending_to_modem = pending_to_modem:sub(n + 1)
    end
    if #pending_to_fc > 0 then
        local nwritten = ser_device:writestring(pending_to_fc)
        if nwritten > 0 then
            pending_to_fc = pending_to_fc:sub(nwritten + 1)
        end
    end
    -- request CSQ signal strength at 1Hz
    if now_ms - last_CSQ_ms > 1000 then
        last_CSQ_ms = now_ms
        cmux_AT_send("AT+CSQ\r\n")
        cmux_AT_send("AT+CPSI?\r\n")
    end
    if now_ms - last_CSQ_reply_ms > 5000 then
        last_CSQ_reply_ms = now_ms
        gcs:send_named_float('LTE_RSSI', -1)
    end
end

local step_count = 0
local last_step = nil

local function update()
    if LTE_ENABLE:get() == 0 then
        return update, 500
    end

    if change_baud then
        uart:begin(change_baud)
        change_baud = nil
    end

    if step == "CONNECTED" then
        -- run the connected step at 200Hz
        step_CONNECTED()
        step_count = 0
        return update, 5
    end

    -- prevent getting stuck
    if step == last_step and step ~= "ATI" then
        step_count = step_count + 1
        if step_count > 50 then
            gcs:send_text(MAV_SEVERITY.INFO, "LTE_modem: step reset")
            step = "ATI"
        end
    else
        step_count = 0
    end
    last_step = step

    gcs:send_text(MAV_SEVERITY.INFO, string.format('LTE_modem: step %s', step))

    if step == "ATI" then
        step_ATI()
        return update, 1100
    end

    if step == "BAUD" then
        step_BAUD()
        return update, 200
    end

    if step == "CREG" then
        step_CREG()
        return update, 500
    end
    
    if step == "CIPMODE" then
        step_CIPMODE()
        return update, 200
    end

    if step == "NETOPEN" then
        step_NETOPEN()
        return update, 200
    end

    if step == "CMUX" then
        step_CMUX()
        return update, 200
    end

    if step == "PPPOPEN" then
        step_PPPOPEN()
        return update, 200
    end
    
    if step == "CIPOPEN" then
        step_CIPOPEN()
        return update, 200
    end

    gcs:send_text(MAV_SEVERITY.ERROR, string.format("LTE_modem: bad step %s", step))
    step = "ATI"
end

gcs:send_text(MAV_SEVERITY.INFO, 'LTE_modem: starting')

return update,500



================================================
File: drivers/LTE_modem.md
================================================
# LTE Modem Driver

This driver implements support for LTE modems for establishing
cellular data connections. It provides either PPP or a transparent TCP
connectivity to a remote server through the LTE modem, allowing
network communication over LTE networks without using a companion
computer.

The driver best paired with with the ArduPilot remote support server
https://support.ardupilot.org, but can also be used for any other
network service.

If you don't have access to the ArduPilot support server you can
install your own using https://github.com/ArduPilot/UDPProxy

# Supported Hardware

Currently the only modem that is supported is the SIM76xx series of
modems from SimCom.

# Parameters

The script uses the following parameters:

## LTE_ENABLE

This must be set to 1 to enable the driver. Set to 0 to disable the
LTE modem driver.

## LTE_PROTOCOL

This controls if a PPP connection will be used or a raw TCP connection
with MAVLink2.

Set LTE_PROTOCOL to 48 for PPP and enable ArduPilot networking with
the NET_ENABLE=1 parameter.

Set LTE_PROTOCOL to 2 for MAVLink2 and enable the LTE_SERVER
parameters for the TCP server you want to connect to.

Note that the LTE_PROTOCOL parameter must match the value of the
SCR_SDEVn_PROTO parameter.

## LTE_SERPORT

This sets the serial port to use for the LTE modem. This is the index
of the SERIALn_ ports that are set to 28 for "scripting".

## LTE_SCRPORT

This sets the scripting serial port to use for the LTE modem. This is
the index of the SCR_SDEVn ports that are set to 2 for "MAVLink2". This
port handles the MAVLink data that will be transmitted over the LTE
connection. You must first set SCR_SDEV_EN to 1 to enable scripting
serial devices.

## LTE_SERVER_IP0

This is the first octet of the server IP address to connect to. The
full IP address is constructed from LTE_SERVER_IP0 through
LTE_SERVER_IP3. Range: 0-255. This is not used with PPP.

## LTE_SERVER_IP1

This is the second octet of the server IP address to connect to.
Range: 0-255. This is not used with PPP.

## LTE_SERVER_IP2

This is the third octet of the server IP address to connect to.
Range: 0-255. This is not used with PPP.

## LTE_SERVER_IP3

This is the fourth octet of the server IP address to connect to.
Range: 0-255. This is not used with PPP.

## LTE_SERVER_PORT

This sets the IPv4 port of the server to connect to. This should match
the port that your ground control station or server is listening on.
Range: 1-65525. This is not used with PPP.

## LTE_BAUD

This sets the baud rate for the serial port to the LTE modem to use
for data transfer. Common values are 115200 or 921600. Default:
115200.

## LTE_IBAUD

The initial baud rate when the modem is powered on. This is normally
115200 but can be changed in the modem using the AT+IREX terminal command.

## LTE_TIMEOUT

This sets the timeout in seconds for the LTE connection. If no data is
received for this time, the connection will be reset and the driver
will attempt to reconnect. Range: 1-60 seconds. Default: 10 seconds.

## LTE_OPTIONS

This sets options for debugging and data display

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - A SERIALn_PROTOCOL should be set to 28 (Scripting) where n matches LTE_SERPORT
 - SCR_SDEV should be set to 48 (PPP) or 2 (MAVLink2) for the port matching LTE_SCRPORT

If using PPP then you also need to ensure PPP support is compiled into
your firmware (you can use https://custom.ardupilot.org to do that)
and set NET_ENABLE=1. You will likely also want to setup some outgoing
UDP or TCP ports with the NET_Pn parameters.

Then the flight controller should be rebooted and parameters should be
refreshed.

Once loaded, the LTE_ parameters will appear and should be configured
according to the parameter list above. The server IP address and port
must be set to match your ground control station or telemetry server.

Here is a full set of required parameter settings assuming you want to
use PPP and make a TCP connection to the ArduPilot support server on
port 20001. It assumes you have the modem on Telem1 (SERIAL1)

 - SCR_ENABLE 1
 - SCR_SDEV_EN 1
 - SCR_SDEV1_PROTO 48
 - SERIAL1_PROTOCOL 28
 - LTE_PROTOCOL 48
 - NET_ENABLE 1
 - NET_P1_TYPE 3
 - NET_P1_IP0 157
 - NET_P1_IP1 245
 - NET_P1_IP2 83
 - NET_P1_IP3 174
 - NET_P1_PORT 20001

here is an alternative configuration where a direct TCP connection to
the support server is used and modem is attached on SERAL1 (no PPP used)

 - SCR_ENABLE 1
 - SCR_SDEV_EN 1
 - SCR_SDEV1_PROTO 2
 - SERIAL1_PROTOCOL 28
 - LTE_PROTOCOL 2
 - LTE_SERVER_IP0 157
 - LTE_SERVER_IP1 245
 - LTE_SERVER_IP2 83
 - LTE_SERVER_IP3 174
 - LTE_SERVER_PORT 20001

# Status Messages

The driver provides status messages through the GCS indicating the current
connection state:

- "LTE_modem: starting" - Driver initialization
- "LTE_modem: found modem" - Modem detected and responding
- "LTE_modem: CREG OK" - Network registration successful
- "LTE_modem: transparent mode set" - Modem configured for transparent operation
- "LTE_modem: network opened" - Network stack ready
- "LTE_modem: connected" - TCP connection established
- "LTE_modem: connection closed, reconnecting" - Connection lost, attempting reconnection
- "LTE_modem: timeout" - No data received within timeout period
- "LTE_modem: error response from modem" - Modem returned an error

# Physical Connections

The modem should be connected to a flight controller serial
port. You may also want to use a serial port with hardware flow
control support and set BRD_SERn_RTSCRS to 1 for that port.

Note that the modems can be quite sensitive to power supply
issues. The power from the serial port will likely not be sufficient.

# Troubleshooting

The driver creates a log file "LTE_modem.log" on the SD card that contains
all communication with the modem. This log can be useful for debugging
connection issues.

Common issues:
- Ensure the SIM card is properly inserted and activated
- Check that the cellular antenna is properly connected
- Verify network coverage at the operating location
- Confirm the server IP address and port are correct and reachable
- Check that the serial port configuration matches between the flight controller and modem

If the connection fails or is lost, the driver will automatically attempt
to reconnect by restarting the connection sequence.

# Logging

A LTE log message is saved in the onboard log. That has signal
strength information and data transfer statistics.

A NAMED_VALUE_FLOAT MAVLink message "LTE_RSSI" is sent with the RSSI
signal strength.



================================================
File: drivers/UltraMotion.lua
================================================
--[[
   driver for UltraMotion servos
   https://www.ultramotion.com/
   based on an earlier driver by Fred Darnell
--]]

local PARAM_TABLE_KEY = 89
local PARAM_TABLE_PREFIX = "UM_"

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: UM_SERVO_MASK
  // @DisplayName: Mask of UltraMotion servos
  // @Description: Mask of UltraMotion servos
  // @Bitmask: 0:SERVO1,1:SERVO2,2:SERVO3,3:SERVO4,4:SERVO5,5:SERVO6,6:SERVO7,7:SERVO8,8:SERVO9,9:SERVO10,10:SERVO11,11:SERVO12
  // @User: Standard
--]]
UM_SERVO_MASK = bind_add_param("SERVO_MASK", 1, 0)

--[[
  // @Param: UM_CANDRV
  // @DisplayName: Set CAN driver
  // @Description: Set CAN driver
  // @Values: 0:None,1:1stCANDriver,2:2ndCanDriver
  // @User: Standard
--]]
local UM_CANDRV = bind_add_param('CANDRV', 2, 1)    -- CAN driver to use

--[[
  // @Param: UM_RATE_HZ
  // @DisplayName: Update rate for UltraMotion servos
  // @Description: Update rate for UltraMotion servos
  // @Units: Hz
  // @Range: 1 400
  // @User: Standard
--]]
UM_RATE_HZ = bind_add_param("RATE_HZ", 3, 70)

--[[
  // @Param: UM_OPTIONS
  // @DisplayName: Optional settings
  // @Description: Optional settings
  // @Bitmask: 0:LogAllFrames,1:ParseTelemetry,2:SendPosAsNamedValueFloat
  // @User: Standard
--]]
UM_OPTIONS = bind_add_param("OPTIONS", 5, 0)

local OPTION_LOGALLFRAMES = 0x01
local OPTION_PARSETELEM = 0x02
local OPTION_NVF_TELEM_POS = 0x04

if UM_SERVO_MASK:get() == 0 then
   gcs:send_text(MAV_SEVERITY.INFO, "UltraMotion UM_SERVO_MASK is empty")
   return
end

-- Load CAN driver, using the scripting protocol
-- use a buffer size of 25
local CAN_BUF_LEN = 25
if UM_CANDRV:get() == 1 then
   driver = CAN:get_device(CAN_BUF_LEN)
elseif UM_CANDRV:get() == 2 then
   driver = CAN:get_device2(CAN_BUF_LEN)
end
if not driver then
   gcs:send_text(MAV_SEVERITY.INFO, "UltraMotion: init failed")
   return
end

local frame_count = 0

-- marker for extended frame format
local CAN_FLAG_EFF = uint32_t(1)<<31

--[[
   frame logging - can be replayed with Tools/scripts/CAN/CAN_playback.py
--]]
local function log_can_frame(frame)
   logger:write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                frame:id(),
                frame:dlc(),
                frame_count,
                frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                frame:data(4), frame:data(5), frame:data(6), frame:data(7))
   frame_count = frame_count + 1
end

--[[
   create a new actuator object
--]]
function Actuator(unitID)
    local o = {}
    o.unitID = unitID or 0
    -- pre-fill the msg ID to avoid expensive uint32_t operations at runtime
    o.msg = CANFrame()
    o.msg:id(CAN_FLAG_EFF | uint32_t(unitID))
    o.msg:dlc(2)
    return o
end

--[[
   put a 16 bit little endian value
--]]
local function put_uint16(msg, ofs, value)
   msg:data(ofs, value & 0xFF)
   msg:data(ofs+1, value >> 8)
end

--[[
   use the UM_SERVO_MASK to create a table of actuators
   need to restart scripting to change the UM_SERVO_MASK
--]]
local actuators = {}
for i = 1, 32 do
   local mask = 1 << (i-1)
   if UM_SERVO_MASK:get() & mask ~= 0 then
      actuators[i] = Actuator(i)
   end
end

--[[
   send outputs to all servos
--]]
local function send_outputs()
   local noutputs = #actuators
   for i = 1, noutputs do
      local pwm = SRV_Channels:get_output_pwm_chan(actuators[i].unitID-1)
      local msg = actuators[i].msg

      put_uint16(msg, 0, pwm)

      driver:write_frame(msg, 10000)
   end
end

--[[
   parse one telemetry frame. The telemetry data format depends on
   the txData parameter set in the servos

   This code assumes txData is KLMGHEFY. See the datasheet for the
   meaning of these data codes
--]]
local function parse_telemetry(frame)
   local bytes = ""
   local dlc = frame:dlc()
   for i = 1, dlc do
      bytes = bytes .. string.char(frame:data(i-1))
   end
   local swordlow, sword24, pos, curr, temp = string.unpack("<HBHHB", bytes)
   local statusword = swordlow | (sword24 << 16)
   local txid = frame:id_signed()
   local pos_scaled = pos / 65535.0
   local current_scaled = curr / 32767.0
   local temp_scaled = temp - 50.0
   if txid < 256 then
      logger:write('UMSV','Id,Status,Curr,Pos,Temp','Bifff','#----','-----', txid, statusword, current_scaled, pos_scaled, temp_scaled)
      if UM_OPTIONS:get() & OPTION_NVF_TELEM_POS ~= 0 then
         gcs:send_named_float(string.format('UMPOS_%u',txid), pos_scaled)
      end
   end
end

--[[
   read any incoming CAN frames
--]]
local function read_frames()
   for _ = 1,30 do
      local frame = driver:read_frame()
      if not frame then
         return
      end
      if UM_OPTIONS:get() & OPTION_LOGALLFRAMES ~= 0 then
         log_can_frame(frame)
      end
      if UM_OPTIONS:get() & OPTION_PARSETELEM ~= 0 then
         if frame:dlc() == 8 then
            -- assume any 8 byte frame is a telemetry frame
            parse_telemetry(frame)
         end
      end
   end
end

function update()
   send_outputs()
   read_frames()
   return update, 1000/UM_RATE_HZ:get()
end

gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded UltraMotion with %u actuators", #actuators))

return update, 100



================================================
File: drivers/UltraMotion.md
================================================
# UltraMotion CAN Driver

This driver implements support for the UltraMotion CAN servos

# Parameters

The script used the following parameters:

## UM_SERVO_MASK

Mask of servo channels to transmit using UltraMotion CAN messages

## UM_CANDRV

This sets the CAN scripting driver number to attach to. This is
normally set to 1 to use a CAN driver with CAN_Dx_PROTOCOL=10. To use
the 2nd scripting CAN driver set this to 2 and set CAN_Dx_PROTOCOL=12.

## UM_RATE_HZ

This sets the update rate of the script in Hz (how often it checks for
new data from the ECU). A value of 200 is reasonable.

## UM_OPTIONS

This sets optional features. Set bit 1 for enabling CAN logging. Bit 2
enables telemetry parsing. Bit 3 for sending the position of all
servos as NAMED_VALUE_FLOAT MAVLink packets of name UMPOS_n where n is
the unit ID.

# Operation

This driver should be loaded by placing the lua script in the
APM/SCRIPTS directory on the microSD card, which can be done either
directly or via MAVFTP. The following key parameters should be set:

 - SCR_ENABLE should be set to 1
 - UM_SERVO_MASK needs to be set to a mask of servos

It is also strongly recommended that you raise SCR_THD_PRIORITY to 3
to ensure the script gets sufficient priority.

then the flight controller should rebooted and parameters should be
refreshed.

# Telemetry Support

To use telemetry you need to setup the servos with a specific txData
format. The code currently assumes txData is pABCDEFS




================================================
File: drivers/mount-djirs2-driver.lua
================================================
-- mount-djirs2-driver.lua: DJIRS2 mount/gimbal driver

--[[
  How to use
    Connect gimbal to autopilot's CAN1 port or CAN2 port
    If connected to CAN1, set CAN_D1_PROTOCOL = 10 (Scripting), CAN_P1_DRIVER = 1 (First driver)
    If connected to CAN2, set CAN_D2_PROTOCOL = 10 (Scripting), CAN_P2_DRIVER = 2 (Second driver)
    Set SCR_ENABLE = 1 to enable scripting
    Set SCR_HEAP_SIZE = 120000 (or higher)
    Set MNT1_TYPE = 9 (Scripting) to enable the mount/gimbal scripting driver
    Reboot the autopilot
    Copy this script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot
    set DJIR_DEBUG to 1 to display parsing and errors stats at 5sec.  Set to 2 to display gimbal angles

  Advanced usage
    The gimbal can be connected to an existing DroneCAN bus (on ArduPilot 4.6 or later) by setting CAN_Dx_PROTOCOL2=10 on that bus's driver
    The gimbal can be used as the Nth mount (instead of the first) by setting MNTn_TYPE = 9 and modifying the script's user definitions
    The gimbal can be used with the Scripting2 protocol by modifying the script's user definitions
    Multiple gimbals can be used at once by duplicating the script and connecting them to different buses
 
  The following sources were used as a reference during the development of this script
    Constant Robotics DJIR SDK: https://github.com/ConstantRobotics/DJIR_SDK
    Ceinem's ROS node for DJI RS2: https://github.com/ceinem/dji_rs2_ros_controller

  CAN format
    packet's data segment holds up to 8 serial bytes.  These should be extracted and sent to the serial packet parser
    the CAN packets will never hold the contents of more than one serial packet

    the external caller (e.g. this script) must send CAN frames with frameId = 0x223
    gimbal will reply with frameId = 0x222

  Serial Packet format
     byte      description     notes
     0         header          AA
     1~2       Ver/Length      bits 0~9 are length of entire frame, LSB first. bits 10~15 are version number
     3         CmdType         bits 0~4 are Reply type, 0=No Reply required, 1=Can reply or not after data sent, 2~31=Reply is required after data sent
                               bit 5 is Frame type, 0=Command frame, 1=Reply Frame
                               bits 6~7 reserved (0 by default)
     4         ENC             bits 0~4 length of supplementary bytes when encrypting
                               bits 5~7 Encryption type, 0=Unencrypted, 1=AES256 encyrption
     5~7       RES             reserved
     8~9       SEQ             sequence number.  increments with each packet
     10~11     CRC-16          frame header check
     12~n      Data            Data segment Start
       12        CmdSet        Data segment Command set
       13        CmdID         Data segment Command code
       14~n      Data content  Data content
     n+1       CRC-32          frame check (the entire frame)

  Used CmdSet and CmdId
     0x0E, 0x00: Handheld Gimbal Position Control
       Command frame bytes
        0~1: yaw angle * 10, int16, -1800 to +1800
        2~3: roll angle * 10, int16, -300 to +300
        4~5: pitch angle * 10, int16, -560 to +1460
        6: ctrl_byte, uint8
              bit0 = 0:relative control, 1:absolute control
              bit1 = 0:yaw axis valid, 1:invalid
              bit2 = 0:roll axis valid, 1:invalid
              bit3 = 0:pitch axis valid, 1:invalid
              bit4~7 = reserved, must be zero
        7: time for action, uint8_t, unit: 0.1s.  e.g. if 20, gimbal will rotate to the position desired within 2sec
      Reply frame bytes
        0: return code, uint8_t

     0x0E, 0x02: Obtain the angle information of handheld gimbal, including joint angle and attitude angle
       Command frame bytes
        0: ctrl_byte, uint8_t, 0x00:No operation, 0x01:angle of handlheld gimbal, 0x02:joint angle of handheld gimbal
      Reply frame bytes
        0: return code, uint8_t
        1: data_type, uint8_t, 0x00:Data is not ready, 0x01:attitude angle, 0x02:joint angle
        2~3: yaw angle * 10, int16, -1800 to +1800
        4~5: roll angle * 10, int16, -300 to +300
        6~7: pitch angle * 10, int16, -560 to +1460


--]]

-- user definitions
local MOUNT_INSTANCE = 0                -- default to MNT1
local CAN_INSTANCE = 0                  -- default to first scripting CAN protocol

-- global definitions
local INIT_INTERVAL_MS = 3000           -- attempt to initialise the gimbal at this interval
local UPDATE_INTERVAL_MS = 1            -- update interval in millis
local REPLY_TIMEOUT_MS = 100            -- timeout waiting for reply after 0.1 sec
local REQUEST_ATTITUDE_INTERVAL_MS = 100-- request attitude at 10hz
local SET_ATTITUDE_INTERVAL_MS = 100    -- set attitude at 10hz
local SEND_FRAMEID = 0x223              -- send CAN messages with this frame id
local RECEIVE_FRAMEID = 0x222           -- receive CAN messages with this frame id
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- parameters
local PARAM_TABLE_KEY = 38
assert(param:add_table(PARAM_TABLE_KEY, "DJIR_", 2), "could not add param table")
assert(param:add_param(PARAM_TABLE_KEY, 1, "DEBUG", 0), "could not add DJIR_DEBUG param")
assert(param:add_param(PARAM_TABLE_KEY, 2, "UPSIDEDOWN", 0), "could not add DJIR_UPSIDEDOWN param")

--[[
  // @Param: DJIR_DEBUG
  // @DisplayName: DJIRS2 debug
  // @Description: Enable DJIRS2 debug
  // @Values: 0:Disabled,1:Enabled,2:Enabled with attitude reporting
  // @User: Advanced
--]]
local DJIR_DEBUG = Parameter("DJIR_DEBUG")              -- debug level. 0:disabled 1:enabled 2:enabled with attitude reporting

--[[
  // @Param: DJIR_UPSIDEDOWN
  // @DisplayName: DJIRS2 upside down
  // @Description: DJIRS2 upside down
  // @Values: 0:Right side up,1:Upside down
  // @User: Standard
--]]
local DJIR_UPSIDEDOWN = Parameter("DJIR_UPSIDEDOWN")    -- 0:rightsideup, 1:upsidedown

-- message definitions
local HEADER = 0xAA
local RETURN_CODE = {SUCCESS=0x00, PARSE_ERROR=0x01, EXECUTION_FAILED=0x02, UNDEFINED=0xFF}
local ATTITUDE_PACKET_LEN = {LEGACY=24, LATEST=26}      -- attitude packet expected length.  Legacy must be less than latest
local POSITION_CONTROL_PACKET_LEN = {LEGACY=17, LATEST=19}  -- position control packet expected length.  Legacy must be less than latest
local SPEED_CONTROL_PACKET_LEN = {LEGACY=17, LATEST=19} -- speed control packet expected length.  Legacy must be less than latest

-- parsing state definitions
local PARSE_STATE_WAITING_FOR_HEADER        = 0
local PARSE_STATE_WAITING_FOR_VERLENGTH     = 1
local PARSE_STATE_WAITING_FOR_DATA          = 2

-- other parsing definitions
local CAN_PACKET_LENGTH_MAX = 8         -- CAN packet maximum length
local SERIAL_PACKET_LENGTH_MAX = 32     -- serial packet maximum length.  used to sanity check length of incoming messages
local SERIAL_PACKET_LENGTH_MIN = 16     -- serial packet minimum length.  used to sanity check sends

-- local variables and definitions
local driver                            -- CAN bus
local initialised = false               -- true once connection to gimbal has been initialised
local parse_state = PARSE_STATE_WAITING_FOR_HEADER  -- parse state
local parse_length = 0                  -- incoming message's packet length
local parse_buff = {}                   -- message buffer holding roll, pitch and yaw angles from gimbal
local parse_bytes_recv = 0              -- message buffer length.  count of the number of bytes received in the message so far
local last_send_seq = 0                 -- last sequence number sent
local last_req_attitude_ms = uint32_t(0)  -- system time of last request for attitude
local last_set_attitude_ms = uint32_t(0)  -- system time of last set attitude call
local REPLY_TYPE = {NONE=0, ATTITUDE=1, POSITION_CONTROL=2, SPEED_CONTROL=3} -- enum of expected reply types
local expected_reply = REPLY_TYPE.NONE  -- currently expected reply type
local expected_reply_ms = uint32_t(0)   -- system time that reply is first expected.  used for timeouts

-- parsing status reporting variables
local last_print_ms = uint32_t(0)       -- system time that debug output was last printed
local bytes_read = 0                    -- number of bytes read from gimbal
local bytes_written = 0                 -- number of bytes written to gimbal
local bytes_error = 0                   -- number of bytes read that could not be parsed
local write_fails = 0                   -- number of times write failed
local execute_fails = 0                 -- number of times that gimbal was unable to execute the command
local reply_timeouts = 0                -- number of timeouts waiting for replies

local crc16_lookup = {
    0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
    0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
    0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
    0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
    0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
    0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
    0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
    0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
    0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
    0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
    0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
    0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
    0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
    0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
    0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
    0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
    0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
    0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
    0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
    0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
    0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
    0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
    0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
    0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
    0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
    0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
    0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
    0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
    0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
    0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
    0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
    0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
}

local crc32_lookup = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
}

-- calculate crc16 for a series of bytes
-- byte_array should be a table of uint8 values
-- start_byte should be the first byte to start from (using 1 indexing) or left as nil to default to the first byte
-- num_bytes should be the number of bytes to process or left as nil to use the entire message
function calc_crc16(byte_array, start_byte, num_bytes)
  start_byte = start_byte or 1
  num_bytes = num_bytes or #byte_array - start_byte + 1
  local crc = 0x3AA3
  for i = start_byte, num_bytes do
    local b = byte_array[i] & 0xFF
    local crc16_lookup_index = ((crc ~ b) % 256) + 1
    local lookup_val = crc16_lookup[crc16_lookup_index]
    crc = ((crc >> 8) & 0xFF) ~ lookup_val
  end
  return crc
end

-- calculate crc32 for a series of bytes
-- byte_array should be a table of uint8 values
-- start_byte should be the first byte to start from (using 1 indexing) or left as nil to default to the first byte
-- num_bytes should be the number of bytes to process or left as nil to use the entire message
function calc_crc32(byte_array, start_byte, num_bytes)
  start_byte = start_byte or 1
  num_bytes = num_bytes or #byte_array - start_byte + 1
  local crc = 0x3AA3
  for i = start_byte, num_bytes do
    local b = byte_array[i] & 0xFF
    local crc32_lookup_index = (((crc ~ b) & 0xff) + 1)
    local lookup_val = crc32_lookup[crc32_lookup_index]
    crc = ((crc >> 8) & 0x00FFFFFF) ~ lookup_val
  end
  return crc
end

-- get lowbyte of a number
function lowbyte(num)
  return num & 0xFF
end

-- get highbyte of a number
function highbyte(num)
  return (num >> 8) & 0xFF
end

-- get int16 from two bytes
function int16_value(hbyte, lbyte)
  local uret = uint16_value(hbyte, lbyte)
  if uret <= 0x8000 then
    return uret
  else
    return uret - 0x10000
  end
end

-- get uint16 from two bytes
function uint16_value(hbyte, lbyte)
  return ((hbyte & 0xFF) << 8) | (lbyte & 0xFF)
end

-- get uint32 from four bytes
function uint32_value(byte3, byte2, byte1, byte0)
  return (((byte3 & 0xFF) << 24) | ((byte2 & 0xFF) << 16) | ((byte1 & 0xFF) << 8) | (byte0 & 0xFF))
end

-- wrap yaw angle in degrees to value between 0 and 360
function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

-- wrap yaw angle in degrees to value between -180 and +180
function wrap_180(angle_deg)
  local res = wrap_360(angle_deg)
  if res > 180 then
    res = res - 360
  end
  return res
end

-- perform any require initialisation
function init()
  local mnt_type_name = ("MNT%d_TYPE"):format(MOUNT_INSTANCE+1)
  local mnt_type = param:get(mnt_type_name)
  if mnt_type ~= 9 then
    gcs:send_text(MAV_SEVERITY.CRITICAL, ("DJIR: set %s=9"):format(mnt_type_name))
    do return end
  end

  -- get CAN device and filter to receive only replies from the gimbal
  local buffer_size = 8 -- buffer up to two replies
  if CAN_INSTANCE == 0 then
    driver = CAN:get_device(buffer_size)
  elseif CAN_INSTANCE == 1 then
    driver = CAN:get_device2(buffer_size)
  end
  if driver and driver:add_filter(-1, RECEIVE_FRAMEID) then
    initialised = true
    gcs:send_text(MAV_SEVERITY.INFO, "DJIR: mount driver started")   
  else
    gcs:send_text(MAV_SEVERITY.CRITICAL, "DJIR: failed to connect to CAN bus")   
  end
end

-- send serial message over CAN bus
-- returns true on success, false on failure
function send_msg(serial_msg)

  if not serial_msg then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "DJIR: cannot send invalid message")
    do return false end
  end

  -- calculate number of CAN frames required to send mesage
  local num_frames = math.floor(#serial_msg / CAN_PACKET_LENGTH_MAX)
  if #serial_msg % CAN_PACKET_LENGTH_MAX > 0 then
    num_frames = num_frames + 1
  end

  -- create and send CAN messages
  for i=0, num_frames-1 do
    local start_byte = i * CAN_PACKET_LENGTH_MAX + 1
    local finish_byte = math.min(start_byte + CAN_PACKET_LENGTH_MAX - 1 , #serial_msg)
    local num_bytes = finish_byte - start_byte + 1

    local canframe = CANFrame()
    canframe:id(SEND_FRAMEID)
    canframe:dlc(num_bytes)
    for j = 0, num_bytes-1 do
      canframe:data(j, serial_msg[start_byte+j])
    end
    if driver:write_frame(canframe, 10000) then
      bytes_written = bytes_written + num_bytes
    else
      write_fails = write_fails + 1
      -- on failure do not send rest of message
      do return false end
    end
  end

  return true
end

-- get next sequence number that should be used for send commands
function get_next_sequence_number()
  last_send_seq = last_send_seq + 1
  if last_send_seq > 0xFFFF then
    last_send_seq = 0
  end
  return last_send_seq
end

-- update serial message's sequence number, crc-16 and crc-32 fields
function update_msg_seq_and_crc(serial_msg)
  -- sanity checks
  if not serial_msg then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "DJIR: update_msg_seq_and_crc null arg")
    do return end
  end
  if #serial_msg < SERIAL_PACKET_LENGTH_MIN then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "DJIR: update_msg_seq_and_crc message too short")
    do return end
  end

  -- update sequence
  local seq = get_next_sequence_number()
  serial_msg[9] = lowbyte(seq)
  serial_msg[10] = highbyte(seq)

  -- update header crc16
  local crc16 = calc_crc16(serial_msg, 1, 10)
  serial_msg[11] = lowbyte(crc16)
  serial_msg[12] = highbyte(crc16)

  -- update entire frame's crc32
  local crc32 = calc_crc32(serial_msg, 1, #serial_msg-4)
  serial_msg[#serial_msg-3] = lowbyte(crc32)
  serial_msg[#serial_msg-2] = lowbyte(crc32 >> 8)
  serial_msg[#serial_msg-1] = lowbyte(crc32 >> 16)
  serial_msg[#serial_msg] = lowbyte(crc32 >> 24)
end

-- request attitude from gimbal
function request_attitude()
  -- Field number                  1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19
  --                             SOF  LenL  LenH CmdTyp  Enc   RES   RES   RES  SeqL  SeqH  CrcL  CrcH CmdSet CmdId Data1 CRC32 CRC32 CRC32 CRC32
  local request_attitude_msg = {0xAA, 0x13, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0E, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00}

  -- update_msg_seq_and_crc
  update_msg_seq_and_crc(request_attitude_msg)

  -- send bytes
  if send_msg(request_attitude_msg) then
    expected_reply = REPLY_TYPE.ATTITUDE
    expected_reply_ms = millis()
  else
    expected_reply = REPLY_TYPE.NONE
  end
end

-- send target angles (in degrees) to gimbal
-- yaw_angle_deg is always a body-frame angle
function send_target_angles(roll_angle_deg, pitch_angle_deg, yaw_angle_deg, time_sec)
  -- default argument values
  roll_angle_deg = roll_angle_deg or 0
  pitch_angle_deg = pitch_angle_deg or 0
  yaw_angle_deg = yaw_angle_deg or 0
  time_sec = time_sec or 2

  -- if upsidedown, add 180deg to yaw
  if DJIR_UPSIDEDOWN:get() > 0 then
    yaw_angle_deg = wrap_180(yaw_angle_deg + 180)
  end

  -- ensure angles are integers
  roll_angle_deg = math.floor(roll_angle_deg + 0.5)
  pitch_angle_deg = math.floor(pitch_angle_deg + 0.5)
  yaw_angle_deg = math.floor(yaw_angle_deg + 0.5)
  time_sec = math.floor(time_sec + 0.5)

  --    0x0E, 0x00: Handheld Gimbal Position Control
  --      Command frame bytes
  --       0~1: yaw angle * 10, int16, -1800 to +1800
  --       2~3: roll angle * 10, int16, -300 to +300
  --       4~5: pitch angle * 10, int16, -560 to +1460
  --       6: ctrl_byte, uint8
  --             bit0 = 0:relative control, 1:absolute control
  --             bit1 = 0:yaw axis valid, 1:invalid
  --             bit2 = 0:roll axis valid, 1:invalid
  --             bit3 = 0:pitch axis valid, 1:invalid
  --             bit4~7 = reserved, must be zero
  --       7: time for action, uint8_t, unit: 0.1s.  e.g. if 20, gimbal will rotate to the position desired within 2sec
  --
  -- Field number                1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    26
  -- Field name                SOF  LenL  LenH CmdTyp  Enc   RES   RES   RES  SeqL  SeqH  CrcL  CrcH CmdSet CmdId YawL  YawH  RollL RollH PitL  PitH  Ctrl  Time CRC32 CRC32 CRC32 CRC32
  local set_target_att_msg = {0xAA, 0x1A, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x20, 0x00, 0x30, 0x00, 0x40, 0x00, 0x01, 0x14, 0x00, 0x00, 0x00, 0x00}

  -- set angles
  set_target_att_msg[15] = lowbyte(yaw_angle_deg * 10)
  set_target_att_msg[16] = highbyte(yaw_angle_deg * 10)
  set_target_att_msg[17] = lowbyte(roll_angle_deg * 10)
  set_target_att_msg[18] = highbyte(roll_angle_deg * 10)
  set_target_att_msg[19] = lowbyte(pitch_angle_deg * 10)
  set_target_att_msg[20] = highbyte(pitch_angle_deg * 10)

  -- set time
  set_target_att_msg[22] = lowbyte(time_sec * 10)

  -- update_msg_seq_and_crc
  update_msg_seq_and_crc(set_target_att_msg)

  -- send bytes
  if send_msg(set_target_att_msg) then
    expected_reply = REPLY_TYPE.POSITION_CONTROL
    expected_reply_ms = millis()
  else
    expected_reply = REPLY_TYPE.NONE
  end
end

-- send target rates (in deg/sec) to gimbal
function send_target_rates(roll_rate_degs, pitch_rate_degs, yaw_rate_degs)
  -- default argument values
  roll_rate_degs = roll_rate_degs or 0
  pitch_rate_degs = pitch_rate_degs or 0
  yaw_rate_degs = yaw_rate_degs or 0

  -- ensure rates are integers. invert roll direction
  roll_rate_degs = -math.floor(roll_rate_degs + 0.5)
  pitch_rate_degs = math.floor(pitch_rate_degs + 0.5)
  yaw_rate_degs = math.floor(yaw_rate_degs + 0.5)

  --    0x0E, 0x01: Handheld Gimbal Speed Control
  --      Command frame bytes
  --       0~1: yaw speed * 10, int16, -3600 to +3600
  --       2~3: roll speed * 10, int16, -3600 to +3600
  --       4~5: pitch speed * 10, int16, -3600 to +3600
  --       6: ctrl_byte, uint8, always use 0x88
  --             bit0~2 = reserved, must be zero
  --             bit3 = 0:consider focal length, 1:do not consider focal length
  --             bit4~6 = reserved, must be zero
  --             bit7 = 0:release speed control, 1:take over speed control
  --
  -- Field number                  1     2     3     4     5     6     7     8     9    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25
  -- Field name                  SOF  LenL  LenH CmdTyp  Enc   RES   RES   RES  SeqL  SeqH  CrcL  CrcH CmdSet CmdId YawL  YawH  RollL RollH PitL  PitH  Ctrl CRC32 CRC32 CRC32 CRC32
  local set_target_speed_msg = {0xAA, 0x19, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x88, 0x00, 0x00, 0x00, 0x00}

  -- set rates
  set_target_speed_msg[15] = lowbyte(yaw_rate_degs * 10)
  set_target_speed_msg[16] = highbyte(yaw_rate_degs * 10)
  set_target_speed_msg[17] = lowbyte(roll_rate_degs * 10)
  set_target_speed_msg[18] = highbyte(roll_rate_degs * 10)
  set_target_speed_msg[19] = lowbyte(pitch_rate_degs * 10)
  set_target_speed_msg[20] = highbyte(pitch_rate_degs * 10)

  -- update_msg_seq_and_crc
  update_msg_seq_and_crc(set_target_speed_msg)

  -- send bytes
  if send_msg(set_target_speed_msg) then
    expected_reply = REPLY_TYPE.SPEED_CONTROL
    expected_reply_ms = millis()
  else
    expected_reply = REPLY_TYPE.NONE
  end
end

-- consume incoming CAN packets
function read_incoming_packets()
  local canframe
  while true do
    canframe = driver:read_frame()
    if not canframe then return end
    for i = 0, canframe:dlc()-1 do
      parse_byte(canframe:data(i))
    end
  end
end

-- parse an byte from the gimbal
function parse_byte(b)

    -- update num bytes read (for reporting only)
    bytes_read = bytes_read + 1

    -- clear buffer while waiting for header
    if parse_state == PARSE_STATE_WAITING_FOR_HEADER then
      parse_expected_crc = 0
      parse_bytes_recv = 0
    end

    -- add byte to buffer
    parse_bytes_recv = parse_bytes_recv + 1
    parse_buff[parse_bytes_recv] = b

    -- waiting for header
    if parse_state == PARSE_STATE_WAITING_FOR_HEADER then
      if b == HEADER then
        parse_state = PARSE_STATE_WAITING_FOR_VERLENGTH
        do return end
      else
        -- unexpected byte
        bytes_error = bytes_error + 1
      end
    end

    -- waiting for version/length LSB
    if parse_state == PARSE_STATE_WAITING_FOR_VERLENGTH then
      if parse_bytes_recv == 2 then
        parse_length = b
      else
        parse_length = uint16_value(b & 0x03, parse_length)
        if (parse_length < SERIAL_PACKET_LENGTH_MIN) or (parse_length > SERIAL_PACKET_LENGTH_MAX) then
          -- invalid length
          parse_state = PARSE_STATE_WAITING_FOR_HEADER
          bytes_error = bytes_error + 1
        else
          parse_state = PARSE_STATE_WAITING_FOR_DATA
        end
      end
      do return end
    end

    -- waiting for data
    if (parse_state == PARSE_STATE_WAITING_FOR_DATA) and (parse_bytes_recv >= parse_length) then
        -- check crc16
        local expected_crc16 = calc_crc16(parse_buff, 1, 10)
        local received_crc16 = uint16_value(parse_buff[12], parse_buff[11])
        if (expected_crc16 ~= received_crc16) then
          if DJIR_DEBUG:get() > 0 then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: crc16 exp:%x got:%x", expected_crc16, received_crc16))
          end
          bytes_error = bytes_error + 1
          parse_state = PARSE_STATE_WAITING_FOR_HEADER
          do return end
        end

        -- check crc32
        local expected_crc32 = calc_crc32(parse_buff, 1, parse_length-4)
        local received_crc32 = uint32_value(parse_buff[parse_length], parse_buff[parse_length-1], parse_buff[parse_length-2], parse_buff[parse_length-3])
        if (expected_crc32 ~= received_crc32) then
          if DJIR_DEBUG:get() > 0 then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: crc32 exp:%x got:%x", expected_crc32, received_crc32))
          end
          bytes_error = bytes_error + 1
          parse_state = PARSE_STATE_WAITING_FOR_HEADER
          do return end
        end

        -- check if reply
        local cmd_type_reply = (parse_buff[4] & 0x20) > 0

        -- process reply messages
        if cmd_type_reply then

          if expected_reply == REPLY_TYPE.NONE then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: unexpected reply len:%d", parse_length))
          end

          -- parse attitude reply message
          if (expected_reply == REPLY_TYPE.ATTITUDE) and (parse_length >= ATTITUDE_PACKET_LEN.LEGACY) then
            -- default to legacy format but also handle latest format
            local ret_code_field = 13
            local yaw_field = 15
            local pitch_field = 17
            local roll_field = 19
            if (parse_length >= ATTITUDE_PACKET_LEN.LATEST) then
              ret_code_field = 15
              yaw_field = 17
              pitch_field = 21
              roll_field = 19
            end
            local ret_code = parse_buff[ret_code_field]
            if ret_code == RETURN_CODE.SUCCESS then
              local yaw_deg = int16_value(parse_buff[yaw_field+1],parse_buff[yaw_field]) * 0.1
              local pitch_deg = int16_value(parse_buff[pitch_field+1],parse_buff[pitch_field]) * 0.1
              local roll_deg = int16_value(parse_buff[roll_field+1],parse_buff[roll_field]) * 0.1
              -- if upsidedown, subtract 180deg from yaw to undo addition of target
              if DJIR_UPSIDEDOWN:get() > 0 then
                yaw_deg = wrap_180(yaw_deg - 180)
              end
              mount:set_attitude_euler(MOUNT_INSTANCE, roll_deg, pitch_deg, yaw_deg)
              if DJIR_DEBUG:get() > 1 then
                gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: roll:%4.1f pitch:%4.1f yaw:%4.1f", roll_deg, pitch_deg, yaw_deg))
              end
            else
              execute_fails = execute_fails + 1
            end
          end

          -- parse position control reply message
          if (expected_reply == REPLY_TYPE.POSITION_CONTROL) and (parse_length >= POSITION_CONTROL_PACKET_LEN.LEGACY) then
            -- default to legacy format but also handle latest format
            local ret_code_field = 13
            if (parse_length >= POSITION_CONTROL_PACKET_LEN.LATEST) then
              ret_code_field = 15
            end
            local ret_code = parse_buff[ret_code_field]
            if ret_code ~= RETURN_CODE.SUCCESS then
              execute_fails = execute_fails + 1
            end
          end

          -- parse speed control reply message
          if (expected_reply == REPLY_TYPE.SPEED_CONTROL) and (parse_length >= SPEED_CONTROL_PACKET_LEN.LEGACY) then
            -- default to legacy format but also handle latest format
            local ret_code_field = 13
            if (parse_length >= SPEED_CONTROL_PACKET_LEN.LATEST) then
              ret_code_field = 15
            end
            local ret_code = parse_buff[ret_code_field]
            if ret_code ~= RETURN_CODE.SUCCESS then
              execute_fails = execute_fails + 1
            end
          end

          -- clear expected reply flag
          expected_reply = REPLY_TYPE.NONE
        else
          -- not attempting to parse
          gcs:send_text(MAV_SEVERITY.INFO, "DJIR: skipped reply:" .. tostring(cmd_type_reply) .. "len:" .. tostring(parse_length))
        end

       parse_state = PARSE_STATE_WAITING_FOR_HEADER
       do return end
    end

end

-- the main update function that performs a simplified version of RTL
function update()

  -- initialise connection to gimbal
  if not initialised then
    init()
    return update, INIT_INTERVAL_MS
  end

  -- consume incoming bytes
  read_incoming_packets()

  -- get system time
  local now_ms = millis()

  -- report parsing status
  if (DJIR_DEBUG:get() > 0) and ((now_ms - last_print_ms) > 5000) then
    last_print_ms = now_ms
    gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: r:%u w:%u fail:%u,%u perr:%u to:%u", bytes_read, bytes_written, write_fails, execute_fails, bytes_error, reply_timeouts))
  end

  -- handle expected reply timeouts
  if (expected_reply ~= REPLY_TYPE.NONE) then
    if ((now_ms - expected_reply_ms) > REPLY_TIMEOUT_MS) then
      if DJIR_DEBUG:get() > 0 then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("DJIR: timeout expecting %d", expected_reply))
      end
      expected_reply = REPLY_TYPE.NONE
      reply_timeouts = reply_timeouts + 1
    else
      -- do not process any messages
      return update, UPDATE_INTERVAL_MS
    end
  end

  -- request gimbal attitude
  if now_ms - last_req_attitude_ms > REQUEST_ATTITUDE_INTERVAL_MS then
    last_req_attitude_ms = now_ms
    request_attitude()
    return update, UPDATE_INTERVAL_MS
  end

  -- set gimbal attitude or rate
  if now_ms - last_set_attitude_ms > SET_ATTITUDE_INTERVAL_MS then
    last_set_attitude_ms = now_ms

    -- send angle target
    local roll_deg, pitch_deg, yaw_deg, yaw_is_ef = mount:get_angle_target(MOUNT_INSTANCE)
    if roll_deg and pitch_deg and yaw_deg then
      if yaw_is_ef then
        -- convert to body-frame
        yaw_deg = wrap_180(yaw_deg - math.deg(ahrs:get_yaw_rad()))
      end
      send_target_angles(roll_deg, pitch_deg, yaw_deg, 1)
      return update, UPDATE_INTERVAL_MS
    end

    -- send rate target (ignoring earth-frame flag as the gimbal doesn't use it)
    local roll_degs, pitch_degs, yaw_degs, _ = mount:get_rate_target(MOUNT_INSTANCE)
    if roll_degs and pitch_degs and yaw_degs then
      send_target_rates(roll_degs, pitch_degs, yaw_degs)
      return update, UPDATE_INTERVAL_MS
    end
    return update, UPDATE_INTERVAL_MS
  end

  return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: drivers/mount-djirs2-driver.md
================================================
# DJI RS2 and RS3-Pro Mount Driver

DJI RS2 and RS3-Pro gimbal mount driver lua script

## How to use

- Connect gimbal to autopilot's CAN1 port or CAN2 port
- If connected to CAN1, set CAN_D1_PROTOCOL = 10 (Scripting), CAN_P1_DRIVER = 1 (First driver)
- If connected to CAN2, set CAN_D2_PROTOCOL = 10 (Scripting), CAN_P2_DRIVER = 2 (Second driver)
- Set SCR_ENABLE = 1 to enable scripting
- Set SCR_HEAP_SIZE = 120000 (or higher)
- Set MNT1_TYPE = 9 (Scripting) to enable the mount/gimbal scripting driver
- Reboot the autopilot
- Copy the mount-djirs2-driver.lua script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot

## Advanced usage
- The gimbal can be connected to an existing DroneCAN bus (on ArduPilot 4.6 or later) by setting CAN_Dx_PROTOCOL2=10 on that bus's driver
- The gimbal can be used as the Nth mount (instead of the first) by setting MNTn_TYPE = 9 and modifying the script's user definitions
- The gimbal can be used with the Scripting2 protocol by modifying the script's user definitions
- Multiple gimbals can be used at once by duplicating the script and connecting them to different buses

## Issues

If the ground station reports "Pre-arm: Mount not healthy", update the 
gimbal firmware using the DJI Ronin phone app to version 01.04.00.20 or 
later to correct a mismatch in the way data is received from the gimbal. 
Completing this update may take more than an hour.



================================================
File: drivers/mount-viewpro-driver.lua
================================================
-- mount-viewpro-driver.lua: Viewpro mount/gimbal driver

--[[
  How to use
    Connect gimbal UART to one of the autopilot's serial ports
    Set SERIALx_PROTOCOL = 28 (Scripting) where "x" corresponds to the serial port connected to the gimbal
    Set SCR_ENABLE = 1 to enable scripting and reboot the autopilot
    Set MNT1_TYPE = 9 (Scripting) to enable the mount/gimbal scripting driver
    Set CAM1_TYPE = 7 (Scripting) to enable the camera scripting driver
    Set RCx_OPTION = 300 (Scripting1) to allow real-time selection of the video feed and camera control
    Copy this script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot
    Set VIEP_CAM_SWLOW, VIEP_CAM_SWMID, VIEP_CAM_SWHIGH to which cameras are controlled by the auxiliary switch
        0: No change in camera selection
        1: EO1
        2: IR thermal
        3: EO1 + IR Picture-in-picture
        4: IR + EO1 Picture-in-picture
        5: Fusion
        6: IR1 13mm
        7: IR2 52mm
    Set VIEP_ZOOM_SPEED to control speed of zoom (value between 0 and 7)
    Set VIEP_ZOOM_MAX to the maximum zoom.  E.g. for a camera with 20x zoom, set to 20
    Optionally set VIEP_DEBUG = 1 or 2 to increase level of debug output to the GCS
 
  Packet format
     byte      description     notes
     0~2       header          0x55 0xAA 0xDC
     3         body length     bit0~5: body length, n=all bytes from byte3 to checksum, min=4, max=63.  bits6~7: frame counter
     4         frame id
     5~n+1     data            1st byte is command id?
     n+2       checksum        XOR of byte3 to n+1 (inclusive)
--]]

---@diagnostic disable: cast-local-type
---@diagnostic disable: undefined-global

-- parameters
local PARAM_TABLE_KEY = 39
assert(param:add_table(PARAM_TABLE_KEY, "VIEP_", 6), "could not add param table")
assert(param:add_param(PARAM_TABLE_KEY, 1, "DEBUG", 0), "could not add VIEP_DEBUG param")
assert(param:add_param(PARAM_TABLE_KEY, 2, "CAM_SWLOW", 1), "could not add VIEP_CAM_SWLOW param")
assert(param:add_param(PARAM_TABLE_KEY, 3, "CAM_SWMID", 2), "could not add VIEP_CAM_SWMID param")
assert(param:add_param(PARAM_TABLE_KEY, 4, "CAM_SWHIGH", 6), "could not add VIEP_CAM_CAM_SWHIGH param")
assert(param:add_param(PARAM_TABLE_KEY, 5, "ZOOM_SPEED", 7), "could not add VIEP_ZOOM_SPEED param")
assert(param:add_param(PARAM_TABLE_KEY, 6, "ZOOM_MAX", 20), "could not add VIEP_ZOOM_MAX param")

-- bind parameters to variables
local MNT1_TYPE = Parameter("MNT1_TYPE")    -- should be 9:Scripting
local CAM1_TYPE = Parameter("CAM1_TYPE")    -- should be 7:Scripting

--[[
  // @Param: VIEP_DEBUG
  // @DisplayName: ViewPro debug
  // @Description: ViewPro debug
  // @Values: 0:Disabled, 1:Enabled, 2:Enabled including attitude reporting
  // @User: Advanced
--]]
local VIEP_DEBUG = Parameter("VIEP_DEBUG")  -- debug level. 0:disabled 1:enabled 2:enabled with attitude reporting

--[[
  // @Param: VIEP_CAM_SWLOW
  // @DisplayName: ViewPro Camera For Switch Low
  // @Description: Camera selection when switch is in low position
  // @Values: 0:No change in camera selection, 1:EO1, 2:IR thermal, 3:EO1 + IR Picture-in-picture, 4:IR + EO1 Picture-in-picture, 5:Fusion, 6:IR1 13mm, 7:IR2 52mm
  // @User: Standard
--]]
local VIEP_CAM_SWLOW = Parameter("VIEP_CAM_SWLOW")      -- RC swith low position's camera selection

--[[
  // @Param: VIEP_CAM_SWMID
  // @DisplayName: ViewPro Camera For Switch Mid
  // @Description: Camera selection when switch is in middle position
  // @Values: 0:No change in camera selection, 1:EO1, 2:IR thermal, 3:EO1 + IR Picture-in-picture, 4:IR + EO1 Picture-in-picture, 5:Fusion, 6:IR1 13mm, 7:IR2 52mm
  // @User: Standard
--]]
local VIEP_CAM_SWMID = Parameter("VIEP_CAM_SWMID")      -- RC swith middle position's camera selection

--[[
  // @Param: VIEP_CAM_SWHIGH
  // @DisplayName: ViewPro Camera For Switch High
  // @Description: Camera selection when switch is in high position
  // @Values: 0:No change in camera selection, 1:EO1, 2:IR thermal, 3:EO1 + IR Picture-in-picture, 4:IR + EO1 Picture-in-picture, 5:Fusion, 6:IR1 13mm, 7:IR2 52mm
  // @User: Standard
--]]
local VIEP_CAM_SWHIGH = Parameter("VIEP_CAM_SWHIGH")    -- RC swith high position's camera selection

--[[
  // @Param: VIEP_ZOOM_SPEED
  // @DisplayName: ViewPro Zoom Speed
  // @Description: ViewPro Zoom Speed.  Higher numbers result in faster zooming
  // @Range: 0 7
  // @User: Standard
--]]
local VIEP_ZOOM_SPEED = Parameter("VIEP_ZOOM_SPEED")    -- zoom speed from 0 (slow) to 7 (fast)

--[[
  // @Param: VIEP_ZOOM_MAX
  // @DisplayName: ViewPro Zoom Times Max
  // @Description: ViewPro Zoom Times Max
  // @Range: 0 30
  // @User: Standard
--]]
local VIEP_ZOOM_MAX = Parameter("VIEP_ZOOM_MAX")        -- zoom times max

-- global definitions
local CAM_SELECT_RC_OPTION = 300        -- rc channel option used to control which camera/video is used. RCx_OPTION = 300 (scripting1)
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local INIT_INTERVAL_MS = 3000           -- attempt to initialise the gimbal at this interval
local UPDATE_INTERVAL_MS = 100          -- update at 10hz
local MOUNT_INSTANCE = 0                -- always control the first mount/gimbal
local CAMERA_INSTANCE = 0               -- always use the first camera

-- packet parsing definitions
local HEADER1 = 0x55                    -- 1st header byte
local HEADER2 = 0xAA                    -- 2nd header byte
local HEADER3 = 0xDC                    -- 3rd header byte
local PACKET_LENGTH_MIN = 4             -- serial packet minimum length.  used for sanity checks
local PACKET_LENGTH_MAX = 63            -- serial packet maximum length.  used for sanity checks

-- parsing state definitions
local PARSE_STATE_WAITING_FOR_HEADER1   = 0
local PARSE_STATE_WAITING_FOR_HEADER2   = 1
local PARSE_STATE_WAITING_FOR_HEADER3   = 2
local PARSE_STATE_WAITING_FOR_LENGTH    = 3
local PARSE_STATE_WAITING_FOR_FRAMEID   = 4
local PARSE_STATE_WAITING_FOR_DATA      = 5

-- received FrameId
local T1_F1_B1_D1_FRAMEID = 0x40        -- includes roll, pitch, yaw angles

-- camera operation commands
local CAM_COMMAND_NO_ACTION = 0x00
local CAM_COMMAND_STOP_FOCUS_AND_ZOOM = 0x01
local CAM_COMMAND_ZOOM_OUT = 0x08
local CAM_COMMAND_ZOOM_IN = 0x09
local CAM_COMMAND_FOCUS_PLUS = 0x0A
local CAM_COMMAND_FOCUS_MINUS = 0x0B
local CAM_COMMAND_TAKE_PICTURE = 0x13
local CAM_COMMAND_START_RECORD = 0x14
local CAM_COMMAND_STOP_RECORD = 0x15
local CAM_COMMAND_AUTO_FOCUS = 0x19
local CAM_COMMAND_MANUAL_FOCUS = 0x1A

-- tracking commands
local TRACK_COMMAND_STOP = 0x01
local TRACK_COMMAND_START = 0x03
local TRACK_COMMAND2_SET_POINT = 0x0A
local TRACK_COMMAND2_SET_RECT_TOPLEFT = 0x0B
local TRACK_COMMAND2_SET_RECT_BOTTOMRIGHT = 0x0C

-- camera control2 commands
local CAM_COMMAND2_SET_EO_ZOOM = 0x53

-- hardcoded outgoing messages
local HEARTBEAT_MSG = {0x55,0xAA,0xDC,0x44,0x00,0x00,0x44}

-- local variables and definitions
local uart                              -- uart object connected to mount
local initialised = false               -- true once connection to gimbal has been initialised
local parse_state = PARSE_STATE_WAITING_FOR_HEADER1 -- parse state
local parse_expected_crc = 0            -- incoming messages expected crc.  this is checked against actual crc received
local parse_length = 0                  -- incoming message parsed length
local parse_frameid = 0                 -- incoming message command id
local parse_data_buff = {}              -- data buffer holding roll, pitch and yaw angles from gimbal
local parse_data_bytes_recv = 0         -- count of the number of bytes received in the message so far
local last_frame_counter = 0            -- last frame counter sent to gimbal.  always between 0 and 3
local cam_choice = 0                    -- last camera choice (see VIEP_CAM_SWLOW/MID/HIGH parameters)
local cam_pic_count = 0                 -- last picture count.  used to detect trigger pic
local cam_rec_video = false             -- last record video state.  used to detect record video
local cam_zoom_type = 0                 -- last zoom type 1:Rate 2:Pct
local cam_zoom_value = 0                -- last zoom value.  If rate, zoom out = -1, hold = 0, zoom in = 1.  If Pct then value from 0 to 100
local cam_focus_type = 0                -- last focus type 1:Rate, 2:Pct, 4:Auto
local cam_focus_value = 0               -- last focus value.  If Rate then focus in = -1, focus hold = 0, focus out = 1
local last_tracking_type = 0            -- last recorded tracking type (0:None, 1:Point, 2:Rectangle)
local last_tracking_p1x = 0             -- last recorded tracking point1 (used for center or top-left)
local last_tracking_p1y = 0             -- last recorded tracking point1 (used for center or top-left)
local last_tracking_p2x = 0             -- last recorded tracking point2 (bottom-right)
local last_tracking_p2y = 0             -- last recorded tracking point2 (bottom-right)
local tracking_active = false           -- true when tracking is active (rate and angle controls are disabled)

-- parsing status reporting variables
local last_print_ms = 0                 -- system time that debug output was last printed
local bytes_read = 0                    -- number of bytes read from gimbal
local bytes_written = 0                 -- number of bytes written to gimbal
local bytes_error = 0                   -- number of bytes read that could not be parsed
local msg_ignored = 0                   -- number of ignored messages (because frame id does not match)

-- debug variables
local last_test_send_md = 0             -- system time that a test message was last sent
local debug_buff = {}                   -- debug buffer to display bytes from gimbal

-- get lowbyte of a number
function lowbyte(num)
  return num & 0xFF
end

-- get highbyte of a number
function highbyte(num)
  return (num >> 8) & 0xFF
end

-- get uint16 from two bytes
function uint16_value(hbyte, lbyte)
  return ((hbyte & 0xFF) << 8) | (lbyte & 0xFF)
end

-- get int16 from two bytes
function int16_value(hbyte, lbyte)
  local uret = uint16_value(hbyte, lbyte)
  if uret <= 0x8000 then
    return uret
  else
    return uret - 0x10000
  end
end

-- wrap yaw angle in degrees to value between 0 and 360
function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

-- wrap yaw angle in degrees to value between -180 and +180
function wrap_180(angle_deg)
  local res = wrap_360(angle_deg)
  if res > 180 then
    res = res - 360
  end
  return res
end

-- calculate crc from existing crc value and new byte
function calc_crc(orig_crc, b)
  local crc = (orig_crc ~ b) & 0xFF
  return crc
end

-- find and initialise serial port connected to gimbal
function init()
  -- check mount parameter
  if MNT1_TYPE:get() ~= 9 then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "ViewPro: set MNT1_TYPE=9")
    do return end
  end

  -- check cam type parametr
  if CAM1_TYPE:get() ~= 7 then
    gcs:send_text(MAV_SEVERITY.CRITICAL, "ViewPro: set CAM1_TYPE=7")
    do return end
  end

  -- find and init first instance of SERIALx_PROTOCOL = 28 (Scripting)
  uart = serial:find_serial(0)
  if uart == nil then
    gcs:send_text(3, "ViewPro: no SERIALx_PROTOCOL = 28") -- MAV_SEVERITY_ERR
  else
    uart:begin(115200)
    uart:set_flow_control(0)
    initialised = true
    gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: started")
  end
end

-- send hard coded message
function send_msg(msg)
  for i=1,#msg do
    uart:write(msg[i])
    -- debug
    bytes_written = bytes_written + 1
  end
end

-- parse test message
function parse_test_msg(msg)
  for i=1,#msg do
    parse_byte(msg[i])
  end
end

-- reading incoming packets from gimbal
function read_incoming_packets()
  local n_bytes = uart:available()
  while n_bytes > 0 do
    n_bytes = n_bytes - 1
    parse_byte(uart:read())
  end
end

-- parse a single byte from gimbal
function parse_byte(b)
    -- record num bytes for reporting
    bytes_read = bytes_read + 1

    -- debug
    if VIEP_DEBUG:get() > 1 then
      debug_buff[#debug_buff+1] = b
      if #debug_buff >= 10 then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: %x %x %x %x %x %x %x %x %x %x", debug_buff[1], debug_buff[2], debug_buff[3], debug_buff[4], debug_buff[5], debug_buff[6], debug_buff[7], debug_buff[8], debug_buff[9], debug_buff[10]))
        debug_buff = {}
      end
    end

    -- waiting for header1
    if parse_state == PARSE_STATE_WAITING_FOR_HEADER1 then
      if b == HEADER1 then
        parse_state = PARSE_STATE_WAITING_FOR_HEADER2
        parse_expected_crc = 0
        parse_data_bytes_recv = 0
        do return end
      end
      bytes_error = bytes_error + 1
    end

    -- waiting for header2
    if parse_state == PARSE_STATE_WAITING_FOR_HEADER2 then
      if b == HEADER2 then
        parse_state = PARSE_STATE_WAITING_FOR_HEADER3
      else
        -- unexpected byte so reset parsing state
        parse_state = PARSE_STATE_WAITING_FOR_HEADER1
        bytes_error = bytes_error + 1
      end
      do return end
    end

    -- waiting for header3
    if parse_state == PARSE_STATE_WAITING_FOR_HEADER3 then
      if b == HEADER3 then
        parse_state = PARSE_STATE_WAITING_FOR_LENGTH
      else
        -- unexpected byte so reset parsing state
        parse_state = PARSE_STATE_WAITING_FOR_HEADER1
        bytes_error = bytes_error + 1
      end
      do return end
    end

    -- waiting for length
    if parse_state == PARSE_STATE_WAITING_FOR_LENGTH then
      parse_expected_crc = calc_crc(parse_expected_crc, b)
      parse_length = b & 0x3F
      if parse_length >= PACKET_LENGTH_MIN and parse_length <= PACKET_LENGTH_MAX then
        parse_state = PARSE_STATE_WAITING_FOR_FRAMEID
      else
        -- unexpected length
        parse_state = PARSE_STATE_WAITING_FOR_HEADER1
        bytes_error = bytes_error + 1
        if VIEP_DEBUG:get() > 0 then
          gcs:send_text(MAV_SEVERITY.ERROR, string.format("ViewPro: invalid len:%d", parse_length))
        end
      end
      do return end
    end

    -- waiting for command id
    if parse_state == PARSE_STATE_WAITING_FOR_FRAMEID then
      parse_expected_crc = calc_crc(parse_expected_crc, b)
      parse_frameid = b
      parse_state = PARSE_STATE_WAITING_FOR_DATA
      do return end
    end

    -- waiting for data
    if parse_state == PARSE_STATE_WAITING_FOR_DATA then

      -- check for crc
      if parse_data_bytes_recv >= parse_length - 3 then
        if b == parse_expected_crc then
          -- crc matched, process packet
          local processed = false

          -- T1_F1_B1_D1
          if parse_frameid == T1_F1_B1_D1_FRAMEID then
            processed = true
            -- T1 holds target info including target lean angles
            -- F1 holds tracker sensor status (which camera, tracking vs lost)
            -- B1 section holds actual lean angles
            -- D1 section holds camera status including zoom level
            local servo_status = (parse_data_buff[24] & 0xF0 >> 4)
            local roll_deg = int16_value(parse_data_buff[24] & 0x0F, parse_data_buff[25]) * (180.0/4095.0) - 90.0
            local yaw_deg = int16_value(parse_data_buff[26], parse_data_buff[27]) * (360.0 / 65536.0)
            local pitch_deg = -int16_value(parse_data_buff[28], parse_data_buff[29]) * (360.0 / 65536.0)
            mount:set_attitude_euler(MOUNT_INSTANCE, roll_deg, pitch_deg, yaw_deg)

            if VIEP_DEBUG:get() > 0 then
              gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: r:%f p:%f y:%f ss:%x", roll_deg, pitch_deg, yaw_deg, servo_status))
            end
          end

          if not processed then
            msg_ignored = msg_ignored + 1
            if VIEP_DEBUG:get() > 0 then
              gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: ignored frameid:%x", parse_frameid))
            end
          end
        else
          -- crc mismatch
          bytes_error = bytes_error + 1
          if VIEP_DEBUG:get() > 0 then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: crc exp:%x got:%x", parse_expected_crc, b))
          end
        end
        parse_state = PARSE_STATE_WAITING_FOR_HEADER1
        do return end
      end

      -- add latest byte to crc and buffer
      parse_expected_crc = calc_crc(parse_expected_crc, b)
      parse_data_bytes_recv = parse_data_bytes_recv + 1
      parse_data_buff[parse_data_bytes_recv] = b
    end
end

-- write a byte to the uart and update the checksum
function write_byte(b, checksum)
  if b == nil or checksum == nil then
    gcs:send_text(3, "ViewPro: failed to write byte") -- MAV_SEVERITY_ERR
    return
  end
  local byte_to_write = b & 0xFF
  uart:write(byte_to_write)
  bytes_written = bytes_written + 1
  local checksum_ret = (checksum ~ byte_to_write) & 0xFF
  return checksum_ret
end

-- calculate length and frame count byte
-- length is all bytes after the header including CRC
function calc_length_and_frame_byte(length)
  -- increment frame counter
  last_frame_counter = last_frame_counter + 1 & 0x03
  return  (last_frame_counter << 6 | length & 0x3F) & 0xFF
end

-- send target angles (in degrees) to gimbal
-- yaw_angle_deg is always a body-frame angle
function send_target_angles(pitch_angle_deg, yaw_angle_deg)

  -- prepare A1 message, FrameId 0x1A, CmdId 0x0B
  local length_and_frame_counter = calc_length_and_frame_byte(0x0C)
  local pitch_angle_output = math.floor((-pitch_angle_deg / 360.0 * 65536.0) + 0.5)
  local yaw_angle_output = math.floor((yaw_angle_deg / 360.0 * 65536.0) + 0.5)

  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)      -- length and frame count
  checksum = write_byte(0x1A, checksum)                         -- 0x1A: A1 FrameId
  checksum = write_byte(0x0B, checksum)                         -- 0x0B: absolute angle
  checksum = write_byte(highbyte(yaw_angle_output), checksum)   -- yaw angle MSB
  checksum = write_byte(lowbyte(yaw_angle_output), checksum)    -- yaw angle LSB
  checksum = write_byte(highbyte(pitch_angle_output), checksum) -- pitch angle MSB
  checksum = write_byte(lowbyte(pitch_angle_output), checksum)  -- pitch angle LSB
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  write_byte(checksum, 0)                                       -- checksum
end

-- send target rates (in deg/sec) to gimbal
function send_target_rates(pitch_rate_degs, yaw_rate_degs)

  -- prepare A1 message, FrameId 0x1A, CmdId 0x01
  local length_and_frame_counter = calc_length_and_frame_byte(0x0C)
  local pitch_rate_output = math.floor((-pitch_rate_degs * 100.0) + 0.5)
  local yaw_rate_output = math.floor((yaw_rate_degs * 100.0) + 0.5)

  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)      -- length and frame count
  checksum = write_byte(0x1A, checksum)                         -- 0x1A: A1 FrameId
  checksum = write_byte(0x01, checksum)                         -- 0x01: manual rate angle
  checksum = write_byte(highbyte(yaw_rate_output), checksum)    -- yaw rate MSB
  checksum = write_byte(lowbyte(yaw_rate_output), checksum)     -- yaw rate LSB
  checksum = write_byte(highbyte(pitch_rate_output), checksum)  -- pitch angle MSB
  checksum = write_byte(lowbyte(pitch_rate_output), checksum)   -- pitch angle LSB
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  checksum = write_byte(0, checksum)                            -- unused
  write_byte(checksum, 0)                                       -- checksum
end

-- send camera commands
function send_camera_control(camera_choice, cam_command)

  -- prepare C1 message, FrameId 0x1C
  -- bits 0~2 : video choose
  -- bits 3~5 : zoom speed
  -- bits 6~12 : operation command
  -- bits 13~15 : LRF (rangefinder)
  local length_and_frame_counter = calc_length_and_frame_byte(0x05)

  local video_choose = camera_choice & 0x07

  local zoom_speed = 0
  if cam_command == CAM_COMMAND_ZOOM_OUT or cam_command == CAM_COMMAND_ZOOM_IN then
    zoom_speed = (VIEP_ZOOM_SPEED:get() & 0x07) << 3
  end

  local operation_cmd = ((cam_command & 0xFFFF) & 0x7F) << 6
  local data_bytes = video_choose | zoom_speed | operation_cmd

  -- debug
  --gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: camcmd:%x msb:%x lsb:%x", cam_command, highbyte(cmd_shifted), lowbyte(cmd_shifted)))
  gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: cam choice:%x", video_choose))

  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)  -- length and frame count
  checksum = write_byte(0x1C, checksum)                 -- 0x1C: C1 FrameId
  checksum = write_byte(highbyte(data_bytes), checksum) -- msb
  checksum = write_byte(lowbyte(data_bytes), checksum)  -- lsb
  write_byte(checksum, 0)                               -- checksum
end

-- send camera commands using C2 message
function send_camera_control2(cam_command, cam_value)

  -- ensure cam_value is an integer
  cam_value = math.floor(cam_value + 0.5)

  -- prepare C2 message, FrameId 0x2C
  -- byte0 : command (0x50:set brightness, 0x51:set contrast, 0x52: set aperture, 0x53:set EO zoom, 0x54:set focus, 0x55:set ISO, 0x56:set thermal cam digital zoom)
  -- byte1~2 : value related to command
  local length_and_frame_counter = calc_length_and_frame_byte(0x06)
  cam_command = cam_command & 0xFF
  local data_bytes = cam_value & 0xFFFF

  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)  -- length and frame count
  checksum = write_byte(0x2C, checksum)                 -- 0x2C: C2 FrameId
  checksum = write_byte(cam_command, checksum)          -- command
  checksum = write_byte(highbyte(data_bytes), checksum) -- msb
  checksum = write_byte(lowbyte(data_bytes), checksum)  -- lsb
  write_byte(checksum, 0)                               -- checksum
end

-- send tracking commands using E1 message
function send_tracking_control(camera_choice, tracking_command, param2)

  -- prepare E1 message, FrameId 0x1E
  -- byte0 : tracking source (0x01:EO 1, 0x02: IR, 0x03:EO 2)
  -- byte1 : basic command
  --         0x02: Search (Bring up the cross
  --         0x03: Turn on tracking
  --         0x04: Switch tracking point to cross position(take placed by enable tracking)
  --         0X05: AI function ON/OFF
  --         0X08: For AI. Auto track target once identified
  --         0x09: For AI. Change target when click targets identified
  --         0x0A: For AI. Not change target when click identified targets.
  --         0X21: 32× 32 small template
  --         0X22: 64× 64 medium template
  --         0X23: 128× 128 big template
  --         0X24: Self-adapt between small and medium template
  --         0X25: Self-adapt between small and big template
  --         0X26: Self-adapt between medium and big template
  --         0X28: Self-adaption between small, medium and big template
  --  byte2 : parameter 2, value related to above command

  local length_and_frame_counter = calc_length_and_frame_byte(0x06)
  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)  -- length and frame count
  checksum = write_byte(0x1E, checksum)                 -- 0x1E: E1 FrameId
  checksum = write_byte(camera_choice, checksum)        -- camera choice
  checksum = write_byte(tracking_command & 0xFF, checksum)  -- tracking command
  checksum = write_byte(param2 & 0xFF, checksum)        -- param2
  write_byte(checksum, 0)                               -- checksum
end

-- send tracking commands using E2 message
function send_tracking_control2(tracking_command2, param1, param2)

  -- prepare E2 message, FrameId 0x2E
  -- byte0 : tracking source (0x01:EO 1, 0x02: IR, 0x03:EO 2)
  -- byte1 : basic command
  --         0x0A: The tracking point moves to the commanded position
  --         0x0B: Rectangular tracking area, top left corner point set
  --         0x0C: Rectangular tracking area, lower right corner point set
  --  byte2~3 : Tracking point yaw, 1bit=1pixel, -960~960, 0 is center, negative is left, positive is right
  --  byte4~5 : Tracking point pitch, 1bit=1pixel, -540~540, 0 is center, negative is up, positive is down

  param1 = math.floor(param1 + 0.5) & 0xFFFF
  param2 = math.floor(param2 + 0.5) & 0xFFFF
  local length_and_frame_counter = calc_length_and_frame_byte(0x08)
  write_byte(HEADER1, 0)
  write_byte(HEADER2, 0)
  write_byte(HEADER3, 0)
  local checksum = write_byte(length_and_frame_counter, 0)  -- length and frame count
  checksum = write_byte(0x2E, checksum)             -- 0x2E: E2 FrameId
  checksum = write_byte(tracking_command2 & 0xFF, checksum) -- tracking command2
  checksum = write_byte(highbyte(param1), checksum) -- param1 msb
  checksum = write_byte(lowbyte(param1), checksum)  -- param1 lsb
  checksum = write_byte(highbyte(param2), checksum) -- param2 msb
  checksum = write_byte(lowbyte(param2), checksum)  -- param2 lsb
  write_byte(checksum, 0)                           -- checksum
end

-- return camera selection according to RC switch position and VIEW_CAM_SWxxx parameter
-- used in C1 message's "video choose" to specify which cameras should be controlled
function get_camera_choice()
  local cam_switch_pos = rc:get_aux_cached(CAM_SELECT_RC_OPTION)
  if cam_switch_pos == 0 then
    return VIEP_CAM_SWLOW:get()
  end
  if cam_switch_pos == 1 then
    return VIEP_CAM_SWMID:get()
  end
  return VIEP_CAM_SWHIGH:get()
end

-- check for changes in camera state and send messages to gimbal if required
function check_camera_state()

  -- check for change in camera
  local curr_cam_choice = get_camera_choice()
  if cam_choice ~= curr_cam_choice then
    cam_choice = curr_cam_choice
    send_camera_control(cam_choice, CAM_COMMAND_NO_ACTION)
  end

  -- get latest camera state from AP driver
  local cam_state = camera:get_state(CAMERA_INSTANCE)
  if not cam_state then
    return
  end

  -- check for take picture
  if cam_state:take_pic_incr() and cam_state:take_pic_incr() ~= cam_pic_count then
    cam_pic_count = cam_state:take_pic_incr()
    send_camera_control(cam_choice, CAM_COMMAND_TAKE_PICTURE)
    if VIEP_DEBUG:get() > 0 then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: took pic %u", pic_count))
    end
  end

  -- check for start/stop recording video
  if cam_state:recording_video() ~= cam_rec_video then
    cam_rec_video = cam_state:recording_video()
    if cam_rec_video > 0 then
      send_camera_control(cam_choice, CAM_COMMAND_START_RECORD)
      gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: start recording")
    else
      send_camera_control(cam_choice, CAM_COMMAND_STOP_RECORD)
      gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: stop recording")
    end
    if VIEP_DEBUG:get() > 0 then
      gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: rec video:" .. tostring(cam_rec_video))
    end
  end

  -- check zoom
  -- zoom out = -1, hold = 0, zoom in = 1
  local zoom_type_changed = cam_state:zoom_type() and (cam_state:zoom_type() ~= cam_zoom_type)
  local zoom_value_changed = cam_state:zoom_value() and (cam_state:zoom_value() ~= cam_zoom_value)
  if (zoom_type_changed or zoom_value_changed) then
    cam_zoom_type = cam_state:zoom_type()
    cam_zoom_value = cam_state:zoom_value()

    -- zoom rate
    if cam_zoom_type == 1 then
      if cam_zoom_value < 0 then
        send_camera_control(cam_choice, CAM_COMMAND_ZOOM_OUT)
      elseif cam_zoom_value > 0 then
        send_camera_control(cam_choice, CAM_COMMAND_ZOOM_IN)
      else
        send_camera_control(cam_choice, CAM_COMMAND_STOP_FOCUS_AND_ZOOM)
      end
    end

    -- zoom percent
    if cam_zoom_type == 2 then
      -- convert zoom percentage (in the range 0 to 100) to value in the range of 0 to VIEW_ZOOM_MAX * 10
      send_camera_control2(CAM_COMMAND2_SET_EO_ZOOM, VIEP_ZOOM_MAX:get() * cam_zoom_value * 0.1)
    end

    if VIEP_DEBUG:get() > 0 then
      gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: zoom type:" .. tostring(cam_zoom_type) .. " value:" .. tostring(cam_zoom_value))
    end
  end

  -- check manual focus
  -- focus in = -1, focus hold = 0, focus out = 1
  local focus_type_changed = cam_state:focus_type() and (cam_state:focus_type() ~= cam_focus_type)
  local focus_value_changed = cam_state:focus_value() and (cam_state:focus_value() ~= cam_focus_value)
  if (focus_type_changed or focus_value_changed) then
    cam_focus_type = cam_state:focus_type()
    cam_focus_value = cam_state:focus_value()

    -- focus rate
    if cam_focus_type == 1 then
      if cam_focus_value < 0 then
        send_camera_control(cam_choice, CAM_COMMAND_MANUAL_FOCUS)
        send_camera_control(cam_choice, CAM_COMMAND_FOCUS_MINUS)
      elseif cam_focus_value == 0 then
        send_camera_control(cam_choice, CAM_COMMAND_STOP_FOCUS_AND_ZOOM)
      elseif cam_focus_value > 0 then
        send_camera_control(cam_choice, CAM_COMMAND_MANUAL_FOCUS)
        send_camera_control(cam_choice, CAM_COMMAND_FOCUS_PLUS)
      end
      if VIEP_DEBUG:get() > 0 then
        gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: focus:" .. tostring(cam_focus_step))
      end
    end

    -- check auto focus
    if cam_focus_type == 4 then
      send_camera_control(cam_choice, CAM_COMMAND_AUTO_FOCUS)
      if VIEP_DEBUG:get() > 0 then
        gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: auto focus:" .. tostring(cam_autofocus))
      end
    end
  end
end

-- check for changes in tracking state and send messages to gimbal if required
function check_tracking_state()

  -- get latest camera state from AP driver
  local cam_state = camera:get_state(CAMERA_INSTANCE)
  if not cam_state then
    return
  end

  -- get current camera choice
  local curr_cam_choice = get_camera_choice()

  -- check for change in tracking state
  local tracking_type_changed = cam_state:tracking_type() ~= last_tracking_type
  local tracking_type_p1_changed = (cam_state:tracking_p1():x() ~= last_tracking_p1x) or (cam_state:tracking_p1():y() ~= last_tracking_p1y)
  local tracking_type_p2_changed = (cam_state:tracking_p2():x() ~= last_tracking_p2x) or (cam_state:tracking_p2():y() ~= last_tracking_p2y)
  last_tracking_type = cam_state:tracking_type()
  last_tracking_p1x = cam_state:tracking_p1():x()
  last_tracking_p1y = cam_state:tracking_p1():y()
  last_tracking_p2x = cam_state:tracking_p2():x()
  last_tracking_p2y = cam_state:tracking_p2():y()

  if (last_tracking_type == 0) and tracking_type_changed then
    -- turn off tracking
    send_tracking_control(curr_cam_choice, TRACK_COMMAND_STOP, 0)
    tracking_active = false
    gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: tracking OFF")
  end

  if (last_tracking_type == 1) and (tracking_type_changed or tracking_type_p1_changed) then
    -- turn tracking point on
    local yaw_value = (last_tracking_p1x - 0.5) * 960
    local pitch_value = (last_tracking_p1y - 0.5) * 540
    send_tracking_control(curr_cam_choice, TRACK_COMMAND_START, 0)
    send_tracking_control2(TRACK_COMMAND2_SET_POINT, yaw_value, pitch_value)
    tracking_active = true
    gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: tracking point ON")
  end

  if (last_tracking_type == 2) and (tracking_type_changed or tracking_type_p1_changed or tracking_type_p2_changed) then
    -- turn tracking rectangle on
    local yaw_value1 = (last_tracking_p1x - 0.5) * 960
    local pitch_value1 = (last_tracking_p1y - 0.5) * 540
    local yaw_value2 = (last_tracking_p2x - 0.5) * 960
    local pitch_value2 = (last_tracking_p2y - 0.5) * 540
    send_tracking_control(curr_cam_choice, TRACK_COMMAND_START, 0)
    send_tracking_control2(TRACK_COMMAND2_SET_RECT_TOPLEFT, yaw_value1, pitch_value1)
    send_tracking_control2(TRACK_COMMAND2_SET_RECT_BOTTOMRIGHT, yaw_value2, pitch_value2)
    tracking_active = true
    gcs:send_text(MAV_SEVERITY.INFO, "ViewPro: tracking rectangle ON")
  end
end

-- the main update function that performs a simplified version of RTL
function update()

  -- get current system time
  local now_ms = millis()

  -- initialise connection to gimbal
  if not initialised then
    init()
    return update, INIT_INTERVAL_MS
  end

  -- status reporting
  if (VIEP_DEBUG:get() > 0) and (now_ms - last_print_ms > 5000) then
    last_print_ms = now_ms
    gcs:send_text(MAV_SEVERITY.INFO, string.format("ViewPro: r:%u w:%u err:%u ign:%u", bytes_read, bytes_written, bytes_error, msg_ignored))
  end

  -- consume incoming bytes
  read_incoming_packets()

  -- check camera state and send control messages
  check_camera_state()

  -- check tracking state and send tracking control messages
  check_tracking_state()

  -- send heartbeat, gimbal should respond with T1+F1+B1+D1
  send_msg(HEARTBEAT_MSG)

  -- request gimbal attitude by sending heartbeat
  if now_ms - last_test_send_md > 1000 then
    last_test_send_md = now_ms
    send_msg(HEARTBEAT_MSG)
  end

  if not tracking_active then
    -- send target angle to gimbal
    local roll_deg, pitch_deg, yaw_deg, yaw_is_ef = mount:get_angle_target(MOUNT_INSTANCE)
    if roll_deg and pitch_deg and yaw_deg then
      if yaw_is_ef then
        yaw_deg = wrap_180(yaw_deg - math.deg(ahrs:get_yaw_rad()))
      end
      send_target_angles(pitch_deg, yaw_deg)
      return update, UPDATE_INTERVAL_MS
    end

    -- send target rate to gimbal
    local roll_degs, pitch_degs, yaw_degs, _ = mount:get_rate_target(MOUNT_INSTANCE)
    if roll_degs and pitch_degs and yaw_degs then
      send_target_rates(pitch_degs, yaw_degs)
      return update, UPDATE_INTERVAL_MS
    end
  end

  return update, UPDATE_INTERVAL_MS
end

return update()



================================================
File: drivers/mount-viewpro-driver.md
================================================
# Mount Viewpro Driver

Viewpro gimbal driver lua script

# How To Use

  Connect gimbal UART to one of the autopilot's serial ports
  Set SERIALx_PROTOCOL = 28 (Scripting) where "x" corresponds to the serial port connected to the gimbal
  Set SCR_ENABLE = 1 to enable scripting and reboot the autopilot
  Set MNT1_TYPE = 9 (Scripting) to enable the mount/gimbal scripting driver
  Set CAM1_TYPE = 7 (Scripting) to enable camera control using the scripting driver
  Set RCx_OPTION = 300 (Scripting1) to allow real-time selection of the video feed and camera control
  Copy this script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot
  Set VIEP_CAM_SWLOW, VIEP_CAM_SWMID, VIEP_CAM_SWHIGH to which cameras are controlled by the auxiliary switch
      0: No change in camera selection
      1: EO1
      2: IR thermal
      3: EO1 + IR Picture-in-picture
      4: IR + EO1 Picture-in-picture
      5: Fusion
      6: IR1 13mm
      7: IR2 52mm
  Set VIEP_ZOOM_SPEED to control speed of zoom (value between 0 and 7)
  Set VIEP_ZOOM_MAX to the maximum zoom.  E.g. for a camera with 20x zoom, set to 20
  Optionally set VIEP_DEBUG = 1 or 2 to increase level of debug output to the GCS



================================================
File: drivers/torqeedo-torqlink.lua
================================================
 --[[
    Torqeedo TorqLink driver lua script

    How To Use:

    Connect the Torqeedo motor(s) to the autopilot's CAN ports.  If only one motor is used it should be connected to CAN1
    If two motors are used, connect the left motor to CAN1 and the right motor to CAN2

    Enable CAN1 by setting these parameters:
      - CAN_P1_DRIVER = 1 (First driver)
      - CAN_D1_PROTOCOL = 10 (Scripting)

    If CAN2 is being used set these parameters:
      - CAN_P2_DRIVER = 2 (Second driver)
      - CAN_D2_PROTOCOL = 12 (Scripting2)

    Copy this script to the autopilot's SD card in the APM/scripts directory and restart the autopilot
--]]

local PARAM_TABLE_KEY = 91
local PARAM_TABLE_PREFIX = "TRQL_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')

--[[
  // @Param: TRQL_ENABLE
  // @DisplayName: Torqeedo TorqLink Enable
  // @Description: Torqeedo TorqLink Enable
  // @Values: 0:Disabled, 1:Enabled
  // @User: Standard
--]]
local TRQL_ENABLE = bind_add_param('ENABLE', 1, 1)

--[[
  // @Param: TRQL_DEBUG
  // @DisplayName: Torqeedo TorqLink Debug Level
  // @Description: Torqeedo TorqLink Debug Level
  // @Values: 0:None, 1:Low, 2:Medium, 3:High
  // @User: Standard
--]]
local TRQL_DEBUG = bind_add_param('DEBUG', 2, 0)

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local TEXT_PREFIX_STR = "torqeedo-torqlink:"    -- prefix for text messages sent to user
local UPDATE_MS = 10                            -- update interval in milliseconds, 10 = 100hz
local SRV_FN_THROTTLE = 70                      -- servo function for throttle
local SRV_FN_THROTTLE_LEFT = 73                 -- servo function for left motor
local SRV_FN_THROTTLE_RIGHT = 74                -- servo function for right motor
local CAN_BUF_LEN = 8                           -- CAN frame length
local CAN_WRITE_TIMEOUT_US = 10000              -- timeout in microseconds for writing a frame to the Torqeedo device
local TORQCAN_DIR_FORWARD = 126                 -- forward direction command
local TORQCAN_DIR_NEUTRAL = 125                 -- neutral direction command
local TORQCAN_DIR_BACKWARDS = 124               -- reverse direction command
local TORQCAN_PF_MASK = 0x00FF0000              -- bitmask used to extract health from PGN message
local TORQCAN_DA_MASK = 0x0000FF00              -- bitmask used to extract health from PGN message
local RECEIVE_TIMEOUT_MS = 1000                 -- timeout for receiving a frame from the Torqeedo device
local OUTPUT_INTERVAL_MS = 50					-- output interval in milliseconds, 50 = 20hz
local RECOVERY_DELAY_MS = 2000                  -- delay (in ms) after motor recovers before sending outputs

-- local variables
local left_device_last_recv_ms = uint32_t(0)    -- system time of last frame received from CAN1 device
local right_device_last_recv_ms = uint32_t(0)   -- system time of last frame received from CAN2 device
local left_device_timeout = true                -- flag to indicate if the left device is in a timeout state
local right_device_timeout = true               -- flag to indicate if the right device is in a timeout state
local last_send_ms = uint32_t(0)                -- system time of last command sent to Torqeedo devices
local recovery_start_ms = uint32_t(0)           -- system time motor communication was recovered (0 if not recovered recently)
local debug_send_speed_ms = uint32_t(0)         -- system time of last debug speed message

-- get CAN drivers with protocol configured for scripting, set buffer size to 8 frames
local left_device = CAN:get_device(CAN_BUF_LEN)
local right_device = CAN:get_device2(CAN_BUF_LEN)

-- swap two floats
function swap_float(f1, f2)
    return f2, f1
end

-- interpolate function
function interpolate(output_low, output_high, input_value, input_low, input_high)
-- support either polarity
    if (input_low > input_high) then
        input_low, input_high = swap_float(input_low, input_high)
        output_low, output_high = swap_float(output_low, output_high)
    end
    if (input_value <= input_low) then
        return output_low
    end
    if (input_value > input_high) then
        return output_high
    end
    local p = (input_value - input_low) / (input_high - input_low)
    return math.floor((output_low + p * (output_high - output_low)))
end

-- send speed and direction control commands
-- speed should be in the range of -1 to +1
function send_speed_and_direction(device, speed)

    -- sanity check device
    if not device then
        return
    end

    -- get absolute speed
    local speed_abs = math.abs(speed)

	-- convert speed into range 0 to 250
    local speed_cmd = interpolate(0.0, 250.0, speed_abs, 0.0, 1.0)

    -- extended frame, priority 12, PGN 0xF003, and node ID 208 - (0x8CF003d0)
    -- lua cannot handle numbers so large, so we have to use uint32_t userdata
    local speed_frame = CANFrame()
    speed_frame:id((uint32_t(1) << 31) | (uint32_t(12) << 24) | (uint32_t(tonumber("0xF003")) << 8) | uint32_t(208))
    speed_frame:dlc(8)
    speed_frame:data(0, 255)
    speed_frame:data(1, speed_cmd)
    speed_frame:data(2, 255)
    speed_frame:data(3, 255)
    speed_frame:data(4, 255)
    speed_frame:data(5, 255)
    speed_frame:data(6, 255)
    speed_frame:data(7, 255)

    -- write the speed frame with a 10000us timeout
    device:write_frame(speed_frame, CAN_WRITE_TIMEOUT_US)

    -- calculate direction
    local dir_cmd = TORQCAN_DIR_NEUTRAL
    if speed < 0 then
        dir_cmd = TORQCAN_DIR_BACKWARDS
    elseif speed > 0 then
        dir_cmd = TORQCAN_DIR_FORWARD
    end

    -- set transmission to forward
    local dir_frame = CANFrame()

    -- extended frame, priority 12, PGN 0xF005, and node ID 208 - (0x8CF005d0)
    -- lua cannot handle numbers so large, so we have to use uint32_t userdata
    dir_frame:id((uint32_t(1) << 31) | (uint32_t(12) << 24) | (uint32_t(tonumber("0xF005")) << 8) | uint32_t(208))
    dir_frame:dlc(8)
    dir_frame:data(0, dir_cmd) -- transmission gear (124-126)
    dir_frame:data(1, 255)
    dir_frame:data(2, 255)
    dir_frame:data(3, 255)
    dir_frame:data(4, 255)
    dir_frame:data(5, 255)
    dir_frame:data(6, 255)
    dir_frame:data(7, 255)

    -- write the direction frame with a 10000us timeout
    device:write_frame(dir_frame, CAN_WRITE_TIMEOUT_US)

    -- print frame debug at 1hz
    if TRQL_DEBUG:get() > 0 then
        local now_ms = millis()
        if (now_ms - debug_send_speed_ms) > 1000 then
            debug_send_speed_ms = now_ms
            gcs:send_text(MAV_SEVERITY.INFO, string.format("%s speed:%4.2f dir:%d", TEXT_PREFIX_STR, speed_cmd, dir_cmd))
        end
    end
end

-- get parameter group number (PGN) from frame id
function get_PGN_from_frameid(can_frame_id)
    local pf = (TORQCAN_PF_MASK & can_frame_id) >> 16
    local da = (TORQCAN_DA_MASK & can_frame_id) >> 8
    local pgn
    if pf >= 240 then
        pgn = pf * 256 + da
    else
        pgn = pf * 256
    end
    return pgn
end

-- parse a frame, returns true if motor is healthy
function parse_frame_for_health(frame)
    -- extract Parameter Group Number (PGN) from frame id
    local pgn = tostring(get_PGN_from_frameid(frame:id()))
    if pgn == "65299" then -- check if Torqeedo is ready
        local ready = frame:data(4) >> 7 -- check first bit of thruster status bitmap
        if ready == 1 then
            do return true end
        end
    end

    -- print incoming frame debug
    if TRQL_DEBUG:get() > 1 then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("%s read id:%d PGN:%s", TEXT_PREFIX_STR, frame:id():toint(), pgn))
    end
    return false
end

-- read incoming frames
function read_incoming_frames()
    -- read incoming frame from left device
    if left_device then
        local frame = left_device:read_frame()
        if frame and parse_frame_for_health(frame) then
            left_device_last_recv_ms = millis()
        end
    end

    -- read incoming frame from right device
    if right_device then
        local frame = right_device:read_frame()
        if frame and parse_frame_for_health(frame) then
            right_device_last_recv_ms = millis()
        end
    end
end

-- print welcome message
gcs:send_text(MAV_SEVERITY.INFO, "torqeedo-torqlink script loaded")

-- update function runs at about 20hz
function update()

    -- check if script is enabled
    if TRQL_ENABLE:get() == 0 then
        return update, 1000
    end

    -- read incoming frames from devices
    read_incoming_frames()

    -- get current time
    local now_ms = millis()

    -- check for timeouts of left device
    local left_device_timeout_prev = left_device_timeout
    left_device_timeout = (now_ms - left_device_last_recv_ms) > RECEIVE_TIMEOUT_MS
    if left_device_timeout ~= left_device_timeout_prev then
        if left_device_timeout then
            gcs:send_text(MAV_SEVERITY.WARNING, TEXT_PREFIX_STR .. "device1 timeout")
        else
            gcs:send_text(MAV_SEVERITY.INFO, TEXT_PREFIX_STR .. "device1 healthy")
            recovery_start_ms = now_ms
        end
    end

    -- check for timeouts of right device
    local right_device_timeout_prev = right_device_timeout
    right_device_timeout = (now_ms - right_device_last_recv_ms) > RECEIVE_TIMEOUT_MS
    if right_device_timeout ~= right_device_timeout_prev then
        if right_device_timeout then
            gcs:send_text(MAV_SEVERITY.WARNING, TEXT_PREFIX_STR .. "device2 timeout")
        else
            gcs:send_text(MAV_SEVERITY.INFO, TEXT_PREFIX_STR .. "device2 healthy")
            recovery_start_ms = now_ms
        end
    end

    -- send commands to motors at specified interval
    if (now_ms - last_send_ms) >= OUTPUT_INTERVAL_MS then
        -- record last send time (we will certainly send a command below)
        last_send_ms = now_ms

        -- suppress output for 2 seconds after recovery
        local recovery_active = false
        if recovery_start_ms > 0 then
            if ((now_ms - recovery_start_ms) < RECOVERY_DELAY_MS) then
                recovery_active = true
            else
                -- clear recovery start time
                recovery_start_ms = uint32_t(0)
            end
        end

        -- determine whether we should send throttle or left and right throttle
        local throttle_defined = (SRV_Channels:find_channel(SRV_FN_THROTTLE) ~= nil)
        local left_throttle_defined = (SRV_Channels:find_channel(SRV_FN_THROTTLE_LEFT) ~= nil)
        local right_throttle_defined = (SRV_Channels:find_channel(SRV_FN_THROTTLE_RIGHT) ~= nil)

        -- default left and right speed to 0 (in range -1 to +1)
        local left_device_speed = 0
        local right_device_speed = 0

        -- use throttle by default but use left and/or right throttle if defined
        if throttle_defined then
            left_device_speed = SRV_Channels:get_output_scaled(SRV_FN_THROTTLE) * 0.01
            right_device_speed = SRV_Channels:get_output_scaled(SRV_FN_THROTTLE) * 0.01
        end
        if left_throttle_defined then
            left_device_speed = SRV_Channels:get_output_scaled(SRV_FN_THROTTLE_LEFT) * 0.001
        end
        if right_throttle_defined then
            right_device_speed = SRV_Channels:get_output_scaled(SRV_FN_THROTTLE_RIGHT) * 0.001
        end

        -- override speed if device timesout or in recovery
        if left_device_timeout or recovery_active then
            left_device_speed = 0
        end
        if right_device_timeout or recovery_active then
            right_device_speed = 0
        end

        -- if no outputs defined print warning to user
        if not (left_throttle_defined or right_throttle_defined or throttle_defined) then
            gcs:send_text(MAV_SEVERITY.WARNING, TEXT_PREFIX_STR .. "check SERVOx_FUNCTION")
        else
            -- send speed and direction to left and right devices
            send_speed_and_direction(left_device, left_device_speed)
            send_speed_and_direction(right_device, right_device_speed)
        end
    end

    return update, UPDATE_MS
end

return update()



================================================
File: drivers/torqeedo-torqlink.md
================================================
# Torqeedo TroqLink Driver

Torqeedo TorqLink driver lua script

# How To Use

Connect the Torqeedo motor(s) to the autopilot's CAN ports.  If only one motor is used it should be connected to CAN1.
If two motors are used, connect the left motor to CAN1 and the right motor to CAN2

Enable CAN1 by setting these parameters:

- CAN_P1_DRIVER = 1 (First driver)
- CAN_D1_PROTOCOL = 10 (Scripting)

If CAN2 is being used set these parameters:

- CAN_P2_DRIVER = 2 (Second driver)
- CAN_D2_PROTOCOL = 12 (Scripting2)

Copy this script to the autopilot's SD card in the APM/scripts directory and restart the autopilot



================================================
File: drivers/TOFSense-M/TOFSense-M_CAN.lua
================================================
--[[
   Driver for NoopLoop TOFSense-M CAN Version. Can be used as a 1-D RangeFidner or 3-D proximity sensor. Upto 3 CAN devices supported in this script although its easy to extend.
--]]

---@diagnostic disable: undefined-field
---@diagnostic disable: undefined-global

local update_rate_ms    = 10  -- update rate (in ms) of the driver. 10ms was found to be appropriate

-- Global variables (DO NOT CHANGE)
local param_num_lua_driver_backend = 36         -- parameter number for lua rangefinder
local param_num_lua_prx_backend = 15            -- parameter number for lua proximity
local sensor_setup_done = false

-- Table contains the following info for 3 sensors. If more sensors are needed, this table will need to be increased
-- approportate scritping backend from rngfnd/prx library, true if backend exists, index parsed last from sensor, minimum distance found since index was 0, Param to decide which rngfnd/prx backednd will match to this sensor, param to decide CAN ID of this sensor 
local backend_driver = {
  {lua_driver_backend = nil, sensor_driver_found = false, last_index = 0, min_distance = 0, INSTANCE, CAN_ID},
  {lua_driver_backend = nil, sensor_driver_found = false, last_index = 0, min_distance = 0, INSTANCE, CAN_ID},
  {lua_driver_backend = nil, sensor_driver_found = false, last_index = 0, min_distance = 0, INSTANCE, CAN_ID}
}

local PARAM_TABLE_KEY = 104
local PARAM_TABLE_PREFIX = "TOFSENSE_"

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 15), 'could not add param table')

--[[
  // @Param: TOFSENSE_PRX
  // @DisplayName: TOFSENSE-M to be used as Proximity sensor
  // @Description: Set 0 if sensor is to be used as a 1-D rangefinder (minimum of all distances will be sent, typically used for height detection). Set 1 if it should be used as a 3-D proximity device (Eg. Obstacle Avoidance)
  // @Values: 0:Set as Rangefinder, 1:Set as Proximity sensor
  // @User: Standard
--]]
SET_PRX = bind_add_param('PRX', 1, 0)

--[[
  // @Param: TOFSENSE_NO
  // @DisplayName: TOFSENSE-M Connected
  // @Description: Number of TOFSENSE-M CAN sensors connected
  // @Range: 1 3
  // @User: Standard
--]]
MAX_SENSORS = bind_add_param('NO', 2, 1)

--[[
  // @Param: TOFSENSE_MODE
  // @DisplayName: TOFSENSE-M mode to be used
  // @Description: TOFSENSE-M mode to be used. 0 for 8x8 mode. 1 for 4x4 mode
  // @Values: 0: 8x8 mode, 1: 4x4 mode
  // @User: Standard
--]]
MODE = bind_add_param('MODE', 3, 0)

-- first sensor
--[[
  // @Param: TOFSENSE_INST1
  // @DisplayName: TOFSENSE-M First Instance
  // @Description: First TOFSENSE-M sensors backend Instance. Setting this to 1 will pick the first backend from PRX_ or RNG_ Parameters (Depending on TOFSENSE_PRX)
  // @Range: 1 3
  // @User: Standard
--]]
backend_driver[1].INSTANCE = bind_add_param('INST1', 4, 1)

--[[
  // @Param: TOFSENSE_ID1
  // @DisplayName: TOFSENSE-M First ID
  // @Description: First TOFSENSE-M sensor ID. Leave this at 0 to accept all IDs and if only one sensor is present. You can change ID of sensor from NAssistant Software
  // @Range: 1 255
  // @User: Standard
--]]
backend_driver[1].CAN_ID = bind_add_param('ID1', 5, 0)

-- second sensor
--[[
  // @Param: TOFSENSE_INST2
  // @DisplayName: TOFSENSE-M Second Instance
  // @Description: Second TOFSENSE-M sensors backend Instance. Setting this to 2 will pick the second backend from PRX_ or RNG_ Parameters (Depending on TOFSENSE_PRX)
  // @Range: 1 3
  // @User: Standard
--]]
backend_driver[2].INSTANCE = bind_add_param('INST2', 6, 2)

--[[
  // @Param: TOFSENSE_ID2
  // @DisplayName: TOFSENSE-M Second ID
  // @Description: Second TOFSENSE-M sensor ID. This cannot be 0. You can change ID of sensor from NAssistant Software
  // @Range: 1 255
  // @User: Standard
--]]
backend_driver[2].CAN_ID = bind_add_param('ID2', 7, 2)

--third sensor
--[[
  // @Param: TOFSENSE_INST3
  // @DisplayName: TOFSENSE-M Third Instance
  // @Description: Third TOFSENSE-M sensors backend Instance. Setting this to 3 will pick the second backend from PRX_ or RNG_ Parameters (Depending on TOFSENSE_PRX)
  // @Range: 1 3
  // @User: Standard
--]]
backend_driver[2].INSTANCE = bind_add_param('INST3', 8, 2)

--[[
  // @Param: TOFSENSE_ID3
  // @DisplayName: TOFSENSE-M Thir ID
  // @Description: Third TOFSENSE-M sensor ID. This cannot be 0. You can change ID of sensor from NAssistant Software
  // @Range: 1 255
  // @User: Standard
--]]
backend_driver[2].CAN_ID = bind_add_param('ID3', 9, 3)


-- check both CAN device for scripting backend. CAN Buffer length set to fixed 5
local driver = CAN:get_device(5)
if not driver then
  driver = CAN:get_device2(5)
end
if not driver then
  error("No scripting CAN interfaces found")
  return
end

function setup_sensor(sensor, param_num)
  local sensor_count = sensor:num_sensors() -- number of sensors connected
  if  MAX_SENSORS:get() > 3 then
    error("TOFSENSE: Only 3 devices supported")
  end

  for i = 1, MAX_SENSORS:get() do
    local backends_found = 0
    local sensor_driver_found = false
    local lua_driver_backend
    for j = 0, sensor_count -1 do
      local device = sensor:get_backend(j)
      if ((not sensor_driver_found) and  device and (device:type() == param_num)) then
        -- this is a lua driver
        backends_found = backends_found + 1
        if backends_found == backend_driver[i].INSTANCE:get() then
          -- get the correct instance as we may have multile scripting backends doing different things
          sensor_driver_found = true
          lua_driver_backend = device
        end
      end
    end
    if not sensor_driver_found then
      -- We can't use this script if user hasn't setup a lua backend
      error(string.format("TOFSENSE: Could not find SCR Backend ".. tostring(i)))
      return
    end
    backend_driver[i].sensor_driver_found = true
    backend_driver[i].lua_driver_backend = lua_driver_backend
  end

end

-- get yaw and pitch of the pixel based message index.
function convert_to_angle(index)
  -- The distances are sent in either a 4x4 or 8x8 grid. The horizontal and vertical FOV are 45 degrees so we can work out the angles
  local index_row_max = 8
  if (MODE:get() ~= 0) then
    index_row_max = 4
  end
  local angle_division = 45/index_row_max
  local horizontal_index = (index) % index_row_max
  local vertical_index = math.floor(index / index_row_max)
  local yaw = -22.5 + (horizontal_index*angle_division)
  local pitch = -22.5 + (vertical_index*angle_division)
  return yaw, pitch
end

-- send the message down to proximity library. This needs to be a 3D vector
function sent_prx_message(prx_backend, dist, yaw_deg, pitch_deg, push_to_boundary)
  if (dist > 0) then
    prx_backend:set_distance_min_max(0,4)
    prx_backend:handle_script_distance_msg(dist, yaw_deg, pitch_deg, push_to_boundary)
  end
end

-- send the message down to proximity library. This needs to be a single distance
function send_rfnd_message(rfnd_backend, dist)
    if dist > 0 and (SET_PRX:get() == 0) then
      local sent_successfully = rfnd_backend:handle_script_msg(dist)
      if not sent_successfully then
        -- This should never happen as we already checked for a valid configured lua backend above
        gcs:send_text(0, string.format("RFND Lua Script Error"))
      end
  end
end

-- get the correct instance from parameters according to the CAN ID received
function get_instance_from_CAN_ID(frame)
  for i = 1, MAX_SENSORS:get() do
    if ((uint32_t(frame:id() - 0x200)) ==  uint32_t(backend_driver[i].CAN_ID:get())) then
       return i
    end
  end
  return 0
end

-- this is the loop which periodically runs
function update()

  -- setup the sensor according to user preference of using proximity library or rangefinder
  if not sensor_setup_done then
    if SET_PRX:get() == 0 then
      setup_sensor(rangefinder, param_num_lua_driver_backend)
    else
      setup_sensor(proximity, param_num_lua_prx_backend)
    end
    sensor_setup_done = true
  end

  -- read frame if available
  local frame = driver:read_frame()
  if not frame then
    return
  end

  local instance
  if ((backend_driver[1].CAN_ID:get() ~= 0)) then
    instance = get_instance_from_CAN_ID(frame)
    if (instance == 0) then
      -- wrong ID
      return
    end
  else
    -- Simply accept any ID
    instance = 1
  end

  -- Correct ID, so parse the data
  local distance = ((frame:data(0)<<8 | frame:data(1)<<16 | frame:data(2)<<24)/256) / 1000
  local status = frame:data(3)
  local index = frame:data(6)
  local update_rfnd = false
  if (index < backend_driver[instance].last_index) then
    -- One cycle of data has come. Lets update all backends involved
    if SET_PRX:get() == 1 then
      backend_driver[instance].lua_driver_backend:update_virtual_boundary()
    else
      update_rfnd = true
    end
  end
  backend_driver[instance].last_index = index

  if status < 255 then
    -- Status is healthy
    if (SET_PRX:get() == 1) then
      -- Send 3D data to Proximity Library
      local yaw, pitch =  convert_to_angle(index)
      sent_prx_message(backend_driver[instance].lua_driver_backend, distance, yaw, pitch, false)
    end
    if (backend_driver[instance].min_distance == 0 or distance < backend_driver[instance].min_distance) then
      -- store min data incase user wants to use it as a 1-D RangeFinder
      backend_driver[instance].min_distance = distance
    end
  end

  if (update_rfnd) then
    send_rfnd_message(backend_driver[instance].lua_driver_backend, backend_driver[instance].min_distance)
    -- reset
    backend_driver[instance].min_distance = 0
  end
end

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
      gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
      -- when we fault we run the update function again after 1s, slowing it
      -- down a bit so we don't flood the console with errors
      return protected_wrapper, 1000
  end
  return protected_wrapper, update_rate_ms
end

-- start running update loop
return protected_wrapper()



================================================
File: drivers/TOFSense-M/TOFSense-M_CAN.md
================================================
# TOFSense-M CAN Driver

TOFSense-M CAN Driver lua script. Only Copter/Rover/Plane 4.5 and above

## How to use - Pre-Configuration

- Connect sensors to autopilot's CAN1 port or CAN2 port
- If connected to CAN1, set CAN_D1_PROTOCOL = 10 (Scripting), CAN_P1_DRIVER = 1 (First driver)
- If connected to CAN2, set CAN_D2_PROTOCOL = 10 (Scripting), CAN_P2_DRIVER = 2 (Second driver)
- Set SCR_ENABLE = 1 to enable scripting
- Set SCR_HEAP_SIZE = 150000 (or higher)
- If using the sensor as a 1-D Rangefinder (typically for terrain following); set RNGFND1_TYPE = 36 (Scripting) to enable the rangefinder scripting driver
- If using the sensor as a 3-D Proximity sensor (typically for obstacle); set PRX1_TYPE = 15 (Scripting) to enable the proximity scripting driver
- Reboot the autopilot
- Copy the TOFSense-M_CAN.lua script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot


## How to use - Script Parameter Configuration

If everything above is done correctly, new "TOFSENSE_" parameters should be visible (only after script loads. Please refresh parameters if not visible). Script parameters to adjust are listed below

### TOFSENSE_PRX
If you have set RNGFND1_TYPE = 36, then set this as 0
If you have set PRX1_TYPE = 15, then set this as 1
Any change in this parameter will require a reboot (or scripting restart), ignore any errors on change before reboot. Make sure RNGFND/PRX is configured before setting this.


### TOFSENSE_NO
Total number of  TOFSense-M CAN sensors connected on the bus. Change will require a reboot


### TOFSENSE_MODE
TOFSENSE-M mode to be used.
- 0 for 8x8 mode.
- 1 for 4x4 mode.
All sensors must be in same mode. You can change the mode of sensor from NAssistant Software

### TOFSENSE_ID1
First TOFSENSE-M sensor ID. Leave this at 0 to accept all IDs and if only one sensor is present. You can change ID of sensor from NAssistant Software.


### TOFSENSE_INST1
First TOFSENSE-M sensors RNGFND_/PRX_ Instance
Setting this to 1 will pick the first backend from PRX_ or RNG_ Parameters.
So for example if RNGFND1_TYPE = 36, RNGFND2_TYPE = 36, then you can set this parameter to 2, to pick RNGFND2_ parameters to configure this sensor


### Configuring more than one sensor on same CAN bus

As described above, TOFSENSE_INST2, TOFSENSE_ID2 and TOFSENSE_INST3, TOFSENSE_ID3 can be adjusted so to support multiple sensors


================================================
File: drivers/TOFSense-M/TOFSense-M_Serial.lua
================================================
--[[
  Upto 3 CAN devices supported in this script although its easy to extend.
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type
---@diagnostic disable: undefined-global

local sensor_no         = 1     -- Sensor ID. Upload a copy of this script to the flight controller with this variable changed if you would like to use multiple of these sensors as serial. Switching to CAN highly recommended in that case
local update_rate_ms    = 10    -- update rate (in ms) of the driver. 10ms was found to be appropriate
local bytes_to_parse    = 100   -- serial bytes to parse in one interation of lua script. Reduce this if script is not able to complete in time
local debug_enable      = false -- helpgul debug GCS prints

-- Global variables (DO NOT CHANGE)
local NOOPLOOP_FRAME_HEADER = 0x57
local NOOPLOOP_FRAME_HEADER_1 = 0x01
local param_num_lua_driver_backend = 36         -- parameter number for lua rangefinder
local param_num_lua_prx_backend = 15            -- parameter number for lua proximity
local lua_driver_backend                        -- store lua backend here
local sensor_driver_found = false               -- true if user has configured lua backend
local num_pixels = 16                           -- automatically updated if 64. User can select between 16/64 from NAssistant software
local total_bytes_to_expect = 112               -- total bytes in one complete packet
local linebuf = {}                              -- serial buffer
local linebuf_len = 0
local index_row_max = 8

local PARAM_TABLE_KEY = 109 + sensor_no
local PARAM_TABLE_PREFIX = string.format("TOFSENSE_S" .. sensor_no.. "_")

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'could not add param table')

--[[
  // @Param: TOFSENSE_S1_PRX
  // @DisplayName: TOFSENSE-M to be used as Proximity sensor
  // @Description: Set 0 if sensor is to be used as a 1-D rangefinder (minimum of all distances will be sent, typically used for height detection). Set 1 if it should be used as a 3-D proximity device (Eg. Obstacle Avoidance)
  // @Values: 0:Set as Rangefinder, 1:Set as Proximity sensor
  // @User: Standard
--]]
SET_PRX    = bind_add_param('PRX', 1, 0)

--[[
  // @Param: TOFSENSE_S1_SP
  // @DisplayName: TOFSENSE-M serial port config
  // @Description: UART instance sensor is connected to. Set 1 if sensor is connected to the port with fist SERIALx_PROTOCOL = 28. 
  // @Range: 1 4
  // @User: Standard
--]]
SERIAL_PORT = bind_add_param('SP', 2, 1)

--[[
  // @Param: TOFSENSE_S1_BR
  // @DisplayName: TOFSENSE-M serial port baudrate
  // @Description: Serial Port baud rate. Sensor baud rate can be changed from Nassistant software
  // @User: Standard
--]]
SERIAL_BAUD = bind_add_param('BR', 3, 230400)

-- find the serial scripting serial port instance. 0 indexed.
-- SERIALx_PROTOCOL 28
local port = assert(serial:find_serial(SERIAL_PORT:get() - 1),"Could not find Scripting Serial Port")

-- begin the serial port
port:begin(SERIAL_BAUD:get())
-- port:set_flow_control(0)

function setup_sensor(sensor, param_num)
  local sensor_count = sensor:num_sensors() -- number of sensors connected
  for j = 0, sensor_count -1 do
    local device = sensor:get_backend(j)
    if ((not sensor_driver_found) and  device and (device:type() == param_num)) then
      -- this is a lua driver
      sensor_driver_found = true
      lua_driver_backend = device
    end
  end
  if not sensor_driver_found then
    -- We can't use this script if user hasn't setup a lua backend
    gcs:send_text(0, string.format("Configure Lua Sensor"))
    return
  end
end

-- get yaw and pitch of the pixel based message index.
function convert_to_angle(index)
  -- The distances are sent in either a 4x4 or 8x8 grid. The horizontal and vertical FOV are 45 degrees so we can work out the angles
  local angle_division = 45/index_row_max
  local horizontal_index = (index) % index_row_max
  local vertical_index = math.floor(index / index_row_max)
  local yaw = -22.5 + (horizontal_index*angle_division)
  local pitch = -22.5 + (vertical_index*angle_division)
  return yaw, pitch
end

-- send the message down to proximity library. This needs to be a 3D vector. User of this function needs to ensure prx backend exists
function sent_prx_message(dist, yaw_deg, pitch_deg, push_to_boundary)
  if dist > 0 then
    lua_driver_backend:set_distance_min_max(0,4)
    lua_driver_backend:handle_script_distance_msg(dist, yaw_deg, pitch_deg, push_to_boundary)
  end
end

-- send the message down to proximity library. This needs to be a single distance. User of this function needs to ensure rngfnd backend exists
function send_rfnd_message(dist)
  if dist > 0 then
    local sent_successfully = lua_driver_backend:handle_script_msg(dist)
    if not sent_successfully then
      -- This should never happen as we already checked for a valid configured lua backend above
      gcs:send_text(0, string.format("RFND Lua Script Error"))
    end
end
end

function update() -- this is the loop which periodically runs

  if not sensor_driver_found then
    if SET_PRX:get() == 0 then
      setup_sensor(rangefinder, param_num_lua_driver_backend)
    else
      setup_sensor(proximity, param_num_lua_prx_backend)
    end
  end

  if (not sensor_driver_found) then
    -- We can't use this script if user hasn't setup a lua backend
    return
  end

  local nbytes = port:available()
  nbytes = math.min(nbytes, bytes_to_parse)
  while nbytes > 0 do
    nbytes = nbytes - 1
    local r = port:read()
    if r < 0 then
      break
    end
    local c = r

    -- if buffer is empty and this byte is 0x57, add to buffer
    if linebuf_len == 0 then
        if c == NOOPLOOP_FRAME_HEADER then
            -- lua table indexing starts from 1
            linebuf[linebuf_len + 1] = c
            linebuf_len = linebuf_len + 1
        else
          linebuf_len = 0
        end
    elseif linebuf_len == 1 then
        -- if buffer has 1 element and this byte is 0x00, add it to buffer
        -- if not clear the buffer
        if c == NOOPLOOP_FRAME_HEADER_1 then
            linebuf[linebuf_len + 1] = c
            linebuf_len = linebuf_len + 1
        else
            linebuf_len = 0
        end

    elseif linebuf_len == 8 then
        -- store the next character as "number of pixels"
        num_pixels = tonumber(c)
        linebuf[linebuf_len + 1] = c
        linebuf_len = linebuf_len + 1
        -- Check if num_pixels is either 64 or 16
        if num_pixels ~= 64 and num_pixels ~= 16 then
            linebuf_len = 0
        end
        --update total bytes to expect
        total_bytes_to_expect = 16 + (num_pixels * 6)
        if num_pixels == 16 then
          index_row_max = 4
        end
    else
      -- add character to buffer
      linebuf[linebuf_len + 1] = c
      linebuf_len = linebuf_len + 1
      if linebuf_len == total_bytes_to_expect then
          -- calculate checksum
          local checksum = 0
          for i = 1, total_bytes_to_expect - 1 do
              checksum = (checksum + linebuf[i]) % 256
          end
          -- if checksum matches extract contents
          if checksum ~= linebuf[total_bytes_to_expect] then
            if debug_enable then
              gcs:send_text(0, "Checksum does not matches")
            end
          else
            local min_distance = 0
            local min_index = 0
            local index = -1
            for i = 10, total_bytes_to_expect - 7, 6 do
                local distance = ((linebuf[i]<<8 | linebuf[i+1]<<16 | linebuf[i+2]<<24)/256) / 1000000
                local status = linebuf[i+3]
                index = index + 1
                if status < 255 then
                  if (SET_PRX:get() == 1) then
                    local yaw, pitch =  convert_to_angle(index)
                    if debug_enable then
                      gcs:send_text(0, "Distance debug: " .. distance .. " mm, status: " .. status .. "Yaw " .. yaw .. "pitch " .. pitch)
                    end
                    sent_prx_message(distance, yaw, pitch, false)
                  end
                  if status == 0 and (min_distance == 0 or distance < min_distance) then
                      min_distance = distance
                      min_index = index
                  end
                end
              end

              if (SET_PRX:get() == 1) then
                -- update prx boundary now that we have parsed all data
                lua_driver_backend:update_virtual_boundary()
              else if min_distance > 0 then
                  if debug_enable then
                    local yaw,pitch =  convert_to_angle(min_index)
                    gcs:send_text(0, "Distance: " .. min_distance .. " m. Yaw " .. yaw .. "pitch " .. pitch)
                  end
                  send_rfnd_message(min_distance)
                end
              end
            end
          -- clear buffer
          linebuf_len = 0
      end
    end
  end
end

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
      gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
      -- when we fault we run the update function again after 1s, slowing it
      -- down a bit so we don't flood the console with errors
      return protected_wrapper, 1000
  end
  return protected_wrapper, update_rate_ms
end

-- start running update loop
return protected_wrapper()



================================================
File: drivers/TOFSense-M/TOFSense-M_Serial.md
================================================
# TOFSense-M Serial Driver

TOFSense-M Serial Driver lua script. Only Copter/Rover/Plane 4.5 and above

## How to use - Pre-Configuration

- Connect sensors to one of autopilot's Serial port
- Set SERIALx_PROTOCOL 28
- Set SCR_ENABLE = 1 to enable scripting
- Set SCR_HEAP_SIZE = 150000 (or higher)
- If using the sensor as a 1-D Rangefinder (typically for terrain following); set RNGFND1_TYPE = 36 (Scripting) to enable the rangefinder scripting driver
- If using the sensor as a 3-D Proximity sensor (typically for obstacle); set PRX1_TYPE = 15 (Scripting) to enable the proximity scripting driver
- Reboot the autopilot
- Copy the TOFSense-M_Serial.lua script to the autopilot's SD card in the APM/scripts directory and reboot the autopilot

## How to use - Script Parameter Configuration

If everything above is done correctly, new "TOFSENSE_S_" parameters should be visible (only after script loads. Please refresh parameters if not visible). Script parameters to adjust are listed below. Any changes would require reboot

### TOFSENSE_S1_PRX
If you have set RNGFND1_TYPE = 36, then set this as 0
If you have set PRX1_TYPE = 15, then set this as 1
Any change in this parameter will require a reboot (or scripting restart), ignore any errors on change before reboot. Make sure RNGFND/PRX is configured before setting this.

### TOFSENSE_S1_SP
UART instance sensor is connected to. Set 1 if sensor is connected to the port with fist SERIALx_PROTOCOL = 28. For example, if SERIAL1_PROTOCOL = 28, and SERIAL2_PROTOCOL = 28, then setting this parameter 2 would assume the SERIAL2 port is attached to the sensor

### TOFSENSE_S1_BR
Serial Port baud rate. Sensor baud rate of the sensor can be changed from Nassistant software


## Advanced: Configuring more than one sensor on different Serial ports

It is not recommended to use this driver for more than one sensor. However, it is possible if you wish to do it.
Simply make a copy of the lua script, open it and change the first line "local sensor_no = 1" to "local sensor_no = 2" and upload that script along side the first script.
Once a reboot is done, new TOFSENSE_S2_ parameters should be visible which can be configured as described above. 




================================================
File: examples/README.md
================================================
#LUA Examples


This directory contains some script examples. For simulation the scripts should be placed in the simulation's "scripts" directory located in the root directory from which the sim is run.
Note: if an example uses auxillary files (mission list, other scripts,etc.) the user will have to determine where the files should be placed from the script. If no path name is specified in the file name, then it should be placed one directory level above the "scripts" directory.



================================================
File: examples/6DoF_roll_pitch.lua
================================================
-- A script for controlling the roll and pitch of 6DoF vehicles
-- The script sets the target roll and pitch to the current value when arming or when E-stop is removed
-- this allows the vehicle to be placed upside-down on the ground and to take off as normal
-- its is also possible to setup a switch with option 300 to use either 4 or 6DoF control

-- make sure the vehicle is capable of 6DoF control
assert(param:get('FRAME_CLASS') == 16, "script requires a 6DoF vehicle")

local e_stop = rc:find_channel_for_option(31)
local sw = rc:find_channel_for_option(300)
local motors_spinning = false

function update() -- this is the loop which periodically runs

  -- motor state
  local current_motors_spinning = false

  if arming:is_armed() then
    -- if armed then motors are spinning
    current_motors_spinning = true
  end

  if e_stop then
    -- if E-stop switch is setup
    if e_stop:get_aux_switch_pos() == 2 then
      -- E-stop on, motors stopped
      current_motors_spinning = false
    end
  end

  if not motors_spinning and current_motors_spinning then
    -- Just armed or removed E-stop
    -- set offsets to current attitude
    local roll = math.deg(ahrs:get_roll_rad())
    local pitch = math.deg(ahrs:get_pitch_rad())
    attitude_control:set_offset_roll_pitch(roll,pitch)
    gcs:send_text(0, string.format("Set Offsets Roll: %0.1f, Pitch: %0.1f",roll,pitch))

    if sw then
      if sw:get_aux_switch_pos() == 2 then
        -- switch to 'normal' 4 DoF attitude control
        gcs:send_text(0, "4 DoF attitude control")
        attitude_control:set_lateral_enable(false)
        attitude_control:set_forward_enable(false)

      else
        -- 6DoF attutude control
        gcs:send_text(0, "6 DoF attitude control")
        attitude_control:set_lateral_enable(true)
        attitude_control:set_forward_enable(true)
      end
    end

  end
  motors_spinning = current_motors_spinning

  return update, 100 -- 10hz
end

return update()



================================================
File: examples/AHRS_switch.lua
================================================
-- switch between EKF2 and EKF3 on a switch

local AUX_FUNCTION_NUM = 300
local EKF_TYPE = Parameter('AHRS_EKF_TYPE')

function update()
   local sw_pos = rc:get_aux_cached(AUX_FUNCTION_NUM)
   if not sw_pos then
      return update, 100
   end
   if sw_pos == 2 then
      EKF_TYPE:set(3)
   else
      EKF_TYPE:set(2)
   end
   return update, 100
end

gcs:send_text(0, "Loaded AHRS switch for EKF3/EKF2")

return update()



================================================
File: examples/BQ40Z_bms_shutdown.lua
================================================
-- TI BQ40Z BMS shutdown script

local mavlink_msgs = require("MAVLink/mavlink_msgs")

local COMMAND_ACK_ID = mavlink_msgs.get_msgid("COMMAND_ACK")
local COMMAND_LONG_ID = mavlink_msgs.get_msgid("COMMAND_LONG")
local msg_map = {}
msg_map[COMMAND_ACK_ID] = "COMMAND_ACK"
msg_map[COMMAND_LONG_ID] = "COMMAND_LONG"

local PARAM_TABLE_KEY = 51
local PARAM_TABLE_PREFIX = "BATT_BQ40Z_"
-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')
--[[
  // @Param: BATT_BQ40Z_BUS
  // @DisplayName: Bus number for the BQ40Z
  // @Description: Bus number for the BQ40Z
  // @Range: 0 3
  // @User: Standard
--]]
local BATT_BQ40Z_BUS = bind_add_param('BUS', 1, 0)


local MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = 246
local MAV_RESULT_ACCEPTED = 0
local MAV_RESULT_FAILED = 4

-- initialize MAVLink rx with buffer depth and number of rx message IDs to register
mavlink:init(10, 1)
-- Register message id to receive
mavlink:register_rx_msgid(COMMAND_LONG_ID)
-- Block MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN so we can handle the ACK
mavlink:block_command(MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN)

-- Init BMS i2c device
local i2c_addr = BATT_BQ40Z_BUS:get()
assert(i2c_addr ~= nil, "BATT_BQ40Z_BUS not retrievable")
local bms = i2c:get_device(math.floor(i2c_addr), 0x0B)

-- Exit emergency shutdown (for BQ40Z60, twice for redundancy)
bms:transfer("\x00\xA7\x23", 0)
bms:transfer("\x00\xA7\x23", 0)

-- Function that is returned to the AP scheduler when we want to shutdown
local function shutdown_loop()
    local ret = bms:transfer("\x00\x10\x00", 0)
    if ret == nil then
        gcs:send_text(0, "BQ40Z shutdown transfer failed")
    end

    return shutdown_loop, 500
end

-- Main loop
local function update()
    local msg, chan = mavlink:receive_chan()
    local parsed_msg = nil

    if (msg ~= nil) then
        parsed_msg = mavlink_msgs.decode(msg, msg_map)
    end

    if parsed_msg ~= nil and (parsed_msg.msgid == COMMAND_LONG_ID) and (parsed_msg.command == MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN) then
        -- Prepare ack
        local ack = {}
        ack.command = parsed_msg.command
        ack.result = MAV_RESULT_ACCEPTED
        ack.progress = 0
        ack.result_param2 = 0
        ack.target_system = parsed_msg.sysid
        ack.target_component = parsed_msg.compid

        -- Don't shutdown if armed
        if arming:is_armed() and parsed_msg.param1 == 2 then
            gcs:send_text(1, "Not sutting down BQ40Z as vehicle is armed")
            ack.result = MAV_RESULT_FAILED
            mavlink:send_chan(chan, mavlink_msgs.encode("COMMAND_ACK", ack))

        -- Shutdown
        elseif parsed_msg.param1 == 2 then
            gcs:send_text(1, "Shutting down BQ40Z!!!")
            mavlink:send_chan(chan, mavlink_msgs.encode("COMMAND_ACK", ack))
            return shutdown_loop, 0

        -- Pass through the command if it isn't requesting shutdown
        else
            local command_int = {
                p1 = parsed_msg.param1,
                p2 = parsed_msg.param2,
                p3 = parsed_msg.param3,
                p4 = parsed_msg.param4,
            }
            local result = gcs:run_command_int(MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN, command_int)
            ack.result = result
            mavlink:send_chan(chan, mavlink_msgs.encode("COMMAND_ACK", ack))
        end
    end

    return update, 1000
end


return update, 1000



================================================
File: examples/CAN_MiniCheetah_drive.lua
================================================
-- Control MiniCheetah motor driver over CAN
-- https://os.mbed.com/users/benkatz/code/HKC_MiniCheetah/docs/tip/CAN__com_8cpp_source.html

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil

-- Load CAN driver with a buffer size of 20
local driver = CAN:get_device(20)

local target_ID = uint32_t(1)

local pos_max = 12.5
local vel_max = 65
local Kp_min = 0
local Kp_max = 500
local Kd_min = 0
local kd_max = 5
local torque_max = 18

local position_des = 0
local position_inc = 0.01

-- convert decimal to int within given range and width
function to_uint(val, min, max, bits)
  local range = max - min
  local int_range = 0
  for i = 0, bits - 1 do
    int_range = int_range | (1 << i)
  end
  return math.floor((((val - min)/range) * int_range) + 0.5)
end

-- convert int to decimal within given range and width
function from_uint(val, min, max, bits)
  local range = max - min
  local int_range = 0
  for i = 0, bits - 1 do
    int_range = int_range | (1 << i)
  end
  return ((val / int_range) * range) + min
end

-- send a motor command
function send(position, velocity, Kp, Kd, torque)

  -- 16 bit position command, between -4*pi and 4*pi
  -- 12 bit velocity command, between -30 and + 30 rad/s
  -- 12 bit kp, between 0 and 500 N-m/rad
  -- 12 bit kd, between 0 and 100 N-m*s/rad
  -- 12 bit feed forward torque, between -18 and 18 N-m

  -- range check
  assert(math.abs(position) <= pos_max, "position out of range")
  assert(math.abs(velocity) <= vel_max, "velocity out of range")
  assert((Kp >= Kp_min) and (Kp <= Kp_max), "Kp out of range")
  assert((Kd >= Kd_min) and (Kd <= kd_max), "Kd out of range")
  assert(math.abs(torque) <= torque_max, "torque out of range")

  -- convert from decimal to integer
  position = to_uint(position, -pos_max,    pos_max,    16)
  velocity = to_uint(velocity, -vel_max,    vel_max,    12)
  Kp       = to_uint(Kp,        Kp_min,     Kp_max,     12)
  Kd       = to_uint(Kd,        Kd_min,     kd_max,     12)
  torque   = to_uint(torque,   -torque_max, torque_max, 12)

  msg = CANFrame()
  msg:id(target_ID)

  -- 0: [position[15-8]]
  msg:data(0, position >> 8)

  -- 1: [position[7-0]] 
  msg:data(1, position & 0xFF)

  -- 2: [velocity[11-4]]
  msg:data(2, velocity >> 4)

  -- 3: [velocity[3-0], kp[11-8]]
  msg:data(3, ((velocity << 4) | (Kp >> 8)) & 0xFF)

  -- 4: [kp[7-0]]
  msg:data(4, Kp & 0xFF)

  -- 5: [kd[11-4]]
  msg:data(5, Kd >> 4)

  -- 6: [kd[3-0], torque[11-8]]
  msg:data(6, ((Kd << 4) | (torque >> 8)) & 0xFF)

  -- 7: [torque[7-0]]
  msg:data(7, torque & 0xFF)

  -- sending 8 bytes of data
  msg:dlc(8)

  -- write the frame with a 10000us timeout
  driver:write_frame(msg, 10000)

end

-- send command to enable motor
function enable()
  msg = CANFrame()

  msg:id(target_ID)

  msg:data(0, 0xFF)
  msg:data(1, 0xFF)
  msg:data(2, 0xFF)
  msg:data(3, 0xFF)
  msg:data(4, 0xFF)
  msg:data(5, 0xFF)
  msg:data(6, 0xFF)
  msg:data(7, 0xFC)

  msg:dlc(8)

  driver:write_frame(msg, 10000)
end

-- send command to disable motor
function disable()
  msg = CANFrame()

  msg:id(target_ID)

  msg:data(0, 0xFF)
  msg:data(1, 0xFF)
  msg:data(2, 0xFF)
  msg:data(3, 0xFF)
  msg:data(4, 0xFF)
  msg:data(5, 0xFF)
  msg:data(6, 0xFF)
  msg:data(7, 0xFD)

  msg:dlc(8)

  driver:write_frame(msg, 10000)
end

-- send command to zero motor
function zero()
  msg = CANFrame()

  msg:id(target_ID)

  msg:data(0, 0xFF)
  msg:data(1, 0xFF)
  msg:data(2, 0xFF)
  msg:data(3, 0xFF)
  msg:data(4, 0xFF)
  msg:data(5, 0xFF)
  msg:data(6, 0xFF)
  msg:data(7, 0xFE)

  msg:dlc(8)

  driver:write_frame(msg, 10000)
end

-- receive data from motor
function receive()

    -- Read a message from the buffer
    frame = driver:read_frame()

    -- noting waiting, return early
    if not frame then
      return
    end

  -- 8 bit ID
  -- 16 bit position, between -4*pi and 4*pi
  -- 12 bit velocity, between -30 and + 30 rad/s
  -- 12 bit current, between -40 and 40;

  -- 0: [ID[7-0]]
  -- 1: [position[15-8]]
  -- 2: [position[7-0]]
  -- 3: [velocity[11-4]]
  -- 4: [velocity[3-0], current[11-8]]
  -- 5: [current[7-0]]

  local ID = frame:data(0)
  local position = (frame:data(1) << 8) | frame:data(2)
  local velocity = (frame:data(3) << 4) | (frame:data(4) >> 4)
  local current = ( (frame:data(4) << 8) | frame:data(5)) & 0xFFF

  -- from integer to decimal
  position = from_uint(position, -pos_max,    pos_max,    16)
  velocity = from_uint(velocity, -vel_max,    vel_max,    12)
  current  = from_uint(current,  -torque_max, torque_max, 12)

  return ID, position, velocity, current

end

function update()

  send(position_des, 0, 100, 1, 0)

  local ID, position, velocity, current = receive()
  if ID then
    gcs:send_named_float('POS',position)
    gcs:send_named_float('VEL',velocity)
    gcs:send_named_float('CUR',current)
  end

  position_des = position_des + position_inc

  if position_des > pos_max then
    position_inc = -math.abs(position_inc)
    position_des = pos_max
  end
  if position_des < -pos_max then
    position_inc = math.abs(position_inc)
    position_des = -pos_max
  end

  return update, 10

end

function init()
  enable()
  return update, 100
end

return init, 1000



================================================
File: examples/CAN_logger.lua
================================================
--[[
   This script captures raw packets to a log file for later playback using Tools/scripts/CAN/CAN_playback.py onto a CAN bus.
   Set CAN_D1_PROTOCOL to 10 for scripting.
   Also need LOG_DISARMED set to 1 if running this while disarmed.
--]]

---@diagnostic disable: param-type-mismatch

local can_driver = CAN:get_device(25)

if not can_driver then
   gcs:send_text(0,"No scripting CAN interface found")
   return
end

local last_print_ms = millis()
local frame_count = 0
local last_frame_count = 0

function update()

   local more_frames = true
   for _ = 1, 25 do
      local frame = can_driver:read_frame()
      if not frame then
         more_frames = false
         break
      end
      local id = frame:id()
      logger.write("CANF",'Id,DLC,FC,B0,B1,B2,B3,B4,B5,B6,B7','IBIBBBBBBBB',
                   id,
                   frame:dlc(),
                   frame_count,
                   frame:data(0), frame:data(1), frame:data(2), frame:data(3),
                   frame:data(4), frame:data(5), frame:data(6), frame:data(7))
      frame_count = frame_count + 1
   end

   local now = millis()
   if now - last_print_ms >= 1000 then
      local dt = (now - last_print_ms):tofloat()*0.001
      gcs:send_text(0, string.format("CAN: %.2f fps", (frame_count-last_frame_count)/dt))
      last_print_ms = now
      last_frame_count = frame_count
   end

   if more_frames then
      -- sleep for min possible time to try not to lose frames
      return update, 0
   end
   return update, 2
end

return update()



================================================
File: examples/CAN_read.lua
================================================
-- This script is an example of reading from the CAN bus
---@diagnostic disable: need-check-nil

-- Load CAN driver1. The first will attach to a protocol of 10, the 2nd to a protocol of 12
-- this allows the script to distinguish packets on two CAN interfaces
local driver1 = CAN:get_device(5)
local driver2 = CAN:get_device2(5)

if not driver1 and not driver2 then
   gcs:send_text(0,"No scripting CAN interfaces found")
   return
end

-- Only accept DroneCAN node status msg on second driver
-- node status is message ID 341
-- Message ID is 16 bits left shifted by 8 in the CAN frame ID.
driver2:add_filter(uint32_t(0xFFFF) << 8, uint32_t(341) << 8)

function show_frame(dnum, frame)
    gcs:send_text(0,string.format("CAN[%u] msg from " .. tostring(frame:id()) .. ": %i, %i, %i, %i, %i, %i, %i, %i", dnum, frame:data(0), frame:data(1), frame:data(2), frame:data(3), frame:data(4), frame:data(5), frame:data(6), frame:data(7)))
end

function update()

   -- see if we got any frames
   if driver1 then
      frame = driver1:read_frame()
      if frame then
         show_frame(1, frame)
      end
   end
   if driver2 then
      frame = driver2:read_frame()
      if frame then
         show_frame(2, frame)
      end
   end

  return update, 10

end

return update()



================================================
File: examples/CAN_write.lua
================================================
-- This script is an example of writing to CAN bus
---@diagnostic disable: need-check-nil

-- Load CAN driver, using the scripting protocol and with a buffer size of 5
local driver = CAN:get_device(5)

-- transfer ID of the message were sending
local Transfer_ID = 0

-- RGB colours in 0 - 255 range, and RGB fade speed
local red = 255
local green = 0
local blue  = 0
local fade_speed = 5


function update()

  -- send UAVCAN Light command
  -- uavcan.equipment.indication.LightsCommand
  -- note that as we don't do dynamic node allocation, the target light device must have a static node ID

  msg = CANFrame()

  -- extended frame, priority 30, message ID 1081 and node ID 11
  -- lua cannot handle numbers so large, so we have to use uint32_t userdata
  msg:id( (uint32_t(1) << 31) | (uint32_t(30) << 24) | (uint32_t(1081) << 8) | uint32_t(11) )

  msg:data(0,0) -- set light_id = 0

  -- convert colors to 565 rgb
  local red_5bit   = red >> 3
  local green_6bit = green >> 2
  local blue_5bit  = blue >> 3

  -- first is made up of 5 bits red and 3 bits of green
  msg:data(1, (red_5bit << 3) | (green_6bit >> 3))

  -- remaining 3 bits of green and 5 of blue
  msg:data(2, ((green_6bit << 5) | blue_5bit) & 0xFF)

  -- Tail includes, start of transfer, end of transfer, toggle and transfer ID bits.
  msg:data(3, (1 << 7) | (1 << 6) | Transfer_ID)

  Transfer_ID = Transfer_ID + 1
  -- transfer ID is 5 bits
  if Transfer_ID > 31 then
    Transfer_ID = 0
  end

  -- sending 4 bytes of data
  msg:dlc(4)

  -- write the frame with a 10000us timeout
  driver:write_frame(msg, 10000)

  -- basic RGB fade
  if red > 0 and blue == 0 then
    red = red - fade_speed
    green = green + fade_speed
  end
  if green > 0 and red == 0 then
    green = green - fade_speed
    blue = blue + fade_speed
  end
  if blue > 0 and green == 0 then
    red = red + fade_speed
    blue = blue - fade_speed
  end

  return update, 100

end

return update()



================================================
File: examples/DroneCAN_test.lua
================================================
--[[
    example of creating and sending DroneCAN messages
--]]


local MAGNETICFIELDSTRENGTHHIRES_ID = 1043
local MAGNETICFIELDSTRENGTHHIRES_SIGNATURE = uint64_t(0x3053EBE3, 0xD750286F)

local RAWAIRDATA_ID = 1027
local RAWAIRDATA_SIGNATURE = uint64_t(0xC77DF38B, 0xA122F5DA)

local PARAM_GETSET_ID = 11
local PARAM_GETSET_SIGNATURE = uint64_t(0xA7B622F9, 0x39D1A4D5)

local NODESTATUS_ID = 341
local NODESTATUS_SIGNATURE = uint64_t(0x0F0868D0, 0xC1A7C6F1)

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local TARGET_NODE = Parameter('SCR_USER1')

-- a handle we will use for broadcasting, sent as CANFD
local dc_handle = DroneCAN_Handle(0, MAGNETICFIELDSTRENGTHHIRES_SIGNATURE, MAGNETICFIELDSTRENGTHHIRES_ID, true)

-- a handle for fetching parameters
local param_handle = DroneCAN_Handle(0, PARAM_GETSET_SIGNATURE, PARAM_GETSET_ID)

--[[
    setup subscription to NodeStatus
--]]
local nodestatus_handle = DroneCAN_Handle(0, NODESTATUS_SIGNATURE, NODESTATUS_ID)
nodestatus_handle:subscribe()

--[[
    setup subscription to raw air data
--]]
local airspeed_handle = DroneCAN_Handle(0, RAWAIRDATA_SIGNATURE, RAWAIRDATA_ID)
airspeed_handle:subscribe()

-- table of all nodes
local node_status = {}


--[[
    send highres mag using a global handle
--]]
local function send_mag_highres()
    local payload = string.pack("Bfff", 7, 1, 2, 3)
    dc_handle:broadcast(payload)
    gcs:send_text(MAV_SEVERITY.INFO, "mag highres broadcast done")
end

--[[
    send highres mag using a handle that will be closed after being used
--]]
local function send_mag_highres2()
    local h = DroneCAN_Handle(0, MAGNETICFIELDSTRENGTHHIRES_SIGNATURE, MAGNETICFIELDSTRENGTHHIRES_ID)
    local payload = string.pack("Bfff", 8, 10, 11, 12)
    h:broadcast(payload)
    gcs:send_text(MAV_SEVERITY.INFO, "mag highres broadcast2 done")
end

--[[
    unpack a float16 into a floating point number
--]]
local function unpackFloat16(v16)
    -- Extract the sign (bit 15), exponent (bits 10–14) and fraction (bits 0–9)
    local sign     = (v16 >> 15) & 0x1
    local exponent = (v16 >> 10) & 0x1F
    local fraction = v16 & 0x3FF

    local value
    if exponent == 0 then
        if fraction == 0 then
            -- Zero (positive or negative)
            value = 0.0
        else
            -- Subnormal numbers (exponent = -14, no implicit leading 1)
            value = (fraction / 1024.0) * 2.0^-14
        end
    elseif exponent == 0x1F then
        if fraction == 0 then
            -- Infinity (positive or negative)
            value = math.huge
        else
            -- NaN (Not a Number)
            value = 0/0
        end
    else
        -- Normalized numbers: implicit 1 before the fraction and exponent bias of 15.
        value = (1 + fraction / 1024.0) * 2.0^(exponent - 15)
    end

    -- Apply the sign bit
    if sign == 1 then
        value = -value
    end

    return value
end

--[[
    check for incoming airspeed broadcast messages
--]]
local function check_airspeed()
    local payload, nodeid = airspeed_handle:check_message()
    if not payload then
        return
    end
    local flags, static_pressure, differential_pressure, static_pressure_sensor_temperature,
        differential_pressure_sensor_temperature, static_air_temperature, pitot_temperature = string.unpack("BffHHHH", payload)
    if flags then
        local temp_C = unpackFloat16(static_air_temperature) - 273.15;
        gcs:send_text(MAV_SEVERITY.INFO, string.format("Rawairdata(%u): %f %.2fC",
                                                       nodeid, differential_pressure, temp_C))
        logger:write("ASPL", 'SP,DP,ST,DT,SAT,PIT', 'ffffff',
                     static_pressure, differential_pressure, static_pressure_sensor_temperature, differential_pressure_sensor_temperature,
                     static_air_temperature, pitot_temperature)
    end
end

--[[
    parse a parameter GetSet NumericValue
--]]
local function parse_param_NumericValue(payload, byte_offset)
    local vtype = string.unpack("B", payload, byte_offset[1])
    byte_offset[1] = byte_offset[1] + 1
    if vtype == 0 then
        return nil
    elseif vtype == 1 then
        -- integer (treat as 32 bit for now, actually 64 bit)
        local ret = string.unpack("i", payload, byte_offset[1])
        byte_offset[1] = byte_offset[1] + 8
        return ret
    elseif vtype == 2 then
        -- float32
        local ret = string.unpack("f", payload, byte_offset[1])
        byte_offset[1] = byte_offset[1] + 4
        return ret
    else
        return nil
    end
end

--[[
    parse a parameter GetSet Value
--]]
local function parse_param_Value(payload, byte_offset)
    local vtype = string.unpack("B", payload, byte_offset[1])
    byte_offset[1] = byte_offset[1] + 1
    if vtype == 0 then
        return nil
    elseif vtype == 1 then
        -- signed integer (64 bit), return as signed 32 bit number
        local ret_lo, ret_hi = string.unpack("II", payload, byte_offset[1])
        byte_offset[1] = byte_offset[1] + 8
        if ret_hi & 0x80000000 then
            return -ret_lo
        end
        return ret_lo
    elseif vtype == 2 then
        -- float32
        local ret = string.unpack("f", payload, byte_offset[1])
        byte_offset[1] = byte_offset[1] + 4
        return ret
    elseif vtype == 3 then
        -- bool
        local v = string.unpack("B", payload, byte_offset[1])
        byte_offset[1] = byte_offset[1] + 1
        return v == 1
    elseif vtype == 4 then
        -- string
        local slen = string.unpack("B", payload, byte_offset[1])
        local ret = string.sub(payload, byte_offset[1]+1, slen+2)
        byte_offset[1] = byte_offset[1] + 1 + slen
        return ret
    else
        return nil
    end
end


--[[
    parse a parameter GetSet reply
--]]
local function parse_param_reply(payload)
    local byte_offset = {1}
    local value = parse_param_Value(payload, byte_offset)
    local default_value = parse_param_Value(payload, byte_offset)
    local max_value = parse_param_NumericValue(payload, byte_offset)
    local min_value = parse_param_NumericValue(payload, byte_offset)
    local name = string.sub(payload, byte_offset[1], #payload)
    return name, value, default_value, min_value, max_value
end

local next_param_index = 0

--[[
    encode a 16 bit number as a DroneCAN int13
--]]
local function encode_int13(v)
    return (v & 0xFF) | (v&0xFF00)<<3
end

local function fetch_param()
    local payload, nodeid = param_handle:check_message()
    if payload then
        local pname, pvalue = parse_param_reply(payload)
        if not pname or not pvalue then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("param restart loop %u", next_param_index))
            next_param_index = -1
        elseif type(pvalue) == "string" then
            gcs:send_text(MAV_SEVERITY.INFO, string.format("got param reply from %u idx=%u '%s' : %s", nodeid, next_param_index, pname, pvalue))
        else
            gcs:send_text(MAV_SEVERITY.INFO, string.format("got param reply from %u idx=%u '%s' : %f", nodeid, next_param_index, pname, pvalue))
        end
        next_param_index = next_param_index + 1
    end
    param_handle:request(TARGET_NODE:get(), string.pack("H",encode_int13(next_param_index)))
end

--[[
    check for new NodeStatus messages
--]]
local function check_node_status()
    local payload, nodeid = nodestatus_handle:check_message()
    if not payload then
        return
    end
    local uptime_sec, bits, _ = string.unpack("IBH", payload)
    local health = bits&3
    local mode = (bits>>2)&7
    local sub_mode = (bits>>5)&7
    if not node_status[nodeid] then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("Found node %u", nodeid))
    end
    node_status[nodeid] = { uptime_sec=uptime_sec, health=health, mode=mode, sub_mode=sub_mode }
end

local last_low_rate_ms = uint32_t(0)

local function update()
    local now = millis()
    if now - last_low_rate_ms >= 1000 then
        last_low_rate_ms = now
        send_mag_highres()
        send_mag_highres2()
        check_airspeed()
    end
    check_node_status()
    fetch_param()

    return update, 10
end

return update, 1000



================================================
File: examples/EFI_tester.lua
================================================
--[[
   simulator for CAN EFI
   this can be used with a loopback cable between CAN1 and CAN2 to test CAN EFI Drivers
--]]

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter


local driver2 = CAN.get_device2(25)
if not driver2 then
   gcs:send_text(0,string.format("EFISIM: Failed to load CAN driver"))
   return
end

local PARAM_TABLE_KEY = 13
local PARAM_TABLE_PREFIX = "EFISIM_"

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')

local EFISIM_TYPE  = bind_add_param('TYPE', 1, 0)
local EFISIM_RATE_HZ  = bind_add_param('RATE_HZ', 2, 100)

function get_time_sec()
   return millis():tofloat() * 0.001
end

local FRM_100 = uint32_t(0x80000100)
local FRM_101 = uint32_t(0x80000101)
local FRM_102 = uint32_t(0x80000102)
local FRM_104 = uint32_t(0x80000104)
local FRM_105 = uint32_t(0x80000105)
local FRM_106 = uint32_t(0x80000106)
local FRM_10A = uint32_t(0x8000010A)
local FRM_10C = uint32_t(0x8000010C)
local FRM_10D = uint32_t(0x8000010D)
local FRM_10F = uint32_t(0x8000010F)
local FRM_113 = uint32_t(0x80000113)
local FRM_114 = uint32_t(0x80000114)
local FRM_115 = uint32_t(0x80000115)

function put_u8(msg, ofs, v)
   msg:data(ofs,v&0xFF)
end

function put_u16_LE(msg, ofs, v)
   msg:data(ofs,v&0xFF)
   msg:data(ofs+1,v>>8)
end

function put_u32_LE(msg, ofs, v)
   msg:data(ofs+0,v&0xFF)
   msg:data(ofs+1,(v>>8)&0xFF)
   msg:data(ofs+2,(v>>16)&0xFF)
   msg:data(ofs+3,(v>>24)&0xFF)
end

function put_u16_BE(msg, ofs, v)
   msg:data(ofs+1,v&0xFF)
   msg:data(ofs,v>>8)
end

function put_u32_BE(msg, ofs, v)
   msg:data(ofs+3,v&0xFF)
   msg:data(ofs+2,(v>>8)&0xFF)
   msg:data(ofs+1,(v>>16)&0xFF)
   msg:data(ofs+0,(v>>24)&0xFF)
end

local rev_counter = 0

--[[
   send SkyPower data. Called at 100Hz
--]]
function send_SkyPower(driver)

   --local msg = CANFrame()
   local t = get_time_sec()

   local RPM = 1200 + math.floor(1000*math.sin(t))
   rev_counter = rev_counter + (RPM/60.0)*0.01

   -- 0x100
   local msg = CANFrame()
   msg:id(FRM_100)
   put_u16_LE(msg,0,RPM)
   put_u16_LE(msg,2,13*10) -- ignition angle
   put_u16_LE(msg,4,45*10) -- throttle angle
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x101
   msg = CANFrame()
   msg:id(FRM_101)
   put_u16_LE(msg,2,917) -- air pressure
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x102
   msg = CANFrame()
   msg:id(FRM_102)
   put_u16_LE(msg,0,7*10) -- ingition gap
   put_u16_LE(msg,2,270*10) -- injection angle
   put_u16_LE(msg,4,37000) -- injection time
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x104
   msg = CANFrame()
   msg:id(FRM_104)
   put_u16_LE(msg,0,math.floor(14.8*10)) -- supply voltage
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x105
   msg = CANFrame()
   msg:id(FRM_105)
   put_u16_LE(msg,0,172*10) -- engine temp head 1
   put_u16_LE(msg,2,65*10) -- air temp
   put_u16_LE(msg,4,320*10) -- exhaust temp
   put_u16_LE(msg,6,113*10) -- ecu temp
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x106
   msg = CANFrame()
   msg:id(FRM_106)
   put_u32_LE(msg,0,math.floor(rev_counter))
   put_u8(msg,4,math.floor(t))
   put_u8(msg,5,math.floor(t/60))
   put_u16_LE(msg,6,math.floor(t/3600))
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x10A
   msg = CANFrame()
   msg:id(FRM_10A)
   put_u16_LE(msg,6,72*10) -- target load
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x10C
   msg = CANFrame()
   msg:id(FRM_10C)
   put_u16_LE(msg,4,145*10) -- engine head temp 2
   put_u16_LE(msg,6,315*10) -- exhaust temp 2
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x10D
   msg = CANFrame()
   msg:id(FRM_10D)
   put_u16_LE(msg,4,72*10) -- current load
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x10F
   msg = CANFrame()
   msg:id(FRM_10F)
   put_u16_LE(msg,4,2*10) -- fuel consumption
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x113
   msg = CANFrame()
   msg:id(FRM_113)
   put_u16_LE(msg,2,1*10) -- gen amps
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x114
   msg = CANFrame()
   msg:id(FRM_114)
   put_u16_LE(msg,2,2400*10) -- gen RPM
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- 0x115
   msg = CANFrame()
   msg:id(FRM_115)
   put_u16_LE(msg,4,30*100) -- gen current
   msg:dlc(8)
   driver:write_frame(msg, 10000)
end

--[[
   send HFE data. Called at 100Hz
--]]
function send_HFE(driver)

   --local msg = CANFrame()
   local t = get_time_sec()

   local RPM = 1200 + math.floor(1000*math.sin(t))
   rev_counter = rev_counter + (RPM/60.0)*0.01

   -- fast telem
   local msg = CANFrame()
   local base_id = uint32_t(0x88000005)
   msg:id(base_id | 0x00000)
   put_u16_BE(msg,1,RPM)
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- slow telem0
   msg = CANFrame()
   msg:id(base_id | 0x10000)
   put_u16_BE(msg,5,101324/2) -- air pressure
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- slow telem1
   msg = CANFrame()
   msg:id(base_id | 0x20000)
   put_u8(msg,0,35) -- inlet air temp, signed, deg C
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- slow telem2
   msg = CANFrame()
   msg:id(base_id | 0x30000)
   put_u8(msg,1,math.floor((67+128)/1.5)) -- MAT
   put_u16_BE(msg,6,173) -- fuel flow in grams/hr
   msg:dlc(8)
   driver:write_frame(msg, 10000)
   

end

--[[
   send Halo6000 data. Called at 100Hz
--]]
function send_Halo6K(driver)

   --local msg = CANFrame()
   local t = get_time_sec()

   local RPM = 1200 + math.floor(1000*math.sin(t))
   rev_counter = rev_counter + (RPM/60.0)*0.01

   -- fast telem1
   local msg = CANFrame()
   msg:id(0x1c1)
   put_u16_LE(msg,0,RPM)
   msg:dlc(8)
   driver:write_frame(msg, 10000)

   -- fast telem2
   msg = CANFrame()
   msg:id(0x1c2)
   put_u16_LE(msg,0,math.floor(30.2*5))
   put_u16_LE(msg,2,math.floor(3.2*5)+200)
   msg:dlc(8)
   driver:write_frame(msg, 10000)
end

function update()
   if EFISIM_TYPE:get() == 1 then
      send_SkyPower(driver2)
   elseif EFISIM_TYPE:get() == 2 then
      send_HFE(driver2)
   elseif EFISIM_TYPE:get() == 3 then
      send_Halo6K(driver2)
   end
   return update, math.floor(1000/EFISIM_RATE_HZ:get())
end

gcs:send_text(0,string.format("EFISIM: loaded"))

return update()



================================================
File: examples/ESC_slew_rate.lua
================================================
--[[
   run an ESC with a sinisoidal demand, with settable limits and frequency
--]]

local PARAM_TABLE_KEY = 136
local PARAM_TABLE_PREFIX = "ETEST_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')

local ETEST_CHAN      = bind_add_param('CHAN',          1, 0)
local ETEST_PCT       = bind_add_param('PCT',           2, 100)
local ETEST_PWM_MIN   = bind_add_param('PWM_MIN',       3, 1000)
local ETEST_PWM_MAX   = bind_add_param('PWM_MAX',       4, 2000)
local ETEST_FREQ      = bind_add_param('FREQ',          5, 1)
local ETEST_WTYPE     = bind_add_param('WTYPE',         6, 0)

-- local WTYPE_SIN = 0
local WTYPE_SQUARE = 1

function update()
   local chan = ETEST_CHAN:get()
   local freq = ETEST_FREQ:get()
   if chan > 0 and freq > 0 then
      local t = 0.001 * millis():tofloat()
      local pi = 3.1415
      local out_sin = math.sin(pi * t * freq * 2.0)
      if ETEST_WTYPE:get() == WTYPE_SQUARE then
         if out_sin > 0 then
            out_sin = 1
         else
            out_sin = -1
         end
      end
      local output = out_sin * ETEST_PCT:get() * 0.01
      local pwm_min = ETEST_PWM_MIN:get()
      local pwm_max = ETEST_PWM_MAX:get()
      local pwm_mid = 0.5*(pwm_min+pwm_max)
      local pwm = math.floor(pwm_mid + (pwm_max-pwm_mid) * output)
      SRV_Channels:set_output_pwm_chan_timeout(chan-1, pwm, 100)
      logger:write('ESLW', 'PWM,Freq', 'If', pwm, freq)
      gcs:send_named_float('PWN',pwm)
      gcs:send_named_float('FREQ',freq)
   end
   return update, 5 -- 200Hz
end

return update()



================================================
File: examples/FenceBreach.lua
================================================
-- Example of checking and reporting on geo-fence breach

local breach_lookup = {
  [1] = "Maximim altitude",
  [2] = "Circle",
  [4] = "Polygon",
  [8] = "Minimum altitude"
}

-- Lookup brach type bitmask and return the names of any breached fences
local function get_breach_names(breaches)
  local msg = ""
  for bitmaks, name in pairs(breach_lookup) do
    if (breaches & bitmaks) ~= 0 then
      -- And + delimiter between types if more than one
      if (string.len(msg) > 0) then
        msg = msg .. " + "
      end
      msg = msg .. name
    end
  end

  return msg
end

function update()

  local breaches = fence:get_breaches()
  if breaches ~= 0 then
    -- Time passed since fence breach
    local breach_time = millis() - fence:get_breach_time()

    gcs:send_text(0, string.format("Breached: %s fence, outside for %0.2f seconds", get_breach_names(breaches), breach_time:tofloat() * 0.001))
  end

  return update, 1000
end

return update()



================================================
File: examples/FlexDebug.lua
================================================
--[[
   ArduPilot lua script to log debug messages from AM32 DroneCAN
   ESCs on the flight controller

   To install set SCR_ENABLE=1 and put this script in APM/SCRIPTS/ on
   the microSD of the flight controller then restart the flight
   controller
--]]

-- assume ESCs are nodes 30, 31, 32 and 33
local ESC_BASE = 30

local AM32_DEBUG = 100

local last_tstamp = {}
local ts_zero = uint32_t(0)
local reported_version_error = false

function log_AM32()
   for i = 0, 3 do
      local last_ts = last_tstamp[i] or ts_zero
      tstamp_us, msg = DroneCAN_get_FlexDebug(0, ESC_BASE+i, AM32_DEBUG, last_ts)
      if tstamp_us and msg then
         version, commutation_interval, num_commands, num_input, rx_errors, rxframe_error, rx_ecode, auto_advance_level = string.unpack("<BiHHHHiB", msg)
         if not version or version ~= 1 then
            if not reported_version_error then
               reported_version_error = true
               gcs:send_text(0, string.format("AM32 debug version error %u", version))
            end
            return
         end
         logger:write('AMD1','Node,CI,NC,NI,RXerr,FrE,RXec,AAL','BiHHHHiB','#-------','--------',i,commutation_interval, num_commands, num_input, rx_errors, rxframe_error, rx_ecode, auto_advance_level)
         if rx_ecode then
            gcs:send_named_float(string.format('AM32_EC_%u',i), rx_ecode)
         end
         last_tstamp[i] = tstamp_us
      end
   end
end

function update()
   log_AM32()
   return update, 5
end

gcs:send_text(0, "Loaded AM32_debug_log")

return update, 5





================================================
File: examples/Flip_Mode.lua
================================================
-- This script replicates the behavior of flip mode
local MODE_NUMBER = 100

-- Register flip as mode 100
local FLIP_MODE_STATE = assert(vehicle:register_custom_mode(MODE_NUMBER, "Flip 2", "FLI2"))

-- Get input channels
local THROTTLE_CHAN = math.floor(assert(param:get("RCMAP_THROTTLE")))
local pilot_throttle = assert(rc:get_channel(THROTTLE_CHAN))
local pilot_pitch = assert(rc:get_channel(assert(param:get("RCMAP_PITCH"))))
local pilot_roll = assert(rc:get_channel(assert(param:get("RCMAP_ROLL"))))

local HOVER_THROTTLE = Parameter("MOT_THST_HOVER")
local THROTTLE_MIN = Parameter("RC" .. THROTTLE_CHAN .. "_MIN")
local THROTTLE_MAX = Parameter("RC" .. THROTTLE_CHAN .. "_MAX")
local THROTTLE_DZ = Parameter("RC" .. THROTTLE_CHAN .. "_DZ")

-- Replication of the copter function
local function get_throttle_mid()
    local r_in = (THROTTLE_MIN:get() + THROTTLE_MAX:get()) * 0.5

    local radio_trim_low = THROTTLE_MIN:get() + THROTTLE_DZ:get()

    return 1000.0 * ((r_in - radio_trim_low) / (THROTTLE_MAX:get() - radio_trim_low))
end

-- Replication of the copter function
local function get_pilot_desired_throttle()

    local thr_mid = HOVER_THROTTLE:get()
    local throttle_control = (pilot_throttle:norm_input_ignore_trim() + 1.0) * (1000.0 / 2.0)

    local mid_stick = get_throttle_mid()

    local throttle_in
    if throttle_control < mid_stick then
        throttle_in = throttle_control * 0.5 / mid_stick

    else
        throttle_in = 0.5 + ((throttle_control - mid_stick) * 0.5 / (1000.0 - mid_stick))

    end

    local expo = -(thr_mid - 0.5) / 0.375
    expo = math.max(expo, -0.5)
    expo = math.min(expo,  1.0)

    return throttle_in * (1.0-expo) + expo*throttle_in*throttle_in*throttle_in
end

-- Used to check for mode changes
local last_mode_number

local MODES = {
    STABILIZE = 0,
    ALT_HOLD = 2,
}

-- Check if we should be allowed to enter flip mode
local function allow_enter(previous_mode)

    -- Only allow flip from stabilize and alt hold
    if (previous_mode ~= MODES.STABILIZE) and (previous_mode ~= MODES.ALT_HOLD) then
        return false
    end

    -- Must be armed and flying
    if (not arming:is_armed()) or (not vehicle:get_likely_flying()) then
        return false
    end

    return true
end

local FLIP_STATE = {
    START = 0,
    ROLL = 1,
    PITCH_A = 2,
    PITCH_B = 3,
    RECOVER = 4,
}
local state
local start_ms
local roll_dir
local pitch_dir
local start_attitude = {
    roll = 0,
    pitch = 0,
    yaw = 0,
}

-- Init on first call
local previous_mode
local function init()
    -- Record the previous mode, this is returned to on completion of the flip
    previous_mode = last_mode_number

    -- Return to previous mode immediately if flip cannot be performed
    if not allow_enter(previous_mode) then
        vehicle:set_mode(previous_mode)
        return
    end

    state = FLIP_STATE.START
    start_ms = millis()

    roll_dir = 0.0
    pitch_dir = 0.0

    -- choose direction based on pilot's roll and pitch sticks
    if pilot_pitch:norm_input_dz() > 0.1 then
        pitch_dir = 1.0
    elseif pilot_pitch:norm_input_dz() < -0.1 then
        pitch_dir = -1.0
    elseif pilot_roll:norm_input_dz() >= 0 then
        roll_dir = 1.0
    else
        roll_dir = -1.0
    end

    -- Record start attitude to be used in recovery stage
    start_attitude.roll = math.deg(ahrs:get_roll_rad())
    start_attitude.pitch = math.deg(ahrs:get_pitch_rad())
    start_attitude.yaw = math.deg(ahrs:get_yaw_rad())

end

local FLIP_THR_INC = 0.2
local FLIP_THR_DEC = 0.24
local FLIP_ROTATION_RATE = 400

local function run()
    local NOW = millis()

    -- Disarmed, pilot input or timeout then return to previous mode
    local PILOT_INPUT = (math.abs(pilot_roll:norm_input_dz()) > 0.85) or (math.abs(pilot_pitch:norm_input_dz()) > 0.85)
    if (not arming:is_armed()) or PILOT_INPUT or ((NOW - start_ms) > 2500) then
        vehicle:set_mode(previous_mode)
        return
    end

    local roll_deg = math.deg(ahrs:get_roll_rad())
    local pitch_deg = math.deg(ahrs:get_pitch_rad())

    if state == FLIP_STATE.RECOVER then
        -- Target original attitude with 0 climb rate
        vehicle:set_target_angle_and_climbrate(start_attitude.roll, start_attitude.pitch, start_attitude.yaw, 0.0, false, 0.0)

        -- See if we have returned to the desired angle
        local recovery_angle = math.abs((roll_deg - start_attitude.roll) * roll_dir) + math.abs((pitch_deg - start_attitude.pitch) * pitch_dir)

        if recovery_angle < 5.0 then
            -- Complete, return to original mode
            vehicle:set_mode(previous_mode)
        end
        return
    end

    local throttle_out = get_pilot_desired_throttle()

    local flip_angle = roll_deg * roll_dir + pitch_deg * pitch_dir

    if state == FLIP_STATE.START then
        -- Increase throttle
        throttle_out = math.min(throttle_out + FLIP_THR_INC, 1.0)

        -- Check for next stage
        if flip_angle >= 45.0 then
            if roll_dir ~= 0 then
                -- Rolling flip
                state = FLIP_STATE.ROLL
            else
                -- Pitching flip
                state = FLIP_STATE.PITCH_A
            end
        end

    elseif state == FLIP_STATE.ROLL then
        -- decrease throttle
        throttle_out = math.max(throttle_out - FLIP_THR_DEC, 0.0)

        -- beyond 90deg move on to recovery
        if (flip_angle < 45.0) and (flip_angle > -90.0) then
            state = FLIP_STATE.RECOVER
        end

    elseif state == FLIP_STATE.PITCH_A then
        -- decrease throttle
        throttle_out = math.max(throttle_out - FLIP_THR_DEC, 0.0)

        -- check roll for inversion
        if (math.abs(roll_deg) > 90.0) and (flip_angle > 45.0) then
            state = FLIP_STATE.PITCH_B
        end

    elseif state == FLIP_STATE.PITCH_B then
        -- decrease throttle
        throttle_out = math.max(throttle_out - FLIP_THR_DEC, 0.0)

        -- check roll for un-inversion
        if (math.abs(roll_deg) < 90.0) and (flip_angle > -45.0) then
            state = FLIP_STATE.RECOVER
        end

    end

    -- Send rate and throttle command to vehicle
    local roll_rate = FLIP_ROTATION_RATE * roll_dir
    local pitch_rate = FLIP_ROTATION_RATE * pitch_dir

    vehicle:set_target_rate_and_throttle(roll_rate, pitch_rate, 0.0, throttle_out)

end

local function exit()
    -- Nothing to do here
end

local function update()
    local mode = vehicle:get_mode()

    -- Update entry state
    FLIP_MODE_STATE:allow_entry(allow_enter(mode))

    if mode == MODE_NUMBER then
        if last_mode_number ~= MODE_NUMBER then
            -- Fist call after entering
            init()
        else
            -- Runtime function
            run()
        end

    elseif last_mode_number == MODE_NUMBER then
        -- Exit mode
        exit()
    end
    last_mode_number = mode

    -- Run at 100Hz
    return update, 10
end

return update()



================================================
File: examples/LED_matrix_image.lua
================================================
--[[
Script to control LED strips based on the roll of the aircraft. This is an example to demonstrate
the LED interface for WS2812 LEDs
--]]

--[[
for this demo we will use a single strip with 30 LEDs
--]]
local matrix_x = 7
local matrix_y = 7

-- matrix to convert from x y pos to location in the strip
local id = {}
-- because my strips go diagonally to get the led's closer together this is a odd ordering
id[1] = {}
id[1][1] = 21
id[1][2] = 20
id[1][3] = 10
id[1][4] = 9
id[1][5] = 3
id[1][6] = 2
id[1][7] = 0

id[2] = {}
id[2][1] = 33
id[2][2] = 22
id[2][3] = 19
id[2][4] = 11
id[2][5] = 8
id[2][6] = 4
id[2][7] = 1

id[3] = {}
id[3][1] = 34
id[3][2] = 32
id[3][3] = 23
id[3][4] = 18
id[3][5] = 12
id[3][6] = 7
id[3][7] = 5

id[4] = {}
id[4][1] = 42
id[4][2] = 35
id[4][3] = 31
id[4][4] = 24
id[4][5] = 17
id[4][6] = 13
id[4][7] = 6

id[5] = {}
id[5][1] = 43
id[5][2] = 41
id[5][3] = 36
id[5][4] = 30
id[5][5] = 25
id[5][6] = 16
id[5][7] = 14

id[6] = {}
id[6][1] = 47
id[6][2] = 44
id[6][3] = 40
id[6][4] = 37
id[6][5] = 29
id[6][6] = 26
id[6][7] = 15

id[7] = {}
id[7][1] = 48
id[7][2] = 46
id[7][3] = 45
id[7][4] = 39
id[7][5] = 38
id[7][6] = 28
id[7][7] = 27

-- ArduPilot logo 7 x 48, RGB
local image = {}
image[1] = {}
image[2] = {}
image[3] = {}
image[4] = {}
image[5] = {}
image[6] = {}
image[7] = {}

image[1][1] = {0, 0, 0}
image[2][1] = {0, 0, 0}
image[3][1] = {0, 0, 0}
image[4][1] = {0, 0, 0}
image[5][1] = {0, 0, 0}
image[6][1] = {0, 0, 0}
image[7][1] = {0, 0, 0}

image[1][2] = {0, 0, 0}
image[2][2] = {0, 0, 0}
image[3][2] = {0, 0, 0}
image[4][2] = {0, 0, 0}
image[5][2] = {0, 0, 0}
image[6][2] = {0, 0, 0}
image[7][2] = {191, 191, 191}

image[1][3] = {0, 0, 0}
image[2][3] = {0, 0, 0}
image[3][3] = {0, 0, 0}
image[4][3] = {0, 0, 0}
image[5][3] = {0, 0, 0}
image[6][3] = {191, 191, 191}
image[7][3] = {0, 0, 0}

image[1][4] = {0, 0, 0}
image[2][4] = {0, 0, 0}
image[3][4] = {0, 0, 0}
image[4][4] = {196, 196, 196}
image[5][4] = {191, 191, 191}
image[6][4] = {0, 0, 0}
image[7][4] = {191, 191, 191}

image[1][5] = {0, 0, 0}
image[2][5] = {0, 0, 0}
image[3][5] = {0, 0, 0}
image[4][5] = {191, 191, 191}
image[5][5] = {0, 0, 0}
image[6][5] = {0, 0, 0}
image[7][5] = {191, 191, 191}

image[1][6] = {0, 0, 0}
image[2][6] = {0, 0, 0}
image[3][6] = {191, 191, 191}
image[4][6] = {0, 0, 0}
image[5][6] = {191, 191, 191}
image[6][6] = {0, 0, 0}
image[7][6] = {191, 191, 191}

image[1][7] = {0, 0, 0}
image[2][7] = {191, 191, 191}
image[3][7] = {0, 0, 0}
image[4][7] = {0, 0, 0}
image[5][7] = {191, 191, 191}
image[6][7] = {0, 0, 0}
image[7][7] = {191, 191, 191}

image[1][8] = {191, 191, 191}
image[2][8] = {191, 191, 191}
image[3][8] = {191, 191, 191}
image[4][8] = {191, 191, 191}
image[5][8] = {191, 191, 191}
image[6][8] = {191, 191, 191}
image[7][8] = {191, 191, 191}

image[1][9] = {0, 0, 0}
image[2][9] = {0, 0, 0}
image[3][9] = {0, 0, 0}
image[4][9] = {0, 0, 0}
image[5][9] = {0, 0, 0}
image[6][9] = {0, 0, 0}
image[7][9] = {191, 191, 191}

image[1][10] = {0, 0, 0}
image[2][10] = {191, 191, 191}
image[3][10] = {191, 191, 191}
image[4][10] = {191, 191, 191}
image[5][10] = {191, 191, 191}
image[6][10] = {191, 191, 191}
image[7][10] = {191, 191, 191}

image[1][11] = {191, 191, 191}
image[2][11] = {190, 190, 190}
image[3][11] = {0, 0, 0}
image[4][11] = {0, 0, 0}
image[5][11] = {0, 0, 0}
image[6][11] = {0, 0, 0}
image[7][11] = {191, 191, 191}

image[1][12] = {191, 191, 191}
image[2][12] = {192, 192, 192}
image[3][12] = {0, 0, 0}
image[4][12] = {191, 191, 191}
image[5][12] = {0, 0, 0}
image[6][12] = {0, 0, 0}
image[7][12] = {191, 191, 191}

image[1][13] = {191, 191, 191}
image[2][13] = {191, 191, 191}
image[3][13] = {191, 191, 191}
image[4][13] = {191, 191, 191}
image[5][13] = {193, 193, 193}
image[6][13] = {0, 0, 0}
image[7][13] = {191, 191, 191}

image[1][14] = {0, 0, 0}
image[2][14] = {191, 191, 191}
image[3][14] = {191, 191, 191}
image[4][14] = {0, 0, 0}
image[5][14] = {191, 191, 191}
image[6][14] = {187, 187, 187}
image[7][14] = {191, 191, 191}

image[1][15] = {0, 0, 0}
image[2][15] = {191, 191, 191}
image[3][15] = {191, 191, 191}
image[4][15] = {191, 191, 191}
image[5][15] = {191, 191, 191}
image[6][15] = {191, 191, 191}
image[7][15] = {191, 191, 191}

image[1][16] = {195, 195, 195}
image[2][16] = {191, 191, 191}
image[3][16] = {191, 191, 191}
image[4][16] = {191, 191, 191}
image[5][16] = {191, 191, 191}
image[6][16] = {191, 191, 191}
image[7][16] = {191, 191, 191}

image[1][17] = {191, 191, 191}
image[2][17] = {190, 190, 190}
image[3][17] = {0, 0, 0}
image[4][17] = {0, 0, 0}
image[5][17] = {190, 190, 190}
image[6][17] = {191, 191, 191}
image[7][17] = {191, 191, 191}

image[1][18] = {191, 191, 191}
image[2][18] = {191, 191, 191}
image[3][18] = {0, 0, 0}
image[4][18] = {0, 0, 0}
image[5][18] = {191, 191, 191}
image[6][18] = {191, 191, 191}
image[7][18] = {191, 191, 191}

image[1][19] = {0, 0, 0}
image[2][19] = {191, 191, 191}
image[3][19] = {191, 191, 191}
image[4][19] = {191, 191, 191}
image[5][19] = {191, 191, 191}
image[6][19] = {0, 0, 0}
image[7][19] = {191, 191, 191}

image[1][20] = {0, 0, 0}
image[2][20] = {0, 0, 0}
image[3][20] = {0, 0, 0}
image[4][20] = {0, 0, 0}
image[5][20] = {0, 0, 0}
image[6][20] = {0, 0, 0}
image[7][20] = {191, 191, 191}

image[1][21] = {0, 0, 0}
image[2][21] = {191, 191, 191}
image[3][21] = {191, 191, 191}
image[4][21] = {191, 191, 191}
image[5][21] = {191, 191, 191}
image[6][21] = {0, 0, 0}
image[7][21] = {191, 191, 191}

image[1][22] = {191, 191, 191}
image[2][22] = {192, 192, 192}
image[3][22] = {192, 192, 192}
image[4][22] = {192, 192, 192}
image[5][22] = {191, 191, 191}
image[6][22] = {191, 191, 191}
image[7][22] = {191, 191, 191}

image[1][23] = {0, 0, 0}
image[2][23] = {0, 0, 0}
image[3][23] = {0, 0, 0}
image[4][23] = {0, 0, 0}
image[5][23] = {191, 191, 191}
image[6][23] = {191, 191, 191}
image[7][23] = {191, 191, 191}

image[1][24] = {191, 191, 191}
image[2][24] = {191, 191, 191}
image[3][24] = {191, 191, 191}
image[4][24] = {191, 191, 191}
image[5][24] = {191, 191, 191}
image[6][24] = {0, 0, 0}
image[7][24] = {191, 191, 191}

image[1][25] = {192, 192, 192}
image[2][25] = {192, 192, 192}
image[3][25] = {192, 192, 192}
image[4][25] = {192, 192, 192}
image[5][25] = {0, 0, 0}
image[6][25] = {0, 0, 0}
image[7][25] = {191, 191, 191}

image[1][26] = {0, 0, 0}
image[2][26] = {254, 210, 15}
image[3][26] = {251, 195, 20}
image[4][26] = {249, 179, 23}
image[5][26] = {249, 163, 26}
image[6][26] = {244, 150, 28}
image[7][26] = {191, 191, 191}

image[1][27] = {255, 223, 11}
image[2][27] = {254, 211, 18}
image[3][27] = {244, 196, 36}
image[4][27] = {242, 181, 41}
image[5][27] = {240, 166, 41}
image[6][27] = {237, 152, 46}
image[7][27] = {191, 191, 191}

image[1][28] = {255, 221, 12}
image[2][28] = {253, 210, 20}
image[3][28] = {0, 0, 0}
image[4][28] = {249, 179, 23}
image[5][28] = {0, 0, 0}
image[6][28] = {0, 0, 0}
image[7][28] = {191, 191, 191}

image[1][29] = {252, 222, 12}
image[2][29] = {253, 210, 18}
image[3][29] = {252, 195, 20}
image[4][29] = {249, 179, 23}
image[5][29] = {0, 0, 0}
image[6][29] = {0, 0, 0}
image[7][29] = {191, 191, 191}

image[1][30] = {0, 0, 0}
image[2][30] = {253, 210, 18}
image[3][30] = {251, 195, 20}
image[4][30] = {248, 179, 23}
image[5][30] = {0, 0, 0}
image[6][30] = {0, 0, 0}
image[7][30] = {191, 191, 191}

image[1][31] = {0, 0, 0}
image[2][31] = {0, 0, 0}
image[3][31] = {0, 0, 0}
image[4][31] = {0, 0, 0}
image[5][31] = {0, 0, 0}
image[6][31] = {0, 0, 0}
image[7][31] = {191, 191, 191}

image[1][32] = {0, 0, 0}
image[2][32] = {253, 210, 18}
image[3][32] = {251, 195, 20}
image[4][32] = {249, 179, 23}
image[5][32] = {249, 163, 26}
image[6][32] = {244, 150, 28}
image[7][32] = {191, 191, 191}

image[1][33] = {0, 0, 0}
image[2][33] = {0, 0, 0}
image[3][33] = {0, 0, 0}
image[4][33] = {0, 0, 0}
image[5][33] = {0, 0, 0}
image[6][33] = {0, 0, 0}
image[7][33] = {191, 191, 191}

image[1][34] = {0, 0, 0}
image[2][34] = {253, 210, 17}
image[3][34] = {251, 195, 20}
image[4][34] = {249, 179, 23}
image[5][34] = {249, 163, 26}
image[6][34] = {244, 150, 28}
image[7][34] = {191, 191, 191}

image[1][35] = {0, 0, 0}
image[2][35] = {0, 0, 0}
image[3][35] = {0, 0, 0}
image[4][35] = {0, 0, 0}
image[5][35] = {250, 162, 26}
image[6][35] = {244, 150, 28}
image[7][35] = {191, 191, 191}

image[1][36] = {0, 0, 0}
image[2][36] = {0, 0, 0}
image[3][36] = {0, 0, 0}
image[4][36] = {0, 0, 0}
image[5][36] = {249, 163, 26}
image[6][36] = {244, 150, 28}
image[7][36] = {191, 191, 191}

image[1][37] = {0, 0, 0}
image[2][37] = {0, 0, 0}
image[3][37] = {252, 196, 21}
image[4][37] = {248, 179, 23}
image[5][37] = {0, 0, 0}
image[6][37] = {0, 0, 0}
image[7][37] = {191, 191, 191}

image[1][38] = {0, 0, 0}
image[2][38] = {253, 210, 18}
image[3][38] = {0, 0, 0}
image[4][38] = {0, 0, 0}
image[5][38] = {249, 163, 26}
image[6][38] = {0, 0, 0}
image[7][38] = {191, 191, 191}

image[1][39] = {249, 223, 14}
image[2][39] = {0, 0, 0}
image[3][39] = {244, 193, 22}
image[4][39] = {247, 187, 41}
image[5][39] = {0, 0, 0}
image[6][39] = {245, 149, 28}
image[7][39] = {191, 191, 191}

image[1][40] = {252, 222, 14}
image[2][40] = {0, 0, 0}
image[3][40] = {249, 196, 18}
image[4][40] = {249, 179, 19}
image[5][40] = {0, 0, 0}
image[6][40] = {0, 0, 0}
image[7][40] = {191, 191, 191}

image[1][41] = {255, 222, 13}
image[2][41] = {250, 214, 18}
image[3][41] = {0, 0, 0}
image[4][41] = {0, 0, 0}
image[5][41] = {247, 164, 22}
image[6][41] = {244, 147, 32}
image[7][41] = {191, 191, 191}

image[1][42] = {0, 0, 0}
image[2][42] = {255, 209, 17}
image[3][42] = {251, 195, 20}
image[4][42] = {249, 179, 23}
image[5][42] = {247, 164, 26}
image[6][42] = {0, 0, 0}
image[7][42] = {191, 191, 191}

image[1][43] = {0, 0, 0}
image[2][43] = {249, 213, 15}
image[3][43] = {0, 0, 0}
image[4][43] = {0, 0, 0}
image[5][43] = {0, 0, 0}
image[6][43] = {0, 0, 0}
image[7][43] = {191, 191, 191}

image[1][44] = {249, 221, 15}
image[2][44] = {244, 211, 18}
image[3][44] = {0, 0, 0}
image[4][44] = {0, 0, 0}
image[5][44] = {0, 0, 0}
image[6][44] = {0, 0, 0}
image[7][44] = {191, 191, 191}

image[1][45] = {255, 221, 12}
image[2][45] = {253, 210, 18}
image[3][45] = {251, 195, 20}
image[4][45] = {249, 179, 23}
image[5][45] = {249, 163, 26}
image[6][45] = {245, 149, 26}
image[7][45] = {191, 191, 191}

image[1][46] = {255, 221, 12}
image[2][46] = {251, 211, 17}
image[3][46] = {0, 0, 0}
image[4][46] = {0, 0, 0}
image[5][46] = {0, 0, 0}
image[6][46] = {0, 0, 0}
image[7][46] = {191, 191, 191}

image[1][47] = {255, 221, 12}
image[2][47] = {0, 0, 0}
image[3][47] = {0, 0, 0}
image[4][47] = {0, 0, 0}
image[5][47] = {0, 0, 0}
image[6][47] = {0, 0, 0}
image[7][47] = {0, 0, 0}

image[1][48] = {0, 0, 0}
image[2][48] = {0, 0, 0}
image[3][48] = {0, 0, 0}
image[4][48] = {0, 0, 0}
image[5][48] = {0, 0, 0}
image[6][48] = {0, 0, 0}
image[7][48] = {0, 0, 0}

--[[
 use SERVOn_FUNCTION 94 for LED. We can control up to 16 separate strips of LEDs
 by putting them on different channels
--]]
local chan = SRV_Channels:find_channel(94)

if not chan then
    gcs:send_text(6, "LEDs: channel not set")
    return
end

-- find_channel returns 0 to 15, convert to 1 to 16
chan = chan + 1

gcs:send_text(6, "LEDs: chan=" .. tostring(chan))

-- initialisation code
--serialLED:set_num_neopixel(chan,  matrix_x * matrix_y)
serialLED:set_num_profiled(chan,  matrix_x * matrix_y)

local offset = 8;

local function display_image(image_in,offset_in,brightness_in)
    local im_offset = 0
    if offset_in then
        im_offset = offset_in
    end
    local brightness = 1
    if brightness_in then
        brightness = brightness_in
    end

    for i = 1, 48 do
        local x_index = i + im_offset
        if x_index >= 1 and x_index <= matrix_x then
            for j = 1, matrix_y do
                serialLED:set_RGB(chan, id[j][x_index], math.floor(image_in[j][i][1]*brightness), math.floor(image_in[j][i][2]*brightness), math.floor(image_in[j][i][3]*brightness))
            end
        end
    end
    
end


function update_LEDs()

  serialLED:set_RGB(chan, -1, 0, 0, 0)

  display_image(image,offset,0.05) 

  serialLED:send(chan)

  offset = offset - 1

 -- scroll until it is off the left edge
  if offset < - 48 - 8 then
    -- start with the stuff off the right edge of the display
    offset = 8
  end


  return update_LEDs, 100
end

return update_LEDs, 1000



================================================
File: examples/LED_matrix_text.lua
================================================
--[[
Script to control LED strips based on the roll of the aircraft. This is an example to demonstrate
the LED interface for WS2812 LEDs
--]]

--[[
for this demo we will use a single strip with 30 LEDs
--]]
local matrix_x = 7
local matrix_y = 7

-- matrix to convert from x y pos to location in the strip
local id = {}
-- because my strips go diagonally to get the led's closer together this is a odd ordering
id[1] = {}
id[1][1] = 21
id[1][2] = 20
id[1][3] = 10
id[1][4] = 9
id[1][5] = 3
id[1][6] = 2
id[1][7] = 0

id[2] = {}
id[2][1] = 33
id[2][2] = 22
id[2][3] = 19
id[2][4] = 11
id[2][5] = 8
id[2][6] = 4
id[2][7] = 1

id[3] = {}
id[3][1] = 34
id[3][2] = 32
id[3][3] = 23
id[3][4] = 18
id[3][5] = 12
id[3][6] = 7
id[3][7] = 5

id[4] = {}
id[4][1] = 42
id[4][2] = 35
id[4][3] = 31
id[4][4] = 24
id[4][5] = 17
id[4][6] = 13
id[4][7] = 6

id[5] = {}
id[5][1] = 43
id[5][2] = 41
id[5][3] = 36
id[5][4] = 30
id[5][5] = 25
id[5][6] = 16
id[5][7] = 14

id[6] = {}
id[6][1] = 47
id[6][2] = 44
id[6][3] = 40
id[6][4] = 37
id[6][5] = 29
id[6][6] = 26
id[6][7] = 15

id[7] = {}
id[7][1] = 48
id[7][2] = 46
id[7][3] = 45
id[7][4] = 39
id[7][5] = 38
id[7][6] = 28
id[7][7] = 27

-- https://github.com/noopkat/oled-font-5x7/blob/master/oled-font-5x7.js
local font = {}
font[' '] = {0x00, 0x00, 0x00, 0x00, 0x00} -- // space
font['!'] = {0x00, 0x00, 0x5F, 0x00, 0x00} -- // !
font['"'] = {0x00, 0x07, 0x00, 0x07, 0x00} -- // "
font['#'] = {0x14, 0x7F, 0x14, 0x7F, 0x14} -- // #
font['$'] = {0x24, 0x2A, 0x7F, 0x2A, 0x12} -- // $
font['%'] = {0x23, 0x13, 0x08, 0x64, 0x62} -- // %
font['&'] = {0x36, 0x49, 0x55, 0x22, 0x50} -- // &
font['('] = {0x00, 0x1C, 0x22, 0x41, 0x00} -- // (
font[')'] = {0x00, 0x41, 0x22, 0x1C, 0x00} -- // )
font['*'] = {0x08, 0x2A, 0x1C, 0x2A, 0x08} -- // *
font['+'] = {0x08, 0x08, 0x3E, 0x08, 0x08} -- // +
font[','] = {0x00, 0x50, 0x30, 0x00, 0x00} -- // ,
font['-'] = {0x08, 0x08, 0x08, 0x08, 0x08} -- // -
font['.'] = {0x00, 0x60, 0x60, 0x00, 0x00} -- // .
font['/'] = {0x20, 0x10, 0x08, 0x04, 0x02} -- // /
font['0'] = {0x3E, 0x51, 0x49, 0x45, 0x3E} -- // 0
font['1'] = {0x00, 0x42, 0x7F, 0x40, 0x00} -- // 1
font['2'] = {0x42, 0x61, 0x51, 0x49, 0x46} -- // 2
font['3'] = {0x21, 0x41, 0x45, 0x4B, 0x31} -- // 3
font['4'] = {0x18, 0x14, 0x12, 0x7F, 0x10} -- // 4
font['5'] = {0x27, 0x45, 0x45, 0x45, 0x39} -- // 5
font['6'] = {0x3C, 0x4A, 0x49, 0x49, 0x30} -- // 6
font['7'] = {0x01, 0x71, 0x09, 0x05, 0x03} -- // 7
font['8'] = {0x36, 0x49, 0x49, 0x49, 0x36} -- // 8
font['9'] = {0x06, 0x49, 0x49, 0x29, 0x1E} -- // 9
font[':'] = {0x00, 0x36, 0x36, 0x00, 0x00} -- // :
font[';'] = {0x00, 0x56, 0x36, 0x00, 0x00} -- // ;
font['<'] = {0x00, 0x08, 0x14, 0x22, 0x41} -- // <
font['='] = {0x14, 0x14, 0x14, 0x14, 0x14} -- // =
font['>'] = {0x41, 0x22, 0x14, 0x08, 0x00} -- // >
font['?'] = {0x02, 0x01, 0x51, 0x09, 0x06} -- // ?
font['@'] = {0x32, 0x49, 0x79, 0x41, 0x3E} -- // @
font['A'] = {0x7E, 0x11, 0x11, 0x11, 0x7E} -- // A
font['B'] = {0x7F, 0x49, 0x49, 0x49, 0x36} -- // B
font['C'] = {0x3E, 0x41, 0x41, 0x41, 0x22} -- // C
font['D'] = {0x7F, 0x41, 0x41, 0x22, 0x1C} -- // D
font['E'] = {0x7F, 0x49, 0x49, 0x49, 0x41} -- // E
font['F'] = {0x7F, 0x09, 0x09, 0x01, 0x01} -- // F
font['G'] = {0x3E, 0x41, 0x41, 0x51, 0x32} -- // G
font['H'] = {0x7F, 0x08, 0x08, 0x08, 0x7F} -- // H
font['I'] = {0x00, 0x41, 0x7F, 0x41, 0x00} -- // I
font['J'] = {0x20, 0x40, 0x41, 0x3F, 0x01} -- // J
font['K'] = {0x7F, 0x08, 0x14, 0x22, 0x41} -- // K
font['L'] = {0x7F, 0x40, 0x40, 0x40, 0x40} -- // L
font['M'] = {0x7F, 0x02, 0x04, 0x02, 0x7F} -- // M
font['N'] = {0x7F, 0x04, 0x08, 0x10, 0x7F} -- // N
font['O'] = {0x3E, 0x41, 0x41, 0x41, 0x3E} -- // O
font['P'] = {0x7F, 0x09, 0x09, 0x09, 0x06} -- // P
font['Q'] = {0x3E, 0x41, 0x51, 0x21, 0x5E} -- // Q
font['R'] = {0x7F, 0x09, 0x19, 0x29, 0x46} -- // R
font['S'] = {0x46, 0x49, 0x49, 0x49, 0x31} -- // S
font['T'] = {0x01, 0x01, 0x7F, 0x01, 0x01} -- // T
font['U'] = {0x3F, 0x40, 0x40, 0x40, 0x3F} -- // U
font['V'] = {0x1F, 0x20, 0x40, 0x20, 0x1F} -- // V
font['W'] = {0x7F, 0x20, 0x18, 0x20, 0x7F} -- // W
font['X'] = {0x63, 0x14, 0x08, 0x14, 0x63} -- // X
font['Y'] = {0x03, 0x04, 0x78, 0x04, 0x03} -- // Y
font['Z'] = {0x61, 0x51, 0x49, 0x45, 0x43} -- // Z
font['['] = {0x00, 0x00, 0x7F, 0x41, 0x41} -- // [
font[']'] = {0x41, 0x41, 0x7F, 0x00, 0x00} -- // ]
font['^'] = {0x04, 0x02, 0x01, 0x02, 0x04} -- // ^
font['_'] = {0x40, 0x40, 0x40, 0x40, 0x40} -- // _
font['a'] = {0x20, 0x54, 0x54, 0x54, 0x78} -- // a
font['b'] = {0x7F, 0x48, 0x44, 0x44, 0x38} -- // b
font['c'] = {0x38, 0x44, 0x44, 0x44, 0x20} -- // c
font['d'] = {0x38, 0x44, 0x44, 0x48, 0x7F} -- // d
font['e'] = {0x38, 0x54, 0x54, 0x54, 0x18} -- // e
font['f'] = {0x08, 0x7E, 0x09, 0x01, 0x02} -- // f
font['g'] = {0x08, 0x14, 0x54, 0x54, 0x3C} -- // g
font['h'] = {0x7F, 0x08, 0x04, 0x04, 0x78} -- // h
font['i'] = {0x00, 0x44, 0x7D, 0x40, 0x00} -- // i
font['j'] = {0x20, 0x40, 0x44, 0x3D, 0x00} -- // j
font['k'] = {0x00, 0x7F, 0x10, 0x28, 0x44} -- // k
font['l'] = {0x00, 0x41, 0x7F, 0x40, 0x00} -- // l
font['m'] = {0x7C, 0x04, 0x18, 0x04, 0x78} -- // m
font['n'] = {0x7C, 0x08, 0x04, 0x04, 0x78} -- // n
font['o'] = {0x38, 0x44, 0x44, 0x44, 0x38} -- // o
font['p'] = {0x7C, 0x14, 0x14, 0x14, 0x08} -- // p
font['q'] = {0x08, 0x14, 0x14, 0x18, 0x7C} -- // q
font['r'] = {0x7C, 0x08, 0x04, 0x04, 0x08} -- // r
font['s'] = {0x48, 0x54, 0x54, 0x54, 0x20} -- // s
font['t'] = {0x04, 0x3F, 0x44, 0x40, 0x20} -- // t
font['u'] = {0x3C, 0x40, 0x40, 0x20, 0x7C} -- // u
font['v'] = {0x1C, 0x20, 0x40, 0x20, 0x1C} -- // v
font['w'] = {0x3C, 0x40, 0x30, 0x40, 0x3C} -- // w
font['x'] = {0x44, 0x28, 0x10, 0x28, 0x44} -- // x
font['y'] = {0x0C, 0x50, 0x50, 0x50, 0x3C} -- // y
font['z'] = {0x44, 0x64, 0x54, 0x4C, 0x44} -- // z
font['{'] = {0x00, 0x08, 0x36, 0x41, 0x00} -- // {
font['|'] = {0x00, 0x00, 0x7F, 0x00, 0x00} -- // |
font['}'] = {0x00, 0x41, 0x36, 0x08, 0x00} -- // }

--[[
 use SERVOn_FUNCTION 94 for LED. We can control up to 16 separate strips of LEDs
 by putting them on different channels
--]]
local chan = SRV_Channels:find_channel(94)

if not chan then
    gcs:send_text(6, "LEDs: channel not set")
    return
end

-- find_channel returns 0 to 15, convert to 1 to 16
chan = chan + 1

gcs:send_text(6, "LEDs: chan=" .. tostring(chan))

-- initialisation code
--serialLED:set_num_neopixel(chan,  matrix_x * matrix_y)
serialLED:set_num_profiled(chan,  matrix_x * matrix_y)

local offset = 8;
local text_string = "ArduPilot"

local function display_char(char,r,g,b,offset_in)
local char_offset = 0
if offset_in then
    char_offset = offset_in
end
if char_offset > matrix_x then
    return
end
if char_offset < 1 - 5 then
    return
end

for i = 1, 5 do
    local x_index = i + char_offset
    if x_index >= 1 and x_index <= matrix_x then
        local font_colum = font[char][i]
        for j = 1, 7 do
            if (font_colum & 1) == 1 then
                serialLED:set_RGB(chan, id[j][x_index], r, g, b)
            end
            font_colum = font_colum >> 1
        end
    end
end

end

local function display_string(string,r,g,b,offset_in)
local str_offset = 0
for i = 1, string:len() do
    display_char(string:sub(i,i),r,g,b,str_offset + offset_in)
    str_offset = str_offset + 6
end
end

function update_LEDs()

  serialLED:set_RGB(chan, -1, 0, 0, 0)

  display_string(text_string,100,0,0,offset)

  serialLED:send(chan)

  offset = offset - 1

 -- scroll until it is off the left edge
  if offset < -text_string:len()*6 then
    -- start with the stuff off the right edge of the display
    offset = 8

    text_string = tostring(math.floor(math.deg(ahrs:get_yaw_rad())))
  end

  return update_LEDs, 100
end

return update_LEDs, 1000




================================================
File: examples/LED_poslight.lua
================================================
--[[
 Script to use LED strips as position lights.
 For this script we will use two strips with up to 8 LEDs each.
--]]
local num_leds = 8
local timer = 0

-- Brightness for green or red light.
local br_color = 255

 -- Brightness for flash light when armed.
local br_flash = 255

--[[
 Use SERVOn_FUNCTION 94 for left LED strip 
 Use SERVOn_FUNCTION 95 for right LED strip
--]]
local chan_left = assert(SRV_Channels:find_channel(94),"LEDs left: channel not set")
local chan_right = assert(SRV_Channels:find_channel(95),"LEDs right: channel not set")

-- find_channel returns 0 to 15, convert to 1 to 16
chan_left = chan_left + 1
chan_right = chan_right + 1

gcs:send_text(6, "LEDs strip left: chan=" .. tostring(chan_left))
gcs:send_text(6, "LEDs strip right: chan=" .. tostring(chan_right))

-- initialisation code
assert(serialLED:set_num_neopixel(chan_left, num_leds),"Failed left LED setup")
assert(serialLED:set_num_neopixel(chan_right, num_leds),"Failed right LED setup")
--assert(serialLED:set_num_profiled(chan_left, num_leds),"Failed left LED setup")
--assert(serialLED:set_num_profiled(chan_right, num_leds),"Failed right LED setup")

function update_LEDs()
  if arming:is_armed() then
    if (timer == 0) then
      serialLED:set_RGB(chan_left, -1, br_flash, br_flash, br_flash)
      serialLED:set_RGB(chan_right, -1, br_flash, br_flash, br_flash)
    elseif (timer == 1) then
      serialLED:set_RGB(chan_left, -1, br_color, 0, 0)
      serialLED:set_RGB(chan_right, -1, 0, br_color, 0)
    elseif (timer == 2) then
      serialLED:set_RGB(chan_left, -1, br_flash, br_flash, br_flash)
      serialLED:set_RGB(chan_right, -1, br_flash, br_flash, br_flash)
    elseif (timer == 3) then
      serialLED:set_RGB(chan_left, -1, br_color, 0, 0)
      serialLED:set_RGB(chan_right, -1, 0, br_color, 0)
    end
    timer = timer + 1
    if (timer > 10) then
      timer = 0
    end
  else 
    serialLED:set_RGB(chan_left, -1, br_color, 0, 0)
    serialLED:set_RGB(chan_right, -1, 0, br_color, 0)
    timer = 0
  end
  serialLED:send(chan_left)
  serialLED:send(chan_right)
  return update_LEDs, 100 -- run at 10Hz
end

return update_LEDs()



================================================
File: examples/LED_roll.lua
================================================
--[[
Script to control LED strips based on the roll of the aircraft. This is an example to demonstrate
the LED interface for WS2812 LEDs
--]]


--[[
for this demo we will use a single strip with 30 LEDs
--]]
local num_leds = 30

--[[
 use SERVOn_FUNCTION 94 for LED. We can control up to 16 separate strips of LEDs
 by putting them on different channels
--]]
local chan = SRV_Channels:find_channel(94)

if not chan then
    gcs:send_text(6, "LEDs: channel not set")
    return
end

-- find_channel returns 0 to 15, convert to 1 to 16
chan = chan + 1

gcs:send_text(6, "LEDs: chan=" .. tostring(chan))

-- initialisation code
--serialLED:set_num_neopixel(chan,  num_leds)
serialLED:set_num_profiled(chan,  num_leds)

-- constrain a value between limits
function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end

--[[
Table of colors on a rainbow, red first
--]]
local rainbow = {
  { 255, 0, 0 },
  { 255, 127, 0 },
  { 255, 255, 0 },
  { 0,   255, 0 },
  { 0,   0,   255 },
  { 75,  0,   130 },
  { 143, 0,   255 },
}

--[[
Function to set a LED to a color on a classic rainbow spectrum, with v=0 giving red
--]]
local function set_Rainbow(channel, led, v)
  local num_rows = #rainbow
  local row = math.floor(constrain(v * (num_rows-1)+1, 1, num_rows-1))
  local v0 = (row-1) / (num_rows-1)
  local v1 = row / (num_rows-1)
  local p = (v - v0) / (v1 - v0)
  r = math.floor(rainbow[row][1] + p * (rainbow[row+1][1] - rainbow[row][1]))
  g = math.floor(rainbow[row][2] + p * (rainbow[row+1][2] - rainbow[row][2]))
  b = math.floor(rainbow[row][3] + p * (rainbow[row+1][3] - rainbow[row][3]))
  serialLED:set_RGB(channel, led, r, g, b)
end

--[[
We will set the colour of the LEDs based on roll of the aircraft
--]]
function update_LEDs()
  local roll = constrain(ahrs:get_roll_rad(), math.rad(-60), math.rad(60))

  for led = 0, num_leds-1 do
    local v  = constrain(0.5 + 0.5 * math.sin(roll * (led - num_leds/2) / (num_leds/2)), 0, 1)
    set_Rainbow(chan, led, v)
  end
  serialLED:send(chan)

  return update_LEDs, 20 -- run at 50Hz
end

return update_LEDs, 1000




================================================
File: examples/MAVLinkHL.lua
================================================
--[[
Lua script to simulate a HL connection over a UART
Setup:
This script requires 1 serial port:
A "Script" serial port to connect directly to the GCS

Usage:
Use the "hl_mode" variable to control the behaviour of the script:
0 = start enabled, can be disabled via MAV_CMD_CONTROL_HIGH_LATENCY
1 = enabled on loss of telemetry link for 5 seconds (default)
2 = start disabled, can be enabled via MAV_CMD_CONTROL_HIGH_LATENCY

Use the MAVLink High Latency Control ("link hl on|off" in MAVProxy) to control
whether to send or not

Caveats:
-This will send HIGH_LATENCY2 packets in place of HEARTBEAT packets
-A single HIGH_LATENCY2 packet will be send every 5 sec
-MAVLink 1 will be used, as it's slightly more efficient (50 vs 52 bytes for a HL2 message)
-The param SCR_VM_I_COUNT may need to be increased in some circumstances

Written by Stephen Dade (stephen_dade@hotmail.com)
--]]

---@diagnostic disable: need-check-nil


local port = serial:find_serial(0)

if not port then
    gcs:send_text(0, "No Scripting Serial Port")
    return
end

port:begin(19200)
port:set_flow_control(0)

local time_last_tx = millis():tofloat() * 0.001

local hl_mode = 0
local link_lost_for = 0

-- enable high latency mode from here, instead of having to enable from GCS
if hl_mode == 0 then
    gcs:enable_high_latency_connections(true)
end

--[[
Returns true if the value is NaN, false otherwise
--]]
local function isNaN (x)
    return (x ~= x)
  end

--[[
Lua Object for decoding and encoding MAVLink (V1 only) messages
--]]
local function MAVLinkProcessor()
    -- public fields
    local self = {
        -- define MAVLink message id's
        COMMAND_LONG = 76,
        COMMAND_INT = 75,
        HIGH_LATENCY2 = 235,
        MISSION_ITEM_INT = 73,
        SET_MODE = 11,
        MISSION_SET_CURRENT = 41
    }

    -- private fields
    local _mavbuffer = ""
    local _mavresult = {}
    local _payload_len = 0
    local _mavdecodestate = 0 -- 0=looking for marker, 1=getting header,2=getting payload,3=getting crc
    PROTOCOL_MARKER_V1 = 0xFE
    HEADER_LEN_V1 = 6
    local _txseqid = 0

    -- AUTOGEN from MAVLink generator
    local _crc_extra = {}
    _crc_extra[75] = 0x9e
    _crc_extra[76] = 0x98
    _crc_extra[235] = 0xb3
    _crc_extra[73] = 0x26
    _crc_extra[11] = 0x59
    _crc_extra[41] = 0x1c

    local _messages = {}
    _messages[75] = { -- COMMAND_INT
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"x", "<i4"}, {"y", "<i4"}, {"z", "<f"}, {"command", "<I2"},
        {"target_system", "<B"}, {"target_component", "<B"}, {"frame", "<B"},
        {"current", "<B"}, {"autocontinue", "<B"}
    }
    _messages[76] = { -- COMMAND_LONG
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"param5", "<f"}, {"param6", "<f"}, {"param7", "<f"},
        {"command", "<I2"}, {"target_system", "<B"}, {"target_component", "<B"},
        {"confirmation", "<B"}
    }
    _messages[235] = { -- HIGH_LATENCY2
        {"timestamp", "<I4"}, {"latitude", "<i4"}, {"longitude", "<i4"},
        {"custom_mode", "<I2"}, {"altitude", "<i2"}, {"target_altitude", "<i2"},
        {"target_distance", "<I2"}, {"wp_num", "<I2"}, {"failure_flags", "<I2"},
        {"type", "<B"}, {"autopilot", "<B"}, {"heading", "<B"},
        {"target_heading", "<B"}, {"throttle", "<B"}, {"airspeed", "<B"},
        {"airspeed_sp", "<B"}, {"groundspeed", "<B"}, {"windspeed", "<B"},
        {"wind_heading", "<B"}, {"eph", "<B"}, {"epv", "<B"},
        {"temperature_air", "<b"}, {"climb_rate", "<b"}, {"battery", "<b"},
        {"custom0", "<B"}, -- should be <b (int8), but we're hacking this into a uint8 instead
        {"custom1", "<b"}, {"custom2", "<b"}
    }
    _messages[73] = { -- MISSION_ITEM_INT
        {"param1", "<f"}, {"param2", "<f"}, {"param3", "<f"}, {"param4", "<f"},
        {"x", "<i4"}, {"y", "<i4"}, {"z", "<f"}, {"seq", "<I2"},
        {"command", "<I2"}, {"target_system", "<B"}, {"target_component", "<B"},
        {"frame", "<B"}, {"current", "<B"}, {"autocontinue", "<B"}
    }
    _messages[11] = { -- SET_MODE
        { "custom_mode", "<I4" }, { "target_system", "<B" }, { "base_mode", "<B" },
    }
    _messages[41] = { -- MISSION_SET_CURRENT
        { "seq", "<I2" }, { "target_system", "<B" }, { "target_component", "<B" },
    }
    function self.getSeqID() return _txseqid end

    function self.generateCRC(buffer)
        -- generate the x25crc for a given buffer. Make sure to include crc_extra!
        local crc = 0xFFFF
        for i = 1, #buffer do
            local tmp = string.byte(buffer, i, i) ~ (crc & 0xFF)
            tmp = (tmp ~ (tmp << 4)) & 0xFF
            crc = (crc >> 8) ~ (tmp << 8) ~ (tmp << 3) ~ (tmp >> 4)
            crc = crc & 0xFFFF
        end
        return string.pack("<H", crc)
    end

    function self.parseMAVLink(byte)
        -- parse a new byte and see if we've got MAVLink message
        -- returns true if a packet was decoded, false otherwise
        _mavbuffer = _mavbuffer .. string.char(byte)

        -- check if this is a start of packet
        if _mavdecodestate == 0 and byte == PROTOCOL_MARKER_V1 then
            -- we have a packet start, discard the buffer before this byte
            _mavbuffer = string.char(byte)
            _mavdecodestate = 1
            return
        end

        -- if we have a full header, try parsing
        if #_mavbuffer == HEADER_LEN_V1 and _mavdecodestate == 1 then
            local read_marker = 1
            _, read_marker = string.unpack("<B", _mavbuffer, read_marker)
            _payload_len, read_marker = string.unpack("<B", _mavbuffer,
                                                      read_marker) -- payload is always the second byte
            -- fetch seq/sysid/compid
            _mavresult.seq, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            _mavresult.sysid, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            _mavresult.compid, read_marker =
                string.unpack("<B", _mavbuffer, read_marker)
            -- fetch the message id
            _mavresult.msgid, _ =
                string.unpack("<B", _mavbuffer, read_marker)

            _mavdecodestate = 2
            return
        end

        -- get payload
        if _mavdecodestate == 2 and #_mavbuffer ==
            (_payload_len + HEADER_LEN_V1) then
            _mavdecodestate = 3
            _mavresult.payload = string.sub(_mavbuffer, HEADER_LEN_V1 + 1)
            return
        end

        -- get crc, then process if CRC ok
        if _mavdecodestate == 3 and #_mavbuffer ==
            (_payload_len + HEADER_LEN_V1 + 2) then
            _mavdecodestate = 0
            _mavresult.crc = string.sub(_mavbuffer, -2, -1)

            local message_map = _messages[_mavresult.msgid]
            if not message_map then
                -- we don't know how to decode this message, bail on it
                _mavbuffer = ""
                return true
            end

            -- check CRC, if message defined
            local crc_extra_msg = _crc_extra[_mavresult.msgid]
            if crc_extra_msg ~= nil then
                local calccrc = self.generateCRC(
                                    string.sub(_mavbuffer, 2, -3) ..
                                        string.char(crc_extra_msg))
                if _mavresult.crc ~= calccrc then
                    gcs:send_text(3,
                                  "Bad CRC: " ..
                                      self.bytesToString(_mavbuffer, -2, -1) ..
                                      ", " .. self.bytesToString(calccrc, 1, 2))
                    _mavbuffer = ""
                    return
                end
            end

            -- map all the fields out
            local offset = 1
            for _, v in ipairs(message_map) do
                if v[3] then
                    _mavresult[v[1]] = {}
                    for j = 1, v[3] do
                        _mavresult[v[1]][j], offset = string.unpack(v[2],
                                                                    _mavresult.payload,
                                                                    offset)
                    end
                else
                    _mavresult[v[1]], offset = string.unpack(v[2],
                                                             _mavresult.payload,
                                                             offset)
                end
            end
            -- only process COMMAND_LONG and COMMAND_INT and  MISSION_ITEM_INT messages
            if _mavresult.msgid == self.MISSION_ITEM_INT then
                -- goto somewhere (guided mode target)
                if _mavresult.command == 16 then -- MAV_CMD_NAV_WAYPOINT
                    local loc = Location()
                    loc:lat(_mavresult.x)
                    loc:lng(_mavresult.y)
                    loc:alt(_mavresult.z * 100)
                    if _mavresult.frame == 10 then -- MAV_FRAME_GLOBAL_TERRAIN_ALT
                        loc:terrain_alt(true)
                    elseif _mavresult.frame == 3 then -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                        loc:relative_alt(true)
                    end
                    vehicle:set_target_location(loc)
                end
            elseif _mavresult.msgid == self.SET_MODE then
                vehicle:set_mode(_mavresult.custom_mode)
            elseif _mavresult.msgid == self.COMMAND_LONG then
                --- need to do a little conversion here. Taken from convert_COMMAND_LONG_to_COMMAND_INT()
                local command_long_stores_location = 0
                if (_mavresult.command == 179 or       -- MAV_CMD_DO_SET_HOME
                    _mavresult.command ==  201 or      -- MAV_CMD_DO_SET_ROI
                    _mavresult.command ==  195 or      -- MAV_CMD_DO_SET_ROI_LOCATION
                    _mavresult.command ==  192 or      -- MAV_CMD_DO_REPOSITION
                    _mavresult.command ==  43003) then -- MAV_CMD_EXTERNAL_POSITION_ESTIMATE
                    command_long_stores_location = 1
                end
                local int_frame_conv = 0       -- MAV_FRAME_GLOBAL
                if (_mavresult.command ==  195) then       -- MAV_CMD_DO_SET_ROI_LOCATION
                    int_frame_conv = 3         -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                elseif (_mavresult.command ==  179) then   -- MAV_CMD_DO_SET_HOME
                    int_frame_conv = 0        -- MAV_FRAME_GLOBAL
                elseif (_mavresult.command ==  201) then   -- MAV_CMD_DO_SET_ROI
                    int_frame_conv = 3        -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                elseif (_mavresult.command ==  42006) then   -- MAV_CMD_FIXED_MAG_CAL_YAW
                    int_frame_conv = 3        -- MAV_FRAME_GLOBAL_RELATIVE_ALT
                end
                local int_x = _mavresult.param5
                local int_y = _mavresult.param6
                if isNaN(int_x) then
                    int_x = 0
                end
                if isNaN(int_y) then
                    int_y = 0
                end
                if command_long_stores_location == 1 then
                    int_x = 1E7 * int_x
                    int_y = 1E7 * int_y
                end
                gcs:run_command_int(_mavresult.command, { p1 = _mavresult.param1,
                                                          p2 = _mavresult.param2,
                                                          p3 = _mavresult.param3,
                                                          p4 = _mavresult.param4,
                                                          x = int_x,
                                                          y = int_y,
                                                          z = _mavresult.param7,
                                                          int_frame = int_frame_conv,
                                                          current = 0,
                                                          autocontinue = 0 })
            elseif _mavresult.msgid == self.COMMAND_INT then
                gcs:run_command_int(_mavresult.command, { p1 = _mavresult.param1,
                                                          p2 = _mavresult.param2,
                                                          p3 = _mavresult.param3,
                                                          p4 = _mavresult.param4,
                                                          x = _mavresult.x,
                                                          y = _mavresult.y,
                                                          z = _mavresult.z,
                                                          frame = _mavresult.frame })
            elseif _mavresult.msgid == self.MISSION_SET_CURRENT then
                mission:set_current_cmd(_mavresult.seq)
            end
            _mavbuffer = ""
            return true
        end

        -- packet too big ... start again
        if #_mavbuffer > 263 then 
            _mavbuffer = ""
            _mavdecodestate = 0
        end
        return false
    end

    function self.bytesToString(buf, start, stop)
        local ret = ""
        for idx = start, stop do
            ret = ret .. string.format("0x%x ", buf:byte(idx), 1, -1) .. " "
        end
        return ret
    end

    function self.createMAVLink(message, msgid)
        -- generate a mavlink message (V1 only)

        -- create the payload
        local message_map = _messages[msgid]
        if not message_map then
            -- we don't know how to encode this message, bail on it
            gcs:send_text(3, "Unknown MAVLink message " .. msgid)
            return nil
        end

        local packString = "<"
        local packedTable = {}
        local packedIndex = 1
        for i, v in ipairs(message_map) do
            if v[3] then
                packString = (packString ..
                                 string.rep(string.sub(v[2], 2), v[3]))
                for j = 1, v[3] do
                    packedTable[packedIndex] = message[message_map[i][1]][j]
                    packedIndex = packedIndex + 1
                end
            else
                packString = (packString .. string.sub(v[2], 2))
                packedTable[packedIndex] = message[message_map[i][1]]
                packedIndex = packedIndex + 1
            end
        end

        local payload = string.pack(packString, table.unpack(packedTable))

        -- create the header. Assume componentid of 1
        local header = string.pack('<BBBBBB', PROTOCOL_MARKER_V1, #payload,
                                   _txseqid, param:get('MAV_SYSID'), 1,
                                   msgid)

        -- generate the CRC
        local crc_extra_msg = _crc_extra[msgid]
        local crc = self.generateCRC(string.sub(header, 2) .. payload ..
                                         string.char(crc_extra_msg))

        -- iterate sequence id
        _txseqid = (_txseqid + 1) % 255

        return header .. payload .. crc
    end

    -- return the instance
    return self
end

-- Transmitted HIGH_LATENCY2 packet
local hl2 = {}
hl2.timestamp = 0
hl2.latitude = 0
hl2.longitude = 0
hl2.custom_mode = 0
hl2.altitude = 0
hl2.target_altitude = 0
hl2.target_distance = 0
hl2.wp_num = 0
hl2.failure_flags = 0
hl2.type = gcs:frame_type()
hl2.autopilot = 3 -- MAV_AUTOPILOT_ARDUPILOTMEGA
hl2.heading = 0
hl2.target_heading = 0
hl2.throttle = 0
hl2.airspeed = 0
hl2.airspeed_sp = 0
hl2.groundspeed = 0
hl2.windspeed = 0
hl2.wind_heading = 0
hl2.eph = 0
hl2.epv = 0
hl2.temperature_air = 0
hl2.climb_rate = 0
hl2.battery = 0
hl2.custom0 = 1 -- MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
hl2.custom1 = 0
hl2.custom2 = 0

function wrap_360(angle)
    local res = angle % 360
    if res < 0 then res = res + 360 end
    return res
end

-- Define the MAVLink processor
local mavlink = MAVLinkProcessor()

function HLSatcom()
    -- read in any bytes from GCS and and send to MAVLink processor
    -- only read in 1 packet at a time to avoid time overruns
    while port:available() > 0 do
        local byte = port:read()
        if mavlink.parseMAVLink(byte) then break end
    end

    -- if mode 1 and there's been no mavlink traffic for 5000 ms, enable high latency
    if hl_mode == 1 then
        -- link lost time = boot time - GCS last seen time
        link_lost_for = (millis()- gcs:last_seen()):toint()
        -- gcs:last_seen() is set to millis() during boot (on plane). 0 on rover/copter
        -- So if it's less than 10000 assume no GCS packet received since boot
        if link_lost_for > 5000 and not gcs:get_high_latency_status() and gcs:last_seen() > 10000 then
            gcs:enable_high_latency_connections(true)
        elseif link_lost_for < 5000 and gcs:get_high_latency_status() then
            gcs:enable_high_latency_connections(false)
        end
    end

    -- send HL2 packet every 5 sec
    if gcs:get_high_latency_status() and (millis():tofloat() * 0.001) -
        time_last_tx > 5 then

        -- update HL2 packet
        hl2.timestamp = millis():tofloat()
        local position = ahrs:get_location()
        local wind = ahrs:wind_estimate()

        if position then
            hl2.latitude = tonumber(position:lat())
            hl2.longitude = tonumber(position:lng())
            hl2.altitude = math.floor(tonumber(position:alt()) * 0.01)
        end
        if wind then
            wind_xy = Vector2f()
            wind_xy:x(wind:x())
            wind_xy:y(wind:y())
            hl2.windspeed = math.abs(math.floor(wind_xy:length() * 5))
            hl2.wind_heading = math.floor(wrap_360(wind_xy:angle()) / 2)
        end
        hl2.custom_mode = vehicle:get_mode()

        if vehicle:get_wp_distance_m() ~= nil then
            hl2.target_distance = math.floor(vehicle:get_wp_distance_m() / 10)
        end
        if mission:get_current_nav_index() ~= nil then
            hl2.wp_num = mission:get_current_nav_index()
        end
        if vehicle:get_wp_bearing_deg() ~= nil then
            hl2.target_heading = math.floor(wrap_360(
                                                vehicle:get_wp_bearing_deg()) /
                                                2)
        end

        -- failure flags
        hl2.failure_flags = 0
        if not ahrs:healthy() then
            hl2.failure_flags = hl2.failure_flags + 4096 -- HL_FAILURE_FLAG_ESTIMATOR
        end
        if battery:num_instances() > 0 and not battery:healthy(0) then
            hl2.failure_flags = hl2.failure_flags + 128 -- HL_FAILURE_FLAG_BATTERY
        end
        if gps:num_sensors() > 0 and gps:status(0) <= gps.NO_FIX then
            hl2.failure_flags = hl2.failure_flags + 1 -- HL_FAILURE_FLAG_GPS
        end
        if (FWVersion:type() == 2 or FWVersion:type() == 3) and terrain:status() ==
            terrain.TerrainStatusUnhealthy then
            -- only for copter and plane
            hl2.failure_flags = hl2.failure_flags + 64 -- HL_FAILURE_FLAG_TERRAIN
        end
        if not rc:has_valid_input() then
            hl2.failure_flags = hl2.failure_flags + 256 -- HL_FAILURE_FLAG_RC_RECEIVER
        end

        hl2.heading = math.floor(wrap_360(math.deg(ahrs:get_yaw_rad())) / 2)
        hl2.throttle = math.floor(gcs:get_hud_throttle())
        if ahrs:airspeed_estimate() ~= nil then
            hl2.airspeed = math.abs(math.floor(ahrs:airspeed_estimate() * 5))
        end
        -- hl2.airspeed_sp = 0
        hl2.groundspeed = math.abs(math.floor(
                                       ahrs:groundspeed_vector():length() * 5))

        hl2.temperature_air = math.floor(baro:get_external_temperature())

        if battery:num_instances() > 0 and battery:capacity_remaining_pct(0) ~= nil then
            hl2.battery = battery:capacity_remaining_pct(0)
        else
            hl2.battery = 0
        end
        
        -- just sending armed state here for simplicity. Flight mode is in the custom_mode field
        if arming:is_armed() then
            hl2.custom0 = 129 -- MAV_MODE_FLAG_SAFETY_ARMED + MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        else
            hl2.custom0 = 1 -- MAV_MODE_FLAG_CUSTOM_MODE_ENABLED
        end

        local newpkt = mavlink.createMAVLink(hl2, mavlink.HIGH_LATENCY2)
        gcs:send_text(3,
                      "Sent HL2 packet, size: " .. tostring(#newpkt) .. ", seq " ..
                          mavlink.getSeqID())

        for idx = 1, #newpkt do port:write(newpkt:byte(idx)) end

        time_last_tx = millis():tofloat() * 0.001

    end

    return HLSatcom, 100
end

return HLSatcom, 100




================================================
File: examples/MAVLink_Commands.lua
================================================
-- Example of receiving MAVLink commands

local mavlink_msgs = require("MAVLink/mavlink_msgs")

local COMMAND_ACK_ID = mavlink_msgs.get_msgid("COMMAND_ACK")
local COMMAND_LONG_ID = mavlink_msgs.get_msgid("COMMAND_LONG")

local msg_map = {}
msg_map[COMMAND_ACK_ID] = "COMMAND_ACK"
msg_map[COMMAND_LONG_ID] = "COMMAND_LONG"

-- initialize MAVLink rx with buffer depth and number of rx message IDs to register
mavlink:init(10, 1)

-- register message id to receive
mavlink:register_rx_msgid(COMMAND_LONG_ID)

local MAV_CMD_DO_SET_MODE = 176
local MAV_CMD_WAYPOINT_USER_1 = 31000

-- Block AP parsing user1 so we can deal with it in the script
-- Prevents "unsupported" ack
mavlink:block_command(MAV_CMD_WAYPOINT_USER_1)

function handle_command_long(cmd)
    if (cmd.command == MAV_CMD_DO_SET_MODE) then
        gcs:send_text(0, "Got mode change")

    elseif (cmd.command == MAV_CMD_WAYPOINT_USER_1) then
        -- return ack from command param value
        return math.min(math.max(math.floor(cmd.param1), 0), 5)
    end
    return nil
end

function update()
    local msg, chan = mavlink:receive_chan()
    if (msg ~= nil) then
        local parsed_msg = mavlink_msgs.decode(msg, msg_map)
        if (parsed_msg ~= nil) then

            local result
            if parsed_msg.msgid == COMMAND_LONG_ID then
                result = handle_command_long(parsed_msg)
            end

            if (result ~= nil) then
                -- Send ack if the command is one were intrested in
                local ack = {}
                ack.command = parsed_msg.command
                ack.result = result
                ack.progress = 0
                ack.result_param2 = 0
                ack.target_system = parsed_msg.sysid
                ack.target_component = parsed_msg.compid

                mavlink:send_chan(chan, mavlink_msgs.encode("COMMAND_ACK", ack))
            end
        end
    end

    return update, 1000
end

return update()



================================================
File: examples/Mission_test.lua
================================================
-- This script is a test for AP_Mission bindings

local last_mission_index = mission:get_current_nav_index()

function update() -- this is the loop which periodically runs

  -- check for scripting DO commands in the mission
  local time_ms, param1, param2, param3, param4 = mission_receive()
  if time_ms then
    gcs:send_text(0, string.format("Scripting CMD @ %u ms, %i, %0.2f, %0.2f, %0.2f", time_ms:tofloat(), param1, param2, param3, param4))
  end

  local mission_state = mission:state()

  -- make sure the mission is running
  if mission_state == mission.MISSION_COMPLETE then
    gcs:send_text(0, "LUA: Mission Complete")
    return update, 1000 -- reschedules the loop
  elseif mission_state == mission.MISSION_STOPPED then
    gcs:send_text(0, "LUA: Mission stopped")
    return update, 1000 -- reschedules the loop
  end

  local mission_index = mission:get_current_nav_index()

  -- see if we have changed since we last checked
  if mission_index ~= last_mission_index then

    gcs:send_text(0, "LUA: New Mission Item") -- we spotted a change

    -- print the current and previous nav commands
    gcs:send_text(0, string.format("Prev: %d, Current: %d",mission:get_prev_nav_cmd_id(),mission:get_current_nav_id()))

    last_mission_index = mission_index;

    -- num commands includes home so - 1
    local mission_length = mission:num_commands() - 1
    if mission_length > 1 and mission_index == mission_length then
      local jump_to = 1
      if mission_length > 2 then
        -- jump back to a random mission item
        jump_to = math.random(mission_length - 1)  -- no point jump to the end so - 1
      end
      if mission:set_current_cmd(jump_to) then
        gcs:send_text(0, string.format("LUA: jumped to mission item %d",jump_to))
      else
        gcs:send_text(0, "LUA: mission item jump failed")
      end
    end
  end

  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/MotorMatrix_dotriaconta_octaquad_x.lua
================================================
-- This script is an example setting up a custom motor matrix mix.  It
-- sets up a 32-motor frame, 4 clockwise-X coaxial octacopters stacked
-- one on top of the other.

local NUM_BANKS = 8

-- helper function duplication of the one found in AP_MotorsMatrix
local function add_motor(motor_num, angle_degrees, yaw_factor, testing_order)
   gcs:send_text(0, string.format("  Adding motor %u (ang=%f)", motor_num, angle_degrees))
   MotorsMatrix:add_motor_raw(
      motor_num,
      math.cos(math.rad(angle_degrees + 90)),
      math.cos(math.rad(angle_degrees)),
      yaw_factor,
      testing_order
   )
end

local fr_yaw_factor = 1  -- front-right yaw factor, switches per level
local motor_num = 0
for i = 1, NUM_BANKS do
   local base = (i-1)*4
   gcs:send_text(0, string.format("Setting up motor bank %u at %u", i, base))
   add_motor(motor_num,     45,  fr_yaw_factor, base+1)
   add_motor(motor_num+1, -135,  fr_yaw_factor, base+3)
   add_motor(motor_num+2,  -45, -fr_yaw_factor, base+4)
   add_motor(motor_num+3,  135, -fr_yaw_factor, base+2)
   fr_yaw_factor = -fr_yaw_factor
   motor_num = motor_num + 4
end

assert(MotorsMatrix:init(NUM_BANKS*4), "Failed to init MotorsMatrix")

motors:set_frame_string(string.format("Motors%u", NUM_BANKS*4))



================================================
File: examples/MotorMatrix_fault_tolerant_hex.lua
================================================
-- This script is an example setting up a custom motor matrix mix

-- this is the config for hexacopter with the motor rotations configured for improved fault tolerance
-- see: https://arxiv.org/pdf/1403.5986.pdf

-- duplicate the #defines from AP_Motors
local AP_MOTORS_MATRIX_YAW_FACTOR_CW = -1
local AP_MOTORS_MATRIX_YAW_FACTOR_CCW = 1

local AP_MOTORS_MOT_1 = 0
local AP_MOTORS_MOT_2 = 1
local AP_MOTORS_MOT_3 = 2
local AP_MOTORS_MOT_4 = 3
local AP_MOTORS_MOT_5 = 4
local AP_MOTORS_MOT_6 = 5

-- helper function duplication of the one found in AP_MotorsMatrix
local function add_motor(motor_num, angle_degrees, yaw_factor, testing_order)

    MotorsMatrix:add_motor_raw(motor_num,math.cos(math.rad(angle_degrees + 90)),
                                         math.cos(math.rad(angle_degrees)),
                                         yaw_factor,
                                         testing_order)

end

-- this duplicates the add motor format used in AP_Motors for ease of modification of existing mixes
add_motor(AP_MOTORS_MOT_1,  90, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  2)
add_motor(AP_MOTORS_MOT_2, -90, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 5)
add_motor(AP_MOTORS_MOT_3, -30, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 6)
add_motor(AP_MOTORS_MOT_4, 150, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 3)
add_motor(AP_MOTORS_MOT_5,  30, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  1)
add_motor(AP_MOTORS_MOT_6,-150, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  4)

assert(MotorsMatrix:init(6), "Failed to init MotorsMatrix")

motors:set_frame_string("fault tolerant hex")



================================================
File: examples/MotorMatrix_hexadeca_octa.lua
================================================
-- This script is an example setting up a custom motor matrix mix

-- duplicate the #defines from AP_Motors
local AP_MOTORS_MATRIX_YAW_FACTOR_CW = -1
local AP_MOTORS_MATRIX_YAW_FACTOR_CCW = 1

local AP_MOTORS_MOT_1 = 0
local AP_MOTORS_MOT_2 = 1
local AP_MOTORS_MOT_3 = 2
local AP_MOTORS_MOT_4 = 3
local AP_MOTORS_MOT_5 = 4
local AP_MOTORS_MOT_6 = 5
local AP_MOTORS_MOT_7 = 6
local AP_MOTORS_MOT_8 = 7
local AP_MOTORS_MOT_9 = 8
local AP_MOTORS_MOT_10 = 9
local AP_MOTORS_MOT_11 = 10
local AP_MOTORS_MOT_12 = 11
local AP_MOTORS_MOT_13 = 12
local AP_MOTORS_MOT_14 = 13
local AP_MOTORS_MOT_15 = 14
local AP_MOTORS_MOT_16 = 15

-- helper function duplication of the one found in AP_MotorsMatrix
local function add_motor(motor_num, angle_degrees, yaw_factor, testing_order)

    MotorsMatrix:add_motor_raw(motor_num,math.cos(math.rad(angle_degrees + 90)),
                                         math.cos(math.rad(angle_degrees)),
                                         yaw_factor,
                                         testing_order)

end

-- this duplicates the add motor format used in AP_Motors for ease of modification of existing mixes
add_motor(AP_MOTORS_MOT_1,     0, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   1)
add_motor(AP_MOTORS_MOT_2,     0, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  2)
add_motor(AP_MOTORS_MOT_3,    45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  3)
add_motor(AP_MOTORS_MOT_4,    45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   4)
add_motor(AP_MOTORS_MOT_5,    90, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   5)
add_motor(AP_MOTORS_MOT_6,    90, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  6)
add_motor(AP_MOTORS_MOT_7,   135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  7)
add_motor(AP_MOTORS_MOT_8,   135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   8)
add_motor(AP_MOTORS_MOT_9,   180, AP_MOTORS_MATRIX_YAW_FACTOR_CW,   9)
add_motor(AP_MOTORS_MOT_10,  180, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 10)
add_motor(AP_MOTORS_MOT_11, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 11)
add_motor(AP_MOTORS_MOT_12, -135, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  12)
add_motor(AP_MOTORS_MOT_13,  -90, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  13)
add_motor(AP_MOTORS_MOT_14,  -90, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 14)
add_motor(AP_MOTORS_MOT_15,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 15)
add_motor(AP_MOTORS_MOT_16,  -45, AP_MOTORS_MATRIX_YAW_FACTOR_CW,  16)

assert(MotorsMatrix:init(16), "Failed to init MotorsMatrix")

motors:set_frame_string("Hexadeca-Octa PLUS")



================================================
File: examples/MotorMatrix_hexadeca_octa_cw_x.lua
================================================
-- This script is an example setting up a custom motor matrix mix

-- duplicate the #defines from AP_Motors
local AP_MOTORS_MATRIX_YAW_FACTOR_CW = -1
local AP_MOTORS_MATRIX_YAW_FACTOR_CCW = 1

local AP_MOTORS_MOT_1 = 0
local AP_MOTORS_MOT_2 = 1
local AP_MOTORS_MOT_3 = 2
local AP_MOTORS_MOT_4 = 3
local AP_MOTORS_MOT_5 = 4
local AP_MOTORS_MOT_6 = 5
local AP_MOTORS_MOT_7 = 6
local AP_MOTORS_MOT_8 = 7
local AP_MOTORS_MOT_9 = 8
local AP_MOTORS_MOT_10 = 9
local AP_MOTORS_MOT_11 = 10
local AP_MOTORS_MOT_12 = 11
local AP_MOTORS_MOT_13 = 12
local AP_MOTORS_MOT_14 = 13
local AP_MOTORS_MOT_15 = 14
local AP_MOTORS_MOT_16 = 15

-- helper function duplication of the one found in AP_MotorsMatrix
local function add_motor(motor_num, angle_degrees, yaw_factor, testing_order)

    MotorsMatrix:add_motor_raw(motor_num,math.cos(math.rad(angle_degrees + 90)),
                                         math.cos(math.rad(angle_degrees)),
                                         yaw_factor,
                                         testing_order)

end

-- this duplicates the add motor format used in AP_Motors for ease of modification of existing mixes
add_motor(AP_MOTORS_MOT_1,    22.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,   1 )
add_motor(AP_MOTORS_MOT_2,    22.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  2 )
add_motor(AP_MOTORS_MOT_3,    67.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  3 )
add_motor(AP_MOTORS_MOT_4,    67.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,   4 )
add_motor(AP_MOTORS_MOT_5,   112.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,   5 )
add_motor(AP_MOTORS_MOT_6,   112.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  6 )
add_motor(AP_MOTORS_MOT_7,   157.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW,  7 )
add_motor(AP_MOTORS_MOT_8,   157.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,   8 )
add_motor(AP_MOTORS_MOT_9,  -157.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,   9 )
add_motor(AP_MOTORS_MOT_10, -157.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 10 )
add_motor(AP_MOTORS_MOT_11, -112.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 11 )
add_motor(AP_MOTORS_MOT_12, -112.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,  12 )
add_motor(AP_MOTORS_MOT_13,  -67.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,  13 )
add_motor(AP_MOTORS_MOT_14,  -67.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 14 )
add_motor(AP_MOTORS_MOT_15,  -22.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CCW, 15 )
add_motor(AP_MOTORS_MOT_16,  -22.5,  AP_MOTORS_MATRIX_YAW_FACTOR_CW,  16 )

assert(MotorsMatrix:init(16), "Failed to init MotorsMatrix")

motors:set_frame_string("Hexadeca-Octa X/CW_X")



================================================
File: examples/MotorMatrix_setup.lua
================================================
-- This script is an example setting up a custom motor matrix mix

-- duplicate the standard + Quad mix
MotorsMatrix:add_motor_raw(0,-1, 0, 1, 2)
MotorsMatrix:add_motor_raw(1, 1, 0, 1, 4)
MotorsMatrix:add_motor_raw(2, 0, 1,-1, 1)
MotorsMatrix:add_motor_raw(3, 0,-1,-1, 3)

assert(MotorsMatrix:init(4), "Failed to init MotorsMatrix")

motors:set_frame_string("scripting plus example")



================================================
File: examples/Motor_mixer_dynamic_setup.lua
================================================
-- This script is an example setting up a custom dynamic motor matrix
-- allowing a vehicle to change geometry in flight

-- this mixer is for a plus quad copter, the default SITL vehicle.
-- Setup motor number (zero indexed) and testing order (1 indexed)
Motors_dynamic:add_motor(0, 2)
Motors_dynamic:add_motor(1, 4)
Motors_dynamic:add_motor(2, 1)
Motors_dynamic:add_motor(3, 3)

factors = motor_factor_table()

-- Roll for motors 1 - 4
factors:roll(0, -0.5)
factors:roll(1,  0.5)
factors:roll(2,  0)
factors:roll(3,  0)

-- pitch for motors 1 -4
factors:pitch(0,  0)
factors:pitch(1,  0)
factors:pitch(2,  0.5)
factors:pitch(3, -0.5)

-- yaw for motors 1 -4
factors:yaw(0,  0.5)
factors:yaw(1,  0.5)
factors:yaw(2, -0.5)
factors:yaw(3, -0.5)

-- throttle for motors 1 -4
factors:throttle(0,  1)
factors:throttle(1,  1)
factors:throttle(2,  1)
factors:throttle(3,  1)

-- must load factors before init
Motors_dynamic:load_factors(factors)

-- were expecting 4 motors
assert(Motors_dynamic:init(4), "Failed to init Motors_dynamic")

-- at any time we can then re-load new factors
Motors_dynamic:load_factors(factors)

motors:set_frame_string("Dynamic example")

-- if doing changes in flight it is a good idea to use pcall to protect the script from crashing
-- see 'protected_call.lua' example



================================================
File: examples/Motors_6DoF.lua
================================================
-- This script loads the 6DoF mixer matrix for a 6 motor frame
-- https://youtu.be/QUDhnYvH66k

Motors_6DoF:add_motor(0,  0.003285,  0.470445,  0.031489,  0.885866,  0.563927,  0.031026, true, 1)
Motors_6DoF:add_motor(1, -0.373686, -0.267196,  0.092861,  0.789066, -0.223271,  0.495176, true, 2)
Motors_6DoF:add_motor(2,  0.370400, -0.203249, -0.053720,  0.841080, -0.340656, -0.526202, true, 3)
Motors_6DoF:add_motor(3, -0.146980, -0.216342, -0.338296,  0.001577,  0.900822, -0.460986, true, 4)
Motors_6DoF:add_motor(4, -0.205533, -0.035715,  0.359267, -0.048371,  0.010753, -1.013924, true, 5)
Motors_6DoF:add_motor(5,  0.143881, -0.227449,  0.375220, -0.046098,  0.811593,  0.431718, true, 6)

assert(Motors_6DoF:init(6),'unable to setup 6 motors')

motors:set_frame_string("6DoF example")




================================================
File: examples/NMEA-decode.lua
================================================
-- Script decodes, checks and prints NMEA messages

-- find the serial first (0) scripting serial port instance
local port = serial:find_serial(0)

if not port then
    gcs:send_text(0, "No Scripting Serial Port")
    return
end

-- begin the serial port
-- NMEA is usually 4800 or 9600
port:begin(4800)
port:set_flow_control(0)

-- table for strings used in decoding
local term = {}
local term_is_checksum = false
local term_number = 1
local checksum = 0
local string_complete = false

-- maximum number of terms we expect in the message
local max_terms = 15
-- maximum length of terms we expect
local max_term_length = 5

-- decode a basic NMEA string, only check the checksum
local function decode_NMEA(byte)
    local char = string.char(byte)
    if (char == ',' or char == '\r' or char == '\n' or char == '*') and not string_complete then
        if char == ',' then
            -- end of a term, but still counted for checksum
            checksum = checksum ~ byte
        end

        -- null terminate and decode latest term
        if term_is_checksum then
            -- test the checksum
            string_complete = true
            return checksum == tonumber(term[term_number],16)

        -- else -- we could further decode the message data here
        end

        if char == '*' then
            -- the next characters make up the checksum
            term_is_checksum = true
        end

        -- nothing in current term, add a space, makes the print work
        if not term[term_number] then
            term[term_number] = ' '
        end

        -- move onto next term
        term_number = term_number + 1

        return false
    end
    if char == '$' then
        -- sentence begin
        -- clear all flags, reset the term table and checksum
        term_is_checksum = false
        term_number = 1
        checksum = 0
        term = {}
        string_complete = false
        return false
    end
    
    -- ordinary characters are added to term
    -- if we have too many terms or they are too long then don't add to them
    if term_number < max_terms then
        if term[term_number] then
            if string.len(term[term_number]) < max_term_length then
                term[term_number] = term[term_number] .. char
            end
        else
            term[term_number] = char
        end
    end
    -- update the checksum
    if not term_is_checksum then
        -- checksum is bit wise xor of all characters in the string before the checksum
        checksum = checksum ~ byte
    end
    return false
end

-- the main update function that is used to read in data from serial port
function update()

    if not port then
        gcs:send_text(0, "no Scripting Serial Port")
        return update, 100
    end

    local n_bytes = port:available()
    while n_bytes > 0 do
        local byte = port:read()
        if decode_NMEA(byte) then
            -- we have got a full NMEA message that has passed the checksum
            -- concatenate back to full message and print
            -- don't print the checksum
            gcs:send_text(0, table.concat(term,",",1,#term-1))

        end
        n_bytes = n_bytes - 1
    end

    return update, 100
end

return update, 100



================================================
File: examples/OOP_example.lua
================================================
-- this is an example of how to do object oriented programming in Lua

function constrain(v, minv, maxv)
   -- constrain a value between two limits
   if v < minv then
      return minv
   end
   if v > maxv then
      return maxv
   end
   return v
end

--[[
 a PI controller with feed-forward implemented as a Lua object, using
 closure style object
--]]
local function PIFF(kFF,kP,kI,iMax)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = {}

   -- private fields as locals
   local _kFF = kFF
   local _kP = kP or 0.0
   local _kI = kI or 0.0
   local _iMax = iMax
   local _last_t = nil
   local _log_data = {}
   local _I = 0
   local _counter = 0

   -- update the controller.
   function self.update(target, current)
      local now = millis():tofloat() * 0.001
      if not _last_t then
         _last_t = now
      end
      local dt = now - _last_t
      _last_t = now
      local err = target - current
      _counter = _counter + 1

      local FF = _kFF * target
      local P = _kP * err
      _I = _I + _kI * err * dt
      if _iMax then
         _I = constrain(_I, -_iMax, _iMax)
      end
      local I = _I
      local ret = FF + P + I

      _log_data = { target, current, FF, P, I, ret }
      return ret
   end

   -- log the controller internals
   function self.log(name)
      logger:write(name,'Targ,Curr,FF,P,I,Total','ffffff',table.unpack(_log_data))
   end

   -- return the instance
   return self
end


--[[
 another example of a PIFF controller as an object, this time using
 metatables. Using metatables uses less memory and object creation is
 faster, but access to variables is slower
--]]
local PIFF2 = {}
PIFF2.__index = PIFF2

function PIFF2.new(kFF,kP,kI,iMax)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = setmetatable({},PIFF2)
   self.kFF = kFF
   self.kP = kP
   self.kI = kI
   self.iMax = iMax
   self.last_t = nil
   self.log_data = {}
   self.I = 0
   self.counter = 0
   return self
end

function PIFF2.update(self, target, current)
   local now = millis():tofloat() * 0.001
   if not self.last_t then
      self.last_t = now
   end
   local dt = now - self.last_t
   self.last_t = now
   local err = target - current
   self.counter = self.counter + 1
   local FF = self.kFF * target
   local P = self.kP * err
   self.I = self.I + self.kI * err * dt
   if self.iMax then
      self.I = constrain(self.I, -self.iMax, self.iMax)
   end
   local ret = FF + P + self.I

   self.log_data = { target, current, FF, P, self.I, ret }
   return ret
end

function PIFF2.log(self, name)
   logger:write(name,'Targ,Curr,FF,P,I,Total','ffffff',table.unpack(self.log_data))
end

--[[
 declare two PI controllers, using one of each style. Note the use of new() for the metatables style
--]]
local PI_elevator = PIFF(1.1, 0.0, 0.0, 20.0)
local PI_rudder   = PIFF2.new(1.1, 0.0, 0.0, 20.0)

function test()
  -- note the different syntax for the two varients
  elevator = PI_elevator.update(1.0, 0.5)
  rudder = PI_rudder:update(2.0, 0.7)

  PI_elevator.log("PEL")
  PI_rudder:log("PRD")

  gcs:send_text(0, "tick: " .. tostring(millis()))

  return test, 500
end

return test()



================================================
File: examples/RCIN_test.lua
================================================
-- example of getting RC input

local scripting_rc_1 = rc:find_channel_for_option(300)
local scripting_rc_2 = rc:find_channel_for_option(301)
local flip_flop = 0

function update()
  pwm1 = rc:get_pwm(1)
  pwm2 = rc:get_pwm(2)
  pwm3 = rc:get_pwm(3)
  pwm4 = rc:get_pwm(4)
  gcs:send_text(0, "RCIN 1:" .. tostring(pwm1) .. " 2:" .. tostring(pwm2).. " 3:" .. tostring(pwm3).. " 4:" .. tostring(pwm4))

  -- read normalized input from designated scripting RCx_OPTION
  if scripting_rc_1 then
    gcs:send_text(0, "Scripting in 1:" .. tostring(scripting_rc_1:norm_input()))
  end

  -- read switch input from second designated scripting RCx_OPTION
  if scripting_rc_2 then
    local sw_pos = scripting_rc_2:get_aux_switch_pos()
    if sw_pos == 0 then 
      gcs:send_text(0, "Scripting switch is low")
    elseif sw_pos == 1 then
      gcs:send_text(0, "Scripting switch is middle")
    else
      gcs:send_text(0, "Scripting switch is high")
    end
  end

  -- we can also call functions that are available to RC switches
  -- 28 is Relay one
  rc:run_aux_function(28, flip_flop)

  if (flip_flop == 0) then
    flip_flop = 2 -- switch high
  else
    flip_flop = 0 -- switch low
  end


  return update, 1000 -- reschedules the loop
end

return update()



================================================
File: examples/RC_override.lua
================================================
-- example of overriding RC inputs

---@diagnostic disable: need-check-nil
---@diagnostic disable: param-type-mismatch

local RC4 = rc:get_channel(4)

function update()
   -- mirror RC1 onto RC4
   rc1_input = rc:get_pwm(1)
   RC4:set_override(rc1_input)
   return update, 10
end

gcs:send_text(0, "RC_override example")

return update()



================================================
File: examples/RM3100_self_test.lua
================================================
-- Runs the Built-In Self Test on the RM3100 LR circuits
-- Note COMPASS_DISBLMSK should have the 16th bit set to 1 (RM3100)

-- Init RM3100 on bus 0
local rm3100 = i2c:get_device(0, 0x20)
assert(rm3100 ~= nil, "i2c get_device error, cannot run RM3100 self test")

-- Queues a Built-In Self Test
function queue_test()
    gcs:send_text(1, "Running RM3100 self test")

    -- Queue a self test by setting BIST register
    local ret = rm3100:transfer("\x33\x8F", 0)
    if ret == nil then
        gcs:send_text(1, "Rm3100 BIST transfer failed")
        return queue_test, 1000
    end

    -- Send a POLL request to run a BIST
    ret = rm3100:transfer("\x00\x70", 0)
    if ret == nil then
        gcs:send_text(1, "Rm3100 POLL transfer failed")
        return queue_test, 1000
    end

    -- As a measurement takes time, delay a bit by scheduling a different function
    return read_test, 1000
end


-- Reads back values from a Built-In Self Test
function read_test()
    -- Read the BIST results
    local results_str = rm3100:transfer("\x33", 1)
    if results_str ~= nil then
        local results = results_str:byte()

        if results & (1 << 4) == 0 then
            gcs:send_text(1, "RM3100 X is unhealthy")
        else
            gcs:send_text(1, "RM3100 X is OK")
        end

        if results & (1 << 5) == 0 then
            gcs:send_text(1, "RM3100 Y is unhealthy")
        else
            gcs:send_text(1, "RM3100 Y is OK")
        end

        if results & (1 << 6) == 0 then
            gcs:send_text(1, "RM3100 Z is unhealthy")
        else
            gcs:send_text(1, "RM3100 Z is OK")
        end
    else
        gcs:send_text(1, "Rm3100 BIST read transfer failed")
        return queue_test, 1000
    end

    -- Reset the BIST register
    local ret = rm3100:transfer("\x33\x0F", 0)
    if ret == nil then
        gcs:send_text(1, "Rm3100 BIST reset transfer failed")
        return queue_test, 1000
    end

    -- Send a POLL request to take a data point
    ret = rm3100:transfer("\x00\x70", 0)
    if ret == nil then
        gcs:send_text(1, "Rm3100 POLL data transfer failed")
        return queue_test, 1000
    end

    -- As a measurement takes time, delay a bit by scheduling a different function
    return read_data, 1000
end

-- Reads data from the RM3100
function read_data()
    -- Check that data is ready for a read
    local status_str = rm3100:transfer("\x34", 1)
    if status_str ~= nil then
        local status = status_str:byte()
        if status & (1 << 7) == 0 then
            gcs:send_text(1, "RM3100 data not ready for reading")
            return queue_test, 1000
        end
    else
        gcs:send_text(1, "Rm3100 BIST status reg transfer failed")
        return queue_test, 1000
    end

    -- Read measured values
    local measurements_str = rm3100:transfer("\x24", 9)
    if measurements_str ~= nil then
        local MX, MY, MZ = string.unpack(">i3>i3>i3", measurements_str)
        gcs:send_text(6, string.format("RM3100 Mag: X=%8d Y=%8d Z=%8d", MX, MY, MZ))
    else
        gcs:send_text(1, "Rm3100 data read transfer failed")
        return queue_test, 1000
    end

    -- Loop back to the first function to run another set of tests
    return queue_test, 1000
end

return queue_test, 1000



================================================
File: examples/SN-GCJA5-particle-sensor.lua
================================================
--[[
    This script reads a SN-GCJA5 panasonic particle sensor on i2c
    reading will be saved to data flash logs, CSV file and streamed as named value floats

    Development of this script was sponsored by Cubepilot

    the code is heavily based on the SparkFun arduino library
    https://github.com/sparkfun/SparkFun_Particle_Sensor_SN-GCJA5_Arduino_Library
]]--

---@diagnostic disable: need-check-nil
---@diagnostic disable: undefined-global

-- search for a index without a file, this stops us overwriting from a previous run
local index = 0
local file_name
while true do
  file_name = string.format('Particle %i.csv',index)
  local file = io.open(file_name)
  if file == nil then
    break
  end
  local first_line = file:read(1) -- try and read the first character
  io.close(file)
  if first_line == nil then
    break
  end
  index = index + 1
end

-- open file and make header
file = assert(io.open(file_name, 'w'), 'Could not make file :' .. file_name)
file:write('Lattitude (°), Longitude (°), Absolute Altitude (m), PM 1.0, PM 2.5, PM 10, count 0.5, count 1, count 2.5, count 5, count 7.5, count 10\n')
file:close()

-- load the i2c driver, bus 0
local sensor = i2c:get_device(0,0x33)
sensor:set_retries(10)

-- register names
local SNGCJA5_PM1_0 = 0x00
local SNGCJA5_PM2_5 = 0x04
local SNGCJA5_PM10 = 0x08
local SNGCJA5_PCOUNT_0_5 = 0x0C
local SNGCJA5_PCOUNT_1_0 = 0x0E
local SNGCJA5_PCOUNT_2_5 = 0x10
local SNGCJA5_PCOUNT_5_0 = 0x14
local SNGCJA5_PCOUNT_7_5 = 0x16
local SNGCJA5_PCOUNT_10 = 0x18
local SNGCJA5_STATE = 0x26

-- Reads two consecutive bytes from a given location
local function readRegister16(addr)
  local lsb = sensor:read_registers(addr+0)
  local msb = sensor:read_registers(addr+1)
  if lsb and msb then
    return msb << 8 | lsb
  end
end

-- Reads four consecutive bytes from a given location
local function readRegister32(addr)
  local ll = sensor:read_registers(addr+0)
  local lh = sensor:read_registers(addr+1)
  local hl = sensor:read_registers(addr+2)
  local hh = sensor:read_registers(addr+3)
  if ll and lh and hl and hh then
    return (hh << 24) | (hl << 16) | (lh << 8) | (ll << 0)
  end
end

local function getPM(pmRegister)
  local count = readRegister32(pmRegister)
  if count then
    return count / 1000.0
  end
end

function update() -- this is the loop which periodically runs

  -- read status
  local state = sensor:read_registers(SNGCJA5_STATE)
  if not state then
    gcs:send_text(0, "Failed to read particle sensor state")
    return update, 10000
  end

  local Sensors = (state >> 6) & 3
  local PD =  (state >> 4) & 3
  local LD =  (state >> 2) & 3
  local Fan = (state >> 0) & 3

  -- report sensor errors
  if Sensors ~= 0 then
    if Sensors == 1 then
      gcs:send_text(0, "particle sensor: One sensor or fan abnormal")
    elseif Sensors == 2 then
      gcs:send_text(0, "particle sensor: Two sensors or fan abnormal")
    else
      gcs:send_text(0, "particle sensor: Both sensors and fan abnormal")
    end
    return update, 10000
  end

  -- report photo diode errors
  if PD ~= 0 then
    if statusPD == 1 then
      gcs:send_text(0, "particle sensor: Photo diode: Normal w/ software correction")
    elseif statusPD == 2 then
      gcs:send_text(0, "particle sensor: Photo diode: Abnormal, loss of function")
    else
      gcs:send_text(0, "particle sensor: Photo diode: Abnormal, with software correction")
    end
    return update, 10000
  end

  -- report laser diode errors
  if LD ~= 0 then
    if LD == 1 then
      gcs:send_text(0, "particle sensor: Laser diode: Normal w/ software correction")
    elseif LD == 2 then
      gcs:send_text(0, "particle sensor: Laser diode: Abnormal, loss of function")
    else
      gcs:send_text(0, "particle sensor: Laser diode: Abnormal, with software correction")
    end
    return update, 10000
  end

  -- report fan errors
  if Fan ~= 0 then
    if Fan == 1 then
      gcs:send_text(0, "particle sensor: Fan: Normal w/ software correction")
    elseif Fan == 2 then
      gcs:send_text(0, "particle sensor: Fan: In calibration")
    else
      gcs:send_text(0, "particle sensor: Fan: Abnormal, out of control")
    end
    return update, 10000
  end

  -- read mass density
  local PM1_0 = getPM(SNGCJA5_PM1_0)
  local PM2_5 = getPM(SNGCJA5_PM2_5)
  local PM10  = getPM(SNGCJA5_PM10)

  if (not PM1_0) or (not PM2_5) or (not PM10) then
    gcs:send_text(0, "Failed to read particle sensor mass density")
    return update, 10000
  end

  -- read particle counts
  local PC0_5 = readRegister16(SNGCJA5_PCOUNT_0_5)
  local PC1_0 = readRegister16(SNGCJA5_PCOUNT_1_0)
  local PC2_5 = readRegister16(SNGCJA5_PCOUNT_2_5)
  local PC5_0 = readRegister16(SNGCJA5_PCOUNT_5_0)
  local PC7_5 = readRegister16(SNGCJA5_PCOUNT_7_5)
  local PC10  = readRegister16(SNGCJA5_PCOUNT_10)

  if (not PC0_5) or (not PC1_0) or (not PC2_5) or (not PC5_0) or (not PC7_5) or (not PC10) then
    gcs:send_text(0, "Failed to read particle sensor counts")
    return update, 10000
  end

  local lat = 0
  local lng = 0
  local alt = 0

  -- try and get true position, but don't fail for no GPS lock
  local position = ahrs:get_location()
  if position then
    lat = position:lat()*10^-7
    lng = position:lng()*10^-7
    alt = position:alt()*0.01
  end

  -- write to csv
  file = io.open(file_name, 'a')
  file:write(string.format('%0.8f, %0.8f, %0.2f, %0.4f, %0.4f, %0.4f, %i, %i, %i, %i, %i, %i\n',lat,lng,alt,PM1_0,PM2_5,PM10,PC0_5,PC1_0,PC2_5,PC5_0,PC7_5,PC10))
  file:close()

  -- save to data flash
  logger:write('PART','PM1,PM2.5,PM10,Cnt0.5,Cnt1,Cnt2.5,Cnt5,Cnt7.5,Cnt10','fffffffff',PM1_0,PM2_5,PM10,PC0_5,PC1_0,PC2_5,PC5_0,PC7_5,PC10)

  -- send to GCS
  gcs:send_named_float('PM 1.0',PM1_0)
  gcs:send_named_float('PM 2.5',PM2_5)
  gcs:send_named_float('PM 10',PM10)

  gcs:send_named_float('count 0.5',PC0_5)
  gcs:send_named_float('count 1,',PC1_0)
  gcs:send_named_float('count 2.5,',PC2_5)
  gcs:send_named_float('count 5,',PC5_0)
  gcs:send_named_float('count 7.5,',PC7_5)
  gcs:send_named_float('count 10,',PC10)

  return update, 1000 -- reschedules the loop, 1hz
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/Safety_States.lua
================================================
-- This Script is a example of the safety states avalalbe to lua

local last_armed
local last_motors_armed
local last_E_stop
local last_safe
function update()

  local armed = arming:is_armed()
  if armed ~= last_armed then
    gcs:send_text(0, 'Vehicle armed: ' .. tostring(armed))
  end
  last_armed = armed

  local motors_armed = motors:get_interlock()
  if motors_armed ~= last_motors_armed then
    gcs:send_text(0, 'Motors armed: ' .. tostring(motors_armed))
  end
  last_motors_armed = motors_armed

  local E_stop = SRV_Channels:get_emergency_stop()
  if E_stop ~= last_E_stop then
    gcs:send_text(0, 'E-Stop active: ' .. tostring(E_stop))
  end
  last_E_stop = E_stop

  local safe = SRV_Channels:get_safety_state()
  if safe ~= last_safe then
    gcs:send_text(0, 'Safe state: ' .. tostring(safe))
  end
  last_safe = safe

  return update, 100
end

return update()



================================================
File: examples/Serial_Dump.lua
================================================
-- this script reads data from a serial port and dumps it to a file

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil
---@diagnostic disable: cast-local-type

local file_name = 'raw serial dump.txt'
local file_name_plain = 'serial dump.txt'
local baud_rate = 9600

-- find the serial first (0) scripting serial port instance
-- SERIALx_PROTOCOL 28
local port = assert(serial:find_serial(0),"Could not find Scripting Serial Port")

-- make a file
local file = assert(io.open(file_name, "w"),"Could not create file " .. file_name)
file:close()
file = assert(io.open(file_name_plain, "w"),"Could not create file " .. file_name)
file:close()

-- begin the serial port
port:begin(baud_rate)
port:set_flow_control(0)

function update() -- this is the loop which periodically runs

  local n_bytes = port:available()
  while n_bytes > 0 do
    -- only read a max of 515 bytes in a go
    -- this limits memory consumption
    local buffer = {} -- table to buffer data
    local bytes_target = n_bytes - math.min(n_bytes, 512)
    while n_bytes > bytes_target do
      table.insert(buffer,port:read())
      n_bytes = n_bytes - 1
    end

    -- write as decoded
    file = io.open(file_name, "a")
    file:write(table.concat(buffer,',') .. '\n')
    file:close()

    -- write as plain text
    file = io.open(file_name_plain, "a")
    file:write(string.char(table.unpack(buffer)))
    file:close()

  end

  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/UART_log.lua
================================================
-- Reads data in from UART and logs to dataflash

-- find the serial first (0) scripting serial port instance
local port = serial:find_serial(0)

if not port then
    gcs:send_text(0, "No Scripting Serial Port")
    return
end

-- begin the serial port
port:begin(9600)
port:set_flow_control(0)

-- table for strings used in decoding
local log_data = {}
local term_number = 1
local valid = true
local term

-- number of terms we expect in the message
local num_terms = 3
-- maximum length of terms each term we expect
local max_length = 20

-- decode a basic string
local function decode(byte)
    local char = string.char(byte)
    if char == '\r' or char == '\n' or char == ',' then

        -- decode the term, note this assumes it is a number
        log_data[term_number] = tonumber(term)
        if not log_data[term_number] then
            -- could not convert to a number, discard this message
            valid = false
        end
        term = nil

        -- not got to the end yet
        if char == ',' then
            -- move onto next term
            if term_number < num_terms then
                term_number = term_number + 1
            end
            return false
        end

        -- make sure we have the correct number of terms
        if #log_data ~= num_terms then
            valid = false
        end

        if not valid then
            log_data = {}
        end

        -- reset for the next message
        local is_valid = valid
        term_number = 1
        valid = true

        return is_valid
    end

    -- ordinary characters are added to term
    -- if we have too many terms or they are too long then don't add to them
    if term_number <= num_terms then
        if term then
            if string.len(term) < max_length then
                term = term .. char
            else
                valid = false
            end
        else
            term = char
        end
    else
        valid = false
    end

    return false
end

-- the main update function that is used to read in data from serial port
function update()

    if not port then
        gcs:send_text(0, "no Scripting Serial Port")
        return update, 100
    end

    local n_bytes = port:available()
    while n_bytes > 0 do
        local byte = port:read()
        if decode(byte) then
            -- we have got a full line
            -- save to data flash

            -- care must be taken when selecting a name, must be less than four characters and not clash with an existing log type
            -- format characters specify the type of variable to be logged, see AP_Logger/README.md
            -- not all format types are supported by scripting only: i, L, e, f, n, M, B, I, E, N, and Z
            -- Note that Lua automatically adds a timestamp in micro seconds
            logger:write('SCR','Sensor1,Sensor2,Sensor3','fff',table.unpack(log_data))

            -- reset for the next message
            log_data = {}
        end
        n_bytes = n_bytes - 1
    end

    return update, 100
end

return update, 100



================================================
File: examples/active_source_set.lua
================================================

--returns active source set used by EKF3
-- can be used for infering the current source set in use without RC for autonomous source switching

function update() -- this is the loop which periodically runs

  gcs:send_text(0, string.format("current source  set in use :%d", ahrs:get_posvelyaw_source_set()))

  return update, 1000 -- 1000ms reschedules the loop (1Hz)
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/ahrs-print-angle-and-rates.lua
================================================
-- This script displays the vehicle lean angles and rotation rates at 1hz

function update() -- this is the loop which periodically runs
  roll = math.deg(ahrs:get_roll_rad())
  pitch = math.deg(ahrs:get_pitch_rad())
  yaw = math.deg(ahrs:get_yaw_rad())
  rates = ahrs:get_gyro()
  if rates then
    roll_rate = math.deg(rates:x())
    pitch_rate = math.deg(rates:y())
    yaw_rate = math.deg(rates:z())
  else
    roll_rate = 0
    pitch_rate = 0
    yaw_rate = 0
  end
  gcs:send_text(0, string.format("Ang R:%.1f P:%.1f Y:%.1f Rate R:%.1f P:%.1f Y:%.1f", roll, pitch, yaw, roll_rate, pitch_rate, yaw_rate))
  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/ahrs-print-home-and-origin.lua
================================================
-- example script for using "get_origin()"
-- prints the home and ekf origin lat long and altitude to the console every 5 seconds

function update ()

    home = ahrs:get_home()
    origin = ahrs:get_origin()

    if home then
        gcs:send_text(0, string.format("Home - Lat:%.1f Long:%.1f Alt:%.1f", home:lat(), home:lng(), home:alt()))
    end

    if origin then
        gcs:send_text(0, string.format("Origin - Lat:%.1f Long:%.1f Alt:%.1f", origin:lat(), origin:lng(), origin:alt()))
    end

    return update, 5000

end

return update()


================================================
File: examples/ahrs-print-variances.lua
================================================
-- This script displays the ahrs variances at 1hz
-- get_variances provides the innovations normalised using the innovation variance
-- a value of 0 indicates perfect consistency between the measurement and the EKF solution
-- a value of 1 is the maximum inconsistency that will be accepted by the filter
-- nil is returned for all arguments if variances are not available

function update() -- this is the loop which periodically runs)
  vel_variance, pos_variance, height_variance, mag_variance, airspeed_variance = ahrs:get_variances()
  if vel_variance then
    gcs:send_text(0, string.format("Variances Pos:%.1f Vel:%.1f Hgt:%.1f Mag:%.1f", pos_variance, vel_variance, height_variance, mag_variance:length()))
  else
    gcs:send_text(0, string.format("Failed to retrieve variances"))
  end
  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/ahrs-set-home-to-vehicle-location.lua
================================================
-- example script for using "set_home()"
-- sets the home location to the current vehicle location every 5 seconds

---@diagnostic disable: param-type-mismatch

function update ()

    if ahrs:home_is_set() then
        ahrs:set_home(ahrs:get_location())
        gcs:send_text(0, "Home position reset")
    end

    return update, 5000

end

return update()


================================================
File: examples/ahrs-source-gps-optflow.lua
================================================
-- switches between AHRS/EKF sources based on the pilot's source selection switch or using an automatic source selection algorithm
-- this script is intended to help vehicles automatically switch between GPS and optical flow
--
-- configure a forward or downward facing lidar with a range of at least 5m
-- setup RCx_OPTION = 90 (EKF Source Set) to select the source (low=GPS, middle=opticalflow, high=Not Used)
-- setup RCx_OPTION = 300 (Scripting1).  When this switch is pulled high, the source will be automatically selected
-- SCR_ENABLE = 1 (enable scripting)
-- setup EK3_SRCn_ parameters so that GPS is the primary source, opticalflow is secondary.
--     EK3_SRC1_POSXY = 3 (GPS)
--     EK3_SRC1_VELXY = 3 (GPS)
--     EK3_SRC1_VELZ  = 3 (GPS)
--     EK3_SRC1_POSZ  = 1 (Baro)
--     EK3_SRC1_YAW   = 1 (Compass)
--     EK3_SRC2_POSXY = 0 (None)
--     EK3_SRC2_VELXY = 5 (OpticalFlow)
--     EK3_SRC2_VELZ  = 0 (None)
--     EK3_SRC2_POSZ  = 1 (Baro)
--     EK3_SRC2_YAW   = 1 (Compass)
--     EK3_SRC_OPTIONS    = 0 (Do not fuse all velocities)
--
-- SCR_USER1 holds the threshold (in meters) for rangefinder altitude (around 15 is a good choice)
--     if rangefinder distance >= SCR_USER1, source1 (GPS) will be used
--     if rangefinder distance < SCR_USER1, source2 (optical flow) will be used if innovations are below SRC_USER3 value
-- SCR_USER2 holds the threshold for GPS speed accuracy (around 0.3 is a good choice)
-- SCR_USER3 holds the threshold for optical flow quality (about 50 is a good choice)
-- SCR_USER4 holds the threshold for optical flow innovations (about 0.15 is a good choice)
--
-- When the 2nd auxiliary switch (300/Scripting1) is pulled high automatic source selection uses these thresholds:
---@diagnostic disable: need-check-nil

local rangefinder_rotation = 25     -- check downward (25) facing lidar
local source_prev = 0               -- previous source, defaults to primary source
local sw_auto_pos_prev = -1         -- previous auto source switch position
local auto_switch = false           -- true when auto switching between sources is active
local gps_usable_accuracy = 1.0     -- GPS is usable if speed accuracy is at or below this value
local vote_counter_max = 20         -- when a vote counter reaches this number (i.e. 2sec) source may be switched
local gps_vs_opticalflow_vote = 0   -- vote counter for GPS vs optical (-20 = GPS, +20 = optical flow)

-- initialise parameters
local scr_user1_param = Parameter('SCR_USER1') -- user1 param (rangefinder altitude threshold)
local scr_user2_param = Parameter('SCR_USER2') -- user2 param (GPS speed accuracy threshold)
local scr_user3_param = Parameter('SCR_USER3') -- user3 param (optical flow quality threshold)
local scr_user4_param = Parameter('SCR_USER4') -- user4 param (optical flow innovation threshold)

assert(optical_flow, 'could not access optical flow')

-- play tune on buzzer to alert user to change in active source set
function play_source_tune(source)
  if (source) then
    if (source == 0) then
      notify:play_tune("L8C")       -- one long lower tone
    elseif (source == 1) then
      notify:play_tune("L12DD")     -- two fast medium tones
    elseif (source == 2) then
      notify:play_tune("L16FFF")    -- three very fast, high tones
    end
  end
end

-- the main update function
function update()

  -- check switches are configured
  -- at least one switch must be set
  -- source selection from RCx_FUNCTION = 90 (EKF Source Select)
  -- auto source from RCx_FUNCTION = 300 (Scripting1)
  local rc_function_source = rc:find_channel_for_option(90)
  local rc_function_auto = rc:find_channel_for_option(300)
  if not rc_function_source and not rc_function_auto then
    gcs:send_text(0, "ahrs-source-gps-optflow.lua: RCx_FUNCTION=90 or 300 not set!")
    return update, 1000
  end

  -- check rangefinder distance threshold has been set
  local rangefinder_thresh_dist = scr_user1_param:get()     -- SCR_USER1 holds rangefinder threshold
  if (rangefinder_thresh_dist <= 0) then
    gcs:send_text(0, "ahrs-source-gps-optflow.lua: set SCR_USER1 to rangefinder threshold")
    return update, 1000
  end

  -- check GPS speed accuracy threshold has been set
  local gps_speedaccuracy_thresh = scr_user2_param:get()    -- SCR_USER2 holds GPS speed accuracy threshold
  if (gps_speedaccuracy_thresh <= 0) then
    gcs:send_text(0, "ahrs-source-gps-optflow.lua: set SCR_USER2 to GPS speed accuracy threshold")
    return update, 1000
  end

  -- check optical flow quality threshold has been set
  local opticalflow_quality_thresh = scr_user3_param:get()  -- SCR_USER3 holds opticalflow quality
  if (opticalflow_quality_thresh <= 0) then
    gcs:send_text(0, "ahrs-source-gps-optflow.lua: set SCR_USER3 to OpticalFlow quality threshold")
    return update, 1000
  end

  -- check optical flow innovation threshold has been set
  local opticalflow_innov_thresh = scr_user4_param:get()    -- SCR_USER4 holds opticalflow innovation
  if (opticalflow_innov_thresh <= 0) then
    gcs:send_text(0, "ahrs-source-gps-optflow.lua: set SCR_USER4 to OpticalFlow innovation threshold")
    return update, 1000
  end

  -- check if GPS speed accuracy is over threshold
  local gps_speed_accuracy = gps:speed_accuracy(gps:primary_sensor())
  local gps_over_threshold = (gps_speed_accuracy == nil) or (gps:speed_accuracy(gps:primary_sensor()) > gps_speedaccuracy_thresh)
  local gps_usable = (gps_speed_accuracy ~= nil) and (gps_speed_accuracy <= gps_usable_accuracy)

  -- check optical flow quality
  local opticalflow_quality_good = false
  if (optical_flow) then
    opticalflow_quality_good = (optical_flow:enabled() and optical_flow:healthy() and optical_flow:quality() >= opticalflow_quality_thresh)
  end

  -- get opticalflow innovations from ahrs (only x and y values are valid)
  local opticalflow_over_threshold = true
  local opticalflow_innov = ahrs:get_vel_innovations_and_variances_for_source(5)
  if (opticalflow_innov) then
    local opticalflow_xy_innov = math.sqrt(opticalflow_innov:x() * opticalflow_innov:x() + opticalflow_innov:y() * opticalflow_innov:y())
    opticalflow_over_threshold = (opticalflow_xy_innov == 0.0) or (opticalflow_xy_innov > opticalflow_innov_thresh)
  end

  -- get rangefinder distance
  local rngfnd_distance_m = 0
  if rangefinder:has_data_orient(rangefinder_rotation) then
    rngfnd_distance_m = rangefinder:distance_orient(rangefinder_rotation)
  end
  local rngfnd_over_threshold = (rngfnd_distance_m == 0) or (rngfnd_distance_m > rangefinder_thresh_dist)

  -- opticalflow is usable if quality and innovations are good and rangefinder is in range
  local opticalflow_usable = opticalflow_quality_good and (not opticalflow_over_threshold) and (not rngfnd_over_threshold)

  -- automatic selection logic --

  -- GPS vs opticalflow vote. "-1" to move towards GPS, "+1" to move to Non-GPS
  if (not gps_over_threshold) or (gps_usable and not opticalflow_usable) then
    -- vote for GPS if GPS accuracy good OR GPS is usable and opticalflow is unusable
    gps_vs_opticalflow_vote = math.max(gps_vs_opticalflow_vote - 1, -vote_counter_max)
  elseif opticalflow_usable then
    -- vote for opticalflow if usable
    gps_vs_opticalflow_vote = math.min(gps_vs_opticalflow_vote + 1, vote_counter_max)
  end

  -- auto source vote collation
  local auto_source = -1                         -- auto source undecided if -1
  if gps_vs_opticalflow_vote <= -vote_counter_max then
    auto_source = 0                              -- GPS
  elseif gps_vs_opticalflow_vote >= vote_counter_max then
    auto_source = 1                              -- opticalflow
  end

  -- read source switch position from RCx_FUNCTION = 90 (EKF Source Select)
  local sw_source_pos = rc_function_source:get_aux_switch_pos()
  if sw_source_pos ~= sw_source_pos_prev then    -- check for changes in source switch position
    sw_source_pos_prev = sw_source_pos           -- record new switch position so we can detect changes
    auto_switch = false                          -- disable auto switching of source
    if source_prev ~= sw_source_pos then         -- check if switch position does not match source (there is a one-to-one mapping of switch to source)
      source_prev = sw_source_pos                -- record what source should now be (changed by ArduPilot vehicle code)
      gcs:send_text(0, "Pilot switched to Source " .. string.format("%d", source_prev+1))
    else
      gcs:send_text(0, "Pilot switched but already Source " .. string.format("%d", source_prev+1))
    end
    play_source_tune(source_prev)                -- alert user of source whether changed or not
  end

  -- if auto switch exists then read auto source switch position from RCx_FUNCTION = 300 (Scripting1)
  if rc_function_auto then
    local sw_auto_pos = rc_function_auto:get_aux_switch_pos()
    if sw_auto_pos ~= sw_auto_pos_prev  then       -- check for changes in source auto switch position
      sw_auto_pos_prev = sw_auto_pos               -- record new switch position so we can detect changes
      if sw_auto_pos == 0 then                     -- pilot has pulled switch low
        auto_switch = false                        -- disable auto switching of source
        if sw_source_pos ~= source_prev then       -- check if source will change
          source_prev = sw_source_pos              -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source disabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source disabled, already Source " .. string.format("%d", source_prev+1))
        end
      elseif sw_auto_pos == 2 then                 -- pilot has pulled switch high
        auto_switch = true                         -- enable auto switching of source
        if auto_source < 0 then
          gcs:send_text(0, "Auto source enabled, undecided, Source " .. string.format("%d", source_prev+1))
        elseif auto_source ~= source_prev then     -- check if source will change
          source_prev = auto_source                -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source enabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source enabled, already Source " .. string.format("%d", source_prev+1))
        end
      end
      play_source_tune(source_prev)
    end
  end

  -- auto switching
  if auto_switch and (auto_source >= 0) and (auto_source ~= source_prev) then
    source_prev = auto_source                  -- record selected source
    ahrs:set_posvelyaw_source_set(source_prev)     -- switch to pilot's selected source
    gcs:send_text(0, "Auto switched to Source " .. string.format("%d", source_prev+1))
    play_source_tune(source_prev)
  end

  return update, 100
end

return update()



================================================
File: examples/ahrs-source-gps-wheelencoders.lua
================================================
-- This script helps vehicles move between GPS and Non-GPS environments using GPS and Wheel Encoders
--
-- setup RCx_OPTION = 90 (EKF Source Set) to select the source (low=primary, middle=secondary, high=tertiary)
-- setup RCx_OPTION = 300 (Scripting1).  When this switch is pulled high, the source will be automatically selected
-- setup EK3_SRCn_ parameters so that GPS is the primary source, WheelEncoders are the secondary
--
-- When the auxiliary switch (ZigZag Auto) is pulled high automatic source selection uses these thresholds:
-- SCR_USER2 holds the threshold for GPS speed accuracy (around 0.3 is a good choice)
-- SCR_USER3 holds the threshold for GPS innovations (around 0.3 is a good choice)
--     if GPS speed accuracy <= SCR_USER2 and GPS innovations <= SRC_USER3 then the GPS (primary source set) will be used
--     otherwise wheel encoders (secondary source set) will be used
---@diagnostic disable: need-check-nil

local source_prev = 0               -- previous source, defaults to primary source
local sw_auto_pos_prev = -1         -- previous auto source switch position
local auto_switch = false           -- true when auto switching between sources is active
local vote_counter_max = 20         -- when a vote counter reaches this number (i.e. 2sec) source may be switched
local gps_vs_nongps_vote = 0        -- vote counter for GPS vs NonGPS (-20 = GPS, +20 = NonGPS)

-- play tune on buzzer to alert user to change in active source set
function play_source_tune(source)
  if (source) then
    if (source == 0) then
      notify:play_tune("L8C")       -- one long lower tone
    elseif (source == 1) then
      notify:play_tune("L12DD")     -- two fast medium tones
    elseif (source == 2) then
      notify:play_tune("L16FFF")    -- three very fast, high tones
    end
  end
end

-- the main update function
function update()

  -- check switches are configured
  -- at least one switch must be set
  -- source selection from RCx_FUNCTION = 90 (EKF Source Select)
  -- auto source from RCx_FUNCTION = 300 (Scripting1)
  local rc_function_source = rc:find_channel_for_option(90)
  local rc_function_auto = rc:find_channel_for_option(300)
  if (rc_function_source == nil) and (rc_function_auto == nil) then
    gcs:send_text(0, "ahrs-source-gps-wheelencoders.lua: RCx_FUNCTION=90 or 300 not set!")
    return update, 1000
  end

  -- check GPS speed accuracy threshold has been set
  local gps_speedaccuracy_thresh = param:get('SCR_USER2')  -- SCR_USER2 holds GPS speed accuracy threshold
  if (gps_speedaccuracy_thresh == nil) or (gps_speedaccuracy_thresh <= 0) then
    gcs:send_text(0, "ahrs-source-gps-wheelencoders.lua: set SCR_USER2 to GPS speed accuracy threshold")
    return update, 1000
  end

  -- check GPS innovation threshold has been set
  local gps_innov_thresh = param:get('SCR_USER3')  -- SCR_USER3 holds GPS velocity innovation
  if (gps_innov_thresh == nil) or (gps_innov_thresh <= 0) then
    gcs:send_text(0, "ahrs-source-gps-wheelencoders.lua: set SCR_USER3 to GPS innovation threshold")
    return update, 1000
  end

  -- check if GPS speed accuracy is over threshold
  local gps_speed_accuracy = gps:speed_accuracy(gps:primary_sensor())
  local gps_over_threshold = (gps_speed_accuracy == nil) or (gps:speed_accuracy(gps:primary_sensor()) > gps_speedaccuracy_thresh)

  -- get GPS innovations from ahrs
  local gps_innov = ahrs:get_vel_innovations_and_variances_for_source(3)
  local gps_innov_over_threshold = (gps_innov == nil) or (gps_innov:z() == 0.0) or (math.abs(gps_innov:z()) > gps_innov_thresh)

  -- automatic selection logic --

  -- GPS vs NonGPS vote. "-1" to move towards GPS, "+1" to move to Non-GPS
  if (not gps_over_threshold) and (not gps_innov_over_threshold) then
    -- vote for GPS if GPS accuracy good AND innovations are low
    gps_vs_nongps_vote = math.max(gps_vs_nongps_vote - 1, -vote_counter_max)
  else
    -- otherwise vote for NonGPS (wheel encoders)
    gps_vs_nongps_vote = math.min(gps_vs_nongps_vote + 1, vote_counter_max)
  end

  -- auto source vote collation
  local auto_source = -1                         -- auto source undecided if -1
  if gps_vs_nongps_vote <= -vote_counter_max then
    auto_source = 0                              -- GPS
  elseif gps_vs_nongps_vote >= vote_counter_max then
    auto_source = 1                              -- Non-GPS / wheel encoders
  end

  -- read source switch position from RCx_FUNCTION = 90 (EKF Source Select)
  local sw_source_pos = rc_function_source:get_aux_switch_pos()
  if sw_source_pos ~= sw_source_pos_prev then    -- check for changes in source switch position
    sw_source_pos_prev = sw_source_pos           -- record new switch position so we can detect changes
    auto_switch = false                          -- disable auto switching of source
    if source_prev ~= sw_source_pos then         -- check if switch position does not match source (there is a one-to-one mapping of switch to source)
      source_prev = sw_source_pos                -- record what source should now be (changed by ArduPilot vehicle code)
      gcs:send_text(0, "Pilot switched to Source " .. string.format("%d", source_prev+1))
    else
      gcs:send_text(0, "Pilot switched but already Source " .. string.format("%d", source_prev+1))
    end
    play_source_tune(source_prev)                -- alert user of source regardless of whether it has changed or not
  end

  -- read auto source switch position from RCx_FUNCTION = 300 (Scripting1)
  if rc_function_auto then
    local sw_auto_pos = rc_function_auto:get_aux_switch_pos()
    if sw_auto_pos ~= sw_auto_pos_prev  then       -- check for changes in source auto switch position
      sw_auto_pos_prev = sw_auto_pos               -- record new switch position so we can detect changes
      if sw_auto_pos == 0 then                     -- pilot has pulled switch low
        auto_switch = false                        -- disable auto switching of source
        if sw_source_pos ~= source_prev then       -- check if source will change
          source_prev = sw_source_pos              -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source disabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source disabled, already Source " .. string.format("%d", source_prev+1))
        end
      elseif sw_auto_pos == 2 then                 -- pilot has pulled switch high
        auto_switch = true                         -- enable auto switching of source
        if auto_source < 0 then
          gcs:send_text(0, "Auto source enabled, undecided, Source " .. string.format("%d", source_prev+1))
        elseif auto_source ~= source_prev then     -- check if source will change
          source_prev = auto_source                -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source enabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source enabled, already Source " .. string.format("%d", source_prev+1))
        end
      end
      play_source_tune(source_prev)
    end
  end

  -- auto switching
  if auto_switch and (auto_source >= 0) and (auto_source ~= source_prev) then
    source_prev = auto_source                  -- record selected source
    ahrs:set_posvelyaw_source_set(source_prev)     -- switch to pilot's selected source
    gcs:send_text(0, "Auto switched to Source " .. string.format("%d", source_prev+1))
    play_source_tune(source_prev)
  end

  return update, 100
end

return update()



================================================
File: examples/ahrs-source.lua
================================================
-- switches between AHRS/EKF sources based on the pilot's source selection switch or using an automatic source selection algorithm
-- this script is intended to help vehicles move between GPS and Non-GPS environments
--
-- setup RCx_OPTION = 90 (EKF Source Set) to select the source (low=primary, middle=secondary, high=tertiary)
-- setup RCx_OPTION = 300 (Scripting1).  When this switch is pulled high, the source will be automatically selected
-- setup EK3_SRCn_ parameters so that GPS is the primary source, Non-GPS (i.e. T265) is secondary and optical flow tertiary
-- configure a forward or downward facing lidar with a range of more than 5m
--
-- When the auxiliary switch (ZigZag Auto) is pulled high automatic source selection uses these thresholds:
-- SCR_USER1 holds the threshold for rangefinder altitude:
--     if rangefinder distance >= SCR_USER1, source2 (ExtNav) will be used (if Non-GPS vel innovations are good)
--     if rangefinder distance < SCR_USER1, source3 (optical flow) will be used (if Non-GPS vel innovations are not good)
-- SCR_USER2 holds the threshold for GPS speed accuracy (around 0.3 is a good choice)
-- SCR_USER3 holds the threshold for Non-GPS vertical speed innovation (about 0.3 is a good choice)
--     if both GPS speed accuracy <= SCR_USER2 and ExternalNav speed variance >= SCR_USER3, source1 will be used
--     otherwise source2 (T265) or source3 (optical flow) will be used based on rangefinder distance
---@diagnostic disable: need-check-nil

local rangefinder_rotation = 25     -- check downward (25) facing lidar
local source_prev = 0               -- previous source, defaults to primary source
local sw_auto_pos_prev = -1         -- previous auto source switch position
local auto_switch = false           -- true when auto switching between sources is active
local gps_usable_accuracy = 1.0     -- GPS is usable if speed accuracy is at or below this value
local vote_counter_max = 20         -- when a vote counter reaches this number (i.e. 2sec) source may be switched
local gps_vs_nongps_vote = 0        -- vote counter for GPS vs NonGPS (-20 = GPS, +20 = NonGPS)
local extnav_vs_opticalflow_vote = 0 -- vote counter for extnav vs optical flow (-20 = extnav, +20 = opticalflow)

-- play tune on buzzer to alert user to change in active source set
function play_source_tune(source)
  if (source) then
    if (source == 0) then
      notify:play_tune("L8C")       -- one long lower tone
    elseif (source == 1) then
      notify:play_tune("L12DD")     -- two fast medium tones
    elseif (source == 2) then
      notify:play_tune("L16FFF")    -- three very fast, high tones
    end
  end
end

-- the main update function
function update()

  -- check switches are configured
  -- at least one switch must be set
  -- source selection from RCx_FUNCTION = 90 (EKF Source Select)
  -- auto source from RCx_FUNCTION = 300 (Scripting1)
  local rc_function_source = rc:find_channel_for_option(90)
  local rc_function_auto = rc:find_channel_for_option(300)
  if (rc_function_source == nil) and (rc_function_auto == nil) then
    gcs:send_text(0, "ahrs-source.lua: RCx_FUNCTION=90 or 300 not set!")
    return update, 1000
  end

  -- check rangefinder distance threshold has been set
  local rangefinder_thresh_dist = param:get('SCR_USER1')  -- SCR_USER1 holds rangefinder threshold
  if (rangefinder_thresh_dist == nil) or (rangefinder_thresh_dist <= 0) then
    gcs:send_text(0, "ahrs-source.lua: set SCR_USER1 to rangefinder threshold")
    return update, 1000
  end

  -- check GPS speed accuracy threshold has been set
  local gps_speedaccuracy_thresh = param:get('SCR_USER2')  -- SCR_USER2 holds GPS speed accuracy threshold
  if (gps_speedaccuracy_thresh == nil) or (gps_speedaccuracy_thresh <= 0) then
    gcs:send_text(0, "ahrs-source.lua: set SCR_USER2 to GPS speed accuracy threshold")
    return update, 1000
  end

  -- check external nav innovation threshold has been set
  local extnav_innov_thresh = param:get('SCR_USER3')  -- SCR_USER3 holds Non-GPS vertical velocity innovation
  if (extnav_innov_thresh == nil) or (extnav_innov_thresh <= 0) then
    gcs:send_text(0, "ahrs-source.lua: set SCR_USER3 to ExtNav innovation threshold")
    return update, 1000
  end

  -- check if GPS speed accuracy is over threshold
  local gps_speed_accuracy = gps:speed_accuracy(gps:primary_sensor())
  local gps_over_threshold = (gps_speed_accuracy == nil) or (gps:speed_accuracy(gps:primary_sensor()) > gps_speedaccuracy_thresh)
  local gps_usable = (gps_speed_accuracy ~= nil) and (gps_speed_accuracy <= gps_usable_accuracy)

  -- get external nav innovations from ahrs
  local extnav_innov = ahrs:get_vel_innovations_and_variances_for_source(6)
  local extnav_over_threshold = (extnav_innov == nil) or (extnav_innov:z() == 0.0) or (math.abs(extnav_innov:z()) > extnav_innov_thresh)

  -- get rangefinder distance
  local rngfnd_distance_m = 0
  if rangefinder:has_data_orient(rangefinder_rotation) then
    rngfnd_distance_m = rangefinder:distance_orient(rangefinder_rotation)
  end
  local rngfnd_over_threshold = (rngfnd_distance_m == 0) or (rngfnd_distance_m > rangefinder_thresh_dist)

  -- NonGPS is usable if extnav innovations are good or rangefinder distance is short (for optical flow)
  local nongps_usable = (not extnav_over_threshold) or (not rngfnd_over_threshold)

  -- automatic selection logic --

  -- GPS vs NonGPS vote. "-1" to move towards GPS, "+1" to move to Non-GPS
  if (not gps_over_threshold) or (gps_usable and not nongps_usable) then
    -- vote for GPS if GPS accuracy good OR usable GPS and NonGPS unusable
    gps_vs_nongps_vote = math.max(gps_vs_nongps_vote - 1, -vote_counter_max)
  elseif nongps_usable then
    -- vote for NonGPS if extnav or opticalflow is usable
    gps_vs_nongps_vote = math.min(gps_vs_nongps_vote + 1, vote_counter_max)
  end

  -- extnav vs optical flow vote. "-1" to move towards extnav, "+1" to move to opticalflow
  if (not extnav_over_threshold) then
    -- vote for extnav is innovations under threshold
    extnav_vs_opticalflow_vote = math.max(extnav_vs_opticalflow_vote - 1, -vote_counter_max)
  elseif (not rngfnd_over_threshold) then
    -- vote for optical flow if rangefinder is not over threshold
    extnav_vs_opticalflow_vote = math.min(extnav_vs_opticalflow_vote + 1, vote_counter_max)
  end

  -- auto source vote collation
  local auto_source = -1                         -- auto source undecided if -1
  if gps_vs_nongps_vote <= -vote_counter_max then
    auto_source = 0                              -- GPS
  elseif gps_vs_nongps_vote >= vote_counter_max then
    if extnav_vs_opticalflow_vote <= -vote_counter_max then
      auto_source = 1                            -- extnav
    elseif extnav_vs_opticalflow_vote >= vote_counter_max then
      auto_source = 2                            -- opticalflow
    end
  end

  -- read source switch position from RCx_FUNCTION = 90 (EKF Source Select)
  local sw_source_pos = rc_function_source:get_aux_switch_pos()
  if sw_source_pos ~= sw_source_pos_prev then    -- check for changes in source switch position
    sw_source_pos_prev = sw_source_pos           -- record new switch position so we can detect changes
    auto_switch = false                          -- disable auto switching of source
    if source_prev ~= sw_source_pos then         -- check if switch position does not match source (there is a one-to-one mapping of switch to source)
      source_prev = sw_source_pos                -- record what source should now be (changed by ArduPilot vehicle code)
      gcs:send_text(0, "Pilot switched to Source " .. string.format("%d", source_prev+1))
    else
      gcs:send_text(0, "Pilot switched but already Source " .. string.format("%d", source_prev+1))
    end
    play_source_tune(source_prev)                -- alert user of source whether changed or not
  end

  -- read auto source switch position from RCx_FUNCTION = 300 (Scripting1)
  if rc_function_auto then
    local sw_auto_pos = rc_function_auto:get_aux_switch_pos()
    if sw_auto_pos ~= sw_auto_pos_prev  then       -- check for changes in source auto switch position
      sw_auto_pos_prev = sw_auto_pos               -- record new switch position so we can detect changes
      if sw_auto_pos == 0 then                     -- pilot has pulled switch low
        auto_switch = false                        -- disable auto switching of source
        if sw_source_pos ~= source_prev then       -- check if source will change
          source_prev = sw_source_pos              -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source disabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source disabled, already Source " .. string.format("%d", source_prev+1))
        end
      elseif sw_auto_pos == 2 then                 -- pilot has pulled switch high
        auto_switch = true                         -- enable auto switching of source
        if auto_source < 0 then
          gcs:send_text(0, "Auto source enabled, undecided, Source " .. string.format("%d", source_prev+1))
        elseif auto_source ~= source_prev then     -- check if source will change
          source_prev = auto_source                -- record pilot's selected source
          ahrs:set_posvelyaw_source_set(source_prev)   -- switch to pilot's selected source
          gcs:send_text(0, "Auto source enabled, switched to Source " .. string.format("%d", source_prev+1))
        else
          gcs:send_text(0, "Auto source enabled, already Source " .. string.format("%d", source_prev+1))
        end
      end
      play_source_tune(source_prev)
    end
  end

  -- auto switching
  if auto_switch and (auto_source >= 0) and (auto_source ~= source_prev) then
    source_prev = auto_source                  -- record selected source
    ahrs:set_posvelyaw_source_set(source_prev)     -- switch to pilot's selected source
    gcs:send_text(0, "Auto switched to Source " .. string.format("%d", source_prev+1))
    play_source_tune(source_prev)
  end

  return update, 100
end

return update()



================================================
File: examples/analog_input_and_GPIO.lua
================================================
-- This script is an example of reading a analog pin, PWM in and GPIO

-- for these examples BRD_PWM_COUNT must be 0

---@diagnostic disable: need-check-nil

-- load the analog pin, there are only 16 of these available
-- some are used by the main AP code, ie battery monitors
-- assign them like this in the init, not in the main loop
local analog_in = analog:channel()
if not analog_in:set_pin(13) then -- typically 13 is the battery input
  gcs:send_text(0, "Invalid analog pin")
end

-- load a input pwm pin
local pwm_in = PWMSource()
local pwm_in_fail = PWMSource()

if not pwm_in:set_pin(50) then -- AUX 1
  gcs:send_text(0, "Failed to setup PWM in on pin 50")
end

-- there are a few combinations of PWM in that will not work
-- this is due to the way interrupts are handled, AUX 1 and 6 cannot both
-- be PWM at once because they use the same interrupt (on Cubes), this should fail
if not pwm_in_fail:set_pin(55) then -- AUX 6
  gcs:send_text(0, "Failed to setup PWM in on pin 55")
end

gpio:pinMode(51,1) -- set AUX 2 to output, gpio:pinMode(51,0) would be input

function update()
  gcs:send_text(0, string.format("voltage: %0.2f, PWM: %i, input: ", analog_in:voltage_average(), pwm_in:get_pwm_us()) .. tostring(gpio:read(51)))

  -- analog_in:voltage_average() the average voltage since the last call
  -- analog_in:voltage_latest() the latest voltage reading
  -- analog_in:voltage_average_ratiometric() the average ratiometric voltage (relative to the board 5v)

  -- pwm_in:get_pwm_us() the latest pwm value in us
  -- pwm_in:get_pwm_avg_us() the average pwm value in us since the last call

  -- gpio:read(pin)
  -- gpio:write(pin, state)
  -- gpio:toggle(pin)

  gpio:toggle(51)

  return update, 1000
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/arming-check-batt-temp.lua
================================================
-- This script runs a custom arming check of the battery temperature

auth_id = arming:get_aux_auth_id()
batt_temp_max = 35

function update() -- this is the loop which periodically runs
  if auth_id then
    batt_temp = battery:get_temperature(0)
    if not batt_temp then
      arming:set_aux_auth_failed(auth_id, "Could not retrieve battery temperature")
    elseif (batt_temp >= batt_temp_max) then
      arming:set_aux_auth_failed(auth_id, "Batt temp too high (" .. tostring(batt_temp) .. "C > " .. tostring(batt_temp_max) .. "C)")
    else
      arming:set_aux_auth_passed(auth_id)
    end
  end
  return update, 5000 -- reschedules the loop in 5 seconds
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/arming-check-wp1-takeoff.lua
================================================
-- This script runs a custom arming check for index == 1 and it must be a takeoff mission item

local auth_id = arming:get_aux_auth_id()

local MAV_CMD_NAV_TAKEOFF = 22
local MAV_CMD_NAV_VTOL_TAKEOFF = 84

function update() -- this is the loop which periodically runs
  if auth_id then
    local cmd_id = mission:get_current_nav_id()
    local index = mission:get_current_nav_index()

    if not cmd_id or not index then
      arming:set_aux_auth_failed(auth_id, "Could not retrieve mission")
    elseif ((index ~= 0) and (index ~= 1)) then
      -- index of 0 is valid because when you switch to AUTO it will automatically change to 1
      arming:set_aux_auth_failed(auth_id, "Mission index is not ready")
    elseif ((cmd_id ~= MAV_CMD_NAV_TAKEOFF) and (cmd_id ~= MAV_CMD_NAV_VTOL_TAKEOFF)) then
      arming:set_aux_auth_failed(auth_id, "Mission is not ready to takeoff")
    else
      arming:set_aux_auth_passed(auth_id)
    end
  end
  return update, 2000 -- reschedules the loop in 2 seconds
end

return update() -- run immediately before starting to reschedule





================================================
File: examples/aux_cached.lua
================================================
--[[ 
   example for getting cached aux function value
--]]


local RATE_HZ = 10

local MAV_SEVERITY_ERROR = 3
local MAV_SEVERITY_INFO = 6

local AUX_FUNCTION_NUM = 302

local last_aux_pos = nil

function update()
   local aux_pos = rc:get_aux_cached(AUX_FUNCTION_NUM)
   if aux_pos ~= last_aux_pos then
      last_aux_pos = aux_pos
      gcs:send_text(MAV_SEVERITY_INFO, string.format("Aux set to %u", aux_pos))
   end
end

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, math.floor(1000 / RATE_HZ)
end

-- start running update loop
return protected_wrapper()



================================================
File: examples/battery_internal_resistance_check.lua
================================================
--[[
 script implementing pre-arm check that internal resistance is sensible
--]]

local MAX_RESISTANCE = 0.03  -- Ohms

local auth_id = assert(arming:get_aux_auth_id())

local warning_last_sent_ms = uint32_t() -- time we last sent a warning message to the user
warning_interval_ms = 10000

function update()
   local num_batts = battery:num_instances()
   local ok = true
   for i=0,num_batts do
      local resistance = battery:get_resistance(i)
      failed = resistance > MAX_RESISTANCE
      if failed then
         msg = string.format("Batt[%u] high internal resistance %.5f Ohms", i+1, resistance)
         if millis() - warning_last_sent_ms > warning_interval_ms then
            gcs:send_text(0, msg)
            warning_last_sent_ms = millis()
         end
         arming:set_aux_auth_failed(auth_id, msg)
         ok = false
      end
   end

   if ok then
      arming:set_aux_auth_passed(auth_id)
   end
   return update, 500
end

return update()



================================================
File: examples/benewakeH30_can_rangefinder.lua
================================================
-- Lua Can Driver for Benewake CAN Rangefinder

---@diagnostic disable: undefined-global
---@diagnostic disable: need-check-nil

-- User settable parameters
local update_rate_ms    = 10    -- update rate (in ms) of the driver
local debug_enable = false    -- true to enable debug messages

-- Global variables (DO NOT CHANGE)
local param_num_lua_rfnd_backend = 36         -- parameter number for lua rangefinder
local lua_rfnd_backend                        -- store lua backend here
local lua_rfnd_driver_found = false           -- true if user has configured lua backend


local can_driver = CAN:get_device(5)

gcs:send_text(0,"Scripting started")


-- -------------------------------- RFND DRIVER --------------------------------

function setup_rfnd_sensor()
  if not can_driver then
    gcs:send_text(0,"No scripting CAN interfaces found")
    return
  end

  local sensor_count = rangefinder:num_sensors() -- number of sensors connected
  for j = 0, sensor_count -1 do
    local device = rangefinder:get_backend(j)
    if ((not lua_rfnd_driver_found) and  device and (device:type() == param_num_lua_rfnd_backend)) then
      -- this is a lua driver
      lua_rfnd_driver_found = true
      lua_rfnd_backend = device
    end
  end
  if not lua_rfnd_driver_found then
    -- We can't use this script if user hasn't setup a lua backend
    gcs:send_text(0, string.format("Configure Lua RFND Sensor"))
    return
  end
end

function show_rfnd_frame(frame_rfnd)
  gcs:send_text(0,string.format("RFND msg from " .. tostring(frame_rfnd:id())))
end

function parse_rfnd_can_frame(frame_rfnd)
  local height_cm = (frame_rfnd:data(0)*256 + frame_rfnd:data(1))
  return height_cm*0.01
end

function handle_rfnd_frame(frame_rfnd)
  if debug_enable then
    show_rfnd_frame(frame_rfnd)
  end

  rfnd_dist = parse_rfnd_can_frame(frame_rfnd)

  if (rfnd_dist > 0) then
    local sent_successfully = lua_rfnd_backend:handle_script_msg(rfnd_dist)
    if not sent_successfully then
      -- This should never happen as we already checked for a valid configured lua backend above
      gcs:send_text(0, string.format("RFND Lua Script Error"))
      return
    end
  end
end

-- -------------------------------- MAIN --------------------------------

function update()

  if not lua_rfnd_driver_found then
    setup_rfnd_sensor()
  end

  if (not lua_rfnd_driver_found) then
    -- We can't use this script if user hasn't setup a lua backend
    return
  end

  frame = can_driver:read_frame()
  if not frame then
    -- no frame to parse
    return
  end

  handle_rfnd_frame(frame)

end


-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
      gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
      -- when we fault we run the update function again after 1s, slowing it
      -- down a bit so we don't flood the console with errors
      return protected_wrapper, 1000
  end
  return protected_wrapper, update_rate_ms
end

-- start running update loop
return protected_wrapper()



================================================
File: examples/button_test.lua
================================================
-- This script is an example button functionality

local button_number = 1 -- the button numbber we want to read, as deffined in AP_Button

local button_active_state = true -- the 'pressed' state of the button

local last_button_state

function update() -- this is the loop which periodically runs

  local button_new_state = button:get_button_state(button_number) == button_active_state

  -- the button has changes since the last loop
  if button_new_state ~= last_button_state then
    last_button_state = button_new_state
    if button_new_state then
      gcs:send_text(0, "LUA: Button pressed")
    else
      gcs:send_text(0, "LUA: Button released")
    end
  end

  return update, 1000 -- reschedules the loop (1hz)
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/camera-test.lua
================================================
-- camera-test.lua.  Tests triggering taking pictures at regular intervals

---@diagnostic disable: cast-local-type

-- global definitions
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
local TAKE_PIC_INTERVAL_MS = 5000   -- take pictures at this interval
local CAMERA_INSTANCE = 0           -- always control the first camera

-- local variables
local last_takepic_time_ms = 0      -- system time that picture was last taken

-- the main update function that performs a simplified version of RTL
function update()

  -- get current system time
  local now_ms = millis()

  -- check if time to take picture
  if (now_ms - last_takepic_time_ms > TAKE_PIC_INTERVAL_MS) then
    last_takepic_time_ms = now_ms
    camera:take_picture(CAMERA_INSTANCE)
  end

  -- update at 10hz
  return update, 100
end

-- display startup message
gcs:send_text(MAV_SEVERITY.INFO, "camera-test.lua started")

return update()



================================================
File: examples/cell_balance_check.lua
================================================
--[[
 script implementing pre-arm check that batteries are well balanced
--]]

---@diagnostic disable: param-type-mismatch

local MAX_CELL_DEVIATION = 0.2

local auth_id = arming:get_aux_auth_id()

local NCELLS_MAX = 16

function check_cell_balance(bnum)
   local min_volt = -1
   local max_volt = -1
   for c=0,NCELLS_MAX do
      local voltage = battery:get_cell_voltage(bnum, c)
      if not voltage then
         break
      end
      if min_volt == -1 or min_volt > voltage then
         min_volt = voltage
      end
      if max_volt == -1 or max_volt < voltage then
         max_volt = voltage
      end
   end
   local vdiff = max_volt - min_volt
   if vdiff > MAX_CELL_DEVIATION then
      arming:set_aux_auth_failed(auth_id, string.format("Batt[%u] imbalance %.1fV", bnum+1, vdiff))
      return false
   end
   return true
end

function update()
   local num_batts = battery:num_instances()
   local ok = true
   for i=0,num_batts do
      if not check_cell_balance(i) then
         ok = false
      end
   end
   if ok then
      arming:set_aux_auth_passed(auth_id)
   end
   return update, 500
end

return update()



================================================
File: examples/command_int.lua
================================================
--[[
   demonstrate using the gcs:command_int() interface to send commands from MAVLink MAV_CMD_xxx set
--]]

local MAV_FRAME_GLOBAL_RELATIVE_ALT = 3

local MAV_CMD_DO_SET_MODE = 176
local MAV_CMD_DO_REPOSITION = 192

-- some plane flight modes for testing
local MODE_LOITER = 12
local MODE_GUIDED = 15

local MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = 1

--[[
create a NaN value
--]]
local function NaN()
   return 0/0
end

--[[
   test API calls. When in LOITER mode change to GUIDED and force flying to a location NE of home
--]]
local function test_command_int()
   if vehicle:get_mode() ~= MODE_LOITER then
      return
   end
   local home = ahrs:get_home()
   if not home then
      return
   end

   -- force mode GUIDED
   gcs:run_command_int(MAV_CMD_DO_SET_MODE, { p1 = MAV_MODE_FLAG_CUSTOM_MODE_ENABLED, p2 = MODE_GUIDED })

   -- and fly to 200m NE of home and 100m above home
   local dest = home:copy()
   dest:offset_bearing(45, 200)

   gcs:run_command_int(MAV_CMD_DO_REPOSITION, { frame = MAV_FRAME_GLOBAL_RELATIVE_ALT,
                                                p1 = -1,
                                                p4 = NaN(),
                                                x = dest:lat(),
                                                y = dest:lng(),
                                                z = 100 })
end

local function update()
   test_command_int()
   return update, 1000
end

return update, 1000




================================================
File: examples/copter-circle-speed.lua
================================================
-- Maintain a constant ground speed while flying in Circle mode even if the pilot adjusts the radius
--
-- CAUTION: This script only works for Copter
-- this script waits for the vehicle to be armed and in circle mode and then
-- updates the target rate around the circle (in degrees / sec) to maintain the desired ground speed

local circle_ground_speed = 6 -- the ground speed in circle mode (m/s)

function update() -- this is the loop which periodically runs

  -- must be armed, flying and in circle mode
  if (not arming:is_armed()) or (not vehicle:get_likely_flying()) or (vehicle:get_mode() ~= 7) then
    return update, 1000 -- reschedules the loop, 1hz
  end

  -- get circle radius
  local radius = vehicle:get_circle_radius()
  if not radius then
    gcs:send_text(0, "speed-circle.lua: failed to get circle radius")
    return update, 1000
  end

  -- set the rate to give the desired ground speed at the current radius
  local new_rate = 360 * (circle_ground_speed / (radius*math.pi*2))
  new_rate = math.max(new_rate, -90)
  new_rate = math.min(new_rate, 90)
  if not vehicle:set_circle_rate(new_rate) then
    gcs:send_text(0, "speed-circle.lua: failed to set rate")
  else
    gcs:send_text(0, string.format("speed-circle.lua: radius:%f new_rate=%f", radius, new_rate))
  end

  return update, 100 -- reschedules the loop, 10hz
end

return update()



================================================
File: examples/copter-fast-descent.lua
================================================
-- Copter descends very rapidly in a spiral pattern to a preset altitude above home
--
-- CAUTION: This script only works for Copter 4.2 (and higher)
-- this script waits for the vehicle to be changed to Guided mode and then:
--    a) flies a spiral pattern using the velocity and acceleration control
--    b) slows the spiral and stops at the preset altitude
--    c) switches to RTL

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type
---@diagnostic disable: need-check-nil

-- constants
local copter_guided_mode_num = 4    -- Guided mode is 4 on copter
local copter_rtl_mode_num = 6       -- RTL is 6 on copter
local circle_radius_rate_max_ms = 1 -- radius expands at max of this many m/s
local circle_radius_accel_mss = 1   -- radius expansion speed accelerates at this many m/s/s
local accel_xy = 1                  -- horizontal acceleration in m/s^2
local accel_z = 1                   -- target vertical acceleration is 1m/s/s
local speed_z_slowdown = 0.1        -- target vertical speed during final slowdown

-- timing and state machine variables
local stage = 0                     -- stage of descent
local last_update_ms                -- system time of last update
local dt = 0.01                     -- update rate of script (0.01 = 100hz)
local interval_ms = 1               -- update interval in ms
local last_print_ms = 0             -- pilot update timer
local auto_last_id = -1             -- unique id used to detect if a new NAV_SCRIPT_TIME command has started

-- control related variables
local circle_center_pos = Vector3f()-- center of circle position as an offset from EKF origin
local circle_radius = 0             -- target circle's current radius (this is slowly expanded to circle_radius_max)
local circle_radius_rate_ms = 0     -- target circle's radius is increasing at this rate in m/s
local circle_angle_rad = 0          -- current target angle on circle (in radians)
local target_alt_D = 0              -- target altitude in m from EKF origin (Note: down is positive)
local speed_xy = 0                  -- target horizontal speed (i.e. tangential velocity or horizontal speed around the circle)
local speed_z = 0                   -- target descent rate currently
local target_yaw_deg = 0            -- target yaw in degrees (degrees is more convenient based on interface)

-- create and initialise parameters
local PARAM_TABLE_KEY = 75          -- parameter table key must be used by only one script on a particular flight controller
assert(param:add_table(PARAM_TABLE_KEY, "FDST_", 6), 'could not add param table')
assert(param:add_param(PARAM_TABLE_KEY, 1, 'ACTIVATE', 0), 'could not add FDST_ACTIVATE param')     -- 0:active in Guided, 1:active in Auto's NAV_SCRIPT_TIME command
assert(param:add_param(PARAM_TABLE_KEY, 2, 'ALT_MIN', 50), 'could not add FDST_ALT_MIN param')      -- copter will stop at this altitude above home
assert(param:add_param(PARAM_TABLE_KEY, 3, 'RADIUS', 10), 'could not add FDST_RADIUS parameter')    -- target circle's maximum radius
assert(param:add_param(PARAM_TABLE_KEY, 4, 'SPEED_XY', 5), 'could not add FDST_SPEED_XY param')     -- max target horizontal speed
assert(param:add_param(PARAM_TABLE_KEY, 5, 'SPEED_DN', 10), 'could not add FDST_SPEED_DN param')    -- target descent rate
assert(param:add_param(PARAM_TABLE_KEY, 6, 'YAW_BEHAVE', 0), 'could not add FDST_YAW_BEHAVE param') -- 0:yaw does not change 1:yaw points toward center

-- bind parameters to variables
local activate_type = Parameter("FDST_ACTIVATE")       -- activate type 0:Guided, 1:Auto's NAV_SCRIPT_TIME
local alt_above_home_min = Parameter("FDST_ALT_MIN")   -- copter will stop at this altitude above home
local circle_radius_max = Parameter("FDST_RADIUS")     -- target circle's maximum radius
local speed_xy_max = Parameter("FDST_SPEED_XY")        -- max target horizontal speed
local speed_z_max = Parameter("FDST_SPEED_DN")         -- target descent rate
local yaw_behave = Parameter("FDST_YAW_BEHAVE")        -- 0:yaw is static, 1:yaw points towards center of circle

-- the main update function
function update()

  -- update dt
  local now_ms = millis()
  if (last_update_ms) then
      dt = (now_ms - last_update_ms):tofloat() / 1000.0
  end
  if (dt > 1) then
    dt = 0
  end
  last_update_ms = now_ms

  -- determine if progress update should be sent to user
  local update_user = false
  if (now_ms - last_print_ms > 5000) then
    last_print_ms = now_ms
    update_user = true
  end

  -- reset stage until activated in Guided or Auto mode
  if (activate_type:get() == 0) then
    -- activate_type 0: reset stage when disarmed or not in Guided mode
    if not arming:is_armed() or (vehicle:get_mode() ~= copter_guided_mode_num) then 
      stage = 0
      if (update_user and arming:is_armed()) then
        gcs:send_text(6, "Fast Descent: waiting for Guided")
      end
      return update, interval_ms
    end
  else
    -- activate_type 1: reset stage when disarmed or not in Auto executing NAV_SCRIPT_TIME command
    auto_last_id, cmd, arg1, arg2, arg3, arg4 = vehicle:nav_script_time()
    if not arming:is_armed() or not auto_last_id then 
      stage = 0
      if (update_user and arming:is_armed()) then
        gcs:send_text(6, "Fast Descent: waiting for NAV_SCRIPT_TIME")
      end
      return update, interval_ms
    end
  end

  if (stage == 0) then            -- Stage0: initialise
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_location()
    if home and curr_loc then
      circle_center_pos = ahrs:get_relative_position_NED_origin()
      circle_radius_rate_ms = 0   -- reset circle radius expandion rate to zero
      circle_radius = 0           -- reset circle radius to zero
      if yaw_behave:get() == 0 then
        -- yaw does not move so reset starting angle to current heading
        circle_angle_rad = ahrs:get_yaw_rad()
      else
        -- yaw points towards center so start 180deg behind vehicle
        circle_angle_rad = ahrs:get_yaw_rad() + math.pi
        if (circle_angle_rad >= (math.pi * 2)) then
          circle_angle_rad = circle_angle_rad - (math.pi * 2)
        end
      end
      target_yaw_deg = math.deg(ahrs:get_yaw_rad()) -- target heading will be kept at original heading
      target_alt_D = circle_center_pos:z() -- initialise target alt using current position (Note: down is positive)
      speed_xy = 0
      speed_z = 0
      stage = stage + 1           -- advance to next stage
      gcs:send_text(5, "Fast Descent: starting")
    end
  elseif (stage == 1) then        -- Stage1: descend

    -- get current position
    local rel_pos_home_NED = ahrs:get_relative_position_NED_home()

    -- increase circle radius
    circle_radius_rate_ms = math.min(circle_radius_rate_ms + (circle_radius_accel_mss * dt), circle_radius_rate_max_ms)   -- accelerate radius expansion
    circle_radius = math.min(circle_radius + (circle_radius_rate_ms * dt), circle_radius_max:get())  -- increase radius

    -- calculate horizontal and vertical speed
    if (circle_radius < circle_radius_max:get()) then
      speed_xy = math.max(speed_xy - (accel_xy * dt), 0)  -- decelerate horizontal speed to zero
      speed_z = math.max(speed_z - (accel_z * dt), 0)     -- decelerate vertical speed to zero
    else
      -- calculate conversion between alt-above-home and alt-above-ekf-origin
      local home_alt_above_origin = 0
      local home = ahrs:get_home()
      local ekf_origin = ahrs:get_origin()
      if home and ekf_origin then
        local dist_NED = home:get_distance_NED(ekf_origin)
        home_alt_above_origin = dist_NED:z()
      end

      -- calculate target speeds
      local target_dist_to_alt_min = -target_alt_D - home_alt_above_origin - alt_above_home_min:get()  -- alt target's distance to alt_min
      if (target_dist_to_alt_min > 0) then
        local speed_z_limit = speed_z_max:get()
        speed_z_limit = math.min(speed_z_limit, math.sqrt(2.0 * target_dist_to_alt_min * accel_z))  -- limit speed so vehicle can stop at ALT_MIN
        speed_z_limit = math.max(speed_z_limit, speed_z_slowdown) -- vertical speed should never be less than 0.1 m/s when above ALT_MIN
        speed_z = math.min(speed_z + (accel_z * dt), speed_z_limit)

        speed_xy = math.min(speed_xy + (accel_xy * dt), speed_xy_max:get()) -- accelerate horizontal speed to maximum
      else
        -- below alt min so decelerate target speeds to zero
        speed_xy = math.max(speed_xy - (accel_xy * dt), 0)  -- decelerate horizontal speed to zero
        speed_z = math.max(speed_z - (accel_z * dt), 0)     -- decelerate vertical speed to zero
      end
    end

    -- calculate angular velocity
    local ang_vel_rads = 0
    if (circle_radius >= circle_radius_max:get()) then
      ang_vel_rads = speed_xy / circle_radius;
    end

    -- increment angular position
    circle_angle_rad = circle_angle_rad + (ang_vel_rads * dt)
    if (circle_angle_rad >= (math.pi * 2)) then
      circle_angle_rad = circle_angle_rad - (math.pi * 2)
    end

    -- calculate target position
    local cos_ang = math.cos(circle_angle_rad)
    local sin_ang = math.sin(circle_angle_rad)
    local target_pos = Vector3f()
    target_pos:x(circle_center_pos:x() + (circle_radius * cos_ang))
    target_pos:y(circle_center_pos:y() + (circle_radius * sin_ang))
    target_alt_D = target_alt_D + (speed_z * dt)
    target_pos:z(target_alt_D)

    -- calculate target velocity
    target_vel = Vector3f()
    target_vel:x(speed_xy * -sin_ang)
    target_vel:y(speed_xy * cos_ang)
    target_vel:z(speed_z)

    -- calculate target acceleration
    local centrip_accel = 0
    if (circle_radius > 0) then
      centrip_accel = speed_xy * speed_xy / circle_radius
    end
    target_accel = Vector3f()
    target_accel:x(centrip_accel * -cos_ang)
    target_accel:y(centrip_accel * -sin_ang)

    -- calculate target yaw
    if yaw_behave:get() == 1 then
      target_yaw_deg = math.deg(circle_angle_rad + math.pi)
      if target_yaw_deg  > 360 then
        target_yaw_deg = target_yaw_deg - 360
      end
    end

    -- send targets to vehicle with yaw target
    vehicle:set_target_posvelaccel_NED(target_pos, target_vel, target_accel, true, target_yaw_deg, false, 0, false)

    -- advance to stage 2 when below target altitude and target speeds are zero
    if (rel_pos_home_NED) then 
      if (-rel_pos_home_NED:z() <= alt_above_home_min:get() and (speed_xy==0) and (speed_z==0)) then
        stage = stage + 1
      end
      if (update_user) then
        gcs:send_text(5, string.format("Fast Descent: alt:%d target:%d", math.floor(-rel_pos_home_NED:z()), math.floor(alt_above_home_min:get())))
      end
    else
      gcs:send_text(5, "Fast Descent: lost position estimate, aborting")
      stage = stage + 1
    end

  elseif (stage == 2) then  -- Stage2: done!
    stage = stage + 1
    gcs:send_text(5, "Fast Descent: done!")
    if (activate_type:get() == 0) then
      -- if activated from Guided change to RTL mode
      vehicle:set_mode(copter_rtl_mode_num)
    else
      -- if activated from Auto NAV_SCRIPT_TIME then mark command as done
      vehicle:nav_script_time_done(auto_last_id)
    end
  end

  return update, interval_ms
end

return update()



================================================
File: examples/copter-fly-vertical-circle.lua
================================================
-- command a Copter to takeoff to 5m and fly a vertical circle in the clockwise direction
--
-- CAUTION: This script only works for Copter
-- this script waits for the vehicle to be armed and RC6 input > 1800 and then:
--    a) switches to Guided mode
--    b) takeoff to 5m
--    c) flies a vertical circle using the velocity controller
--    d) switches to RTL mode

local takeoff_alt_above_home = 5
local copter_guided_mode_num = 4
local copter_rtl_mode_num = 6
local stage = 0
local circle_angle = 0
local circle_angle_increment = 1    -- increment the target angle by 1 deg every 0.1 sec (i.e. 10deg/sec)
local circle_speed = 1              -- velocity is always 1m/s
local yaw_cos = 0                   -- cosine of yaw at takeoff
local yaw_sin = 0                   -- sine of yaw at takeoff

-- the main update function that uses the takeoff and velocity controllers to fly a rough square pattern
function update()
  if not arming:is_armed() then -- reset state when disarmed
    stage = 0
    circle_angle = 0
  else
    pwm6 = rc:get_pwm(6)
    if pwm6 and pwm6 > 1800 then    -- check if RC6 input has moved high
      if (stage == 0) then          -- change to guided mode
        if (vehicle:set_mode(copter_guided_mode_num)) then  -- change to Guided mode
          local yaw_rad = ahrs:get_yaw_rad()
          yaw_cos = math.cos(yaw_rad)
          yaw_sin = math.sin(yaw_rad)
          stage = stage + 1
        end
      elseif (stage == 1) then      -- Stage1: takeoff
        if (vehicle:start_takeoff(takeoff_alt_above_home)) then
          stage = stage + 1
        end
      elseif (stage == 2) then      -- Stage2: check if vehicle has reached target altitude
        local home = ahrs:get_home()
        local curr_loc = ahrs:get_location()
        if home and curr_loc then
          local vec_from_home = home:get_distance_NED(curr_loc)
          gcs:send_text(0, "alt above home: " .. tostring(math.floor(-vec_from_home:z())))
          if (math.abs(takeoff_alt_above_home + vec_from_home:z()) < 1) then
            stage = stage + 1
            bottom_left_loc = curr_loc          -- record location when starting square
          end
        end
      elseif (stage == 3 ) then   -- Stage3: fly a vertical circle

        -- calculate velocity vector
        circle_angle = circle_angle + circle_angle_increment
        if (circle_angle >= 360) then
          stage = stage + 1
        end
        local target_vel = Vector3f()
        local vel_xy = math.cos(math.rad(circle_angle)) * circle_speed
        target_vel:x(yaw_sin * vel_xy)
        target_vel:y(yaw_cos * -vel_xy)
        target_vel:z(-math.sin(math.rad(circle_angle)) * circle_speed)

        -- send velocity request
        if not (vehicle:set_target_velocity_NED(target_vel)) then
          gcs:send_text(0, "failed to execute velocity command")
        end
      elseif (stage == 4) then  -- Stage4: change to RTL mode
        vehicle:set_mode(copter_rtl_mode_num)
        stage = stage + 1
        gcs:send_text(0, "finished square, switching to RTL")
      end
    end
  end

  return update, 100
end

return update()



================================================
File: examples/copter-nav-script-time.lua
================================================
-- Copter perform a simple maneuver in response to a NAV_SCRIPT_TIME mission command while the vehicle is in Auto mode
--
-- Create a simple mission like below
-- TAKEOFF, Alt:10m
-- NAV_SCRIPT_TIME, command=0 (not used in this script), timeout=30 (seconds), arg1=5 (square width in meters), arg2=10 (square height in meters)
-- RETURN-TO-LAUNCH
--
-- Arm the vehicle (in Loiter mode), switch to Auto and raise the throttle
-- The vehicle should climb to 10m
-- This lua script will be fly the vehicle in square pattern in clockwise direction at the current altitude
-- "arg1" specifies the width (e.g. East-West) in meters
-- "arg2" specifies the height (e.g. North-South) in meters
-- Once the vehicle completes the square or the timeout expires the mission will continue and the vehicle should RTL home

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: need-check-nil

local running = false
local last_id = -1          -- unique id used to detect if a new NAV_SCRIPT_TIME command has started
local start_loc             -- vehicle's location when command starts (South-West corner of square)
local target_loc            -- vehicle's target location
local stage = 0             -- stage0: fly North arg2 meters
                            -- stage1: fly East arg1 meters
                            -- stage2: fly South arg2 meters
                            -- stage3: fly West arg2 meters
                            -- stage4: done
local prev_stage = -1       -- previous stage, used to initate call to move to next corner

function update()
  id, cmd, arg1, arg2, arg3, arg4 = vehicle:nav_script_time()
  if id then
    -- handle start of new command
    if id ~= last_id then
      start_loc = ahrs:get_location()       -- initialise south-west corner of square
      if start_loc then
        running = true
        last_id = id
        stage = 0                           -- start heading North
        prev_stage = -1
      else
        gcs:send_text(0, "nav-script-time: failed to get location")
        running = false
      end
    end

    -- set waypoint target according to stage
    if (running and stage ~= prev_stage) then
      prev_stage = stage
      local corner_loc = start_loc:copy()   -- initialise target location to starting location
      if (stage == 0) then
        corner_loc:offset(arg2, 0)          -- North West corner
      end
      if (stage == 1) then
        corner_loc:offset(arg2, arg1)       -- North East corner
      end
      if (stage == 2) then
        corner_loc:offset(0, arg1)          -- South East corner
      end
      -- stage 3 is back to start_loc
      if vehicle:set_target_location(corner_loc) then
        target_loc = corner_loc
      else
        gcs:send_text(0, "nav-script-time: failed to set target")
        vehicle:nav_script_time_done(last_id)
        running = false
      end
    end

    -- advance stage if we have reached within 1m of target
    if running then
      local curr_loc = ahrs:get_location()
      if curr_loc then
        local dist_m = curr_loc:get_distance(target_loc)
        if (dist_m < 1.0) then
          stage = stage + 1
          if stage == 4 then
            vehicle:nav_script_time_done(last_id)
            running = false
          end
        end
      else
        gcs:send_text(0, "nav-script-time: failed to get location")
      end
    end
  else
    -- no active command
    running = false
  end

  return update, 100                        -- update at 10hz
end

return update()



================================================
File: examples/copter-posoffset.lua
================================================
-- Example showing how a position offset can be added to a Copter's auto mission plan
--
-- CAUTION: This script only works for Copter
-- this script waits for the vehicle to be armed and in auto mode and then
-- adds an offset to the position or velocity target
--
-- How To Use
-- 1. copy this script to the autopilot's "scripts" directory
-- 2. set PSC_OFS_xx parameter to the desired position OR velocity offsets desired
-- 3. fly the vehicle in Auto mode (or almost any mode)
-- 4. use the Scripting1 aux switch to enable and disable the offsets

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- setup script specific parameters
local PARAM_TABLE_KEY = 71
local PARAM_TABLE_PREFIX = "PSC_OFS_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'could not add param table')
 
-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
  assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', PARAM_TABLE_PREFIX .. name))
  return Parameter(PARAM_TABLE_PREFIX .. name)
end

--[[
  // @Param: PSC_OFS_POS_N
  // @DisplayName: Position Controller Position Offset North
  // @Description: Position controller offset North
  // @Range: 0 1000
  // @Units: m
  // @User: Standard
--]]
local PSC_OFS_POS_N = bind_add_param("POS_N", 1, 0)

--[[
  // @Param: PSC_OFS_POS_E
  // @DisplayName: Position Controller Position Offset East
  // @Description: Position controller offset North
  // @Range: 0 1000
  // @Units: m
  // @User: Standard
--]]
local PSC_OFS_POS_E = bind_add_param("POS_E", 2, 0)

--[[
  // @Param: PSC_OFS_POS_D
  // @DisplayName: Position Controller Position Offset Down
  // @Description: Position controller offset Down
  // @Range: 0 1000
  // @Units: m
  // @User: Standard
--]]
local PSC_OFS_POS_D = bind_add_param("POS_D", 3, 0)

--[[
  // @Param: PSC_OFS_VEL_N
  // @DisplayName: Position Controller Velocity Offset North
  // @Description: Position controller velocity offset North
  // @Range: 0 10
  // @Units: m/s
  // @User: Standard
--]]
local PSC_OFS_VEL_N = bind_add_param("VEL_N", 4, 0)

--[[
  // @Param: PSC_OFS_VEL_E
  // @DisplayName: Position Controller Velocity Offset East
  // @Description: Position controller velocity offset East
  // @Range: 0 10
  // @Units: m/s
  // @User: Standard
--]]
local PSC_OFS_VEL_E = bind_add_param("VEL_E", 5, 0)

--[[
  // @Param: PSC_OFS_VEL_D
  // @DisplayName: Position Controller Velocity Offset Down
  // @Description: Position controller velocity offset Down
  // @Range: 0 10
  // @Units: m/s
  // @User: Standard
--]]
local PSC_OFS_VEL_D = bind_add_param("VEL_D", 6, 0)

-- local variables
local aux_sw_pos_last = 0

-- welcome message to user
gcs:send_text(MAV_SEVERITY.INFO, "copter-posoffset.lua loaded")

function update()

  -- must be armed, flying and in auto mode
  if (not arming:is_armed()) or (not vehicle:get_likely_flying()) then
    return update, 1000
  end

  -- Scripting1 aux switch enables/disables offsets
  local aux_sw_pos = rc:get_aux_cached(300)
  if aux_sw_pos == nil then
    aux_sw_pos = 0
  end

  -- check for change in aux switch position
  if aux_sw_pos ~= aux_sw_pos_last then
    aux_sw_pos_last = aux_sw_pos
    if aux_sw_pos == 0 then
      -- if switch is in low position clear offsets
      if poscontrol:set_posvelaccel_offset(Vector3f(), Vector3f(), Vector3f()) then
        gcs:send_text(MAV_SEVERITY.ERROR, "copter-posoffset: offsets cleared")
        return update, 1000
      else
        gcs:send_text(MAV_SEVERITY.ERROR, "copter-posoffset: failed to clear offsets")
      end
    else
      gcs:send_text(MAV_SEVERITY.ERROR, "copter-posoffset: offsets activated")
    end
  end

  if aux_sw_pos == 0 then
    return update, 1000
  end

  local pos_offsets_zero = PSC_OFS_POS_N:get() == 0 and PSC_OFS_POS_E:get() == 0 and PSC_OFS_POS_D:get() == 0
  local vel_offsets_zero = PSC_OFS_VEL_N:get() == 0 and PSC_OFS_VEL_E:get() == 0 and PSC_OFS_VEL_D:get() == 0

  -- if position offsets are non-zero or all offsets are zero then send position offsets
  if not pos_offsets_zero or vel_offsets_zero then
    -- set the position offset in meters in NED frame
    local pos_offset_NED = Vector3f()
    pos_offset_NED:x(PSC_OFS_POS_N:get())
    pos_offset_NED:y(PSC_OFS_POS_E:get())
    pos_offset_NED:z(PSC_OFS_POS_D:get())
    if not poscontrol:set_posvelaccel_offset(pos_offset_NED, Vector3f(), Vector3f()) then
      gcs:send_text(MAV_SEVERITY.ERROR, "copter-posoffset: failed to set pos offset")
    end
    test_position = not pos_offsets_zero
  else
    -- first get position offset (cumulative effect of velocity offsets)
    local pos_offset_NED, _, _ = poscontrol:get_posvelaccel_offset()
    if pos_offset_NED == nil then
        print("unable to get position offset")
        pos_offset_NED = Vector3f()
    end
    -- test velocity offsets in m/s in NED frame
    local vel_offset_NED = Vector3f()
    vel_offset_NED:x(PSC_OFS_VEL_N:get())
    vel_offset_NED:y(PSC_OFS_VEL_E:get())
    vel_offset_NED:z(PSC_OFS_VEL_D:get())
    if not poscontrol:set_posvelaccel_offset(pos_offset_NED, vel_offset_NED, Vector3f()) then
      gcs:send_text(MAV_SEVERITY.ERROR, "copter-posoffset: failed to set vel offset")
    end
  end

  -- update at 1hz
  return update, 1000
end

return update()



================================================
File: examples/copter-wall-climber.lua
================================================
-- command a Copter to climb a wall at a specific distance
--
-- CAUTION: This script only works for Copter
--    a) waits for the vehicle to be switched to Guided mode (does nothing)
--    b) accepts pilot roll, pitch, throttle and yaw input
--    c) manual mode
--        - roll and pitch cause vehicle to fly horizontally in body frame at up to WP_SPEED
--        - yaw controls turn rate
--        - throttle controls climb/descent rate at up to PILOT_SPEED_UP/DOWN?  (WP_SPEED_UP, WPNAV_SPEED_DN?)
--    d) autonomous mode
--        - roll is unchanged from manual mode
--        - yaw is unchanged from manual mode
--        - pitch controls target distance to wall (limited to no less than 2m, no more than 8m)
--        - throttle input causes vehicle to switch back to manual mode
--        - climbs at 50cm/s (need parameter?) stopping at 2m intervals
--    e) ZIGZAG_SaveWP aux switch controls switching in and out of auto mode

-- constants
local update_rate_ms = 10           -- script updates at 100hz
local update_rate_dt = update_rate_ms / 1000.0 -- update rate in seconds
local copter_guided_mode_num = 4    -- Copter's guided flight mode is mode 4
local aux_switch_function = 61      -- auxiliary switch function controlling mode.  61 is ZIGZAG_SaveWP
local climb_accel_max = 0.25        -- climb rate acceleration max in m/s/s
local climb_rate_max = 2            -- climb rate max in m/s
local climb_rate_chg_max = climb_accel_max * update_rate_dt -- max change in climb rate in a single iteration
local roll_pitch_speed_max = 2      -- horizontal speed max in m/s
local roll_pitch_accel_max = 0.25      -- horizontal acceleration max in m/s/s
local roll_pitch_speed_chg_max = roll_pitch_accel_max * update_rate_dt  -- max change in roll or pitch speed in a single iteration
local rc_roll_ch = 1                -- RC input channel for roll
local rc_pitch_ch = 2               -- RC input channel for pitch
local rc_throttle_ch = 3            -- RC input channel for throttle
local rc_pwm_dz = 50                -- RC input deadzone in pwm
local wall_pitch_speed_max = roll_pitch_speed_max / 2.0 -- wall control will never overpower pilot
local wall_dist_to_speed_P = 0.5    -- P gain for converting distance to wall to forward speed
local climb_pause_sec = 3           -- pause for this many seconds during each interval
local climb_pause_counter_max = climb_pause_sec / update_rate_dt -- pause control's loop counter's initial value

-- user parmeters
local climb_dist_max = 10           -- vehicle moves to next lane at this many meters above home
local climb_stop_interval = 1       -- vehicle stops after climbing this many meters
local lane_width = 2                -- each lane is 2m apart horizontally

-- lane variables
local lane_number = 0               -- current lane number
local lane_shift_roll_speed = 1     -- vehicle moves right at this speed in m/s
local lane_shift_counter_max = lane_width / (lane_shift_roll_speed * update_rate_dt)
local lane_shift_counter = 0        -- current lane shift counter value
local lane_climb_rate = climb_rate_max / 2.0 -- autonomous climb is always 1/2 maximum

-- global variables
local aux_sw_pos_prev = 0           -- aux switch previous position
local climb_mode = 0                -- 0:manual, 1:automatic climb
local climb_rate = 0                -- current climb rate (negative is down, positive is up)
local climb_total = 0               -- total number of meters above home
local climb_interval_total = 0      -- meters climbed since last stop
local climb_pause_counter = 0       -- current pause counter value
local roll_speed = 0                -- target horizontal roll speed in m/s
local pitch_speed = 0               -- target horizontal pitch speed in m/s
local wall_dist_target = 5          -- target distance to wall

-- get the maximum speed in order to decelerate to zero within the given distance
function get_speed_max(distance, accel_max)
  return math.sqrt(2.0 * math.max(0, distance) * accel_max)
end

-- the main update function that uses the takeoff and velocity controllers to fly a rough square pattern
function update()

  -- reset state when disarmed
  if not arming:is_armed() then
    climb_mode = 0
    climb_rate = 0
    climb_total = 0
    climb_pause_counter = 0
    climb_interval_total = 0
    roll_speed = 0
    pitch_speed = 0
    lane_number = 0
    lane_shift_counter = 0
    lane_climb_rate = math.abs(lane_climb_rate)
    return update, update_rate_ms
  end

  -- if not in Guided mode do nothing
  if vehicle:get_mode() ~= copter_guided_mode_num then
    return update, update_rate_ms
  end

  -- read switch input from RCx_FUNCTION
  local aux_switch = rc:find_channel_for_option(aux_switch_function)
  if aux_switch then
    local sw_pos = aux_switch:get_aux_switch_pos()
    if (sw_pos ~= aux_sw_pos_prev) then
      -- only process input if switch position changed
      aux_sw_pos_prev = sw_pos
      if (sw_pos == 0) then
        -- pilot has selected manual mode
        if (climb_mode ~= 0) then
          gcs:send_text(0, "WallClimb: pilot switch to Manual")
          climb_mode = 0
        end
      elseif (sw_pos == 2) then
        -- pilot has selected auto mode
        if (climb_mode ~= 1) then
          gcs:send_text(0, "WallClimb: pilot switch to Auto")
          climb_mode = 1
        end
      end
    end
  end

  -- read normalised roll, pitch and throttle input
  local roll_input = 0
  local rc_roll_pwm = rc:get_pwm(rc_roll_ch)
  if (rc_roll_pwm and rc_roll_pwm >= 1000 and rc_roll_pwm <= 2000 and (math.abs(rc_roll_pwm - 1500) > rc_pwm_dz)) then
    roll_input = (rc_roll_pwm - 1500) / 500.0
  end
  local pitch_input = 0
  local rc_pitch_pwm = rc:get_pwm(rc_pitch_ch)
  if (rc_pitch_pwm and rc_pitch_pwm >= 1000 and rc_pitch_pwm <= 2000 and (math.abs(rc_pitch_pwm - 1500) > rc_pwm_dz)) then
    pitch_input = (rc_pitch_pwm - 1500) / 500.0
  end
  local throttle_input = 0
  local rc_throttle_pwm = rc:get_pwm(rc_throttle_ch)
  if (rc_throttle_pwm and rc_throttle_pwm >= 1000 and rc_throttle_pwm <= 2000 and (math.abs(rc_throttle_pwm - 1500) > rc_pwm_dz)) then
    throttle_input = (rc_throttle_pwm - 1500) / 500.0
  end

  -- manual mode
  if (climb_mode == 0) then
    -- update target climb rate
    local climb_rate_target = throttle_input * climb_rate_max
    climb_rate = math.min(climb_rate_target, climb_rate + climb_rate_chg_max, climb_rate_max)
    climb_rate = math.max(climb_rate_target, climb_rate - climb_rate_chg_max, -climb_rate_max)
  end

  -- autonomous mode
  local wall_pitch_speed = 0
  local wall_roll_speed = 0
  if (climb_mode == 1) then
    -- convert rangefinder distance to pitch speed
    if rangefinder:has_data_orient(0) then
      local distance_m = rangefinder:distance_orient(0)
      wall_pitch_speed = (distance_m - wall_dist_target) * wall_dist_to_speed_P
      wall_pitch_speed = math.min(wall_pitch_speed, wall_pitch_speed_max)
      wall_pitch_speed = math.max(wall_pitch_speed, -wall_pitch_speed_max)
    end

    -- switch to manual if pilot provides throttle input
    if (math.abs(throttle_input) ~= 0) then
      gcs:send_text(0, "WallClimb: throttle input, switch to Manual")
      climb_mode = 0
    else
      -- update distance climbed
      local climb_chg = climb_rate * update_rate_dt
      climb_interval_total = climb_interval_total + climb_chg
      climb_total = climb_total + climb_chg

      -- determine if we should pause
      local dist_to_interval = climb_stop_interval - math.abs(climb_interval_total)
      if (dist_to_interval <= 0) then
        gcs:send_text(0, "WallClimb: pausing at " .. string.format("%3.1f", climb_total) .. "m")
        climb_pause_counter = climb_pause_counter_max
        climb_interval_total = 0

        -- determine if we should move to next lane
        if ((climb_total > climb_dist_max) or (climb_total <= 0)) then
          lane_number = lane_number + 1
          lane_climb_rate = -lane_climb_rate
          lane_shift_counter = lane_shift_counter_max
          gcs:send_text(0, "WallClimb: starting lane " .. tostring(lane_number))
        end
      end

      -- default target climb rate to lane climb rate
      local climb_rate_target = lane_climb_rate

      -- limit target speed so vehicle can stop before next interval
	  -- speed limit is always at least 0.1m/s so copter doesn't get stuck near interval
      local speed_max = math.max(get_speed_max(dist_to_interval, climb_accel_max), 0.1)
      climb_rate_target = math.max(climb_rate_target, -speed_max)
      climb_rate_target = math.min(climb_rate_target, speed_max)

      -- if paused set target climb rate to zero
      if (climb_pause_counter > 0) then
        climb_pause_counter = climb_pause_counter - 1
        climb_rate_target = 0
        if (climb_pause_counter == 0) then
          gcs:send_text(0, "WallClimb: restarting")
        end
      end

      -- if shifting lanes pause climb and roll right
      if (lane_shift_counter > 0) then
        lane_shift_counter = lane_shift_counter - 1
        wall_roll_speed = lane_shift_roll_speed
        climb_rate_target = 0
        -- if completing lane shift trigger another pause
        if (lane_shift_counter == 0) then
          climb_pause_counter = climb_pause_counter_max
        end
      end

      -- calculate acceleration limited climb rate
      if (climb_rate_target >= climb_rate) then
        climb_rate = math.min(climb_rate_target, climb_rate + climb_rate_chg_max, climb_rate_max)
      else
        climb_rate = math.max(climb_rate_target, climb_rate - climb_rate_chg_max, -climb_rate_max)
      end
    end
  end

  -- update target roll using both pilot and autonomous control (+ve right, -ve left)
  local roll_speed_target = roll_input * roll_pitch_speed_max + wall_roll_speed
  roll_speed = math.min(roll_speed_target, roll_speed + roll_pitch_speed_chg_max, roll_pitch_speed_max)
  roll_speed = math.max(roll_speed_target, roll_speed - roll_pitch_speed_chg_max, -roll_pitch_speed_max)

  -- update target pitch using both pilot and autonomous control (+ve forward, -ve backwards)
  local pitch_speed_target = -pitch_input * roll_pitch_speed_max + wall_pitch_speed
  pitch_speed = math.min(pitch_speed_target, pitch_speed + roll_pitch_speed_chg_max, roll_pitch_speed_max)
  pitch_speed = math.max(pitch_speed_target, pitch_speed - roll_pitch_speed_chg_max, -roll_pitch_speed_max)

  -- convert targets from body to earth frame and send to guided mode velocity controller
  local yaw_rad = ahrs:get_yaw_rad()
  yaw_cos = math.cos(yaw_rad)
  yaw_sin = math.sin(yaw_rad)
  local target_vel_ned = Vector3f()
  target_vel_ned:x(pitch_speed * yaw_cos - roll_speed * yaw_sin)
  target_vel_ned:y(pitch_speed * yaw_sin + roll_speed * yaw_cos)
  target_vel_ned:z(-climb_rate)
  if not (vehicle:set_target_velocity_NED(target_vel_ned)) then
    gcs:send_text(0, "failed to execute velocity command")
  end

  return update, update_rate_ms
end

return update()



================================================
File: examples/copter_alt_offset.lua
================================================
--[[
 add ALT_OFFSET parameter for copter
 This behaves similarly to ALT_OFFSET in plane. It operates only in AUTO mode, and slews the BARO_ALT_OFFSET to allow
 for change of altitude without mission change.
--]]


local PARAM_TABLE_KEY = 79
local PARAM_TABLE_PREFIX = "ALT_"

local MODE_AUTO = 3

local LOOP_RATE = 50

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup SHIP specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')
ALT_OFFSET    = bind_add_param('OFFSET', 1, 0)
ALT_OFFSET_RT = bind_add_param('OFFSET_RT', 2, 1)
BARO_ALT_OFFSET = bind_param("BARO_ALT_OFFSET")

local vehicle_mode = nil

-- constrain a value between limits
function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end

-- main update function
function update()
   vehicle_mode = vehicle:get_mode()

   if vehicle_mode ~= MODE_AUTO then
      BARO_ALT_OFFSET:set(0)
      return
   end

   if not arming:is_armed() then
      -- zero offset when disarmed
      BARO_ALT_OFFSET:set(0)
      ALT_OFFSET:set(0)
   end
   
   local target = ALT_OFFSET:get() * -1.0

   local current = BARO_ALT_OFFSET:get()
   local delta = target - current
   local dt = 1.0 / LOOP_RATE
   local delta_max = ALT_OFFSET_RT:get() * dt

   delta = constrain(delta, -delta_max, delta_max)
   BARO_ALT_OFFSET:set(current + delta)
end

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 1000/LOOP_RATE
end

gcs:send_text(0, "ALT_OFFSET handler loaded")

-- start running update loop
return protected_wrapper()




================================================
File: examples/copter_deploy.lua
================================================
--[[
   script to auto-deploy a vehicle on descent after reaching a specified altitude
   uses raw pressure to not depend on either GPS or on home alt
--]]
local PARAM_TABLE_KEY = 72
local PARAM_TABLE_PREFIX = "DEPL_"
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
---@diagnostic disable: param-type-mismatch

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')

local end_pos    = bind_add_param('OPEN_POS',    1, 1200)
local offset     = bind_add_param('OPEN_OFFSET', 2, 400)
local deployment_alt = bind_add_param('ALT', 3, 1)
local DEPL_CLIMB_ALT = bind_add_param('CLIMB_ALT', 4, 2)
local base_pressure = nil
local SERVO_FUNCTION = 94
local reached_climb_alt = false
local deployed = false

local MODE_LAND = 9

function update_state()
   local pressure = baro:get_pressure()
   if not pressure then
      return
   end
   if not base_pressure then
      base_pressure = pressure
   end
   local altitude = baro:get_altitude_difference(base_pressure, pressure)
   if not altitude then
      return
   end
   gcs:send_named_float('DALT',altitude)
   logger.write("DEPL",'BP,P,Alt','fff',
                base_pressure, pressure, altitude)
   if not reached_climb_alt then
      local start_pos = end_pos:get() + offset:get()
      SRV_Channels:set_output_pwm(SERVO_FUNCTION, start_pos)
      if altitude > DEPL_CLIMB_ALT:get() then
         reached_climb_alt = true
         gcs:send_text(MAV_SEVERITY.ERROR, "DEPL: Reached climb alt")
      end
      return
   end
   if deployed then
      return
   end
   if altitude > deployment_alt:get() then
      return
   end
   deployed = true
   gcs:send_text(MAV_SEVERITY.INFO, "DEPL: deploying")
   vehicle:set_mode(MODE_LAND)
   arming:arm_force()
   if (vehicle:get_mode() ~= MODE_LAND) or not arming:is_armed() then
      gcs:send_text(MAV_SEVERITY.INFO, "DEPL: Arming failed")
      return
   end
   --SRV_Channels:set_output_pwm(SERVO_FUNCTION, end_pos:get())
   gcs:send_text(MAV_SEVERITY.INFO, "DEPL: Deployed successfully")
end
function update() -- this is the loop which periodically runs
   update_state()
   return update, 20 -- Reschedules the loop at 50Hz
end
gcs:send_text(MAV_SEVERITY.INFO, "DEPL: loaded")
return update() -- Run immediately before starting to reschedule



================================================
File: examples/copter_pingpong.lua
================================================
-- This script makes the drone go forward and backward at a defined distance and number of times.
-- The stages are:
-- 0) Change to Guided mode
-- 1) Takeoff to the height defined by takeoff_alt
-- 2) Wait until reaching the takeoff altitude
-- 3) Go forward to the defined distance
-- 4) Go back to the initial position
-- 5) Change to Land mode

local takeoff_alt = 3         -- Takeoff height
local copter_guided_mode_num = 4
local copter_land_mode_num = 9
local stage = 0
local count = 0               -- Number of times the drone has gone forward
local max_count = 2           -- Maximum number of times the drone should go forward
local ping_pong_distance = 10 -- Distance up to which the drone should go forward (m)
local vel = 1                 -- Drone velocity (m/s)

function update()
    -- Checking if the drone is armed
    if not arming:is_armed() then
         -- Reset state when disarmed
        stage = 0
        gcs:send_text(6, "Arming")
    else
        if stage == 0 then      -- Stage0: Change to guided mode
              if vehicle:set_mode(copter_guided_mode_num) then -- Change to Guided mode
                  stage = stage + 1
              end

        elseif stage == 1 then -- Stage1: Takeoff
        gcs:send_text(6, "Taking off")
            if vehicle:start_takeoff(takeoff_alt) then
                stage = stage + 1
            end
            
        elseif stage == 2 then -- Stage2: Check if the vehicle has reached the target altitude
            local home = ahrs:get_home()
            local curr_loc = ahrs:get_position()
            if home and curr_loc then 
                local vec_from_home = home:get_distance_NED(curr_loc)
                gcs:send_text(6, "Altitude above home: " .. tostring(math.floor(-vec_from_home:z())))
                if math.abs(takeoff_alt + vec_from_home:z()) < 1 then
                    stage = stage + 1
                end
            end
        elseif stage == 3 then -- Stage3: Moving Forward
        -- If the number of times is exceeded, switch to stage5
            if count >= max_count then
                stage = stage + 2
            end

                -- Calculate velocity vector
                local target_vel = Vector3f()
                target_vel:x(vel)
                target_vel:y(0)
                target_vel:z(0)

                -- Send velocity request
                if not vehicle:set_target_velocity_NED(target_vel) then
                    gcs:send_text(6, "Failed to execute velocity command")
                end
                
                -- Checking if the stop point is reached
                local home = ahrs:get_home()
                local curr_loc = ahrs:get_position()
                if home and curr_loc then 
                    local vec_from_home = home:get_distance_NED(curr_loc)
                    gcs:send_text(6, "Distance from home: " .. tostring(math.floor(vec_from_home:x())))
                    if math.abs(ping_pong_distance - vec_from_home:x()) < 1 then
                        count = count + 1
                        stage = stage + 1
                    end
                end
            
        elseif stage == 4 then -- Stage4: Moving Back
            -- Calculate velocity vector
            local target_vel = Vector3f()
            target_vel:x(-vel)
            target_vel:y(0)
            target_vel:z(0)

            -- Send velocity request
            if not vehicle:set_target_velocity_NED(target_vel) then
                gcs:send_text(6, "Failed to execute velocity command")
            end
            
            -- Checking if the stop point is reached
            local home = ahrs:get_home()
            local curr_loc = ahrs:get_position()
            if home and curr_loc then 
                local vec_from_home = home:get_distance_NED(curr_loc)
                gcs:send_text(6, "Distance from home: " .. tostring(math.floor(vec_from_home:x())))
                if math.abs(vec_from_home:x()) < 1 then
                    stage = stage - 1
                end
            end
              
          elseif stage == 5 then -- Stage5: Change to land mode
              vehicle:set_mode(copter_land_mode_num)
              stage = stage + 1
              gcs:send_text(6, "Finished pingpong, switching to land")
          end
        end
    return update, 100
end

return update()


================================================
File: examples/copter_pingpong.md
================================================
# Drone Ping-Pong Code

This script makes the drone go forward and backward a defined distance and number of times.


## Stages
- 0: Change to Guided mode
- 1: Takeoff to the height defined by `takeoff_alt`
- 2: Wait until reaching the takeoff altitude
- 3: Go forward to the defined distance
- 4: Go back to the initial position
- 5: Change to Land mode

## Variables:
- `takeoff_alt`: Takeoff height (m)
- `copter_guided_mode_num`: Guided mode number
- `copter_land_mode_num`: Land mode number
- `stage`: current stage
- `count`: Number of times the drone has gone forward
- `max_count`: Maximum number of times the drone should go forward
- `ping_pong_distance`: Distance up to which the drone should go forward (m)
- `vel`: Drone velocity (m/s)

## Understand the code:
First, there is a comment explaining what the code is about and how it works. Then, the local variables that will be used are declared.
 The `copter_guided_mode_num` and `copter_land_mode_num `are standard numbers, defined by ArduPilot, for the Guided and Land flight modes, respectively. The other variables are user-defined settings according to the desired behavior, as indicated in the comments in front of each one.

```lua
-- This script makes the drone go forward and backward at a defined distance and number of times.
-- The stages are:
-- 0) Change to Guided mode
-- 1) Takeoff to the height defined by takeoff_alt
-- 2) Wait until reaching the takeoff altitude
-- 3) Go forward to the defined distance
-- 4) Go back to the initial position
-- 5) Change to Land mode


local takeoff_alt = 3         -- Takeoff height
local copter_guided_mode_num = 4
local copter_land_mode_num = 9
local stage = 0
local count = 0               -- Number of times the drone has gone forward
local max_count = 2           -- Maximum number of times the drone should go forward
local ping_pong_distance = 10 -- Distance up to which the drone should go forward (m)
local vel = 1    

```
Next, there's the main function of the code, the `update()` function, which will be called once the code is started (since it wasn't indicated a waiting time at the last line of the code) and its `return` indicates that this same fucntion will be called again 100ms after finishing its executuion.



```lua
function update()
    -- [Code]
    return update(), 100
end

return update()
```

In the presented if, the code is waiting for the drone to be armed to change to the next stage. The is_armed() function from the arming library is used to check if the drone is armed or not. The send_text() function from the gcs library is used to send a message ("Arming") with severity 6 (information) to the GCS (Ground Control Station). Thus, while the drone is not armed, it remains in stage 0 of the code.

``` lua
if not arming:is_armed() then
    stage = 0
    gcs:send_text(6, "Arming")
```
If the drone is armed, it moves to the else section, which presents a behavior for each stage.
In `stage 0`, the drone flight mode is changed to GUIDED MODE. To do this, it's used the function `set_mode()` of `vehicle` library, which receives the desired flight mode number(copter_guided_mode_num, defined in the local variables). When it verifies the drone has switched to the desired flight mode, it moves to the next stage. 


``` lua
else
    if stage == 0 then
        if vehicle:set_mode(copter_guided_mode_num) then 
            stage = stage + 1
        end
``` 
in stage 1, it's used the `start_takeoff()` function from the `vehicle` library for the drone to take off to a height defined by the variable `takeoff_alt`.

``` lua
elseif stage == 1 then
    gcs:send_text(6, "Taking off")
    if vehicle:start_takeoff(takeoff_alt) then
        stage = stage + 1
    end
``` 

In stage 2, it's used the `ahrs:get_home()` function to get the drone's takeoff location, and the `ahrs:get_position()` function to get the drone's current position. In line 4, it checks that the obtained values are not null. Then, the `home:get_distance_NED()` function stores in `vec_from_home` a 3D vector, starting from `curr_loc` and ending at `home`. In line 7, the code sends to the GCS the value contained in the z-coordinate of `vec_from_home`, i.e., the current altitude of the drone (multiplied by -1 since the vector points towards home, which is at a lower altitude than the current position).

When the difference between `takeoff_alt` and `vec_from_home:z()` is less than 1, indicating that the drone has reached the takeoff altitude, it moves to the next stage (`math.abs()` is used to get the absolute value, and we performed an addition instead of subtraction because the z component is negative).

``` lua
elseif stage == 2 then
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_position()
    if home and curr_loc then 
        local vec_from_home = home:get_distance_NED(curr_loc)
        gcs:send_text(6, "Altitude above home: " .. tostring(math.floor(-vec_from_home:z())))
        if math.abs(takeoff_alt + vec_from_home:z()) < 1 then
            stage = stage + 1
        end
    end
``` 

In `stage3`, first, the drone checks if it has already performed all the requested loops specified in `max_count`. If so, it switches to `stage5`. If not, it executes the commands of `stage3`.

First, it creates a 3D vector `target_vel` to store the desired velocity. Then, it sets the value of each of the components of this created vector (0 for y and z, and `vel` for x).

Then, it uses the `vehicle:set_target_velocity_NED(target_vel)` function to set the drone's velocity as that of `target_vel`. If it encounters any issues, it sends a warning message.


``` lua
elseif (stage == 3) then -- Stage 3: Moving Forward
    -- If the maximum number of times is exceeded, move to stage 5
    if (count >= max_count) then
        stage = stage + 2
    end

    -- Calculate velocity vector
    local target_vel = Vector3f()
    target_vel:x(vel)
    target_vel:y(0)
    target_vel:z(0)

    -- Send velocity request
    if not (vehicle:set_target_velocity_NED(target_vel)) then
        gcs:send_text(6, "Failed to execute velocity command")
    end

``` 

After that, it uses the same strategy as shown before to calculate the distance vector from the takeoff location to verify the distance `x` traveled. When the difference between the distance `x` that the drone traveled and the `ping_pong_distance` is less than 1, it increments the `count` and moves to the next stage.
``` lua

    -- checking if reached stop point
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_position()
    if home and curr_loc then 
        local vec_from_home = home:get_distance_NED(curr_loc)
        gcs:send_text(6, "Distance from home: " .. tostring(math.floor(vec_from_home:x())))
        if(math.abs(ping_pong_distance - vec_from_home:x()) < 1) then
            count = count + 1
            stage = stage + 1
        end
    end
end

``` 
In `Stage4`, the velocity in `x` is multiplied by -1 for the drone to fly in the opposite direction, returning to the takeoff position. When the difference between the drone's position `x` and the takeoff position's `x` is less than 1, it goes back to `Stage3` to start the forward movement again (or not, if the `count` has reached `max_count`).

``` lua
elseif (stage == 4) then -- Stage 4: Moving Back
    -- calculate velocity vector
    local target_vel = Vector3f()
    target_vel:x(-vel)
    target_vel:y(0)
    target_vel:z(0)

    -- send velocity request
    if not (vehicle:set_target_velocity_NED(target_vel)) then
        gcs:send_text(6, "Failed to execute velocity command")
    end

    -- checking if reached stop point
    local home = ahrs:get_home()
    local curr_loc = ahrs:get_position()
    if home and curr_loc then 
        local vec_from_home = home:get_distance_NED(curr_loc)
        gcs:send_text(6, "Distance from home: " .. tostring(math.floor(vec_from_home:x())))
        if(math.abs(vec_from_home:x()) < 1) then
            stage = stage - 1
        end
    end
end

``` 
In `stage5`, the drone simply changes to the Land flight mode and lands, indicating the completion of the code through a message.
``` lua
elseif (stage == 5) then -- Stage 5: Change to LAND mode
    vehicle:set_mode(copter_rtl_mode_num)
    stage = stage + 1
    gcs:send_text(6, "Finished pingpong, switching to LAND")
end

``` 




================================================
File: examples/copy_userdata.lua
================================================
--[[
 An example of using the copy() method on userdata
--]]


local loc1 = Location()
loc1:lat(-35)
loc1:lng(-122)

-- if we did this as loc2 = loc1 then it actually takes a reference
-- by using copy() we get the intended behaviour
local loc2 = loc1:copy()
loc2:offset(3000,5000)

local diff = loc1:get_distance_NE(loc2)
gcs:send_text(0,string.format("locdiff=(%.2f,%.2f)", diff:x(), diff:y()))

local v1 = Vector2f()
v1:x(-35)
v1:y(-122)

local v2 = v1:copy()
v2:x(v2:x()+100)
v2:y(v2:y()+300)

diff = v2 - v1
gcs:send_text(0,string.format("vdiff=(%.2f,%.2f)", diff:x(), diff:y()))



================================================
File: examples/crosstrack_restore.lua
================================================
--[[

   example script to show interrupting a mission and then 
   reseting the crosstracking to the correct line when
   returning to the mission after the interruption

   this functionality is only available in Plane
--]]

SCRIPT_NAME = "Crosstrack Restore"
SCRIPT_NAME_SHORT = "XTrack"
SCRIPT_VERSION = "4.6.0-001"


MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
FLIGHT_MODE = {AUTO=10, RTL=11, LOITER=12, GUIDED=15, QHOVER=18, QLOITER=19, QRTL=21}

local last_sw = -1
local AUX_FN = 300

-- Attempts to duplicate the code that updates the prev_WP_loc variable in the c++ code
local function LocationTracker()

   local self = {}

   -- to get this to work, need to keep 2 prior generations of "target_location"
   local previous_target_location            -- the target prior to the current one
   local previous_previous_target_location   -- the target prior to that - this is the one we want

   function self.same_loc_as(A, B)
      if A == nil or B == nil then
         return false
      end
      if (A:lat() ~= B:lat()) or (A:lng() ~= B:lng()) then
         return false
      end
      return (A:alt() == B:alt()) and (A:get_alt_frame() == B:get_alt_frame())
   end

   function self.save_previous_target_location()
      local target_location = vehicle:get_target_location()
      if target_location ~= nil then
         if not self.same_loc_as(previous_target_location, target_location) then
            -- maintain three generations of location
            previous_previous_target_location = previous_target_location
            previous_target_location = target_location
         end
      else
         previous_target_location = ahrs:get_location()
         previous_previous_target_location = previous_target_location
      end
   end

   function self.get_saved_location()
      return previous_previous_target_location
   end

   return self
end

local location_tracker = LocationTracker()

local function update()

   -- save the previous target location only if in auto mode, if restoring it in AUTO mode
   if vehicle:get_mode() == FLIGHT_MODE.AUTO and location_tracker ~= nil then
      location_tracker.save_previous_target_location()
   end

   local sw_current = rc:get_aux_cached(AUX_FN)
   if not sw_current then
      sw_current = 0
   end
   if sw_current ~= last_sw then
      last_sw = sw_current
      if sw_current == 0 then
        vehicle:set_mode(FLIGHT_MODE.AUTO)
        if location_tracker ~= nil then
            local previous_location = location_tracker.get_saved_location()
            if previous_location ~= nil then
               vehicle:set_crosstrack_start(previous_location)
            end
         end
         gcs:send_text(MAV_SEVERITY.INFO, string.format("%s: Switched to AUTO", SCRIPT_NAME_SHORT))
      else
         vehicle:set_mode(FLIGHT_MODE.LOITER)
         gcs:send_text(MAV_SEVERITY.INFO, string.format("%s: Switched to LOITER", SCRIPT_NAME_SHORT))
      end
   end

   return update,100
end

if FWVersion:type() == 3 then
   gcs:send_text(MAV_SEVERITY.NOTICE, string.format("%s %s script loaded", SCRIPT_NAME, SCRIPT_VERSION) )
   return update()
else
   gcs:send_text(MAV_SEVERITY.NOTICE,string.format("%s: Must run on Plane", SCRIPT_NAME_SHORT))
end



================================================
File: examples/crsf-menu.lua
================================================
--[[
--]]

SCRIPT_NAME = "CRSF Menu"
SCRIPT_NAME_SHORT = "CRSFMenu"
SCRIPT_VERSION = "0.1"

MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
CRSF_EVENT = {PARAMETER_READ=1, PARAMETER_WRITE=2}
CRSF_PARAM_TYPE = {
    UINT8 = 0,  -- deprecated
    INT8 = 1,   -- deprecated
    UINT16 = 2, -- deprecated
    INT16 = 3,  -- deprecated
    FLOAT = 8,
    TEXT_SELECTION = 9,
    STRING = 10,
    FOLDER = 11,
    INFO = 12,
    COMMAND = 13,
}

CRSF_COMMAND_STATUS = {
    READY = 0, --               --> feedback
    START = 1, --               <-- input
    PROGRESS = 2, --            --> feedback
    CONFIRMATION_NEEDED = 3, -- --> feedback
    CONFIRM = 4, --             <-- input
    CANCEL = 5, --              <-- input
    POLL = 6 --                 <-- input
}

-- create a CRSF menu float item
function create_float_entry(name, value, min, max, default, dpoint, step, unit)
    return string.pack(">BzllllBlz", CRSF_PARAM_TYPE.FLOAT, name, value, min, max, default, dpoint, step, unit)
end

-- create a CRSF menu text selection item
function create_text_entry(name, options, value, min, max, default, unit)
    return string.pack(">BzzBBBBz", CRSF_PARAM_TYPE.TEXT_SELECTION, name, options, value, min, max, default, unit)
end

-- create a CRSF menu string item
function create_string_entry(name, value, max)
    return string.pack(">BzzB", CRSF_PARAM_TYPE.STRING, name, value, max)
end

-- create a CRSF menu info item
function create_info_entry(name, info)
    return string.pack(">Bzz", CRSF_PARAM_TYPE.INFO, name, info)
end

-- create a CRSF command entry
function create_command_entry(name, status, timeout, info)
    timeout = timeout or 10 -- 1s
    return string.pack(">BzBBz", CRSF_PARAM_TYPE.COMMAND, name, status, timeout, info)
end

local param1 = create_info_entry("Menu Item 1", "It goes here")
local param2 = create_info_entry("Menu Item 2", "Another one")
local param3 = create_command_entry("Beethoven", CRSF_COMMAND_STATUS.READY, 50, "Command")
local param4 = create_text_entry("Options", "One;Two;Three;Four", 0, 0, 3, 2, "ms")
local param5 = create_string_entry("Change me:", "Some String", 16)
local param6 = create_float_entry("A Number", 12345, 0, 100000, 10000, 3, 5, "nits")

local command, text, astring, afloat

local menu = crsf:add_menu('Example Menu')
local menu2

if menu ~= nil then
    menu:add_parameter(param1)
    menu:add_parameter(param2)
    command = menu:add_parameter(param3)
    text = menu:add_parameter(param4)
    astring = menu:add_parameter(param5)
    afloat = menu:add_parameter(param6)
    menu2 = menu:add_menu("Another Menu")
    if menu2 ~= nil then
        menu2:add_parameter(create_info_entry("Item 1", "Is badass"))
        menu2:add_parameter(create_info_entry("Item 2", "Is extremely badass"))
        menu2:add_parameter(create_text_entry("Options", "Three;Four;Five", 0, 0, 2, 1, "ms"))
    end

    gcs:send_text(MAV_SEVERITY.INFO, string.format("Loaded CRSF menu \'" .. menu:name() .. "\'"))
end

function update()
    local param, payload, events = crsf:get_menu_event(CRSF_EVENT.PARAMETER_WRITE)
    if (events & CRSF_EVENT.PARAMETER_WRITE) ~= 0 then
        if command ~= nil and param == command:id() then
            local command_action = string.unpack(">B", payload)
            if command_action == CRSF_COMMAND_STATUS.START then
                -- we have been asked to start a command, ask for confirmarion
                local new_data = create_command_entry("Beethoven", CRSF_COMMAND_STATUS.CONFIRMATION_NEEDED, 0, "Play?")
                crsf:send_write_response(new_data)
            elseif command_action == CRSF_COMMAND_STATUS.CONFIRM then
                -- we have been asked to start a command, update the parameter to reflect the status
                local new_data = create_command_entry("Beethoven", CRSF_COMMAND_STATUS.PROGRESS, 0, "Playing")
                crsf:send_write_response(new_data)
                notify:play_tune("L16GGGL4E-L16FFFL4D") -- Beethoven's 5th intro
            elseif command_action == CRSF_COMMAND_STATUS.POLL then
                -- we have been asked to start a command, update the parameter to reflect the status
                crsf:send_write_response(param3)
            end
        elseif text ~= nil and param == text:id() then
            local selection = string.unpack(">B", payload)
            gcs:send_text(MAV_SEVERITY.INFO, "Selected option " .. selection)
            crsf:send_write_response(payload)
        elseif astring ~= nil and param == astring:id() then
            local selection = string.unpack(">z", payload)
            gcs:send_text(MAV_SEVERITY.INFO, "New string is " .. selection)
            crsf:send_write_response(payload)
        elseif afloat ~= nil and param == afloat:id() then
            local selection = string.unpack(">i", payload)
            gcs:send_text(MAV_SEVERITY.INFO, "Value is " .. selection / 10*3)
            crsf:send_write_response(payload)
        end
    end
    return update, 100
end

return update, 5000


================================================
File: examples/easter-egg.lua
================================================
-- This script will select a random location (as defined from a lat long coordinate)
-- and will play a set of tunes to navigate you towards that point, and select a new once
-- once the point has been found.
--
-- This script primarily serves to demo how to work with Locations, as well as how to
-- use the tonealarm to play tones, and send status text messages

local ACCEPTANCE_DISTANCE = 20.0

local TUNE_POINT = "MBNT255>A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8A#8"
local TUNE_TOWARDS = "MFT100L8>B"
local TUNE_AWAY = "MFT100L4>A#B#"

local target = Location()
local top_left = Location()
top_left:lat(-353622666)
top_left:lng(1491650479)

local last_distance = 1e10
local notify_interval_ms = uint32_t(5000)
local last_notify_time_ms = millis()
local score = 0

function find_next_point ()
    target:lat(top_left:lat())
    target:lng(top_left:lng())
    target:offset(math.random()*-100, math.random()*10)
    gcs:send_text(6, string.format("New target %d %d", target:lat(), target:lng()))
    local current = ahrs:get_location()
    if current then
        last_distance = current:get_distance(target)
    end
    last_distance = 1e10
    return
end

function update ()
    local current = ahrs:get_location()
    if current then
        local dist = target:get_distance(current)
        local now = millis()
        if dist < ACCEPTANCE_DISTANCE then
            notify:play_tune(TUNE_POINT)
            score = score + 1
            gcs:send_text(6, string.format("Got a point! %d total", score))
            find_next_point()
        elseif (now - last_notify_time_ms) > notify_interval_ms then
            last_notify_time_ms = now
            gcs:send_text(6, string.format("Distance: %.1f %.1f", target:get_distance(current), dist))
            if dist < (last_distance - 1) then
                notify:play_tune(TUNE_TOWARDS)
            elseif dist > (last_distance + 1) then
                notify:play_tune(TUNE_AWAY)
            end
        end
        if math.abs(last_distance - dist) > 1.0 then
            last_distance = dist;
        end

    end
    return update, 100
end

find_next_point()

return update, 100



================================================
File: examples/efi_speed_check.lua
================================================
--[[
    Example for getting state of EFI and checking if the RPM is within tolerance
--]]

function do_check()
    local efi_state = efi:get_state()
    local engine_speed = efi_state:engine_speed_rpm()
    if not engine_speed then
        return
    end
    if engine_speed > 7000 then
        gcs:send_text(2, "ECU RPM is too high!")
    end
end

function update()
    do_check()
    return update, 100
end
gcs:send_text(6, "Started EFI speed check");
return update, 0


================================================
File: examples/esc_rpm_scale.lua
================================================
--[[
set scale factor for RPM on some ESCs to allow for different pole count on some ESCs
--]]

-- set ESC 4 (index 3) to 2.0 times reported RPM
esc_telem:set_rpm_scale(3, 2.0)

-- set ESC 6 (index 5) to 2.0 times reported RPM
esc_telem:set_rpm_scale(5, 2.0)

gcs:send_text(0,"Setup motor poles")



================================================
File: examples/fault_handling.lua
================================================
--[[
   example script to test fault handling with pcall
--]]

---@diagnostic disable: need-check-nil
---@diagnostic disable: undefined-field

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

gcs:send_text(MAV_SEVERITY.INFO, "Loading fault test")

local test_count = 0
local fault_count = 0

--[[
   evaluate a lua function and return nil on fault or the functions return value
--]]
local function evaluate(f)
   local ok, s = pcall(f)
   eval_func = nil
   if ok then
      return s
   end
   fault_count = fault_count + 1
   return nil
end

local function nil_deref()
   local loc = nil
   return loc:lat()
end

local function bad_random()
   return math.random(1,0)
end

local function run_test()
   local script_variant = test_count % 2
   if script_variant == 0 then
      evaluate(nil_deref)
   elseif script_variant == 1 then
      evaluate(bad_random)
   end
end

local function update()
   if test_count % 100 == 0 then
      gcs:send_text(MAV_SEVERITY.INFO,string.format("Test %u fault_count %u", test_count, fault_count))
   end
   test_count = test_count + 1
   run_test()
   assert(fault_count == test_count, "fault and test counts should match")
   return update,1
end

gcs:send_text(MAV_SEVERITY.INFO, "Starting fault test in 2 seconds")

-- wait a while for GCS to connect
return update,2000



================================================
File: examples/frsky_battery.lua
================================================
--[[
  Simple example that sends battery info down the frsky link
  it works with SPort using SERIAL_PROTOCOL=4,10 and with
  FPort using SERIAL_PROTOCOL=23.
  
  We'll be using OpenTX genuine data IDs (https://github.com/opentx/opentx/blob/2.3/radio/src/telemetry/frsky.h)
  
  CURR_FIRST_ID  0x0200
  VFAS_FIRST_ID  0x0210
  
  and we'll be responding to unused sensor IDs.
  This is a list of IDs we can't use:
  - serial protocol 4 uses IDs 0,2,3 and 6
  - serial protocol 10 uses ID 7,13,20,27
  - serial protocol 23, no IDs used
  
  For this test we'll use sensor ID 4 (0xE4), 
  Note: 4 is the index, 0xE4 is the actual ID
--]]

local loop_time = 500 -- number of ms between runs
local sport_data_frame = 0x10
local sensor_id = 0xE4

-- battery 1->instance 0, battery 2->instance 1, etc
local batt_instance = 0

local curr_id = 0x020E
local vfas_id = 0x021E

local function send_voltage(instance)
  local volts = battery:voltage(instance)
  gcs:send_text(7,string.format("FRSKY: batt %d, %.01fV", instance, volts))
  if volts ~= nil then
    frsky_sport:sport_telemetry_push(sensor_id, sport_data_frame, vfas_id, math.floor(volts*100+0.5)) -- centivolts
  end
end

local function send_current(instance)
  local amps = battery:current_amps(instance)
  gcs:send_text(7,string.format("FRSKY: batt %d, %.01fA", instance, amps))
  if amps ~= nil then
    frsky_sport:sport_telemetry_push(sensor_id, sport_data_frame, curr_id, math.floor(amps*10+0.5)) -- deciamps
  end
end

local alternate = 0

function update()
  if batt_instance > battery:num_instances() then
    error("Battery " .. batt_instance .. " does not exist")
  end
  
  if alternate % 2 == 0 then
    send_voltage(batt_instance)
  else
    send_current(batt_instance)
  end
  alternate = (alternate+1)%2
  return update, loop_time
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/frsky_rpm.lua
================================================
--[[
  Simple example that sends rpm info down the frsky link
  it works with SPort using SERIAL_PROTOCOL=4,10 and with
  FPort using SERIAL_PROTOCOL=23.
  
  We'll be using OpenTX genuine RPM data IDs (https://github.com/opentx/opentx/blob/2.3/radio/src/telemetry/frsky.h)
  
  RPM_FIRST_ID  0x0500
  RPM_LAST_ID   0x050F
  
  and we'll be responding to unused sensor IDs.
  This is a list of IDs we can't use:
  - serial protocol 4 uses IDs 0,2,3 and 6
  - serial protocol 10 uses ID 7,13,20,27
  - serial protocol 23, no IDs used
  
  For this test we'll use sensor ID 4 (0xE4), 
  Note: 4 is the index, 0xE4 is the actual ID
--]]

local loop_time = 250 -- number of ms between runs
local sport_data_frame = 0x10
local sensor_id = 0xE4
--[[
  we use the last 2 data ids so we hopefully don't interfere with pre existing sensors
  this is a suggestion but if we know our RPM sensors are going to be
  the only RPM sensors on the bus we can use 0x0500 and 0x0501
--]]
local data_ids = {
  [0] = 0x050E,
  [1] = 0x050F,
}

local function rpm_data_sent(instance, rpm)
  gcs:send_text(7, string.format("rpm_data_sent() %d: %s", instance, tostring(rpm)))
end

local function send_rpm_data(instance, callback)
  local rpm = RPM:get_rpm(instance)
  gcs:send_text(7,string.format("send_rpm_data() %d, %s", instance, tostring(rpm)))
  if rpm ~= nil then
    if frsky_sport:sport_telemetry_push(sensor_id, sport_data_frame, data_ids[instance], rpm) then
      callback(instance, rpm)
    end
  end
end

local rpm_idx = 0

function update()
    send_rpm_data(rpm_idx, rpm_data_sent)
    rpm_idx = (rpm_idx+1)%2
    return update, loop_time
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/frsky_wp.lua
================================================
--[[
  This example adds a new passthrough packet type for waypoints.
  Waypoint data is packet into 32bits and sent down the frsky bus with a DIY appid of 0x5009.

  - 10 bits for current waypoint index, max 1023
  - 12 bits for the distance in meters encoded with AP_Frsky_SPort::prep_number(distance, 3, 2) max is 102.3Km
  - 6 bits for xtrack error (5 bits + sign) encoded with prep_5bits
  - 3 bits for bearing from COG with a 45° resolution

  We'll be responding to an unused sensor ID

  This is a list of IDs we can't use:
  - serial protocol 4 uses IDs 0,2,3 and 6
  - serial protocol 10 uses ID 7,13,20,27
  - serial protocol 23, no IDs used

  For this test we'll use sensor ID 17 (0x71),
  Note: 17 is the index, 0x71 is the actual ID
--]]

local loop_time = 1000 -- number of ms between runs

local WP_OFFSET_DISTANCE 	= 10
local WP_OFFSET_BEARING 	= 29
local WP_OFFSET_XTRACK 		= 22

local WP_LIMIT_COUNT    = 0x3FF   -- 1023
local WP_LIMIT_XTRACK   = 0x7F    -- 127m
local WP_LIMIT_DISTANCE = 0x18F9C -- 102.3Km
local WP_ARROW_COUNT    = 8       -- 8 possible directions

local wp_bearing = 0
local wp_index = 0
local wp_distance = 0
local wp_xtrack = 0

function wrap_360(angle)
    local res = angle % 360
    if res < 0 then
      res = res + 360
    end
    return res
end

function prep_5bits(num)
    local res
    local abs_num = math.floor(math.abs(num) + 0.5)
    if abs_num < 10 then
      res = abs_num << 1
    elseif abs_num < 150 then
      res = ( math.floor((abs_num * 0.1)+0.5) << 1) | 0x1
    else
      res = 0x1F
    end
    if num < 0 then
      res = res | 0x1 << 5
    end
    return res
end

function wp_pack(index, distance, bearing, xtrack)
    local wp_dword
    wp_dword = math.min(index,WP_LIMIT_COUNT)
    wp_dword = wp_dword | frsky_sport:prep_number(math.min(math.floor(distance+0.5),WP_LIMIT_DISTANCE),3,2) << WP_OFFSET_DISTANCE
    wp_dword = wp_dword | prep_5bits(math.min(xtrack,WP_LIMIT_XTRACK)) << WP_OFFSET_XTRACK
    if gps:status(0)  >= gps.GPS_OK_FIX_2D then
      local cog = gps:ground_course(0)      -- deg
      local angle = wrap_360(bearing - cog) -- deg
      local interval = 360 / WP_ARROW_COUNT -- 45 deg
      -- hint from OSD code to avoid unreliable bearing at small distances
      if distance < 2 then
        angle = 0
      end
      -- bearing expressed as offset from cog as multiple of 45° ( 8 sectors) encoded as 3bits
      wp_dword = wp_dword | ((math.floor(((angle + interval/2) / interval)) % WP_ARROW_COUNT) & 0x7) << WP_OFFSET_BEARING
    end

    return wp_dword & 0xFFFFFFFF
end

function update_wp_info()
  local index = mission:get_current_nav_index()
  local distance = vehicle:get_wp_distance_m()
  local bearing = vehicle:get_wp_bearing_deg()
  local xtrack = vehicle:get_wp_crosstrack_error_m()

  if index ~= nil and distance ~= nil and bearing ~= nil and xtrack ~= nil then
    wp_index = index
    wp_bearing = bearing
    wp_distance = distance
    wp_xtrack = xtrack
    return true
  end
  return false
end

function update()

    if not update_wp_info() then
      return update, loop_time
    end

    local sensor_id = 0x71
    local wp_dword = wp_pack(wp_index, wp_distance, wp_bearing, wp_xtrack)
    frsky_sport:sport_telemetry_push(sensor_id, 0x10, 0x5009, wp_dword)

    return update, loop_time
end

return update() , 1000



================================================
File: examples/fw_vtol_failsafe.lua
================================================
-- This script allows for best effort return for quadplanes
-- on loss of forward motor

-- When an engine failure is detected (RPM and Vibration values drop below a certain threshold), the aircraft will:
-- Send a warning ground station
-- Start prioritizing airspeed completely
-- Glide back towards the home location or rally point, monitoring the distance away from the point as well as Altitude.
-- If the aircraft drops below a predetermined minimum altitude, QLAND mode is engaged and the aircraft lands at its current position.
-- If the aircraft arrives within Q_FW_LND_APR_RAD of the return point before dropping below the minimum altitude, it should loiter down to the minimum altitude before switching to QRTL and landing.

---@diagnostic disable: cast-local-type

-- setup param block for VTOL failsafe params
local PARAM_TABLE_KEY = 77
local PARAM_TABLE_PREFIX = "VTFS_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 4), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- consider engine stopped when vibe is low and RPM low for more than 4s
ENGINE_STOPPED_MS = bind_add_param('ENG_STOP_MS', 1, 4000)

-- RPM threshold below which engine may be stopped
RPM_LOW_THRESH = bind_add_param('RPM_THRESH',     2, 500)

-- vibration threshold below which engine may be stopped
VIBE_LOW_THRESH = bind_add_param('VIBE_LOW',      3,  2)

-- altitude threshold for QLAND
LOW_ALT_THRESH = bind_add_param('LOW_ALT',        4,  70)

-- time when engine stopped
local engine_stop_ms = -1
local engine_stopped = false

-- have we triggered failsafe? Only trigger once
local triggered_failsafe = false

-- flight mode numbers for plane
local MODE_AUTO = 10
local MODE_RTL = 11
local MODE_QLAND = 20
local MODE_QRTL = 21

-- update engine running status
function check_engine()
  if not arming:is_armed() then
     engine_stopped = false
     engine_stop_ms = -1
     return true
  end

  local rpm = RPM:get_rpm(0)
  local vibe = ahrs:get_vibration():length()

  -- if either RPM is high or vibe is high then assume engine is running
  if (rpm and (rpm > RPM_LOW_THRESH:get())) or (vibe > VIBE_LOW_THRESH:get()) then
     -- engine is definately running
     engine_stop_ms = -1
     if engine_stopped then
        -- notify user engine has started
        gcs:send_text(0, "Engine: STARTED")
        engine_stopped = false
     end
     return true
  end
  local now = millis()

  if engine_stop_ms == -1 then
     -- start timeout period
     engine_stop_ms = now
     return true
  end
  if now - engine_stop_ms < ENGINE_STOPPED_MS:get() then
     return false
  end
  -- engine has been stopped for ENGINE_STOPPED_MS milliseconds, notify user
  if not engine_stopped then
     engine_stopped = true
     gcs:send_text(0, "Engine: STOPPED")
  end
  return engine_stopped
end

-- trigger failsafe function
function trigger_failsafe()
  if param:get('RTL_AUTOLAND') == 2 then
     -- we don't want to do the mission based autoland, so disable
     -- RTL_AUTOLAND
     param:set('RTL_AUTOLAND', 0)
  end
  if param:get('TECS_SPDWEIGHT') < 2 then
     -- force airspeed priority
     param:set('TECS_SPDWEIGHT', 2)
  end
  -- trigger an RTL to start bringing the vehicle home
  -- it will automatically go to the nearest rally point if set or go to home
  -- if no rally point available within the RALLY_LIMIT_KM
  vehicle:set_mode(MODE_RTL)
end

-- check if we should switch to QLAND
function check_qland()
  local target = vehicle:get_target_location()
  local pos = ahrs:get_location()
  if not target or not pos then
    -- we can't estimate distance
    return
  end
  local dist = target:get_distance(pos)
  local terrain_height = terrain:height_above_terrain(true)
  local threshold = param:get('Q_FW_LND_APR_RAD')
  if dist < threshold and (terrain_height and (terrain_height < LOW_ALT_THRESH:get())) then
    gcs:send_text(0, "Failsafe: LANDING QRTL")
    vehicle:set_mode(MODE_QRTL)
  elseif terrain_height and terrain_height < LOW_ALT_THRESH:get() then
    gcs:send_text(0, "Failsafe: LANDING QLAND")
    vehicle:set_mode(MODE_QLAND)
  end
end

function update()
  -- check engine status
  check_engine()

  -- if armed and in AUTO mode then consider triggering failsafe
  if engine_stopped and vehicle:get_mode() == MODE_AUTO and arming:is_armed() and not triggered_failsafe then
    triggered_failsafe = true
    trigger_failsafe()
    gcs:send_text(0, "Failsafe: TRIGGERED")
  end

  if not engine_stopped and triggered_failsafe then
    triggered_failsafe = false
    gcs:send_text(0, "Failsafe: RECOVERED")
  end

  if triggered_failsafe and vehicle:get_mode() == MODE_RTL then
    check_qland()
  end

  -- run at 5Hz
  return update, 200
end

-- start running update loop
return update()



================================================
File: examples/gen_control.lua
================================================
--[[
   control throttle on a generator to achieve a target battery voltage

   This is meant to replace throttle governors on some hybrid drone
   generators. It monitors battery voltage and controls the throttle
   of the generator to maintain a target voltage using a PI controller
--]]
---@diagnostic disable: need-check-nil
---@diagnostic disable: param-type-mismatch

UPDATE_RATE_HZ = 10

-- setup a parameter block
local PARAM_TABLE_KEY = 73
local PARAM_TABLE_PREFIX = 'GENCTL_'
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 30), 'could not add param table')

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

GENCTL_ENABLE = bind_add_param('ENABLE', 1, 0)
if GENCTL_ENABLE:get() <= 0 then
   return
end

-- MIN, MAX and IDLE PWM for throttle output
GENCTL_PWM_MIN = bind_add_param('PWM_MIN', 2, 1000)
GENCTL_PWM_MAX = bind_add_param('PWM_MAX', 3, 2000)
GENCTL_PWM_IDLE = bind_add_param('PWM_IDLE', 4, 1200)

-- P and I gains for controller
GENCTL_PID_P = bind_add_param('PID_P', 5, 0.1)
GENCTL_PID_I = bind_add_param('PID_I', 6, 0.1)

-- maximum I contribution
GENCTL_PID_IMAX = bind_add_param('PID_IMAX', 7, 1.0)

-- RCn_OPTION value for 3 position switch
GENCTL_RC_FUNC  = bind_add_param('RC_FUNC',  8, 300)

-- output servo channel that we will control
GENCTL_THR_CHAN = bind_add_param('THR_CHAN', 9, 0)

-- battery index to monitor, 0 is first battery
GENCTL_BAT_IDX  = bind_add_param('BAT_IDX', 10, 0)

-- target voltage
GENCTL_VOLT_TARG = bind_add_param('VOLT_TARG', 11, 0)

-- maximum slew rate in percent/second for throttle change
GENCTL_SLEW_RATE = bind_add_param('SLEW_RATE', 12, 100)

local MAV_SEVERITY_INFO = 6
local MAV_SEVERITY_EMERGENCY = 0

local switch = nil
local thr_pwm = GENCTL_PWM_MIN:get()
local last_switch_pos = nil

-- constrain a value between limits
local function constrain(v, vmin, vmax)
   if v < vmin then
      v = vmin
   end
   if v > vmax then
      v = vmax
   end
   return v
end

-- a PI controller implemented as a Lua object
local function PI_controller(kP,kI,iMax,min,max)
   -- the new instance. You can put public variables inside this self
   -- declaration if you want to
   local self = {}

   -- private fields as locals
   local _kP = kP
   local _kI = kI
   local _iMax = iMax
   local _min = min
   local _max = max
   local _last_t = nil
   local _I = 0
   local _P = 0
   local _total = 0
   local _counter = 0
   local _target = 0
   local _current = 0

   -- update the controller.
   function self.update(target, current)
      local now = millis():tofloat() * 0.001
      if not _last_t then
         _last_t = now
      end
      local dt = now - _last_t
      _last_t = now
      local err = target - current
      _counter = _counter + 1

      local P = _kP:get() * err
      if ((_total < _max and _total > _min) or (_total >= _max and err < 0) or (_total <= _min and err > 0)) then
         _I = _I + _kI:get() * err * dt
      end
      if _iMax:get() > 0 then
         _I = constrain(_I, -_iMax:get(), iMax:get())
      end
      local I = _I
      local ret = P + I

      _target = target
      _current = current
      _P = P
      _total = ret
      return ret
   end

   -- reset integrator to an initial value
   function self.reset(integrator)
      _I = integrator
   end

   -- log the controller internals
   function self.log(name)
      -- allow for an external addition to total
      logger.write(name,'Targ,Curr,P,I,Total','fffff',_target,_current,_P,_I,_total)
   end

   -- return the instance
   return self
end

local thr_PI = PI_controller(GENCTL_PID_P, GENCTL_PID_I, GENCTL_PID_IMAX, 0, 1)
local last_pwm = GENCTL_PWM_MIN:get()

function update()
   if switch == nil then
      switch = rc:find_channel_for_option(math.floor(GENCTL_RC_FUNC:get()))
   end
   if switch == nil or GENCTL_ENABLE:get() < 1 then
      -- nothing to do
      return
   end

   local sw_pos = switch:get_aux_switch_pos()
   if sw_pos ~= last_switch_pos then
      if sw_pos == 0 then
         gcs:send_text(MAV_SEVERITY_INFO,"GenCtl: off")
      elseif sw_pos == 1 then
         gcs:send_text(MAV_SEVERITY_INFO,"GenCtl: idle")
      else
         gcs:send_text(MAV_SEVERITY_INFO,"GenCtl: run")
      end
      last_switch_pos = sw_pos
   end

   if sw_pos == 0 then
      -- force low throttle
      thr_pwm = GENCTL_PWM_MIN:get()
      thr_PI.reset(0)
   elseif sw_pos == 1 then
      -- force idle
      thr_pwm = GENCTL_PWM_IDLE:get()
      thr_PI.reset(0)
   else
      local bat_volt = battery:voltage_resting_estimate(GENCTL_BAT_IDX:get())
      local thr_out = thr_PI.update(GENCTL_VOLT_TARG:get(), bat_volt)
      thr_out = constrain(thr_out, 0, 1)
      thr_pwm = GENCTL_PWM_IDLE:get() + thr_out * (GENCTL_PWM_MAX:get() - GENCTL_PWM_IDLE:get())
      thr_PI.log("GENC")
   end
   local max_change = GENCTL_SLEW_RATE:get() * (GENCTL_PWM_MAX:get() - GENCTL_PWM_MIN:get()) * 0.01 / UPDATE_RATE_HZ
   thr_pwm = constrain(thr_pwm, last_pwm - max_change, last_pwm + max_change)
   last_pwm = thr_pwm
   if GENCTL_THR_CHAN:get() > 0 then
      SRV_Channels:set_output_pwm_chan(GENCTL_THR_CHAN:get()-1, math.floor(thr_pwm))
   end
end


-- wrapper around update(). This calls update() at 10Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(MAV_SEVERITY_EMERGENCY, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 1000/UPDATE_RATE_HZ
end

gcs:send_text(MAV_SEVERITY_INFO,"Loaded gen_control.lua")

-- start running update loop
return protected_wrapper()



================================================
File: examples/get_notify_RGB.lua
================================================
-- example of getting the current notify LED colour

function update() -- this is the loop which periodically runs

  local r, g, b = LED:get_rgb()
  gcs:send_text(0, "Notify LED: r: " .. tostring(r) .. ", g: " .. tostring(g) ..", b:" .. tostring(b))

  return update, 1000 -- reschedules the loop
end

-- make sure Scripting LED is enabled
local led_parm = param:get('NTF_LED_TYPES')
if not led_parm then
  error('Could not find NTF_LED_TYPES param')
end

if (led_parm & (1 << 10)) == 0 then
  -- try and enable it
  if param:set_and_save('NTF_LED_TYPES',led_parm | (1 << 10)) then
    error('Enabled Notify Scripting LED, please reboot')
  else
    error('Could not set NTF_LED_TYPES param')
  end
end

return update()



================================================
File: examples/glide_into_wind.lua
================================================
-- Glide into wind, LUA script for glide into wind functionality

-- Background
-- When flying a fixed-wing drone on ad-hoc BVLOS missions, it might not be
-- suitable for the drone to return to home if the C2 link is lost, since that
-- might mean flying without control for an extended time and distance. One
-- option in ArduPlane is to set FS_Long to Glide, which makes the drone glide
-- and land in the direction it happened to have when the command was invoked,
-- without regard to the wind. This script offers a way to decrease the kinetic
-- energy in this blind landing by means of steering the drone towards the wind
-- as GLIDE is initiated, hence lowering the ground speed. The intention is to
-- minimize impact energy at landing - foremost for any third party, but also to
-- minimize damage to the drone.

-- Functionality and setup
-- 1. Set SCR_ENABLE = 1
-- 2. Put script in scripts folder, boot twice
-- 3. A new parameter has appeared:
--    - GLIDE_WIND_ENABL (0=disable, 1=enable)
-- 4. Set GLIDE_WIND_ENABL = 1
-- 5. Read the docs on FS:
--    https://ardupilot.org/plane/docs/apms-failsafe-function.html#failsafe-parameters-and-their-meanings
-- 6. Set FS_LONG_ACTN = 2
-- 7. Set FS_LONG_TIMEOUT as appropriate
-- 8. Set FS_GCS_ENABL = 1
-- 9. If in simulation, set SIM_WIND_SPD = 4 to get a reliable wind direction.
-- 10. Test in simulation: Fly a mission, disable heartbeats by typing 'set
--     heartbeat 0' into mavproxy/SITL, monitor what happens in the console. If
--     QGC or similar GCS is used, make sure it does not send heartbeats.
-- 11. Test in flight: Fly a mission, monitor estimated wind direction from GCS,
--     then fail GCS link and see what happens.
-- 12. Once heading is into wind script will stop steering and not steer again
--     until state machine is reset and failsafe is triggered again. Steering in low
--     airspeeds (thr=0) increases risks of stall and it is preferable touch
--     ground in level roll attitude. If the script parameter hdg_ok_lim is set
--     to tight or the wind estimate is not stable, the script will anyhow stop
--     steering after override_time_lim and enter FBWA - otherwise the script
--     would hinder the GLIDE fail safe.
-- 13. Script will stop interfering as soon as a new goto-point is received or
--     the flight mode is changed by the operator or the remote pilot.

-- During the fail safe maneuver a warning tune is played.

-- State machine
-- CAN_TRIGGER 
--   - Do: Nothing
--   - Change state: If the failsafe GLIDE is triggered: if FS_GCS_ENABL is set
--     and FS_LONG_ACTN is 2, change to TRIGGERED else change to CANCELED
--
-- TRIGGERED
--   - Do: First use GUIDED mode to steer into wind, then switch to FBWA to
--     Glide into wind. Play warning tune.
--   - Change state: If flight mode is changed by operator/remote pilot or
--     operator/remote pilot sends a new goto point, change state to CANCELED
--
-- CANCELED 
--   - Do: Nothing
--   - Change state: When new heart beat arrive, change state to CAN_TRIGGER

-- Credits
-- This script is developed by agising at UASolutions, commissioned by, and in
-- cooperation with Remote.aero, with funding from Swedish AeroEDIH, in response
-- to a need from the Swedish Sea Rescue Society (Sjöräddningssällskapet, SSRS). 

-- Disable diagnostics related to reading parameters to pass linter
---@diagnostic disable: need-check-nil
---@diagnostic disable: param-type-mismatch

-- Tuning parameters
local looptime = 250            -- Short looptime
local long_looptime = 2000      -- Long looptime, GLIDE_WIND is not enabled
local tune_repeat_t = 1000      -- How often to play tune in glide into wind, [ms]
local hdg_ok_lim = 15           -- Acceptable heading error in deg (when to stop steering)
local hdg_ok_t_lim = 5000       -- Stop steering towards wind after hdg_ok_t_lim ms with error less than hdg_ok_lim
local override_time_lim = 15000 -- Max time in GUIDED during GLIDE, after limit set FBWA independent of hdg

-- GCS text levels
local _INFO = 6
local _WARNING = 4

-- Plane flight modes mapping
local mode_FBWA = 5
local mode_GUIDED = 15

-- Tunes
local _tune_glide_warn = "MFT240 L16 cdefgfgfgfg"   --  The warning tone played during GLIDE_WIND

--State variable
local fs_state = nil

-- Flags
local override_enable = false     -- Flag to allow RC channel loverride

-- Variables
local wind_dir_rad = nil                -- param for wind dir in rad
local wind_dir_180 = nil                -- param for wind dir in deg
local hdg_error = nil                   -- Heading error, hdg vs wind_dir_180
local gw_enable = nil                   -- glide into wind enable flag
local hdg = nil                         -- vehicle heading
local wind = Vector3f()                 -- wind 3Dvector
local link_lost_for = nil               -- link loss time counter
local last_seen = nil                   -- timestamp last received heartbeat
local tune_time_since = 0               -- Timer for last played tune
local hdg_ok_t = 0                      -- Timer
local expected_flight_mode = nil        -- Flight mode set by this script
local location_here = nil               -- Current location
local location_upwind = nil             -- Location to hold the target location
local user_notified = false             -- Flag to keep track user being notified or not
local failed_location_counter = 0       -- Counter for failed location requests, possible GPS denied
local upwind_distance = 500             -- Distance to the upwind location, minimum 4x turn radius
local override_time = 0                 -- Time since override started in ms

-- Add param table
local PARAM_TABLE_KEY = 74
local PARAM_TABLE_PREFIX = "GLIDE_WIND_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 30), 'could not add param table')

-------
-- Init
-------

function _init()
  -- Add and init paramters
  GLIDE_WIND_ENABL = bind_add_param('ENABL', 1, 0)

  -- Init parameters
  FS_GCS_ENABL = bind_param('FS_GCS_ENABL')               -- Is set to 1 if GCS lol should trigger FS after FS_LONG_TIMEOUT
  FS_LONG_TIMEOUT = bind_param('FS_LONG_TIMEOUT')         -- FS long timeout in seconds
  FS_LONG_ACTN = bind_param('FS_LONG_ACTN')               -- Is set to 2 for Glide

  send_to_gcs(_INFO, 'LUA: FS_LONG_TIMEOUT timeout: ' .. FS_LONG_TIMEOUT:get() .. 's')

  -- Test paramter
  if GLIDE_WIND_ENABL:get() == nil then
    send_to_gcs(_INFO, 'LUA: Something went wrong, GLIDE_WIND_ENABL not created')
    return _init(), looptime
  else 
    gw_enable = GLIDE_WIND_ENABL:get()
    send_to_gcs(_INFO, 'LUA: GLIDE_WIND_ENABL: ' .. gw_enable)
  end

  -- Init last_seen.
  last_seen = gcs:last_seen()

  -- Init link_lost_for [ms] to FS_LONG_TIMEOUT [s] to prevent link to recover without
  -- new heartbeat. This is to properly init the state machine.
  link_lost_for = FS_LONG_TIMEOUT:get() * 1000

  -- Warn if GLIDE_WIND_ENABL is set and FS_LONG_ACTN is not GLIDE
  if gw_enable == 1 and FS_LONG_ACTN:get() ~= 2 then
    send_to_gcs(_WARNING, 'GLIDE_WIND_ENABL is set, but FS_LONG_ACTN is not GLIDE.')
  end

  -- Init fs_state machine to CANCELED. A heartbeat is required to set the state
  -- to CAN_TRIGGER from where Glide into wind can be triggered.
  fs_state = 'CANCELED'

  -- All set, go to update
  return update(), long_looptime
end


------------
-- Main loop
------------

function update()
  -- Check if state of GLIDE_WIND_ENABL parameter changed, print every change
  if gw_enable ~= GLIDE_WIND_ENABL:get() then
    gw_enable = GLIDE_WIND_ENABL:get()
    send_to_gcs(_INFO, 'LUA: GLIDE_WIND_ENABL: ' .. gw_enable)
    -- If GLIDE_WIND_ENABL was enabled, warn if not FS_LONG_ACTN is set accordingly
    if gw_enable == 1 then
      if FS_LONG_ACTN:get() ~=2 then
        send_to_gcs(_WARNING, 'GLIDE_WIND_ENABL is set, but FS_LONG_ACTN is not GLIDE.')
      end
    end
  end

  -- -- If feature is not enabled, loop slowly
  if gw_enable == 0 then
    return update, long_looptime
  end
  
  -- GLIDE_WIND_ENABL is enabled, look for triggers
  -- Monitor time since last gcs heartbeat
  if last_seen == gcs:last_seen() then
    link_lost_for = link_lost_for + looptime
  else
    -- There has been a new heartbeat, update last_seen and reset link_lost_for
    last_seen = gcs:last_seen()
    link_lost_for = 0
  end

  -- Run the state machine
  -- State CAN_TRIGGER
  if fs_state == 'CAN_TRIGGER' then
    if link_lost_for > FS_LONG_TIMEOUT:get() * 1000 then
      -- Double check that FS_GCS_ENABL is set
      if FS_GCS_ENABL:get() == 1 and FS_LONG_ACTN:get() == 2 then
        fs_state = "TRIGGERED"
        -- Reset some variables
        hdg_ok_t = 0
        user_notified = false
        override_enable = true
        override_time = 0
        failed_location_counter = 0
        -- Set mode to GUIDED before entering TRIGGERED state
        set_flight_mode(mode_GUIDED, 'LUA: Glide into wind state TRIGGERED')
      else
        -- Do not trigger glide into wind, require new heart beats to get here again
        fs_state = "CANCELED"
      end
    end
  -- State TRIGGERED
  elseif fs_state == "TRIGGERED" then
    -- Check for flight mode changes from outside script
    if vehicle:get_mode() ~= expected_flight_mode then
      fs_state = "CANCELED"
      send_to_gcs(_INFO, 'LUA: Glide into wind state CANCELED: flight mode change')
    end

    -- In GUIDED, check for target location changes from outside script (operator)
    if vehicle:get_mode() == mode_GUIDED then
      if not locations_are_equal(vehicle:get_target_location(), location_upwind) then
        fs_state = "CANCELED"
        send_to_gcs(_INFO, 'LUA: Glide into wind state CANCELED: new goto-point')
      end
    end

  -- State CANCELED
  elseif fs_state == "CANCELED" then
    -- Await link is not lost
    if link_lost_for < FS_LONG_TIMEOUT:get() * 1000 then
      fs_state = "CAN_TRIGGER"
      send_to_gcs(_INFO, 'LUA: Glide into wind state CAN_TRIGGER')
    end
  end

  -- State TRIGGERED actions
  if fs_state == "TRIGGERED" then
    -- Get the heading angle
    hdg = math.floor(math.deg(ahrs:get_yaw_rad()))

    -- Get wind direction. Function wind_estimate returns x and y for direction wind blows in, add pi to get true wind dir
    wind = ahrs:wind_estimate()
    wind_dir_rad = math.atan(wind:y(), wind:x())+math.pi
    wind_dir_180 = math.floor(wrap_180(math.deg(wind_dir_rad)))
    hdg_error = wrap_180(wind_dir_180 - hdg)

    -- Check if we are close to target heading
    if math.abs(hdg_error) < hdg_ok_lim then
      -- If we have been close to target heading for hdg_ok_t_lim, switch back to FBWA
      if hdg_ok_t > hdg_ok_t_lim then    
        if override_enable then
          set_flight_mode(mode_FBWA,'LUA: Glide into wind steering complete, GLIDE in FBWA')
        end
        -- Do not override again until state machine has triggered again
        override_enable = false
      else
        hdg_ok_t = hdg_ok_t + looptime
      end
    -- Heading error is big, reset timer hdg_ok_t 
    else
      hdg_ok_t = 0
    end

    -- Play tune every tune_repeat_t [ms]
    if tune_time_since > tune_repeat_t  then
      -- Play tune and reset timer
      send_to_gcs(_INFO, 'LUA: Play warning tune')
      play_tune(_tune_glide_warn)
      tune_time_since = 0
    else
      tune_time_since = tune_time_since + looptime
    end

    -- If not steered into wind yet, update goto point into wind
    if override_enable then
      -- Check override time, if above limit, switch back to FBWA
      override_time = override_time + looptime
      if override_time > override_time_lim then
        set_flight_mode(mode_FBWA, "LUA: Glide into wind override time out, GLIDE in current heading")
        override_enable = false
      end
      -- Get current position and handle if not valid
      location_here = ahrs:get_location()
      if location_here == nil then
        -- In case we cannot get location for some time we must give up and continue with GLIDE
        failed_location_counter = failed_location_counter + 1
        if failed_location_counter > 5 then
          set_flight_mode(mode_FBWA, "LUA: Glide failed to get location, GLIDE in current heading")
          override_enable = false
          return update, looptime
        end
        gcs:send_text(_WARNING, "LUA: Glide failed to get location")
        return update, looptime
      end
      -- Calc upwind position, copy and modify location_here
      location_upwind = location_here:copy()
      location_upwind:offset_bearing(wind_dir_180, upwind_distance)

      -- Set location_upwind as GUIDED target
      if vehicle:set_target_location(location_upwind) then
        if not user_notified then
          send_to_gcs(_INFO, "LUA: Guided target set " .. upwind_distance .. "m away at bearing " .. wind_dir_180)
          -- Just notify once
          user_notified = true
        end
      else
        -- Most likely we are not in GUIDED anymore (operator changed mode), state machine will handle this in next loop.
        gcs:send_text(_WARNING, "LUA: Glide failed to set upwind target")
      end
    end
  end
  return update, looptime
end


-------------------
-- Helper functions
-------------------

-- Set mode and wait for mode change
function set_flight_mode(mode, message)
  expected_flight_mode = mode
  vehicle:set_mode(expected_flight_mode)
  return wait_for_mode_change(mode, message, 0)
end

-- Wait for mode change
function wait_for_mode_change(mode, message, attempt)
  -- If mode change does not go through after 10 attempts, give up
  if attempt > 10 then
    send_to_gcs(_WARNING, 'LUA: Glide into wind mode change failed.')
    return update, looptime
  -- If mode change does not go through, wait and try again
  elseif vehicle:get_mode() ~= mode then
    return wait_for_mode_change(mode, message, attempt + 1), 5
  -- Mode change has gone through
  else
    send_to_gcs(_INFO, message)
    return update, looptime
  end
end

-- Function to compare two Location objects
function locations_are_equal(loc1, loc2)
  -- If either location is nil, they are not equal  
  if not loc1 or not loc2 then
      return false
  end
  -- Compare latitude and longitude, return bool
  return loc1:lat() == loc2:lat() and loc1:lng() == loc2:lng()
end

-- bind a parameter to a variable
function bind_param(name)
  local p = Parameter()
  assert(p:init(name), string.format('could not find %s parameter', name))
  return p
end

-- Add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
  assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
  return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- Print to GCS
function send_to_gcs(level, mess)
  gcs:send_text(level, mess)
end

-- Play tune
function play_tune(tune)
  notify:play_tune(tune)
end

-- Returns the angle in range 0-360
function wrap_360(angle)
  local res = math.fmod(angle, 360.0)
   if res < 0 then
       res = res + 360.0
   end
   return res
end

-- Returns the angle in range -180-180
function wrap_180(angle)
  local res = wrap_360(angle)
  if res > 180 then
     res = res - 360
  end
  return res
end

-- Start up the script
return _init, 2000



================================================
File: examples/gps_synth.lua
================================================
-- get GPS data from ardupilot's native bindings then resynthesize into a
-- virtual NMEA GPS and feed back through the serial device sim bindings.
-- demonstrates the bindings and provides the opportunity for script-controlled
-- tampering and other such activities.

-- parameters:
-- SCR_ENABLE 1
-- SCR_SDEV_EN 1
-- SCR_SDEV1_PROTO 5
-- SERIAL3_PROTOCOL 5
-- SERIAL4_PROTOCOL -1
-- GPS2_TYPE 5
-- GPS_PRIMARY 1
-- GPS_AUTO_SWITCH 0

local ser_device = serial:find_simulated_device(5, 0)
if not ser_device then
  error("SCR_SDEV_EN must be 1 and SCR_SDEVn_PROTO must be 5")
end

function convert_coord(coord, dir)
  -- convert ardupilot degrees*1e7 to NMEA degrees + decimal minutes + dir.
  -- the first character of dir is used if the coordinate is positive,
  -- the second if negative.

  -- handle sign
  if coord < 0 then
    coord = -coord
    dir = dir:sub(2, 2)
  else
    dir = dir:sub(1, 1)
  end

  local degrees = coord // 10000000 -- integer divide
  coord = coord - (degrees * 10000000) -- remove that portion
  local minutes = coord * (60/10000000) -- float divide

  return ("%03d%08.5f,%s"):format(degrees, minutes, dir)
end

function convert_time(time_week, time_week_ms)
  -- convert ardupilot GPS time to NMEA UTC date/time strings

  -- GPS week 1095 starts on Dec 31 2000
  local seconds_per_week = uint32_t(86400*7)
  timestamp_s = uint32_t(time_week - 1095)*seconds_per_week
  -- subtract one day to get to Jan 1 2001, then 18 additional seconds to
  -- account for the GPS to UTC leap second induced offset
  timestamp_s = timestamp_s - uint32_t(86400 + 18)
  -- add in time within the week
  timestamp_s = timestamp_s + (time_week_ms/uint32_t(1000))

  timestamp_s = timestamp_s:toint() -- seconds since Jan 1 2001

  local ts_year = 2001
  local day_seconds = 86400
  while true do
    local year_seconds = day_seconds * ((ts_year % 4 == 0) and 366 or 365)
    if timestamp_s >= year_seconds then
      timestamp_s = timestamp_s - year_seconds
      ts_year = ts_year + 1
    else
      break
    end
  end

  local month_days = {31, (ts_year % 4 == 0) and 29 or 28,
    31, 30, 31, 30, 31, 31, 30, 31, 30, 31}

  local ts_month = 1
  for _, md in ipairs(month_days) do
    local month_seconds = 86400 * md
    if timestamp_s >= month_seconds then
        timestamp_s = timestamp_s - month_seconds
        ts_month = ts_month + 1
    else
      break
    end
  end

  local ts_day = 1+(timestamp_s // 86400)
  timestamp_s = timestamp_s % 86400

  local ts_hour = timestamp_s // 3600
  timestamp_s = timestamp_s % 3600

  local ts_minute = timestamp_s // 60
  local ts_second = timestamp_s % 60

  local date = ("%02d%02d%02d"):format(ts_year-2000, ts_month, ts_day)
  local time = ("%02d%02d%02d.%01d"):format(ts_hour, ts_minute, ts_second,
    (time_week_ms % 1000):toint()//100)

  return date, time
end

function get_gps_data(instance)
  -- get GPS data from ardupilot scripting bindings in native format
  local data = {
    hdop = gps:get_hdop(instance),
    time_week_ms = gps:time_week_ms(instance),
    time_week = gps:time_week(instance),
    sats = gps:num_sats(instance),
    crs = gps:ground_course(instance),
    spd = gps:ground_speed(instance),
    loc = gps:location(instance),
    status = gps:status(instance),
  }
  if data.status < gps.GPS_OK_FIX_3D then
    return nil -- don't bother with invalid data
  end
  return data
end

function arrange_nmea(data)
  -- convert ardupilot data entries to NMEA-compatible format
  local ts_date, ts_time = convert_time(data.time_week, data.time_week_ms)

  return {
    time = ts_time,
    lat = convert_coord(data.loc:lat(), "NS"),
    lng = convert_coord(data.loc:lng(), "EW"),
    spd = data.spd / 0.514, -- m/s to knots
    crs = data.crs, -- degrees
    date = ts_date,
    sats = data.sats,
    hdop = data.hdop,
    alt = data.loc:alt()/100,
  }
end

function wrap_nmea(msg)
  -- compute checksum and add header and footer
  local checksum = 0
  for i = 1,#msg do
    checksum = checksum ~ msg:byte(i, i)
  end

  return ("$%s*%02X\r\n"):format(msg, checksum)
end

function format_nmea(data)
  -- format data into complete NMEA sentences
  local rmc_raw = ("GPRMC,%s,A,%s,%s,%03f,%03f,%s,000.0,E"):format(
    data.time, data.lat, data.lng, data.spd, data.crs, data.date)

  local gga_raw = ("GPGGA,%s,%s,%s,1,%02d,%05.2f,%06.2f,M,0,M,,"):format(
    data.time, data.lat, data.lng, data.sats, data.hdop/100, data.alt)

  return wrap_nmea(rmc_raw), wrap_nmea(gga_raw)
end

function update()
  -- get data from first instance (we are the second)
  local ardu_data = get_gps_data(0)

  if ardu_data then
    local nmea_data = arrange_nmea(ardu_data)
    local rmc, gga = format_nmea(nmea_data)

    if ser_device:writestring(rmc) ~= #rmc 
        or ser_device:writestring(gga) ~= #gga then
      error("overflow, ardupilot is not processing the data, check config!")
    end
  end

  return update, 200 -- 5Hz like a real GPS
end

return update()



================================================
File: examples/hello_world.lua
================================================
-- This script is an example of saying hello

gcs:send_text(0, "hello, world") -- send the traditional message



================================================
File: examples/hello_world_display.lua
================================================
-- This script is an example of printing to a display via scripting
-- Connect a supported display to the autopilot, and configure the NTF_DISPLAY_TYPE parameter seen at https://ardupilot.org/copter/docs/common-display-onboard.html
-- The notify:send_text(text, row) method will override default on the display, disabling the default messages

local switchTimeA
local switchTimeB
local displayWidth = 18
local function update()
    -- Just keep track of when we should switch to a smiley :)
    if switchTimeA == nil then
        switchTimeA = millis() + 5000
        switchTimeB = switchTimeA + 10000
    end

    -- Example of overriding a line keeping some defaults, here we will replace the battery(1) and GPS(2) rows
    if switchTimeA > millis() then
        notify:send_text("Hello, World!", 1)
        notify:send_text(tostring(millis()), 2)

    -- Next demonstrate we can release the text, and the default will be shown again
    elseif switchTimeB > millis() then
        notify:release_text(1)
        notify:release_text(2)

    -- Example of overriding all lines, a smiley, try moving the autopilot around to see it change
    else
        -- Generate the smiley
        local width = (displayWidth / 2)
        local roll = math.floor(width + (ahrs:get_roll_rad() * width)) - 4
        local pitch = math.floor(ahrs:get_pitch_rad() * 6) + 2;
        local sub = 5 - roll
        if sub < 0 then
            sub = 0
        end
        local rows = {}
        if pitch - 2 >= 0 and pitch - 2 <= 5 then 
            rows[pitch - 2] = (string.rep(" ", roll) .. "    ##"):sub(sub);
        end
        if pitch - 1 >= 0 and pitch - 1 <= 5 then 
            rows[pitch - 1] = (string.rep(" ", roll) .. " #    #"):sub(sub);
        end
        if pitch >= 0 and pitch <= 5 then 
            rows[pitch] = (string.rep(" ", roll) .. "      #"):sub(sub);
        end
        if pitch + 1 >= 0 and pitch + 1 <= 5 then 
            rows[pitch + 1] = (string.rep(" ", roll) .. " #    #"):sub(sub);
        end
        if pitch + 2 >= 0 and pitch + 2 <= 5 then 
            rows[pitch + 2] = (string.rep(" ", roll) .. "    ##"):sub(sub);
        end
        if pitch + 3 >= 0 and pitch + 3 <= 5 then 
            rows[pitch + 3] = "";
        end

        -- Send it out to the display
        for i = 0, 5 do
            if rows[i] == nil then
                rows[i] = ""
            end
            notify:send_text(rows[i], i)
        end
    end

    return update, 10
 end
 return update, 1000 -- Wait a few seconds before starting



================================================
File: examples/i2c_scan.lua
================================================
-- This script scans for devices on the i2c bus

---@diagnostic disable: need-check-nil

local address = 0
local found = 0

local i2c_bus = i2c:get_device(0,0)
i2c_bus:set_retries(10)

function update() -- this is the loop which periodically runs

  i2c_bus:set_address(address)

  if i2c_bus:read_registers(0) then
      gcs:send_text(0, "Found I2C at " .. tostring(address))
      found = found + 1
  end

  address = address + 1
  if address == 127 then
    address = 0
    gcs:send_text(0, "Found " .. tostring(found) .. " devices")
    found = 0
  end

  return update, 100 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/jump_tags_calibrate_agl.lua
================================================
--[[
Usage for SITL PLANE testing:

- default params already enable rangefinder
- set param RTL_AUTOLAND 2
- set param SCR_ENABLE 1
- set param RNGFND1_TYPE 100
- restart, if needed
- upload mission (jump_tags_calibrate_agl.waypoints)
- launch plane (switch to AUTO and arm)
- Mission will go to a loiter_unlim at wp 2.
- set param SIM_BARO_DRIFT to your taste to simulate a long mission.
- switch mode to RTL, which jumps you back to AUTO at the DO_LAND_START which begins with a loiter_to_alt.

- once the loiter_to_alt is done, it will do an approach pattern and fly over the runway and sample the altitude
    using the rangefinder. The start and end sample points are defined tag 400 and 401 where at 401 it uses the
    average AGL and adjusts BARO_ALT_GND to compensate for any baro drift.
- It then does the rest of the pattern and lands without the lidar needing to do much because the offset
     has already been corrected for



QGC WPL 110
0	1	0	16	0	0	0	0	-35.3629591	149.1647941	584.016148	1
1	0	3	22	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	10.000000	1
2	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36299850	149.15860890	200.000000	1
3	0	3	189	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
4	0	3	31	0.00000000	0.00000000	0.00000000	0.00000000	-35.36416220	149.16121600	40.000000	1
5	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36648940	149.16154860	30.000000	1
6	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36614380	149.16553970	30.000000	1
7	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36330910	149.16519370	30.000000	1
8	0	0	600	400.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
9	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36233350	149.16505430	100.000000	1
10	0	0	600	401.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
11	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36058800	149.16486380	40.000000	1
12	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36079800	149.16206900	100.000000	1
13	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36720250	149.16250880	40.000000	1
14	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36693130	149.16574360	30.000000	1
15	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36566700	149.16559340	30.000000	1
16	0	3	21	0.00000000	0.00000000	0.00000000	1.00000000	-35.36276450	149.16517900	0.000000	1
--]]



local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}


local ROTATION_PITCH_270 = 25

local MISSION_TAG_MEASURE_AGL_START         = 400
local MISSION_TAG_CALIBRATE_BARO            = 401

local agl_samples_count = 0
local agl_samples_sum = 0


function sample_rangefinder_to_get_AGL()
    if (not rangefinder:has_data_orient(ROTATION_PITCH_270)) then
        -- rangefinder not ready
        return
    end

    -- we're actively sampling rangefinder distance to ground
    local distance_raw_m = rangefinder:distance_orient(ROTATION_PITCH_270)

    -- correct the range for attitude (multiply by DCM.c.z, which is cos(roll)*cos(pitch))
    local ahrs_get_rotation_body_to_ned_c_z = math.cos(ahrs:get_roll_rad())*math.cos(ahrs:get_pitch_rad())
    local agl_corrected_for_attitude_m = distance_raw_m * ahrs_get_rotation_body_to_ned_c_z

    if (agl_samples_count <= 0) then
        agl_samples_count = 0 -- divide-by-zero sanity check in case it somehow wrapped or initialized wrong
        agl_samples_sum = 0
        gcs:send_text(MAV_SEVERITY.INFO, string.format("LUA: AGL measurements started"))
    end

    agl_samples_sum = agl_samples_sum + agl_corrected_for_attitude_m
    agl_samples_count = agl_samples_count + 1

    local agl_average = agl_samples_sum / agl_samples_count
    gcs:send_text(MAV_SEVERITY.INFO, string.format("LUA: AGL measurement %u: %.2fm, avg: %.2f", agl_samples_count, agl_corrected_for_attitude_m, agl_average))
end


function update_baro(new_agl_m)
    
    local current_baro_agl_m = baro:get_altitude()
    local alt_error_m = current_baro_agl_m - new_agl_m
    gcs:send_text(MAV_SEVERITY.INFO, string.format("LUA: AGL alt_error is: %.2f - %.2f = %.2f", current_baro_agl_m, new_agl_m, alt_error_m))

    local baro_alt_offset = param:get('BARO_ALT_OFFSET')
    local baro_alt_offset_new_value = baro_alt_offset + alt_error_m
    gcs:send_text(MAV_SEVERITY.INFO, string.format("LUA: BARO_ALT_OFFSET changed from %.2f to %.2f", baro_alt_offset, baro_alt_offset_new_value))
    param:set('BARO_ALT_OFFSET', baro_alt_offset_new_value)
end


function update()
    if (mission:state() ~= mission.MISSION_RUNNING) or (not arming:is_armed()) or (not vehicle:get_likely_flying()) then
        -- only run landing mission checks if in auto with a valid mission and armed and flying.
        return update, 5000
    end

    local tag, age = mission:get_last_jump_tag()

    if (tag == nil) then
        return update, 1000
    end

    if ((tag == MISSION_TAG_MEASURE_AGL_START) and (age <= 5)) then
        -- we're at or currently on waypoints after the tag so lets start gathering samples
        sample_rangefinder_to_get_AGL()
        -- lets sample at 2 Hz
        return update, 500

    elseif ((tag == MISSION_TAG_CALIBRATE_BARO) and (age <= 3) and (agl_samples_count > 0)) then
        -- finished sampling, use the result to offset baro
        local agl_average_final_m = agl_samples_sum / agl_samples_count
        gcs:send_text(MAV_SEVERITY.INFO, string.format("LUA: AGL measurements stopped: samples = %d, avg = %.2fm", agl_samples_count, agl_average_final_m))
        update_baro(agl_average_final_m)
        agl_samples_count = 0
    else
        agl_samples_count = 0
    end

    return update, 1000
end


gcs:send_text(MAV_SEVERITY.INFO, "LUA: SCRIPT START: Check AGL to calibrate Baro")
return update()





================================================
File: examples/jump_tags_calibrate_agl.waypoints
================================================
QGC WPL 110
0	1	0	16	0	0	0	0	-35.3629591	149.1647941	584.016148	1
1	0	3	22	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	10.000000	1
2	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36299850	149.15860890	200.000000	1
3	0	3	189	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
4	0	3	31	0.00000000	0.00000000	0.00000000	0.00000000	-35.36416220	149.16121600	40.000000	1
5	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36648940	149.16154860	30.000000	1
6	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36614380	149.16553970	30.000000	1
7	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36330910	149.16519370	30.000000	1
8	0	0	600	400.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
9	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36233350	149.16505430	100.000000	1
10	0	0	600	401.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
11	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36058800	149.16486380	40.000000	1
12	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36079800	149.16206900	100.000000	1
13	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36720250	149.16250880	40.000000	1
14	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36693130	149.16574360	30.000000	1
15	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36566700	149.16559340	30.000000	1
16	0	3	21	0.00000000	0.00000000	0.00000000	1.00000000	-35.36276450	149.16517900	0.000000	1



================================================
File: examples/jump_tags_into_wind_landing.lua
================================================
--[[
Usage for SITL PLANE testing:

- set param SIM_WIND_SPD 5
- set param SIM_WIND_DIR 0
- set param RTL_AUTOLAND 2
- set param SCR_ENABLE 1
- restart, if needed
- upload mission (jump_tags_into_wind_landing.waypoints)
- launch plane (switch to AUTO and arm)
- Mission will go to a loiter_unlim at wp 2.
- switch mode to RTL, which jumps you back to AUTO at the DO_LAND_START which begins with a loiter_to_alt.

once the loiter_to_alt is done, it will jump to the landing pattern that has the headwind

- set param SIM_WIND_DIR 180

observe that it will jump to the other direction for always an into-wind landing




QGC WPL 110
0	1	0	16	0	0	0	0	-35.3632622	149.1652376	584.090000	1
1	0	3	22	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	10.000000	1
2	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36296350	149.15812610	200.000000	1
3	0	3	189	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
4	0	3	31	1.00000000	0.00000000	0.00000000	0.00000000	-35.36289790	149.16306140	50.000000	1
5	0	3	600	200.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
6	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36289790	149.16335600	50.000000	1
7	0	3	600	300.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
8	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36733370	149.16327060	40.000000	1
9	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36704940	149.16576500	30.000000	1
10	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36595570	149.16557190	30.000000	1
11	0	3	21	0.00000000	0.00000000	0.00000000	0.00000000	-35.36304990	149.16518770	0.000000	1
12	0	3	600	301.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
13	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35827370	149.16196170	40.000000	1
14	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35809000	149.16448300	30.000000	1
15	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35932370	149.16465460	30.000000	1
16	0	3	21	0.00000000	0.00000000	0.00000000	0.00000000	-35.36246480	149.16510790	0.000000	1
--]]


local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local MAV_CMD_NAV_LAND = 21

-- some made-up numbers for TAGS that are used in the mission
local MISSION_TAG_DETERMINE_LAND_DIRECTION  = 200
local MISSION_TAG_LAND1_DIRECTION_NORMAL    = 300
local MISSION_TAG_LAND1_DIRECTION_REVERSE   = 301


function get_bearing_of_first_land_after_tag(tag)

    local index_start = mission:get_index_of_jump_tag(tag)
    mitem_prev = mission:get_item(index_start)
    if (not mitem_prev) then
        return nil
    end

    for index = index_start+1, mission:num_commands()-1 do
        mitem = mission:get_item(index)
        if (not mitem) then
            return nil
        end
        if (mitem:command() == MAV_CMD_NAV_LAND) then
            local wp1 = Location()
            wp1:lat(mitem_prev:x())
            wp1:lng(mitem_prev:y())
        
            local wp2 = Location()
            wp2:lat(mitem:x())
            wp2:lng(mitem:y())
        
            return wp1:get_bearing(wp2)
        end
        mitem_prev = mitem;
    end
    return nil
end


function check_wind_and_jump_to_INTO_wind_landing()

    local reverse_land_bearing = get_bearing_of_first_land_after_tag(MISSION_TAG_LAND1_DIRECTION_REVERSE)
    if (not reverse_land_bearing) then
        return
    end

    local wind = ahrs:wind_estimate()
    local tail_wind = (math.sin(reverse_land_bearing) * wind:y()) + (math.cos(reverse_land_bearing) * wind:x())

    -- we need at least 10 cm/s of tailwind. With very little wind (or a noisy 0 value) we don't want to flip around.
    local tail_wind_threshold = 0.1

    local tag
    if (tail_wind > tail_wind_threshold) then
        gcs:send_text(MAV_SEVERITY.INFO, "LUA: continuing with normal landing direction")
        tag = MISSION_TAG_LAND1_DIRECTION_NORMAL
    else
        gcs:send_text(MAV_SEVERITY.INFO, "LUA: jump mission to other into-wind landing direction")
        tag = MISSION_TAG_LAND1_DIRECTION_REVERSE
    end

    if (not mission:jump_to_tag(tag)) then
        gcs:send_text(MAV_SEVERITY.WARNING, string.format("LUA: jump_to_tag %u failed", tag))
    end
end


function update()
    if (mission:state() ~= mission.MISSION_RUNNING) or (not arming:is_armed()) or (not vehicle:get_likely_flying()) then
        -- only run landing mission checks if in auto with a valid mission and armed and flying.
        return update, 5000
    end

    local tag, age = mission:get_last_jump_tag()
    if (tag ~= nil) and (tag == MISSION_TAG_DETERMINE_LAND_DIRECTION) and (age <= 3) then
        -- we're at the decision point and its not stale
        check_wind_and_jump_to_INTO_wind_landing()
    end

    return update, 1000
end


gcs:send_text(MAV_SEVERITY.INFO, "LUA: SCRIPT START: Jump_Tag into wind landing")
return update() -- run immediately before starting to reschedule



================================================
File: examples/jump_tags_into_wind_landing.waypoints
================================================
QGC WPL 110
0	1	0	16	0	0	0	0	-35.3632622	149.1652376	584.090000	1
1	0	3	22	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	10.000000	1
2	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36296350	149.15812610	200.000000	1
3	0	3	189	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
4	0	3	31	1.00000000	0.00000000	0.00000000	0.00000000	-35.36289790	149.16306140	50.000000	1
5	0	3	600	200.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
6	0	3	17	0.00000000	0.00000000	0.00000000	0.00000000	-35.36289790	149.16335600	50.000000	1
7	0	3	600	300.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
8	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36733370	149.16327060	40.000000	1
9	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36704940	149.16576500	30.000000	1
10	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.36595570	149.16557190	30.000000	1
11	0	3	21	0.00000000	0.00000000	0.00000000	0.00000000	-35.36304990	149.16518770	0.000000	1
12	0	3	600	301.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.00000000	0.000000	1
13	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35827370	149.16196170	40.000000	1
14	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35809000	149.16448300	30.000000	1
15	0	3	16	0.00000000	0.00000000	0.00000000	0.00000000	-35.35932370	149.16465460	30.000000	1
16	0	3	21	0.00000000	0.00000000	0.00000000	0.00000000	-35.36246480	149.16510790	0.000000	1



================================================
File: examples/land_hagl.lua
================================================
--[[
   demonstrate proving HAGL to plane code for landing
--]]

local MAV_CMD_SET_HAGL = 43005

local ROTATION_PITCH_90 = 24
local ROTATION_PITCH_270 = 25

-- for normal landing use PITCH_270, for inverted use PITCH_90
local RANGEFINDER_ORIENT = ROTATION_PITCH_270

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local RNG_STATUS = { NotConnected = 0, NoData = 1, OutOfRangeLow = 2, OutOfRangeHigh = 3, Good = 4 }


--[[
 create a NaN value
--]]
local function NaN()
   return 0/0
end

local last_active = false

--[[
   send HAGL data
--]]
local function send_HAGL()
   local status = rangefinder:status_orient(RANGEFINDER_ORIENT)
   if status ~= RNG_STATUS.Good then
      last_active = false
      return
   end
   local rangefinder_dist = rangefinder:distance_orient(RANGEFINDER_ORIENT)
   local correction = math.cos(ahrs:get_roll_rad())*math.cos(ahrs:get_pitch_rad())
   local rangefinder_corrected = rangefinder_dist * correction
   if RANGEFINDER_ORIENT == ROTATION_PITCH_90 then
      rangefinder_corrected = -rangefinder_corrected
   end
   if rangefinder_corrected < 0 then
      last_active = false
      return
   end

   -- tell plane the height above ground level
   local timeout_s = 0.2
   local accuracy = NaN()
   gcs:run_command_int(MAV_CMD_SET_HAGL, { p1 = rangefinder_corrected, p2 = accuracy, p3=timeout_s })

   if not last_active then
      last_active = true
      gcs:send_text(MAV_SEVERITY.INFO, string.format("HAGL Active %.1f", rangefinder_corrected))
   end

   -- log it
   logger:write("HAGL", "RDist,HAGL", "ff", rangefinder_dist, rangefinder_corrected)
end

local function update()
   send_HAGL()
   return update, 50
end

gcs:send_text(MAV_SEVERITY.INFO, "Loaded land_hagl")

return update, 1000




================================================
File: examples/lidar_control.lua
================================================
-- enable use of Lidar on quadplanes only for landing, by changing RNGFN_LANDING

local RNGFND_LANDING = Parameter("RNGFND_LANDING")

MODE_QLAND = 20
MODE_QRTL = 21
MODE_AUTO = 10

local NAV_LAND = 21
local NAV_VTOL_LAND = 85

function in_landing()
   local mode = vehicle:get_mode()
   if mode == MODE_QRTL or mode == MODE_QLAND then
      return true
   end
   if mode == MODE_AUTO then
      local id = mission:get_current_nav_id()
      if id == NAV_VTOL_LAND or id == NAV_LAND then
         return true
      end
   end
   return false
end

-- convert a boolean to an int
function bool_to_int(v)
  return v and 1 or 0
end

function update()
   local v = bool_to_int(in_landing())
   if v ~= RNGFND_LANDING:get() then
      if v == 1 then
         gcs:send_text(0,"Enabling Lidar")
      else
         gcs:send_text(0,"Disabling Lidar")
      end
      RNGFND_LANDING:set(v)
   end

  -- run at 1Hz
  return update, 1000
end

return update()



================================================
File: examples/logging.lua
================================================
-- example of logging to a file on the SD card and to data flash
local file_name = "AHRS_DATA.csv"
local file

-- index for the data and table
local roll = 1
local pitch = 2
local yaw = 3
local interesting_data = {}

local function write_to_file()

  if not file then
    error("Could not open file")
  end

  -- write data
  -- separate with comas and add a carriage return
  file:write(tostring(millis()) .. ", " .. table.concat(interesting_data,", ") .. "\n")

  -- make sure file is upto date
  file:flush()

end

local function write_to_dataflash()

  -- care must be taken when selecting a name, must be less than four characters and not clash with an existing log type
  -- format characters specify the type of variable to be logged, see AP_Logger/README.md
  -- https://github.com/ArduPilot/ardupilot/tree/master/libraries/AP_Logger
  -- not all format types are supported by scripting only: i, L, e, f, n, M, B, I, E, and N
  -- lua automatically adds a timestamp in micro seconds
  logger:write('SCR1','roll(deg),pitch(deg),yaw(deg)','fff',interesting_data[roll],interesting_data[pitch],interesting_data[yaw])

  -- it is also possible to give units and multipliers
  logger:write('SCR2','roll,pitch,yaw','fff','ddd','---',interesting_data[roll],interesting_data[pitch],interesting_data[yaw])

end

function update()

  -- get some interesting data
  interesting_data[roll] = math.deg(ahrs:get_roll_rad())
  interesting_data[pitch] = math.deg(ahrs:get_pitch_rad())
  interesting_data[yaw] = math.deg(ahrs:get_yaw_rad())

  -- write to then new file the SD card
  write_to_file()

  -- write to a new log in the data flash log
  write_to_dataflash()

  return update, 1000 -- reschedules the loop
end

-- make a file
-- note that this appends to the same the file each time, you will end up with a very big file
-- you may want to make a new file each time using a unique name
file = io.open(file_name, "a")
if not file then
  error("Could not make file")
end

-- write the CSV header
file:write('Time Stamp(ms), roll(deg), pitch(deg), yaw(deg)\n')
file:flush()

return update, 10000



================================================
File: examples/mag_heading.lua
================================================
--[[ 
   send magnetic heading in degrees as NAMED_VALUE_FLOAT[MAG_HEAD] and NAMED_VALUE_FLOAT[MAG_GCRS]
--]]

local RATE_HZ = 2

-- bind a parameter to a variable given
function bind_param(name)
    local p = Parameter()
    assert(p:init(name), string.format('could not find %s parameter', name))
    return p
end

COMPASS_DEC = bind_param("COMPASS_DEC")

function wrap_360(angle)
    local res = angle % 360
    if res < 0 then
      res = res + 360
    end
    return res
end

function update()
   local yaw_deg = wrap_360(math.deg(ahrs:get_yaw_rad() - COMPASS_DEC:get()))
   local gspd = ahrs:groundspeed_vector()
   local gcrs_deg = wrap_360(math.deg(math.atan(gspd:y(), gspd:x()) - COMPASS_DEC:get()))
   gcs:send_named_float("MAG_HEAD", yaw_deg)
   gcs:send_named_float("MAG_GCRS", gcrs_deg)
end

gcs:send_text(0, "MagHeading loaded")

local MAV_SEVERITY_ERROR = 3

-- wrapper around update(). This calls update() and if update faults
-- then an error is displayed, but the script is not stopped
function protected_wrapper()
    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY_ERROR, "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, math.floor(1000 / RATE_HZ)
end

-- start running update loop
return protected_wrapper()



================================================
File: examples/message_interval.lua
================================================
-- This script is an example of manipulating the message stream rates
--
-- It will periodically run and adjust all the messages to their desired loop rates
-- It can be modified to only run once, however some GCS's will manipulate the rates
-- during the initial connection, so by resetting them periodically we ensure we get
-- the expected telemetry rate

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local loop_time = 5000 -- number of ms between runs

-- mavlink message ids
local AHRS_ID                   = uint32_t(163)
local AHRS2_ID                  = uint32_t(178)
local ATTITUDE_ID               = uint32_t(30)
--local EKF_STATUS_REPORT_ID      = uint32_t(193)
--local GLOBAL_POSITION_INT_ID    = uint32_t(33)
--local GPS_RAW_INT_ID            = uint32_t(24)
--local LOCAL_POSITION_NED_ID     = uint32_t(32)
--local NAV_CONTROLLER_OUTPUT_ID  = uint32_t(62)
--local POWER_STATUS_ID           = uint32_t(125)
--local RAW_IMU_ID                = uint32_t(27)
--local RC_CHANNELS_ID            = uint32_t(65)
--local SERVO_OUTPUT_RAW_ID       = uint32_t(36)
--local SYS_STATUS_ID             = uint32_t(1)
--local SYSTEM_TIME_ID            = uint32_t(2)
--local VFR_HUD_ID                = uint32_t(74)
--local VIBRATION_ID              = uint32_t(241)
--local WIND_ID                   = uint32_t(168)

-- serial port
local serial_port = 0

-- intervals is a table which contains a table for each entry we want to adjust
-- each entry is arranged as {the serial link to adjust, the mavlink message ID, and the broadcast interval in Hz}
local intervals = {{serial_port, ATTITUDE_ID, 2.0}, -- ATTITUDE, 2Hz
                   {serial_port, AHRS_ID, 5.0},     -- AHRS, 5Hz
                   {serial_port, AHRS2_ID, 0},      -- AHRS2, 0hz
                  }

-- print welcome message
gcs:send_text(MAV_SEVERITY.INFO, "Loaded message_interval.lua")

function update() -- this is the loop which periodically runs
  for i = 1, #intervals do -- we want to iterate over every specified interval
    local channel, message, interval_hz = table.unpack(intervals[i]) -- this extracts the channel, MAVLink ID, and interval

    -- Lua checks get the unpacked types wrong, these are the correct types
    ---@cast channel integer
    ---@cast message uint32_t_ud
    ---@cast interval_hz number

    local interval_us = -1
    if interval_hz > 0 then
      interval_us = math.floor(1000000 / interval_hz) -- convert the interval to microseconds
    end
    gcs:set_message_interval(channel, message, interval_us) -- actually sets the interval as appropriate
  end
  return update, loop_time -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/mission-edit-demo.lua
================================================
-- mission editing demo lua script.
-- by Buzz 2020
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: undefined-field

current_pos = nil
home = 0
a = {}
demostage = 0 
eventcounter = 0

function update () -- periodic function that will be called
    current_pos = ahrs:get_location()

  -- adds new/extra mission item at the end by copying the last one and modifying it
  -- get number of last mission item
  wp_num = mission:num_commands()-1
  --get last item from mission
  m = mission:get_item(wp_num) 
  -- get first item from mission
  m1 = mission:get_item(1) 

  if wp_num >  0 then
    gcs:send_text(0, string.format("LUA - Please clear misn to continue demo. size:%d",wp_num+1))
    return update, 1000
  end

  -- no mission, just home at [0] means user has cleared any mission in the system, and this demo is clear to write something new.
  -- it's not required that the mission be empty before we do things, but this script is multi-stage demo so its conveneient
  if ( mission:num_commands() == 1) then
      if demostage == 0  then
            demostage = 1
            gcs:send_text(0, string.format("LUA demo stage 1 starting"))
            return stage1, 1000
      end 
      if demostage == 2  then
            demostage = 3
            gcs:send_text(0, string.format("LUA demo stage 3 starting"))
            return stage3, 1000
      end
      if demostage == 4  then
            demostage = 5
            gcs:send_text(0, string.format("LUA demo stage 5 starting"))
            return stage5, 1000
      end
      if demostage == 6  then
            demostage = 7
            gcs:send_text(0, string.format("LUA demo stage 7 starting"))
            return stage7, 1000
      end
      if demostage == 8  then
            demostage = 9
            gcs:send_text(0, string.format("LUA MISSION demo all COMPLETED."))
            --return update, 1000
      end
  end
  return update, 1000
end

function read_table_from_sd()
    -- Opens a file in read mode
    file = io.open("miss.txt", "r")
    -- sets the default input file as xxxx.txt
    io.input(file)

    -- read whole file, or get empty string
    content = io.read("*all")
    
    if (content == nil) then
        gcs:send_text(0, string.format("file not found, skipping read of miss.txt from sd"))
        return update(), 1000
    end

    local pat = "wp:(%S+)%s+lat:(%S+)%s+lon:(%S+)%s+alt:(%S+)"
    for s1, s2 ,s3,s4 in string.gmatch(content, pat) do
        --s = string.format("wp:%s lat:%s lon:%s alt:%s",s1,s2,s3,s4)
        --gcs:send_text(0, s)
        n1 = tonumber(s1)
        n2 = math.floor(tonumber(s2*10000000))
        n3 = math.floor(tonumber(s3*10000000))
        n4 = tonumber(s4)

        -- use previous item as template...
        m = mission:get_item(mission:num_commands()-1)
        m:command(16) -- 16 = normal WAYPOINT
        m:x(n2)
        m:y(n3)
        m:z(n4)
        -- write as a new item to the end of the list.
        mission:set_item(mission:num_commands(),m)
    end

    gcs:send_text(0, '...loaded file from SD')

    -- closes the open file
    io.close(file)

  return update(), 1000
end

function stage1 ()
  -- demo stage 1 implementation.
  if (demostage == 1 ) and ( mission:num_commands() == 1 )  then
    demostage = 2
    return read_table_from_sd(), 1000
  end

end

function stage3 ()
  -- demo stage 3 implementation.
  --get number of 'last' mission item
  wp_num = mission:num_commands()-1
  -- get HOME item from mission as the 'reference' for future items
  m1 = mission:get_item(0) 
  --get last item from mission
  m = mission:get_item(wp_num) 
  if (demostage == 3 ) then
      -- demo stage 3 starts by writing 10 do-JUMPS over 10 seconds, just for fun
      if mission:num_commands() < 10  then
          m:command(177) -- 177 =  DO_JUMP
          m:param1(m:param1()+1) -- some increments for fun/demo
          m:param2(m:param2()+1)
          gcs:send_text(0, string.format("LUA new miss-item DO_JUMP %d ", wp_num+1))
          mission:set_item(mission:num_commands(),m)
          return stage3, 100 -- stay in stage 3 for now
      end

      -- change copy of last item slightly, for giggles and demo.
      -- This is reading a copy of whatever is currently the last item in the mission, do_jump
      --  and changing/ensuring its type is a 'normal' waypoint, and setting its lat/long/alt
      --  to data we earlier took from HOME, adding an offset and then writing it 
      --  as a NEW mission item at the end 
      if mission:num_commands() == 10 then
          m:command(16) -- 16 = normal WAYPOINT
          m:x(m1:x()+200)
          m:y(m1:y()+200)
          m:z(m1:z()+1)
          gcs:send_text(0, string.format("LUA new miss-item WAYPOINT a %d ", wp_num+1))
          mission:set_item(mission:num_commands(),m)
          return stage3, 100 -- stay in stage 3 for now
      end

      -- change copy of last item slightly, for giggles, and append as a new item
      if (mission:num_commands() > 10) and (mission:num_commands() < 20) then
          m:command(16) -- 16 = normal WAYPOINT
          m:x(m:x()+200)
          m:y(m:y()+200)
          m:z(m:z()+1)
          gcs:send_text(0, string.format("LUA new miss-item WAYPOINT b %d ", wp_num+1))
          mission:set_item(mission:num_commands(),m)
          return stage3, 100 -- stay in stage 3 for now
      end

      -- change copy of last item slightly, for giggles.
      if (mission:num_commands() >= 20) and (mission:num_commands() < 30) then
          m:command(16) -- 16 = normal WAYPOINT
          m:x(m:x()+200)
          m:y(m:y()+200)
          m:z(m:z()+1)
          gcs:send_text(0, string.format("LUA new miss-item WAYPOINT c %d ", wp_num+1))
          mission:set_item(mission:num_commands(),m)
          return stage3, 100 -- stay in stage 3 for now
      end
      -- move on at end of this dempo stage
      if (mission:num_commands() >= 30) then
          gcs:send_text(0, string.format("LUA DEMO stage 3 done. ", wp_num+1))
          demostage = 4
          return update, 100 -- drop to next stage via an update() call
      end
  end

end

function stage5 ()
  -- demo stage 5 implementation for when there's only one wp , HOME, in th system
  if (demostage == 5 ) then 
      -- when no mission, uses home as reference point, otherwise its the 'last item'
      m = mission:get_item(mission:num_commands()-1)
      m:x(m:x())
      m:y(m:y()-400)
      m:z(m:z())
      mission:set_item(1,m)
      gcs:send_text(0, string.format("LUA mode 5 single wp nudge %d",eventcounter))
      eventcounter = eventcounter+1
      if eventcounter > 50 then
          demostage = 6
          eventcounter = 0
          gcs:send_text(0, string.format("LUA DEMO stage 5 done. "))
          return update, 100 -- drop to next stage via an update() call
      end
      return stage5, 100 -- stay in stage 3 for now
  end

end

function stage7 ()
  -- demo stage 5 implementation for when there's more than wp in the system
  if (demostage == 7 ) then --and (mission:num_commands() >= 3) and (mission:num_commands() < 50) then
      -- fiurst time in , there's no mission, lets throw a few wps in to play with later..
      -- change copy of last item slightly, for giggles, and append as a new item
      if (mission:num_commands() == 1)  then
          for _ = 1, 10 do 
              m:command(16) -- 16 = normal WAYPOINT
              m:x(m:x()+math.random(-10000,10000)) -- add something random 
              m:y(m:y()+math.random(-10000,10000)) 
              m:z(m:z()+1)
              gcs:send_text(0, string.format("LUA stage 7 making 10 new nearby random wp's %d ", wp_num+1))
              mission:set_item(mission:num_commands(),m)
          end
          gcs:send_text(0, string.format("LUA scattering complete. %d ", wp_num+1))
          return stage7, 100 -- stay in stage 3 for now
      end
 
    -- things that are further away from this one than distance X..
    m1 = mission:get_item(1)

    -- leave item 0 alone, always
    for x = 1, mission:num_commands()-1 do 

        mitem = mission:get_item(x)

        -- look at each mission item above 1, and get the distance from it to the copter.
        local target = Location()
        target:lat(mitem:x())
        target:lng(mitem:y())
        local cur_d = current_pos:get_distance(target)
        
        if cur_d > 100 then
            if mitem:x() > m1:x() then
                 mitem:x(mitem:x()+400)           
            end
            if mitem:x() < m1:x() then
                 mitem:x(mitem:x()-400)  
            end
            if mitem:y() > m1:y() then
                 mitem:y(mitem:y()+400)        
            end
            if mitem:y() < m1:y() then
                 mitem:y(mitem:y()-400)         
            end
        end

        -- write as a new item to the end of the list.
        mission:set_item(x,mitem)
    end
    gcs:send_text(0, string.format("LUA mode 7 scattering existing wp's.. %d",eventcounter))
  end

  -- do it 50 times then consider it done
  eventcounter = eventcounter+1
  if eventcounter > 50 then
          demostage = 8
          eventcounter = 0
          gcs:send_text(0, string.format("LUA DEMO stage 7 done. "))
          return update, 100 -- drop to next stage via an update() call
  end

  return stage7, 500
end

function wait_for_home()
  current_pos = ahrs:get_location()
  if current_pos == nil then
     return wait_for_home, 1000
  end

  home = ahrs:get_home()
  if home == nil then
     return wait_for_home, 1000
  end
  if home:lat() == 0 then
     return wait_for_home, 1000
  end

  gcs:send_text(0, string.format("LUA MISSION Waiting for Home."))

  return update, 1000
end

function delayed_boot()
    gcs:send_text(0, string.format("LUA MISSION DEMO START"))
    return wait_for_home, 1000
end
return delayed_boot, 5000 




================================================
File: examples/mission-load.lua
================================================
-- Example of loading a mission from the SD card using Scripting
-- Would be trivial to select a mission based on scripting params or RC switch
--Copy this "mission-load.lua" script to the "scripts" directory of the simulation or autopilot's SD card. 
--The "mission1.txt" file containing the mission items should be placed in the directory above the "scripts" directory. 
--In case of placing it on SD Card, mission1.txt file should be placed in the APM directory root.

---@diagnostic disable: param-type-mismatch

local function read_mission(file_name)

  -- Open file
  file = assert(io.open(file_name), 'Could not open :' .. file_name)

  -- check header
  assert(string.find(file:read('l'),'QGC WPL 110') == 1, file_name .. ': incorrect format')

  -- clear any existing mission
  assert(mission:clear(), 'Could not clear current mission')

  -- read each line and write to mission
  local item = mavlink_mission_item_int_t()
  local index = 0
  local fail = false
  while true and not fail do
     local line = file:read()
     if not line then
        break
     end
     local ret, _, seq, _--[[ curr ]], frame, cmd, p1, p2, p3, p4, x, y, z, _--[[ autocont ]] = string.find(line, "^(%d+)%s+(%d+)%s+(%d+)%s+(%d+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+([-.%d]+)%s+(%d+)")
     if not ret then
        fail = true
        break
     end
     if tonumber(seq) ~= index then
        fail = true
        break
     end
     item:seq(tonumber(seq))
     item:frame(tonumber(frame))
     item:command(tonumber(cmd))
     item:param1(tonumber(p1))
     item:param2(tonumber(p2))
     item:param3(tonumber(p3))
     item:param4(tonumber(p4))
     if mission:cmd_has_location(tonumber(cmd)) then
        item:x(math.floor(tonumber(x)*10^7))
        item:y(math.floor(tonumber(y)*10^7))
     else
        item:x(math.floor(tonumber(x)))
        item:y(math.floor(tonumber(y)))
     end
     item:z(tonumber(z))
     if not mission:set_item(index,item) then
        mission:clear() -- clear part loaded mission
        fail = true
        break
     end
     index = index + 1
  end
  if fail then
     mission:clear()  --clear anything already loaded
     error(string.format('failed to load mission at seq num %u', index))
  end
  gcs:send_text(0, string.format("Loaded %u mission items", index))
end

function update()
  read_mission('mission1.txt')
  return
end

return update, 5000



================================================
File: examples/mission-save.lua
================================================
-- Example of saving the current mission to a file on the SD card on arming

---@diagnostic disable: need-check-nil

local function save_to_SD()

  -- check if there is a mission to save
  local num_wp = mission:num_commands()
  if num_wp <= 1 then
    return
  end

  local index = 0
  local file_name
  -- search for a index without a file
  while true do
    file_name = string.format('%i.waypoints',index)
    local file = io.open(file_name)
    if file == nil then
      break
    end
    local first_line = file:read(1) -- try and read the first character
    io.close(file)
    if first_line == nil then
      break
    end
    index = index + 1
  end

  -- create new file
  file = assert(io.open(file_name, 'w'), 'Could not make file :' .. file_name)

  -- header
  file:write('QGC WPL 110\n')

  -- read each item and write to file
  for i = 0, num_wp - 1 do
    local item = mission:get_item(i)
    file:write(string.format('%i\t0\t%i\t%i\t%0.8f\t%.8f\t%.8f\t%.8f\t%.8f\t%.8f\t%.6f\t1\n',item:seq(),item:frame(),item:command(),item:param1(),item:param2(),item:param3(),item:param4(),item:x()*10^-7,item:y()*10^-7,item:z()))
  end

  file:close()

  gcs:send_text(6,'saved mission to: ' .. file_name)

end

function idle_disarmed()
  if arming:is_armed() then
    save_to_SD()
    return idle_armed, 1000
  end
  return idle_disarmed, 1000
end

function idle_armed()
  if not arming:is_armed() then
    return idle_disarmed, 1000
  end
  return idle_armed, 1000
end

return idle_disarmed, 1000



================================================
File: examples/mission_spiral.lua
================================================
--[[
   create a mission of SCR_USER1 waypoints in a spiral pattern, for
   testing large mission transfer

   Runs on any change to SCR_USER1
--]]

local SCR_USER1 = Parameter("SCR_USER1") -- number of WPs
local SCR_USER2 = Parameter("SCR_USER2") -- radius
local SCR_USER3 = Parameter("SCR_USER3") -- center lat
local SCR_USER4 = Parameter("SCR_USER4") -- center lon
local SCR_USER5 = Parameter("SCR_USER5") -- altitude
local SCR_USER6 = Parameter("SCR_USER6") -- number of WPs for spiral compare

local last_SCR_USER1 = SCR_USER1:get()
local last_SCR_USER6 = SCR_USER6:get()

local NAV_WAYPOINT = 16
local FRAME_GLOBAL = 3

local ANGLE_INCREMENT = 5.0
local MIN_RADIUS = 10.0

--[[
   create a waypoint
--]]
function create_WP(i, center, radius, angle)
   local item = mavlink_mission_item_int_t()
   local loc = center:copy()
   loc:offset_bearing(radius, angle)

   item:seq(i)
   item:frame(FRAME_GLOBAL)
   item:command(NAV_WAYPOINT)
   item:param1(0)
   item:param2(0)
   item:param3(0)
   item:param4(0)
   item:x(loc:lat())
   item:y(loc:lng())
   item:z(100+loc:alt()*0.01)
   return item
end

--[[
   create a waypoint based on index
--]]
function create_WP_idx(center, idx)
   local radius = SCR_USER2:get()
   if radius < MIN_RADIUS then
      radius = MIN_RADIUS
   end
   return create_WP(idx, center, radius+idx, idx*ANGLE_INCREMENT)
end

--[[
   get center Location
--]]
function get_center()
   -- if USER3 and USER4 set then use those, allowing autotest to control exact position
   if SCR_USER3:get() ~= 0 and SCR_USER4:get() ~= 0 then
      local loc = Location()
      loc:lat(math.floor(SCR_USER3:get()*1.0e7))
      loc:lng(math.floor(SCR_USER4:get()*1.0e7))
      loc:alt(math.floor(SCR_USER5:get()*100))
      return loc
   end
   return ahrs:get_location()
end

--[[
   create an N point spiral mission
--]]
function create_spiral(N)
   local center = get_center()
   if not center then
      gcs:send_text(0, "Error: Need AHRS location for spiral center")
      return
   end
   mission:clear()

   gcs:send_text(0, string.format("Creating spiral of size %u", N))

   for i=0, N-1 do
      local item = create_WP_idx(center, i)
      if not mission:set_item(i, item) then
         gcs:send_text(0, string.format("Failed to create WP %u", i))
         N = i
         break
      end
   end
   gcs:send_text(0, string.format("Created spiral of size %u", N))
end

--[[
   compare current mission with spiral, used in autotest
--]]
function compare_spiral(N)
   local center = get_center()
   if not center then
      gcs:send_text(0, "Error: Need AHRS location for spiral center")
      return
   end
   gcs:send_text(0, string.format("Comparing spiral of size %u", N))

   -- start from index 1 as home can change
   for i=1, N-1 do
      local item1 = create_WP_idx(center, i)
      local item2 = mission:get_item(i)
      if not item2 then
         gcs:send_text(0, string.format("Failed to fetch WP %u", i))
         return
      end
      if item1:x() ~= item2:x() or item1:y() ~= item2:y() or item1:z() ~= item2:z() then
         gcs:send_text(0, string.format("Compared fail %u (%.8f %.8f %.2f) (%.8f %.8f %.2f)", i,
                                        item1:x()*1.0e-7,
                                        item1:y()*1.0e-7,
                                        item1:z(),
                                        item2:x()*1.0e-7,
                                        item2:y()*1.0e-7,
                                        item2:z()))
         return
      end
   end
   gcs:send_text(0, string.format("Compared spiral of size %u OK", N))
end

function update()
   if SCR_USER1:get() ~= last_SCR_USER1 and SCR_USER1:get() > 0 then
      last_SCR_USER1 = SCR_USER1:get();
      create_spiral(last_SCR_USER1);
   end
   if SCR_USER6:get() ~= last_SCR_USER6 and SCR_USER6:get() > 0 then
      last_SCR_USER6 = SCR_USER6:get();
      compare_spiral(last_SCR_USER6);
   end
   return update, 1000
end

gcs:send_text(0, "Loaded spiral mission creator")
return update, 1000



================================================
File: examples/motor_lost.lua
================================================
--[[
   display motor lost number from MotorsMatrix for multirotors
--]]

local last_motor_lost = -1

function update()
   local lost_index
   if not MotorsMatrix:get_thrust_boost() then
      -- when get_thrust_boost is false then we have not lost a motor
      lost_index = -1
   else
      -- otherwise get the lost motor number
      lost_index = MotorsMatrix:get_lost_motor()
   end
   if lost_index ~= last_motor_lost then
      if lost_index == -1 then
         gcs:send_text(0, string.format("Motors: recovered"))
      else
         gcs:send_text(0, string.format("Motors: lost motor %d", lost_index+1))
      end
      last_motor_lost = lost_index
   end
   return update, 100
end

return update, 100



================================================
File: examples/mount-test.lua
================================================
-- moves 3-axis gimbal (aka "mount") using earth-frame and body-frame rates and angles
--
-- stage 0: move gimbal to neutral position
-- stage 1: yaw CW at 10deg/s in body-frame
-- stage 2: yaw CCW at 10 deg/s in body-frame
-- stage 3: pitch at 10 deg/s in body-frame
-- stage 4: pitch at -10 deg/s in body-frame
-- stage 5: roll at 10 deg/s in body-frame
-- stage 6: roll at -10 deg/s in body-frame
-- stage 7: point North
-- stage 8: point South and center
-- stage 9: point North and Down
-- stage 10: move angle to neutral position

---@diagnostic disable: cast-local-type

local stage = 0
local stage_time_ms = 5000
local stage_start_time_ms = 0
local last_stage = 10

-- the main update function that performs a simplified version of RTL
function update()

  -- get current system time
  local now_ms = millis()

  -- start
  if stage_start_time_ms == 0 then
    stage_start_time_ms = now_ms
  end

  -- check if time to move to next stage
  local update_user = false
  if (now_ms - stage_start_time_ms > stage_time_ms) and (stage < last_stage) then
    stage = stage + 1
    stage_start_time_ms = now_ms
    update_user = true
  end

  if stage == 0 or stage >= last_stage then
    -- move angle to neutral position
    mount:set_angle_target(0, 0, 0, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " move to neutral position")
    end
  end

  if stage == 1 then
    -- yaw CW at 10deg/s in body-frame
    mount:set_rate_target(0, 0, 0, 10, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " yaw at 10deg/s")
    end
  end

  if stage == 2 then
    -- yaw CCW at 10 deg/s in body-frame
    mount:set_rate_target(0, 0, 0, -10, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " yaw at -10deg/s")
    end
  end

  if stage == 3 then
    -- pitch at 10 deg/s in body-frame
    mount:set_rate_target(0, 0, 10, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " pitch at 10deg/s")
    end
  end

  if stage == 4 then
    -- pitch at -10 deg/s in body-frame
    mount:set_rate_target(0, 0, -10, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " pitch at -10deg/s")
    end
  end

  if stage == 5 then
    -- roll at 10 deg/s in body-frame
    mount:set_rate_target(0, 10, 0, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " roll at 10deg/s")
    end
  end

  if stage == 6 then
    -- roll at -10 deg/s in body-frame
    mount:set_rate_target(0, -10, 0, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " roll at -10deg/s")
    end
  end

  if stage == 7 then
    -- point North
    mount:set_angle_target(0, 0, 0, 0, true)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " point North")
    end
  end

  if stage == 8 then
    -- point South and center
    mount:set_angle_target(0, 0, 0, 180, true)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " point South")
    end
  end

  if stage == 9 then
    -- point North and Down
    mount:set_angle_target(0, 0, -90, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " point Down")
    end
  end

  if stage > last_stage then
    -- move angle to neutral position
    mount:set_angle_target(0, 0, 0, 0, false)
    if update_user then
      gcs:send_text(6, "stage:" .. tostring(stage) .. " done!")
    end
  end

  return update, 100
end

return update()



================================================
File: examples/net_test.lua
================================================
--[[
   example script to test lua socket API
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

PARAM_TABLE_KEY = 46
PARAM_TABLE_PREFIX = "NT_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
    return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- Setup Parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 6), 'net_test: could not add param table')

--[[
  // @Param: NT_ENABLE
  // @DisplayName: enable network tests
  // @Description: Enable network tests
  // @Values: 0:Disabled,1:Enabled
  // @User: Standard
--]]
local NT_ENABLE = bind_add_param('ENABLE',  1, 0)
if NT_ENABLE:get() == 0 then
   return
end

local NT_TEST_IP = { bind_add_param('TEST_IP0', 2, 192),
                     bind_add_param('TEST_IP1', 3, 168),
                     bind_add_param('TEST_IP2', 4, 13),
                     bind_add_param('TEST_IP3', 5, 15) }

local NT_BIND_PORT = bind_add_param('BIND_PORT', 6, 15001)

local PORT_ECHO = 7

gcs:send_text(MAV_SEVERITY.INFO, "net_test: starting")

local function test_ip()
   return string.format("%u.%u.%u.%u", NT_TEST_IP[1]:get(), NT_TEST_IP[2]:get(), NT_TEST_IP[3]:get(), NT_TEST_IP[4]:get())
end

local counter = 0
local sock_tcp_echo = Socket(0)
local sock_udp_echo = Socket(1)
local sock_tcp_in = Socket(0)
local sock_tcp_in2 = nil
local sock_udp_in = Socket(1)

assert(sock_tcp_echo, "net_test: failed to create tcp echo socket")
assert(sock_udp_echo, "net_test: failed to create udp echo socket")
assert(sock_tcp_in:bind("0.0.0.0",
                        NT_BIND_PORT:get()), string.format("net_test: failed to bind to TCP %u", NT_BIND_PORT:get()))
assert(sock_tcp_in:listen(1), "net_test: failed to listen")
assert(sock_udp_in:bind("0.0.0.0",
                        NT_BIND_PORT:get()), string.format("net_test: failed to bind to UDP %u", NT_BIND_PORT:get()))

--[[
   test TCP or UDP echo
--]]
local function test_echo(name, sock)
   if not sock:is_connected() then
      if not sock:connect(test_ip(), PORT_ECHO) then
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_echo(%s): failed to connect", name))
         return
      end

      if not sock:set_blocking(true) then
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_echo(%s): failed to set blocking", name))
         return
      end
   end

   local s = string.format("testing %u", counter)
   local nsent = sock:send(s, #s)
   if nsent ~= #s then
      gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_echo(%s): failed to send", name))
      return
   end
   local r = sock:recv(#s)
   if r then
      gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_echo(%s): got reply '%s'", name, r))
   end
end

--[[
   test a simple server
--]]
local function test_server(name, sock)
   if name == "TCP" then
      if not sock_tcp_in2 then
         sock_tcp_in2 = sock:accept()
         if not sock_tcp_in2 then
            return
         end
         gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_server(%s): new connection", name))
      end
      sock = sock_tcp_in2
   end

   local r, ip, port = sock:recv(1024)
   if r and #r > 0 then
      gcs:send_text(MAV_SEVERITY.ERROR, string.format("test_server(%s): got input '%s'", name, r))
   end
   if ip then
      gcs:send_text(MAV_SEVERITY.INFO, string.format("packet from %s:%u", ipv4_addr_to_string(ip), port))
   end
end

local function update()
   test_echo("TCP", sock_tcp_echo)
   test_echo("UDP", sock_udp_echo)
   test_server("TCP", sock_tcp_in)
   test_server("UDP", sock_udp_in)
   counter = counter + 1
   return update,1000
end

return update,100



================================================
File: examples/notch_switch.lua
================================================
--[[

   example script to switch between two notch setups by changing the
   attenuation to zero on the notch to disable. This allows for easy
   in-flight switching between two different notch setups
--]]
local INS_HNTCH_ATT = Parameter('INS_HNTCH_ATT')
local INS_HNTC2_ATT = Parameter('INS_HNTC2_ATT')

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

if not INS_HNTCH_ATT:get() or not INS_HNTC2_ATT:get() then
   gcs:send_text(MAV_SEVERITY.ERROR, string.format("Need 2 notches configured"))
   return
end

local last_sw = -1
local AUX_FN = 300

local attenuation = INS_HNTCH_ATT:get()
if not attenuation then
   gcs:send_text(MAV_SEVERITY.ERROR, string.format("Unable to get attenuation"))
   return
end

function update()
   local sw_current = rc:get_aux_cached(AUX_FN)
   if not sw_current then
      -- treat unset as notch1
      sw_current = 0
   end
   if sw_current ~= last_sw then
      last_sw = sw_current
      if sw_current == 0 then
         INS_HNTC2_ATT:set(0)
         INS_HNTCH_ATT:set(attenuation)
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Switched to notch1 %.2f", attenuation))
      else
         INS_HNTC2_ATT:set(attenuation)
         INS_HNTCH_ATT:set(0)
         gcs:send_text(MAV_SEVERITY.INFO, string.format("Switched to notch2 %.2f", attenuation))
      end
   end
   return update,100
end

return update()




================================================
File: examples/opendog_demo.lua
================================================
-- demo of waving paw of opendog

local pwm = { 1500, 1500, 2000,
              1500, 1500, 1000,
              1500, 1500, 1500,
              1500, 1500, 1500 }

function update()
   local t = 0.001 * millis():tofloat()
   local angle = math.sin(t) * 0.5
   pwm[6] = math.floor(1500.0 + angle*500.0)
   for i = 1, 12 do
       SRV_Channels:set_output_pwm_chan_timeout(i-1, pwm[i], 1000)
    end
    return update, 200
end

gcs:send_text(0, "opendog demo starting")
return update, 1000



================================================
File: examples/orbit_follow.lua
================================================
-- example that does an orbit of a vehicle that is being followed
-- by adjusting the follow offset X and Y parameters
-- user settable FOLL_ORB_TIME and FOLL_ORB_RADIUS parameters
-- are provided for the time for one orbit (in seconds) and the radius
-- of the orbit

-- setup param block for FOLL_ extensions
local PARAM_TABLE_KEY = 83
local PARAM_TABLE_PREFIX = "FOLL_"
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 2), 'could not add param table')

function bind_add_param(name, index, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, index,  name, default_value), string.format('could not add %s', PARAM_TABLE_PREFIX .. name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

local FOLL_OFS_X = Parameter("FOLL_OFS_X")
local FOLL_OFS_Y = Parameter("FOLL_OFS_Y")
local FOLL_ORB_RADIUS = bind_add_param("ORB_RADIUS", 1, 5)
local FOLL_ORB_TIME = bind_add_param("ORB_TIME", 2, 10)

local t = 0

function update()
   t = t + 0.1
   --gcs:send_text(0, string.format("t=%.2f X=%.2f Y=%.2f", t, FOLL_OFS_X:get(), FOLL_OFS_Y:get()))
   if t > FOLL_ORB_TIME:get() then
      t = t - FOLL_ORB_TIME:get()
   end
   FOLL_OFS_X:set(math.cos((t/FOLL_ORB_TIME:get())*2*math.pi)*FOLL_ORB_RADIUS:get())
   FOLL_OFS_Y:set(math.sin((t/FOLL_ORB_TIME:get())*2*math.pi)*FOLL_ORB_RADIUS:get())
   return update, 100
end

gcs:send_text(0, string.format("orbit started"))
return update, 100





================================================
File: examples/param_add.lua
================================================
-- example for adding parameters to a lua script

-- the table key must be used by only one script on a particular flight
-- controller. If you want to re-use it then you need to wipe your old parameters
-- the key must be a number between 0 and 200. The key is persistent in storage
local PARAM_TABLE_KEY = 72

-- create a parameter table with 2 parameters in it. A table can have
-- at most 63 parameters. The table size for a particular table key
-- cannot increase without a reboot. The prefix "MY_" is used with
-- every parameter in the table. This prefix is used to ensure another
-- script doesn't use the same PARAM_TABLE_KEY.
assert(param:add_table(PARAM_TABLE_KEY, "MY_", 2), 'could not add param table')

-- create two parameters. The param indexes (2nd argument) must
-- be between 1 and 63. All added parameters are floats, with the given
-- default value (4th argument).
assert(param:add_param(PARAM_TABLE_KEY, 1, 'TEST', 3.14), 'could not add param1')
assert(param:add_param(PARAM_TABLE_KEY, 2, 'TEST2', 5.7), 'could not add param2')

gcs:send_text(0, string.format("Added two parameters"))

local param1 = Parameter("MY_TEST")
local param2 = Parameter("MY_TEST2")

gcs:send_text(0, string.format("param1=%f", param1:get()))
gcs:send_text(0, string.format("param2=%f", param2:get()))



================================================
File: examples/param_get_set_test.lua
================================================
-- This script is a test of param set and get

local count = 0

-- for fast param acess it is better to get a param object,
-- this saves the code searching for the param by name every time
local VM_I_Count = Parameter()
if not VM_I_Count:init('SCR_VM_I_COUNT') then
  gcs:send_text(6, 'get SCR_VM_I_COUNT failed')
end

-- returns null if param cant be found
local fake_param = Parameter()
if not fake_param:init('FAKE_PARAM') then
  gcs:send_text(6, 'get FAKE_PARAM failed')
end

-- Can also pass param string in constructor to remove the need to init manualy
local user_param = Parameter('SCR_USER1')
-- this will error out for a bad parameter
-- Parameter('FAKE_PARAM')
local success, err = pcall(Parameter,'FAKE_PARAM')
if not success then
  gcs:send_text(0, "Lua Caught Error: " .. err)
end
-- this allows this example to catch the otherwise fatal error
-- not recommend if error is possible/expected, use separate construction and init

-- local user_param = Parameter('SCR_USER1')
-- is equivalent to:
-- local user_param = Parameter()
-- assert(user_param:init('SCR_USER1'), 'No parameter: SCR_USER1')

function update() -- this is the loop which periodically runs

  -- get and print all the scripting parameters
  local value = param:get('SCR_ENABLE')
  if value then
    gcs:send_text(6, string.format('LUA: SCR_ENABLE: %i',value))
  else
    gcs:send_text(6, 'LUA: get SCR_ENABLE failed')
  end
  value = param:get('SCR_VM_I_COUNT')
  if value then
    gcs:send_text(6, string.format('LUA: SCR_VM_I_COUNT: %i',value))
  else
    gcs:send_text(6, 'LUA: get SCR_VM_I_COUNT failed')
  end
  value = param:get('SCR_HEAP_SIZE')
  if value then
    gcs:send_text(6, string.format('LUA: SCR_HEAP_SIZE: %i',value))
  else
    gcs:send_text(6, 'LUA: get SCR_HEAP_SIZE failed')
  end
  value = param:get('SCR_DEBUG_LVL')
  if value then
    gcs:send_text(6, string.format('LUA: SCR_DEBUG_LVL: %i',value))
  else
    gcs:send_text(6, 'LUA: get SCR_DEBUG_LVL failed')
  end

  -- increment the script heap size by one
  local heap_size = param:get('SCR_HEAP_SIZE')
  if heap_size then
    if not(param:set('SCR_HEAP_SIZE',heap_size + 1)) then
      gcs:send_text(6, 'LUA: param set failed')
    end
  else
    gcs:send_text(6, 'LUA: get SCR_HEAP_SIZE failed')
  end

  
  -- increment the VM I count by one using direct accsess method
  local VM_count = VM_I_Count:get()
  if VM_count then
    gcs:send_text(6, string.format('LUA: SCR_VM_I_COUNT: %i',VM_count))
    if not VM_I_Count:set( VM_count + 1) then
        gcs:send_text(6, string.format('LUA: failed to set SCR_VM_I_COUNT'))
    end
  else
    gcs:send_text(6, 'LUA: read SCR_VM_I_COUNT failed')
  end

  local user = user_param:get()
  if user then
    gcs:send_text(6, string.format('LUA: SCR_USER1: %i', user))
  else
    gcs:send_text(6, 'LUA: read SCR_USER1 failed')
  end

  count = count + 1;

  -- self terminate after 30 loops
  if count > 30 then
    gcs:send_text(0, 'LUA: goodbye, world')
    param:set('SCR_ENABLE',0)
  end

  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/plane-callout-alt.lua
================================================
--[[

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

--]]

SCRIPT_VERSION = "4.6.0-003"
SCRIPT_NAME = "Plane Altitude Callouts"
SCRIPT_NAME_SHORT = "Callout"

-- This script calls out altitude if the user is near (WARN) or above (MAX)
-- Allows for units to be feet even if you do everything else in metric because the laws typically specify 400 feet for UAV/RPAS in most countries
-- all of the settings are stored in parameters:
-- CALLOUT_ALT_UNITS 1 = metric, 2 (default) = imperial
-- CALLOUT_ALT_MAX max allowed altitude (its still a message there is no action)
-- CALLOUT_ALT_STEP callout (via GC message) when altitude changes by this amount or more
-- CALLOUT_ALT_CALL seconds between callout of flying altitude
-- CALLOUT_ALT_WARN seconds between callouts that you are less than ALT_STEP below ALT_MAX
-- CALLOUT_ALT_HIGH seconds between callouts that you have exceeded ALT_MAX

REFRESH_RATE      = 1000	    --check every 1 second

MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 102
local PARAM_TABLE_PREFIX = "ZPC_"

-- add a parameter and bind it to a variable
local function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup follow mode specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')


-- Add these ZPC_ parameters specifically for this script
--[[
  // @Param: ZPC_ALT_UNITS
  // @DisplayName: Plane Callouts Units - defaults to feet
  // @Description: 1: Metric/meters or 2: Imperial/feet
  // @User: Standard
--]]
ZPC_ALT_UNITS = bind_add_param('ALT_UNITS', 1, 2)

--[[
    // @Param: ZPC_ALT_MAX
    // @DisplayName: Plane Callouts max altitude
    // @Description: Maximum altitude in ALT_UNITS
    // @Range: 0 30
    // @Units: seconds
--]]
ZPC_ALT_MAX = bind_add_param("ALT_MAX", 2, 400)

--[[
    // @Param: ZPC_ALT_STEP
    // @DisplayName: Plane Callouts altitude steps
    // @Description: Altitude steps for callouts in ALT_UNITS
    // @Range: 0 100
    // @Units: ALT_UNIT
--]]
ZPC_ALT_STEP = bind_add_param("ALT_STEP", 3, 25)

--[[
    // @Param: ZPC_ALT_CALL
    // @DisplayName: Plane Callouts frequency
    // @Description: How often to callout altitude when flying normally
    // @Range: 0 30
    // @Units: seconds
--]]
ZPC_ALT_CALL = bind_add_param("ALT_CALL", 4, 25)

--[[
    // @Param: ZPC_ALT_WARN
    // @DisplayName: Plane altitude warning frequency
    // @Description: How often to nag about almost hitting MAX
    // @Range: 0 30
    // @Units: seconds
--]]
ZPC_ALT_WARN = bind_add_param("ALT_WARN", 5, 25)

--[[
    // @Param: ZPC_ALT_HIGH
    // @DisplayName: Plane altitude max altitude callout frequency
    // @Description: How often to nag about exceeding MAX
    // @Range: 0 30
    // @Units: seconds
--]]
ZPC_ALT_HIGH = bind_add_param("ALT_HIGH", 6, 10)

local alt_units = ZPC_ALT_UNITS:get() or 2  -- default to feet because "thats what it is"
local alt_max = ZPC_ALT_MAX:get() or 400    -- most places this is the legal limit, if you have a different limit, change this
local alt_step = ZPC_ALT_STEP:get() or 25
local alt_call_sec = ZPC_ALT_CALL:get() or 25
local alt_warn_sec = ZPC_ALT_WARN:get() or 25
local alt_high_sec = ZPC_ALT_HIGH:get() or 10

local alt_last = 0
local alt_warn = alt_max - alt_step

local unit = "meters"
if (alt_units == 2) then
    unit = "feet"
end
local altitude_max = string.format("%i %s", math.floor(alt_max+0.5), unit )

local time_last_warn_s = millis() / 1000
local time_last_max_s = millis() / 1000
local time_last_update_s = millis() / 1000
local alt_max_exceeded = false
local alt_warn_exceeded = false

local function update() -- this is the loop which periodically runs
    local current_time_s = millis() / 1000
    -- setting the height/altitude variables like this means all the code below works without change for either metric or Imperial units
    local terrain_height = terrain:height_above_terrain(true)

    -- if terrain height is not available use height above home
    if terrain_height == nil then
            -- override terrain height with home height (TODO: parameterize this)
        local pos = ahrs:get_relative_position_NED_home()
        if pos == nil then
            return
        else
            terrain_height = -pos:z()
        end
    end

    --- allow these parameters to be changed at runtime.
    alt_units = ZPC_ALT_UNITS:get() or 2
    alt_max = ZPC_ALT_MAX:get() or 400    -- most places this is the legal limit, if you have a different limit, change this
    alt_step = ZPC_ALT_STEP:get() or 25
    alt_call_sec = ZPC_ALT_CALL:get() or 25
    alt_warn_sec = ZPC_ALT_WARN:get() or 25
    alt_high_sec = ZPC_ALT_HIGH:get() or 10
    if (alt_units == 2) then
        unit = "feet"
    else
        unit = "meters"
    end

    if (alt_units == 2) then
        terrain_height = terrain_height * 3.28084
    end
    local altitude = string.format("%i %s", math.floor(terrain_height+0.5), unit )

    if terrain_height > alt_max then
        if (time_last_max_s < current_time_s - alt_high_sec) then
            gcs:send_text(MAV_SEVERITY.ERROR, string.format("Altitude %s too high max %s", altitude,  altitude_max ))
            time_last_max_s = current_time_s
            alt_max_exceeded = true
        end
    elseif terrain_height > alt_warn then
            if (time_last_warn_s < current_time_s - alt_warn_sec) then
                gcs:send_text(MAV_SEVERITY.WARNING, string.format("Warning altitude is %s", altitude ))
                time_last_warn_s = current_time_s
                alt_warn_exceeded = true
            end
	else
	    -- we are fine now, but maybe we were not fine before. 
        -- So if we previously displayed altitude warn/error messages, let the pilot know we are now fine
        if(alt_max_exceeded or alt_warn_exceeded) then
            gcs:send_text(MAV_SEVERITY.WARNING, string.format("Altitude %s is Ok", altitude ))
        else
            -- nothing else important happened, so see if our altitude has gone up or down by more than ALT_STEP
		    -- in which case we call it out
            if (time_last_update_s < current_time_s - alt_call_sec) then
                local alt_diff = (terrain_height - alt_last) 
                if (math.abs(alt_diff) > alt_step) then
                    gcs:send_text(MAV_SEVERITY.WARNING, string.format("Altitude is %s", altitude ))
                    alt_last = math.floor(terrain_height / alt_step + 0.5) * alt_step
                end
                time_last_update_s = current_time_s
            end
        end
        alt_max_exceeded = false
        alt_warn_exceeded = false
    end
end

local displayed_banner = false
-- wrapper around update(). This calls update() at 1Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
local function protected_wrapper()

    if not displayed_banner then
        gcs:send_text(MAV_SEVERITY.INFO, string.format("%s %s script loaded callouts in %s", SCRIPT_NAME, SCRIPT_VERSION, unit) )
        displayed_banner = true
    end

    if not arming:is_armed() then return protected_wrapper, REFRESH_RATE * 10 end

    local success, err = pcall(update)
    if not success then
        gcs:send_text(MAV_SEVERITY.ALERT, SCRIPT_NAME_SHORT .. "Internal Error: " .. err)
        -- when we fault we run the update function again after 1s, slowing it
        -- down a bit so we don't flood the console with errors
        return protected_wrapper, 1000
    end
    return protected_wrapper, REFRESH_RATE
end


  -- start running update loop - wait 20 seconds before starting up
return protected_wrapper, 20000




================================================
File: examples/plane-doublets.lua
================================================
-- This script will preform a control surface doublet
-- The desired axis to perform a doublet on is selected and started with a momentary switch
-- The plane maintains trim conditions while the switch is activated using servo overrides
-- If the momentary switch is released before "DOUBLET FINISHED" is seen on the GCS,
-- the aircraft recovers to FBWA mode to assist the pilot.
-- Magnitude and duration of the doublet can also be controlled.
-- It is suggested to allow the aircraft to trim for straight, level, unaccelerated flight (SLUF) in FBWB mode before
-- starting a doublet
-- Charlie Johnson, Oklahoma State University 2020

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type

local DOUBLET_ACTION_CHANNEL = 6 -- RCIN channel to start a doublet when high (>1700)
local DOUBLET_CHOICE_CHANNEL = 7 -- RCIN channel to choose elevator (low) or rudder (high)
local DOUBLET_FUCNTION = 19 -- which control surface (SERVOx_FUNCTION) number will have a doublet happen
-- A (Servo 1, Function 4), E (Servo 2, Function 19), and R (Servo 4, Function 21)
local DOUBLET_MAGNITUDE = 6 -- defined out of 45 deg used for set_output_scaled
local DOUBLET_TIME = 500 -- period of doublet signal in ms

-- flight mode numbers for plane https://mavlink.io/en/messages/ardupilotmega.html
local MODE_MANUAL = 0
local MODE_FBWA = 5
local K_AILERON = 4
local K_ELEVATOR = 19
local K_THROTTLE = 70
local K_RUDDER = 21

-- store timing information during doublet
local start_time = -1
local end_time = -1
local now = -1

-- store information about the doublet channel
local doublet_srv_chan = SRV_Channels:find_channel(DOUBLET_FUCNTION)
local doublet_srv_min = param:get("SERVO" .. doublet_srv_chan + 1 .. "_MIN")
local doublet_srv_max = param:get("SERVO" .. doublet_srv_chan + 1 .. "_MAX")
local doublet_srv_trim = param:get("SERVO" .. doublet_srv_chan + 1 .. "_TRIM")
local pre_doublet_mode = vehicle:get_mode()

function retry_set_mode(mode)
    if vehicle:set_mode(mode) then
        -- if the mode was set successfully, carry on as normal
        desired_mode = -1
        return doublet, 1
    else
        -- if the mode was not set successfully, try again ASAP
        desired_mode = mode
        return retry_set_mode, 1
    end
end

function doublet()
    local callback_time = 100
    if arming:is_armed() == true and rc:get_pwm(DOUBLET_ACTION_CHANNEL) > 1700 and end_time ==-1 then
        -- try for the best timing possible while performing a doublet
        callback_time = DOUBLET_TIME / 10
        -- start a quick doublet based on some math/logic
        now = millis()
        if start_time == -1 then
            -- this is the time that we started
            -- stop time will be start_time + DOUBLET_TIME
            start_time = now
            pre_doublet_mode = vehicle:get_mode()
            -- are we doing a doublet on elevator or rudder? set the other controls to trim
            local doublet_choice_pwm = rc:get_pwm(DOUBLET_CHOICE_CHANNEL)
            local trim_funcs
            local pre_doublet_elevator = SRV_Channels:get_output_pwm(K_ELEVATOR)
            if doublet_choice_pwm < 1500 then
                -- doublet on elevator
                DOUBLET_FUCNTION = K_ELEVATOR
                trim_funcs = {K_AILERON, K_RUDDER}
                DOUBLET_MAGNITUDE = 12
                doublet_srv_trim = pre_doublet_elevator
            else
                -- doublet on rudder
                DOUBLET_FUCNTION = K_RUDDER
                trim_funcs = {K_AILERON}
                DOUBLET_MAGNITUDE = 15
                -- pin elevator to current position. This is most likely different than the _TRIM value
                SRV_Channels:set_output_pwm_chan_timeout(SRV_Channels:find_channel(K_ELEVATOR), pre_doublet_elevator, DOUBLET_TIME * 4)
            end
            -- notify the gcs that we are starting a doublet
            gcs:send_text(6, "STARTING DOUBLET " .. DOUBLET_FUCNTION)
            -- get info about the doublet channel
            doublet_srv_chan = SRV_Channels:find_channel(DOUBLET_FUCNTION)
            doublet_srv_min = param:get("SERVO" .. doublet_srv_chan + 1 .. "_MIN")
            doublet_srv_max = param:get("SERVO" .. doublet_srv_chan + 1 .. "_MAX")
            -- set the channels that need to be pinned to trim until the doublet is done
            for i = 1, #trim_funcs do
                local trim_chan = SRV_Channels:find_channel(trim_funcs[i])
                local trim_pwm = param:get("SERVO" .. trim_chan + 1 .. "_TRIM")
                SRV_Channels:set_output_pwm_chan_timeout(trim_chan, trim_pwm, DOUBLET_TIME * 2)
            end
            -- get the current throttle PWM and pin it there until the doublet is done
            local pre_doublet_throttle = SRV_Channels:get_output_pwm(K_THROTTLE)
            SRV_Channels:set_output_pwm_chan_timeout(
                SRV_Channels:find_channel(K_THROTTLE),
                pre_doublet_throttle,
                DOUBLET_TIME * 3
            )
            -- enter manual mode
            retry_set_mode(MODE_MANUAL)
        end
        -- split time evenly between high and low signal
        if now < start_time + (DOUBLET_TIME / 2) then
            down = doublet_srv_trim - math.floor((doublet_srv_trim - doublet_srv_min) * (DOUBLET_MAGNITUDE / 45))
            SRV_Channels:set_output_pwm_chan_timeout(doublet_srv_chan, down, DOUBLET_TIME / 2 + 100)
        elseif now < start_time + DOUBLET_TIME then
            up = doublet_srv_trim + math.floor((doublet_srv_max - doublet_srv_trim) * (DOUBLET_MAGNITUDE / 45))
            SRV_Channels:set_output_pwm_chan_timeout(doublet_srv_chan, up, DOUBLET_TIME / 2 + 100)
        elseif now < start_time + (DOUBLET_TIME * 2) then
            -- stick fixed response
            -- hold at pre doublet trim position for any damping effects
            SRV_Channels:set_output_pwm_chan_timeout(doublet_srv_chan, doublet_srv_trim, DOUBLET_TIME * 2)
        elseif now > start_time + (DOUBLET_TIME * 2) then
            -- notify GCS
            end_time = now
            gcs:send_text(6, "DOUBLET FINISHED")
        else
            gcs:send_text(6, "this should not be reached")
        end
    elseif end_time ~= -1 and rc:get_pwm(DOUBLET_ACTION_CHANNEL) > 1700 then
        -- wait for RC input channel to go low
        gcs:send_text(6, "RC" .. DOUBLET_ACTION_CHANNEL .. " still high")
        callback_time = 100 -- prevent spamming messages to the GCS
    elseif now ~= -1 and end_time ~= -1 then
        gcs:send_text(6, "RETURN TO PREVIOUS FLIGHT MODE")
        now = -1
        end_time = -1
        start_time = -1
        -- clear all of the timeouts
        control_functions = {K_AILERON, K_ELEVATOR, K_THROTTLE, K_RUDDER}
        for i = 1, 4 do
            local control_chan = SRV_Channels:find_channel(control_functions[i])
            SRV_Channels:set_output_pwm_chan_timeout(control_chan, param:get("SERVO" .. control_chan + 1 .. "_TRIM"), 0)
        end
        retry_set_mode(pre_doublet_mode)
        callback_time = 100 -- don't need to rerun for a little while
    elseif now ~= -1 then
        -- stopped before finishing. recover to level attitude
        gcs:send_text(6, "FBWA RECOVER")
        now = -1
        end_time = -1
        start_time = -1
        -- clear all of the timeouts
        control_functions = {K_AILERON, K_ELEVATOR, K_THROTTLE, K_RUDDER}
        for i = 1, 4 do
            local control_chan = SRV_Channels:find_channel(control_functions[i])
            SRV_Channels:set_output_pwm_chan_timeout(control_chan, param:get("SERVO" .. control_chan + 1 .. "_TRIM"), 0)
        end
        retry_set_mode(MODE_FBWA)
        callback_time = 100
    end
    return doublet, callback_time
end

gcs:send_text(6, "plane-doublets.lua is running")
return doublet(), 500



================================================
File: examples/plane-wind-failsafe.lua
================================================
-- warn the user if wind speed exceeds a threshold, failsafe if a second threshold is exceeded

-- note that this script is only intended to be run on ArduPlane

-- tuning parameters
local warn_speed = 10 -- metres/second
local failsafe_speed = 15 -- metres/second
local warning_interval_ms = uint32_t(15000) -- send user message every 15s

local warning_last_sent_ms = uint32_t() -- time we last sent a warning message to the user

function update()
    local wind = ahrs:wind_estimate() -- get the wind estimate
    if wind then
        -- make a 2D wind vector
        wind_xy = Vector2f()
        wind_xy:x(wind:x())
        wind_xy:y(wind:y())
        speed = wind_xy:length() -- compute the wind speed
        if speed > failsafe_speed then
            gcs:send_text(0, "Wind failsafe at " .. speed .. " metres/second")
            vehicle:set_mode(11) -- FIXME: should be an enum.  11 is RTL.
            return
        end
        if speed > warn_speed then
            if millis() - warning_last_sent_ms > warning_interval_ms then
                    gcs:send_text(4, "Wind warning at " .. speed .. " metres/second")
                warning_last_sent_ms = millis()
            end
        end
    end
    return update, 1000
end

return update, 1000



================================================
File: examples/plane-wind-fs.lua
================================================
-- Adds a smart failsafe that accounts for how far the plane is from home
-- the average battery consumption, and the wind to decide when to failsafe
--
-- CAUTION: This script only works for Plane

---@diagnostic disable: cast-local-type
---@diagnostic disable: undefined-global

-- store the batt info as { instance, filtered, capacity, margin_mah }
-- instance: the battery monitor instance (zero indexed)
-- filtered: internal variable for current draw
-- capacity: internal variable populated from battery monitor capacity param
-- margin_mah: the mah to be remaining when you reach home and use the time margin, note that this is on top of CRT_MAH
local batt_info = { {0, 0, 0, 0}, -- main battery
                                  -- add more batteries to monitor here
                  }

local margin = 30 -- margin in seconds of flight time that should remain once we have reached 
local time_SF = 1 -- the return time safety factor, 1.1 gives 10% extra time for return flight
local filter = 0.9 -- filter gain
local min_flying_time = 30 -- seconds, must have been flying in a none Qmode above the min alt for this long before script will start sampling current
local print_time = 15 -- seconds between update prints (set to zero to disable)
local alt_min = 0 -- the minimum altitude above home the script will start working at, zero disables

-- if true current draw is normalized with dynamic pressure
-- this gives better prediction of current draws at other airspeeds
-- airspeed sensor recommended
local airspeed_normalize = false

-- hard code wind to match SITL
-- should get exact return time estimates < +- 5 seconds
local SITL_wind = false


-- Read in required params
local value = param:get('AIRSPEED_CRUISE')
if value then
  air_speed = value
else
  error('LUA: get AIRSPEED_CRUISE failed')
end
value = param:get('AIRSPEED_MIN')
if value then
  min_air_speed = value
else
  error('LUA: get AIRSPEED_MIN failed')
end
min_ground_speed = param:get('MIN_GROUNDSPEED')
if not min_groundspeed then
  error('LUA: get MIN_GROUNDSPEED failed')
end
max_bank_angle = param:get('ROLL_LIMIT_DEG')
if not max_bank_angle then
  error('LUA: get ROLL_LIMIT_DEG failed')
end

-- https://en.wikipedia.org/wiki/Standard_rate_turn#Radius_of_turn_formula
-- the radius is equal to the circumference per 1 radian
local turn_rad = (air_speed^2) / (9.81 * math.tan(math.rad(max_bank_angle)))

-- Read the radius we expect to circle at when we get home
local home_reached_rad
value = param:get('RTL_RADIUS')
if value then
  value = math.abs(value)
  if value > 0 then
    home_reached_rad = math.abs(value) * 2
  else 
    value = param:get('WP_LOITER_RAD')
    if value then
      home_reached_rad = math.abs(value) * 2
    else
      error('LUA: get WP_LOITER_RAD failed')
    end
  end
else
  error('LUA: get RTL_RADIUS failed')
end

-- internal global variables
local return_start
local return_amps
local trigger_instance = batt_info[1][1]
local last_print = uint32_t()
local timer_start_time = uint32_t()
local timer_active = true

-- calculates the amount of time it will take for the vehicle to return home
-- returns 0 if there is no position, wind or home available
-- returns a negative number if it will take excessively long time, or is impossible
-- otherwise returns the time in seconds to get back
local function time_to_home()
  local home = ahrs:get_home()
  local position = ahrs:get_location()
  local wind = ahrs:wind_estimate()

  if home and position and wind then
    local bearing = position:get_bearing(home)

    -- wind is in NED, convert for readability
    local wind_north = wind:x()
    local wind_east = wind:y()

    -- hard code wind for testing
    if SITL_wind then
      -- only safe to read from params at a high rate because we are in SITL
      -- don't do this on a real vehicle
      wind_speed = param:get('SIM_WIND_SPD')
      wind_dir = param:get('SIM_WIND_DIR')
      if wind_speed and wind_dir then
        wind_dir = math.rad(wind_dir)
        wind_north = -math.cos(wind_dir) * wind_speed
        wind_east = -math.sin(wind_dir) * wind_speed
      else
        error('Could not read SITL wind')
      end
    end
    --gcs:send_text(0, string.format("Wind: north %0.2f, east  %0.2f",wind_north,wind_east))

    -- rotate the wind vector inline with the home bearing
    local tail_wind =  math.sin(bearing) * wind_east + math.cos(bearing) * wind_north
    local cross_wind = math.cos(bearing) * wind_east + math.sin(bearing) * wind_north   -- left to right

    -- we can't get home
    if math.abs(cross_wind) > air_speed then
      return -1, air_speed -- FIXME: this should really be infinity
    end

    -- calculate the crab angle required to cancel out the cross wind
    local crab_angle = math.asin(-cross_wind / air_speed)

    -- the resulting speed in the desired direction
    local home_airspeed = air_speed * math.cos(crab_angle)

    local effective_speed = home_airspeed + tail_wind

    -- Estimate the extra distance required to turn
    local yaw = ahrs:get_yaw_rad()
    -- this is the estimated angle we have to turn to be at the home bearing and crab angle
    local turn_angle_rad = bearing - crab_angle - yaw 
    -- wrap to +- PI
    if turn_angle_rad < math.rad(-180) then
      turn_angle_rad = turn_angle_rad + math.rad(360)
    elseif turn_angle_rad > math.rad(180) then
      turn_angle_rad = turn_angle_rad - math.rad(360)
    end
    --gcs:send_text(0, "turn " .. tostring(math.deg(turn_angle_rad)) .. " deg")

    -- Take into account min ground speed and resulting increased RTL airspeed
    local return_air_speed = air_speed
    if min_ground_speed > 0 and effective_speed < min_ground_speed then
      -- we travel home at the min ground speed 
      effective_speed = min_ground_speed

      -- work out the resulting airspeed
      return_air_speed = math.sqrt((effective_speed-tail_wind)^2 + cross_wind^2)
    end

    -- distance to travel over ground speed + turn circumference over airspeed
    return (position:get_distance(home) / effective_speed) + (math.abs(turn_angle_rad*turn_rad) / air_speed), return_air_speed
  end

  return 0, air_speed -- nothing useful available
end

-- idle function
function idle()
  -- if disarmed and not flying reset for a potential second trigger
  if not arming:is_armed() and not vehicle:get_likely_flying() then
    return update, 100
  end
  return idle, 1000
end

-- time margin update function
function margin_update()
  if not vehicle:get_likely_flying() then
    -- no longer flying, idle function
    return idle, 10000
  end

  -- display the remaining battery capacity on the triggered monitor
  local capacity = battery:pack_capacity_mah(trigger_instance) 
  local consumed = battery:consumed_mah(trigger_instance)
  if capacity and consumed then
    gcs:send_text(0, string.format("Failsafe: %is margin elapsed %.2fmAh remain",margin, capacity - consumed))
  end

  -- idle function
  return idle, 10000
end

-- this is an alternate update function that is simply used to track how long it will take to get home
-- it's really only used for debugging how the prediction rules are working
function track_return_time()
  if not vehicle:get_likely_flying() then
      -- no longer flying, idle function
      return idle, 10000
  end

  local home = ahrs:get_home()
  local position = ahrs:get_location()
  if home and position then
    local now = millis()

    local home_dist = position:get_distance(home)
    if home_dist < home_reached_rad then
      -- calculate the extra time to fly the reached rad distance
      local time_home = time_to_home()
      local total_time = time_home + ((now-return_start)/1000)

      -- display the remaining battery capacity on the triggered monitor
      local capacity = battery:pack_capacity_mah(trigger_instance) 
      local consumed = battery:consumed_mah(trigger_instance)
      if capacity and consumed then
        -- estimate the extra capacity used for the reached rad distance
        return_capacity = return_amps * time_home  * (1000 / 60^2) -- convert from amp second's to mAh
        
        gcs:send_text(0, "Failsafe: RTL took " .. tostring(total_time) .. string.format("s, %.2fmAh remain", capacity - consumed - return_capacity) )

        if margin > 0 then
          return margin_update, margin*1000
        end
      else
        gcs:send_text(0, "Failsafe: RTL took " .. tostring(total_time) .. " s")
      end

      -- idle function
      return idle, 10000
    end

    -- print updates tracking progress
    local return_time = time_to_home()
    local total_time = return_time + ((now-return_start)/1000)
    if last_print + (print_time * 1000) < now and print_time > 0 then
      last_print = now
      if (return_time < 0) then
        gcs:send_text(6, "Failsafe: ground speed low can not get home")
      elseif (return_time > 0) then
        -- cannot get string.format() to work with total time, wrong variable type? ie not %f or %i?
        gcs:send_text(0, "Failsafe: Estimated " .. tostring(total_time) .. string.format("s, %.0fs remain", return_time) )
      end
    end

    logger:write('SFSC','total_return_time,remaining_return_time','If','ss','--',total_time,return_time)
  end
  return track_return_time, 100
end

-- the main update function that is used to decide when we should do a failsafe
function update()
  local now = millis();

  -- check armed
  if not arming:is_armed() then
    --gcs:send_text(0, "Failsafe: disabled: not armed")
    timer_start_time = now
    timer_active = true
    return update, 100
  end

  -- check flying
  if not vehicle:get_likely_flying() then
    --gcs:send_text(0, "Failsafe: disabled: not flying")
    timer_start_time = now
    timer_active = true
    return update, 100
  end

  -- check mode
  local current_mode = vehicle:get_mode()
  if current_mode >= 17 then
    --gcs:send_text(0, "Failsafe: disabled: Q mode")
    timer_start_time = now
    timer_active = true
    return update, 100
  end

  -- check altitude
  if alt_min ~= 0 then
    local dist = ahrs:get_relative_position_NED_home()
    if not dist or -1*dist:z() < alt_min then
      --gcs:send_text(0, "Failsafe: disabled: low alt")
      timer_start_time = now
      timer_active = true
      return update, 100
    end
  end

  -- check timer
  if now - timer_start_time < (min_flying_time * 1000) then
    --gcs:send_text(0, "Failsafe: disabled: timer")
    return update, 100
  end

  -- notify that we have started
  if timer_active then
    gcs:send_text(0, "Smart Battery RTL started monitoring")
    timer_active = false
  end

  -- check airspeed
  local air_speed_in = ahrs:airspeed_estimate()
  if not air_speed_in then
    error("Could not read airspeed")
  end
  if air_speed_in < min_air_speed * 0.75 then
    -- we are not flying fast enough, skip but don't reset the timer
    return update, 100
  end

  local min_remaining_time = 86400 -- 24 hours

  -- find the return time and airspeed
  local return_time, return_airspeed = time_to_home()

  -- default to no normalization
  local q = 1
  local return_q = 1

  -- normalize current with dynamic pressure
  if airspeed_normalize then

    -- we could probably just use air speed^2
    local press = baro:get_pressure()
    local temp = baro:get_external_temperature() + 273.2 -- convert deg centigrade to kelvin
    local density =  press / (temp * 287.058) -- calculate the air density, ideal gas law, constant is (R) specific gas constant for air
    q = 0.5 * density * air_speed_in^2

    return_q = 0.5 * density * return_airspeed^2 -- we could estimate the change in density also, but will be negligible
  end

  logger:write('SFSA','return_time,return_airspeed,Q,return_Q','ffff','snPP','----',return_time,return_airspeed,q,return_q)

  for i = 1, #batt_info do
    local instance, norm_filtered_amps, rated_capacity_mah = table.unpack(batt_info[i])
    local amps = battery:current_amps(instance)
    local consumed_mah = battery:consumed_mah(instance)

    if amps and consumed_mah then

      local norm_amps = amps / q

      -- update all the current consumption rates
      norm_filtered_amps = (norm_filtered_amps * filter) + (norm_amps * (1.0 - filter))
      batt_info[i][2] = norm_filtered_amps

      -- calculate the estimated return amps, estimate the return current if we were to fly at a different airspeed
      return_amps = norm_filtered_amps * return_q

      local remaining_capacity = (rated_capacity_mah - consumed_mah) * 3.6 -- amp seconds (60^2 / 1000)
      local remaining_time = remaining_capacity / return_amps

      local buffer_time = remaining_time - ((return_time * time_SF) + margin)
      logger:write('SFSB','Instance,current,rem_cap,rem_time,buffer','Bffff','#Aiss','--C--',i-1,return_amps,remaining_capacity,remaining_time,buffer_time)
      if  (return_time < 0) or buffer_time < 0 then
        if return_time < 0 then
          gcs:send_text(0, "Failsafe: ground speed low can not get home")
        elseif #batt_info == 1 then
          gcs:send_text(0, string.format("Failsafe: Estimated %.0fs to home", return_time))
        else
          trigger_instance = instance
          gcs:send_text(0, string.format("Failsafe: Estimated %.0fs to home, instance %i", return_time, instance))
        end

        last_print = now
        -- FIXME: We need more insight into what the vehicles already doing. IE don't trigger RTL if we are already landing
        vehicle:set_mode(11) -- plane RTL FIXME: we need a set of enums defined for the vehicles
        -- swap to tracking the time rather then re trigger
        return_start = now

        -- Print the return distance
        --[[local home = ahrs:get_home()
        local position = ahrs:get_location()
        if home and position then
          return_distance = position:get_distance(home)
        end
        gcs:send_text(0, string.format("Failsafe: %.0f m to home", return_distance))]]

        -- print the current draw we estimate
        --gcs:send_text(0, string.format("Failsafe: %.2fa", return_amps))

        return track_return_time, 100
      end
      min_remaining_time = math.min(min_remaining_time, buffer_time)
    end
  end

  -- print updates tracking progress
  if last_print + (print_time * 1000) < now and print_time > 0 then
    last_print = now
    gcs:send_text(6, string.format("%.0f seconds of flight remaining before RTL", min_remaining_time))
  end

  return update, 100
end

-- validate that all the expected monitors have current monitoring capability, and fetch initial values
for i = 1, #batt_info do
  -- check that the instance exists
  local instance = batt_info[i][1]
  if instance > battery:num_instances() then
    error("Battery " .. instance .. " does not exist")
  end
  -- check that we can actually read current from the instance
  if not battery:current_amps(instance) then
    error("Battery " .. instance .. " does not support current monitoring")
  end
  -- store the pack capacity for later use, it's assumed to never change mid flight
  -- subtract the capacity we want remaining when we get home
  local rated_cap = battery:pack_capacity_mah(instance)
  if rated_cap then
    -- read in the critical MAH
    local param_string = 'BATT' .. tostring(instance + 1) .. '_CRT_MAH'
    if instance == 0 then
      param_string = 'BATT_CRT_MAH'
    end

    value = param:get(param_string)
    if  not value then
      error('LUA: get '.. param_string .. ' failed')
    end

    batt_info[i][3] = rated_cap - (batt_info[i][4] + value)
  else
    error("Battery " .. instance .. " does not support current monitoring")
  end
end

return update, 100



================================================
File: examples/plane_guided_follow.lua
================================================
-- support follow in GUIDED mode in plane

local PARAM_TABLE_KEY = 11
local PARAM_TABLE_PREFIX = "GFOLL_"

local MODE_GUIDED = 15

local ALT_FRAME_ABSOLUTE = 0

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup SHIP specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'could not add param table')
GFOLL_ENABLE     = bind_add_param('ENABLE', 1, 0)

-- current target
local target_pos
local current_pos

-- other state
local have_target = false

-- check key parameters
function check_parameters()
  --[[
     parameter values which are auto-set on startup
  --]]
   local key_params = {
      FOLL_ENABLE = 1,
      FOLL_OFS_TYPE = 1,
      FOLL_ALT_TYPE = 0,
   }

   for p, v in pairs(key_params) do
      local current = param:get(p)
      assert(current, string.format("Parameter %s not found", p))
      if math.abs(v-current) > 0.001 then
         param:set_and_save(p, v)
         gcs:send_text(0,string.format("Parameter %s set to %.2f was %.2f", p, v, current))
      end
   end
end

function wrap_360(angle)
   local res = math.fmod(angle, 360.0)
    if res < 0 then
        res = res + 360.0
    end
    return res
end

function wrap_180(angle)
    local res = wrap_360(angle)
    if res > 180 then
       res = res - 360
    end
    return res
end

-- update target state
function update_target()
   if not follow:have_target() then
      if have_target then
         gcs:send_text(0,"Lost beacon")
      end
      have_target = false
      return
   end
   if not have_target then
      gcs:send_text(0,"Have beacon")
   end
   have_target = true

   target_pos = follow:get_target_location_and_velocity_ofs()
end

-- main update function
function update()
   if GFOLL_ENABLE:get() < 1 then
      return
   end

   update_target()
   if not have_target then
      return
   end

   current_pos = ahrs:get_position()
   if not current_pos then
      return
   end
   current_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)

   if vehicle:get_mode() ~= MODE_GUIDED then
      return
   end

   local next_WP = vehicle:get_target_location()
   if not next_WP then
      -- not in a flight mode with a target location
      return
   end

   -- update the target position from the follow library, which includes the offsets
   target_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)
   vehicle:update_target_location(next_WP, target_pos)
end

function loop()
   update()
   -- run at 20Hz
   return loop, 50
end

check_parameters()

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 50
end

-- start running update loop
return protected_wrapper()




================================================
File: examples/plane_guided_terrain.lua
================================================
--[[

   example script to show reseting guided mode to terrain height.
   It's intended to be used when selecting "fly to altitude" in a ground station 
   for example by right clicking on the map in QGC. 
   
   This is actually a workaround to QGC and Mission Planner not having a
   way to set guided altitude above terrain.

   Depending on ZGP_MODE
   When the GCS requests a guided altitude X above home 
    1: reset to current terrain height ignore X 
    2: reset to X above terrain 
    3: reset to current alt + X
    
   this functionality is only available in Plane and 
   requires TERRAIN_ENABLE = 1 and TERRAIN_FOLLOW =1
--]]

SCRIPT_NAME = "OverheadIntel Guided Terrain"
SCRIPT_NAME_SHORT = "TerrGuided"
SCRIPT_VERSION = "4.6.0-005"

REFRESH_RATE = 0.2   -- in seconds, so 5Hz
ALTITUDE_MIN = 50
ALTITUDE_MAX = 120

MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}
MAV_FRAME = { GLOBAL = 0, GLOBAL_RELATIVE_ALT = 3}
ALT_FRAME = { ABSOLUTE = 0, ABOVE_HOME = 1, ABOVE_ORIGIN = 2, ABOVE_TERRAIN = 3 }
FLIGHT_MODE = {AUTO=10, RTL=11, LOITER=12, GUIDED=15, QHOVER=18, QLOITER=19, QRTL=21}

PARAM_TABLE_KEY = 101
PARAM_TABLE_PREFIX = "ZGT_"

local now = millis():tofloat() * 0.001

-- bind a parameter to a variable
function bind_param(name)
    return Parameter(name)
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
    assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), SCRIPT_NAME_SHORT .. string.format('could not add param %s', name))
    return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup follow mode specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), SCRIPT_NAME_SHORT .. 'could not add param table: ' .. PARAM_TABLE_PREFIX)

--[[
    // @Param: ZGT_MODE
    // @DisplayName: Guided Terrain Mode
    // @Description: When the GCS requests a guided altitude X above home 1: reset to current terrain height ignore X 2: reset to X above terrain 3: reset to current alt + X
    // @Range: 1,2,3
--]]
ZGT_MODE = bind_add_param("MODE", 1, 1)
TERRAIN_ENABLE = bind_param("TERRAIN_ENABLE")
TERRAIN_FOLLOW = bind_param("TERRAIN_FOLLOW")

local zgt_mode = ZGT_MODE:get()
local terrain_enable = TERRAIN_ENABLE:get()
local terrain_follow = TERRAIN_FOLLOW:get()

MAV_CMD_INT = { DO_SET_MODE = 176, DO_CHANGE_SPEED = 178, DO_REPOSITION = 192, 
                  GUIDED_CHANGE_SPEED = 43000, GUIDED_CHANGE_ALTITUDE = 43001, GUIDED_CHANGE_HEADING = 43002 }
MAV_FRAME = { GLOBAL = 0, GLOBAL_RELATIVE_ALT = 3, GLOBAL_TERRAIN_ALT = 10}

-- constrain a value between limits
local function constrain(v, vmin, vmax)
    if v < vmin then
       v = vmin
    end
    if v > vmax then
       v = vmax
    end
    return v
end

local function follow_frame_to_mavlink(follow_frame)
    local mavlink_frame = MAV_FRAME.GLOBAL
    if (follow_frame == ALT_FRAME.ABOVE_TERRAIN) then
        mavlink_frame = MAV_FRAME.GLOBAL_TERRAIN_ALT
    elseif (follow_frame == ALT_FRAME.ABOVE_HOME) then
       mavlink_frame = MAV_FRAME.GLOBAL_RELATIVE_ALT
    end
    return mavlink_frame
 end

local now_altitude = millis():tofloat() * 0.001
-- target.alt = new target altitude in meters
-- set_vehicle_target_altitude() Parameters
-- target.frame = Altitude frame MAV_FRAME, it's very important to get this right!
-- target.alt = altitude in meters to acheive
-- target.accel = z acceleration to altitude (1000.0 = max)
local function set_vehicle_target_altitude(target)
   local acceleration = target.accel or 1000.0 -- default to maximum z acceleration
   if math.floor(now) ~= math.floor(now_altitude) then
      now_altitude = millis():tofloat() * 0.001
   end
   if target.alt == nil then
      gcs:send_text(MAV_SEVERITY.ERROR, SCRIPT_NAME_SHORT .. ": set_vehicle_target_altitude no altiude")
      return
   end
   -- GUIDED_CHANGE_ALTITUDE takes altitude in meters
   local mavlink_result = gcs:run_command_int(MAV_CMD_INT.GUIDED_CHANGE_ALTITUDE, {
                              frame = follow_frame_to_mavlink(target.frame),
                              p3 = acceleration,
                              z = target.alt })
    if mavlink_result > 0 then
        gcs:send_text(MAV_SEVERITY.ERROR, SCRIPT_NAME_SHORT .. string.format(": MAVLink GUIDED_CHANGE_ALTITUDE returned %d", mavlink_result))
        return false
    else
        return true
    end
end

local vehicle_mode = vehicle:get_mode()
local save_target_altitude = -1
local save_old_target_altitude = -1
local save_zgt_mode = -1
local save_vehicle_mode = -1

local function update()

    vehicle_mode = vehicle:get_mode()

    terrain_enable = TERRAIN_ENABLE:get()
    terrain_follow = TERRAIN_FOLLOW:get()
    zgt_mode = ZGT_MODE:get()
    if zgt_mode ~= save_zgt_mode then
        -- user changed modes, reset everything
        save_target_altitude = -1
        save_old_target_altitude = -1
    end
    save_zgt_mode = zgt_mode

    -- We should only reset the altitude if newly switched to guided mode
    if save_vehicle_mode ~= vehicle_mode and vehicle_mode == FLIGHT_MODE.GUIDED and terrain_enable == 1 and
        ((terrain_follow & 1) == 1 or (terrain_follow & (1 << 6)) == 64) then
        local target_location = vehicle:get_target_location()
        if target_location ~= nil then
            local target_location_frame = target_location:get_alt_frame()
            -- need to convert the target_location to ABOVE_TERRAIN so we have apples and apples
            local new_target_location = target_location:copy()
            local new_target_altitude = save_target_altitude
            local old_target_altitude = new_target_location:alt()/100

            if save_old_target_altitude ~= old_target_altitude then
                if target_location_frame ~= ALT_FRAME.ABOVE_TERRAIN then
                    if new_target_location:change_alt_frame(ALT_FRAME.ABOVE_TERRAIN) then
                        old_target_altitude = new_target_location:alt()/100
                    end
                end
                -- adjust target_location for home altitude
                local home_location = ahrs:get_home()
                if home_location ~= nil then
                    local home_amsl = terrain:height_amsl(home_location, true)
                    local above_home = (target_location:alt() * 0.01 - home_amsl)
                    local location = ahrs:get_location()
                    if location ~= nil then
                        if location:get_alt_frame() ~= ALT_FRAME.ABOVE_TERRAIN then
                            location:change_alt_frame(ALT_FRAME.ABOVE_TERRAIN)
                        end
                        local current_altitude = location:alt() * 0.01
                        -- @Description: When the GCS requests a guided altitude X above home
                        -- 1: reset to current terrain height ignore X
                        -- 2: reset to X above terrain
                        -- 3: reset to current alt + X
                        if zgt_mode == 1 then
                            new_target_altitude = current_altitude
                        elseif zgt_mode == 2 then
                            new_target_altitude = above_home
                        elseif zgt_mode == 3 then
                            new_target_altitude = current_altitude + above_home
                        end
                        new_target_altitude = constrain(new_target_altitude, ALTITUDE_MIN, ALTITUDE_MAX)
                end
                else
                    gcs:send_text(MAV_SEVERITY.ERROR, string.format("%s: FAILED to get HOME terrain height", SCRIPT_NAME_SHORT))
                end

                if new_target_altitude > 0 and
                   set_vehicle_target_altitude({alt = new_target_altitude, frame = ALT_FRAME.ABOVE_TERRAIN}) then -- pass altitude in meters (location has it in cm)
                    if new_target_altitude ~= save_target_altitude then
                        gcs:send_text(MAV_SEVERITY.NOTICE, string.format("%s: Reset to alt %.0fm above terrain", SCRIPT_NAME_SHORT,
                                    new_target_altitude
                            ))
                        save_target_altitude = new_target_altitude
                    end
                else
                    gcs:send_text(MAV_SEVERITY.ERROR, string.format("%s: FAILED to set altitude ABOVE_TERRAIN ait %.0f", SCRIPT_NAME_SHORT,
                                new_target_altitude
                        ))
                end
            end
            save_old_target_altitude = old_target_altitude
        else
            gcs:send_text(MAV_SEVERITY.ERROR, string.format("%s: altitude not available", SCRIPT_NAME_SHORT))
        end
    else
        -- we switched out of guided, so forget what we thought we knew
        save_target_altitude = -1
        save_old_target_altitude = -1
    end
    save_vehicle_mode = vehicle_mode

   return update, 1000 * REFRESH_RATE
end

-- wrapper around update(). This calls update() at 1/REFRESHRATE Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
local function protected_wrapper()
    local success, err = pcall(update)
    if not success then
       gcs:send_text(0, SCRIPT_NAME_SHORT .. ": Error: " .. err)
       -- when we fault we run the update function again after 1s, slowing it
       -- down a bit so we don't flood the console with errors
       return protected_wrapper, 1000
    end
    return protected_wrapper, 1000 * REFRESH_RATE
end

gcs:send_text(MAV_SEVERITY.NOTICE, string.format("%s %s script loaded", SCRIPT_NAME, SCRIPT_VERSION) )

-- start running update loop
if FWVersion:type() == 3 and terrain_enable then
    gcs:send_text(MAV_SEVERITY.NOTICE, string.format("%s %s script loaded", SCRIPT_NAME, SCRIPT_VERSION) )
    return protected_wrapper()
else
    gcs:send_text(MAV_SEVERITY.NOTICE,string.format("%s: Must run on Plane with terrain follow", SCRIPT_NAME_SHORT))
end



================================================
File: examples/protected_call.lua
================================================
-- this shows how to protect against faults in your scripts
-- you can wrap your update() call (or any other call) in a pcall()
-- which catches errors, allowing you to take an appropriate action


-- example main loop function
function update()
   local t = 0.001 * millis():tofloat()
   gcs:send_text(0, string.format("TICK %.1fs", t))
   if math.floor(t) % 10 == 0 then
      -- deliberately make a bad call to cause a fault, asking for the 6th GPS status
      -- as this is done inside a pcall() the error will be caught instead of stopping the script
      local status = gps:status(5)
      gcs:send_text(0, "GPS status: " .. tostring(status))
   end
end

-- wrapper around update(). This calls update() at 5Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 200
end

-- start running update loop
return protected_wrapper()



================================================
File: examples/proximity_test.lua
================================================
-- This script checks Proximity

function update()
  sensor_count = proximity:num_sensors()
  gcs:send_text(0, string.format("%d proximity sensors found.", sensor_count))

  if sensor_count > 0 then
    object_count = proximity:get_object_count()
    gcs:send_text(0, string.format("%d objects found.", object_count))

    closest_angle, closest_distance = proximity:get_closest_object()
    if closest_angle and closest_distance then
      gcs:send_text(0, "Closest object at angle "..closest_angle.." distance "..closest_distance)
    end

    for i = 0, object_count do
      angle, distance = proximity:get_object_angle_and_distance(i)
      if angle and distance then
        gcs:send_text(0, "Object "..i.." at angle "..angle.." distance "..distance)
      end
    end
  end

  return update, 2000 -- check again in 0.5Hz
end

return update(), 2000 -- first message may be displayed 2 seconds after start-up



================================================
File: examples/qnh_alt.lua
================================================
--[[
    example that sends QNH altitude to GCS as a NAMED_VALUE_FLOAT QNG_ALT_FT in feet

    Note: operator must set QNH_PRESSURE in hPa before each flight!
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

local PARAM_TABLE_KEY = 93
local PARAM_TABLE_PREFIX = "QNH_"

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 8), 'could not add param table')

--[[
  // @Param: QNH_PRESSURE
  // @DisplayName: QNH pressure in hPa
  // @Description: QNH pressure in hPa
  // @Range: 900 1200
  // @Units: hPa
  // @User: Standard
--]]
local QNH_PRESSURE = bind_add_param('PRESSURE', 1, 0)

--[[
    send QNH based alt to GCS
--]]
local function send_qnh_alt()
    local pressure_Pa = baro:get_pressure()
    local qnh_Pa = QNH_PRESSURE:get()*100
    local alt_m = baro:get_altitude_difference(qnh_Pa, pressure_Pa)
    local alt_feet = alt_m * 3.280839895013123
    gcs:send_named_float("QNH_ALT_FT", alt_feet)
end

function update()
    if QNH_PRESSURE:get() > 0 then
        send_qnh_alt()
    end
    return update,1000
end

gcs:send_text(MAV_SEVERITY.INFO, "Loaded qnh_alt")

return update,1000



================================================
File: examples/quadruped.lua
================================================
-- Lua "motor driver" for a four legged (aka quadruped) walking robot
-- 
-- This script consumes controller outputs (i.e. roll, pitch, yaw/steering, throttle, lateral) from
-- the vehicle code and then calculates the outputs for 12 servos controlling four legs
--
-- AutoPilot servo connections:
-- Output1: front right coxa (hip) servo
-- Output2: front right femur (thigh) servo
-- Output3: front right tibia (shin) servo
-- Output4: front left coxa (hip) servo
-- Output5: front left femur (thigh) servo
-- Output6: front left tibia (shin) servo
-- Output7: back left coxa (hip) servo
-- Output8: back left femur (thigh) servo
-- Output9: back left tibia (shin) servo
-- Output10: back right coxa (hip) servo
-- Output11: back right femur (thigh) servo
-- Output12: back right tibia (shin) servo
--
-- CAUTION: This script should only be used with ArduPilot Rover's firmware

---@diagnostic disable: cast-local-type


local FRAME_LEN = 80    -- frame length in mm
local FRAME_WIDTH = 150 -- frame width in mm

local COXA_LEN = 30     -- distance (in mm) from coxa (aka hip) servo to femur servo
local FEMUR_LEN = 85    -- distance (in mm) from femur servo to tibia servo
local TIBIA_LEN = 125   -- distance (in mm) from tibia servo to foot

--body position and rotation parameters
local body_rot_max = 10 -- body rotation maximum for any individual axis
local body_rot_x = 0    -- body rotation about the X axis (i.e. roll rotation)
local body_rot_y = 0    -- body rotation about the Y axis (i.e. pitch rotation)
local body_rot_z = 0    -- body rotation about the Z axis (i.e. yaw rotation)
local body_pos_x = 0    -- body position in the X axis (i.e. forward, back).  should be -40mm to +40mm
local body_pos_y = 0    -- body position in the Y axis (i.e. right, left).  should be -40mm to +40mm
local body_pos_z = 0    -- body position in the Z axis (i.e. up, down).  should be -40mm to +40mm

-- starting positions of the legs
local endpoint_LB = {math.cos(math.rad(45))*(COXA_LEN + FEMUR_LEN), math.sin(math.rad(45))*(COXA_LEN + FEMUR_LEN), TIBIA_LEN}
local endpoint_LF = {math.cos(math.rad(45))*(COXA_LEN + FEMUR_LEN), math.sin(math.rad(-45))*(COXA_LEN + FEMUR_LEN), TIBIA_LEN}
local endpoint_RF = {-math.cos(math.rad(45))*(COXA_LEN + FEMUR_LEN), math.sin(math.rad(-45))*(COXA_LEN + FEMUR_LEN), TIBIA_LEN}
local endpoint_RB = {-math.cos(math.rad(45))*(COXA_LEN + FEMUR_LEN), math.sin(math.rad(45))*(COXA_LEN + FEMUR_LEN), TIBIA_LEN}

-- control input enum
local control_input_roll = 1
local control_input_pitch = 2
local control_input_throttle = 3
local control_input_yaw = 4
local control_input_height = 8

local xy_travel_max = 80     -- x and y axis travel max (used to convert control input) in mm
local yaw_travel_max = 10    -- yaw travel maximum (used to convert control input)
local height_max = 40       -- height maximum (used to convert control input)
local travel_dz = 5          -- travel deadzone.  x, y and yaw travel requests are ignored if their absolute value is less than this number
local x_travel = 0           -- target lenght of gait along x
local y_travel = 0           -- target travel of gait along y
local yaw_travel = 0         -- yaw rotation travel target


local leg_lift_height = 50  -- leg lift height (in mm) while walking

-- gait definition parameters
local gait_type = 0         -- gait pattern.  0 = alternating gait, 1 = wave gait.
local gait_step = 0         -- gait step in execution
local gait_step_total = 0   -- number of steps in gait
local gait_step_leg_start = {0,0,0,0} -- leg starts moving on this gait step (front-right, front-left, back-left, back-right)
local gait_lifted_steps = 0 -- number of steps that a leg is lifted for
local gait_down_steps = 0   -- number of steps that the leg lifted needs to be put down for
local gait_lift_divisor = 0 -- when a leg is lifted and brought back down the action is divided into 2 or multiple steps, so the travel distance also need to be split in between the steps to make the transition natural
local gait_half_lift_height = 0 -- used to split lift across two steps
local gait_travel_divisor = 0    -- number of steps in the gait the leg is touching the floor, this is used as a factor to split the travel distance between the steps

local gait_pos_x = {0,0,0,0}    -- X-axis position for each leg (back-right, front-right, back-left, front-left)
local gait_pos_y = {0,0,0,0}    -- Y-axis position for each leg (back-right, front-right, back-left, front-left)
local gait_pos_z = {0,0,0,0}    -- Z-axis position for each leg (back-right, front-right, back-left, front-left)
local gait_rot_z = {0,0,0,0}    -- Z-axis rotation for each leg (back-right, front-right, back-left, front-left)
local last_angle = {0,0,0,0,0,0,0,0,0,0,0,0}
local start_time = 0
local curr_target = 0

function Gaitselect()
    if (gait_type == 0) then
        -- alternating gait
        gait_step_total = 6
        gait_step_leg_start = {1,4,4,1}
        gait_lifted_steps = 2
        gait_down_steps = 1
        gait_lift_divisor = 2
        gait_half_lift_height = 1
        gait_travel_divisor = 4
    elseif (gait_type == 1) then
        -- wave gait with 28 steps
        gait_step_total = 28
        gait_step_leg_start = {8,15,1,22}
        gait_lifted_steps = 3
        gait_down_steps = 2
        gait_lift_divisor = 2
        gait_half_lift_height = 3
        gait_travel_divisor = 24
    end
end

-- Calculate Gait sequence
function calc_gait_sequence()
    local move_requested = (math.abs(x_travel) > travel_dz) or (math.abs(y_travel) > travel_dz) or (math.abs(yaw_travel) > travel_dz)

    if move_requested then
        for leg_index=1, 4 do
            update_leg(leg_index,move_requested)
        end

        gait_step = gait_step + 1
        if (gait_step>gait_step_total) then
            gait_step = 1
        end
    else
        gait_pos_x = {0,0,0,0}
        gait_pos_y = {0,0,0,0}
        gait_pos_z = {0,0,0,0}
        gait_rot_z = {0,0,0,0}
    end
end

-- in order for the robot to move forward it needs to move its legs in a
-- specific order and this is repeated over and over to attain linear motion. when a
-- specific leg number is passed the update_leg() produces the set of values for the
-- given leg at that step, for each cycle of the gait each leg will move to a set
-- distance which is decided by the x_travel, yaw_travel, y_travel
function update_leg(moving_leg,move_requested)
    local leg_step = gait_step - gait_step_leg_start[moving_leg]
    
    if ((move_requested and (gait_lifted_steps > 0) and leg_step==0) or
        (not move_requested and leg_step==0 and ((gait_pos_x[moving_leg]>2) or
        (gait_pos_y[moving_leg]>2) or (gait_rot_z[moving_leg] >2)))) then
        gait_pos_x[moving_leg] = 0
        gait_pos_z[moving_leg] = -leg_lift_height
        gait_pos_y[moving_leg] = 0
        gait_rot_z[moving_leg] = 0

    elseif (((gait_lifted_steps==2 and leg_step==0) or (gait_lifted_steps>=3 and
            (leg_step==-1 or leg_step==(gait_step_total-1)))) and move_requested) then
        gait_pos_x[moving_leg] = -x_travel/gait_lift_divisor
        gait_pos_z[moving_leg] = -3*leg_lift_height/(3+gait_half_lift_height)
        gait_pos_y[moving_leg] = -y_travel/gait_lift_divisor
        gait_rot_z[moving_leg] = -yaw_travel/gait_lift_divisor

    elseif ((gait_lifted_steps>=2) and (leg_step==1 or leg_step==-(gait_step_total-1)) and move_requested) then
        gait_pos_x[moving_leg] = x_travel/gait_lift_divisor
        gait_pos_z[moving_leg] = -3*leg_lift_height/(3+gait_half_lift_height)
        gait_pos_y[moving_leg] = y_travel/gait_lift_divisor
        gait_rot_z[moving_leg] = yaw_travel/gait_lift_divisor

    elseif (((gait_lifted_steps==5 and (leg_step==-2 ))) and move_requested) then
        gait_pos_x[moving_leg] = -x_travel * 0.5
        gait_pos_z[moving_leg] = -leg_lift_height * 0.5
        gait_pos_y[moving_leg] = -y_travel * 0.5
        gait_rot_z[moving_leg] = -yaw_travel * 0.5

    elseif ((gait_lifted_steps==5) and (leg_step==2 or leg_step==-(gait_step_total-2)) and move_requested) then
        gait_pos_x[moving_leg] = x_travel * 0.5
        gait_pos_z[moving_leg] = -leg_lift_height * 0.5
        gait_pos_y[moving_leg] = y_travel * 0.5
        gait_rot_z[moving_leg] = yaw_travel * 0.5

    elseif ((leg_step==gait_down_steps or leg_step==-(gait_step_total-gait_down_steps)) and gait_pos_y[moving_leg]<0) then
        gait_pos_x[moving_leg] = x_travel * 0.5
        gait_pos_z[moving_leg] = 0
        gait_pos_y[moving_leg] = y_travel * 0.5
        gait_rot_z[moving_leg] = yaw_travel * 0.5

    else
        gait_pos_x[moving_leg] = gait_pos_x[moving_leg] - (x_travel/gait_travel_divisor)
        gait_pos_z[moving_leg] = 0
        gait_pos_y[moving_leg] = gait_pos_y[moving_leg] - (y_travel/gait_travel_divisor)
        gait_rot_z[moving_leg] = gait_rot_z[moving_leg] - (yaw_travel/gait_travel_divisor)
    end
end

-- Body Forward Kinematics calculates where each leg should be.
-- inputs are
--   a) body rotations: body_rot_x, body_rot_y, body_rot_z
--   b) body position: body_pos_x, body_pos_y, body_pos_z
--   c) offset of the center of body
function body_forward_kinematics(X, Y, _, Xdist, Ydist, Zrot)
    local totaldist_x = X + Xdist + body_pos_x
    local totaldist_y = Y + Ydist + body_pos_y
    local distBodyCenterFeet = math.sqrt(totaldist_x^2 + totaldist_y^2)
    local AngleBodyCenter = math.atan(totaldist_y, totaldist_x)
    local rolly = math.tan(math.rad(body_rot_y)) * totaldist_x
    local pitchy = math.tan(math.rad(body_rot_x)) * totaldist_y

    local ansx = math.cos(AngleBodyCenter + math.rad(body_rot_z+Zrot)) * distBodyCenterFeet - totaldist_x + body_pos_x
    local ansy = math.sin(AngleBodyCenter + math.rad(body_rot_z+Zrot)) * distBodyCenterFeet - totaldist_y + body_pos_y
    local ansz = rolly + pitchy + body_pos_z
    return {ansx, ansy, ansz}
end

-- Leg Inverse Kinematics calculates the angles for each servo of each joint using the output of the
-- body_forward_kinematics() function which gives the origin of each leg on the body frame
function leg_inverse_kinematics(x, y, z)
    local coxa = math.deg(math.atan(x, y))
    local trueX = math.sqrt(x^2 + y^2) - COXA_LEN
    local im = math.sqrt(trueX^2 + z^2)

    local q1 = -math.atan(z, trueX)
    local d1 = FEMUR_LEN^2 - TIBIA_LEN^2 + im^2
    local d2 = 2*FEMUR_LEN*im
    local q2 = math.acos(d1/d2)
    local femur = math.deg(q1+q2)

    d1 = FEMUR_LEN^2 - im^2 + TIBIA_LEN^2
    d2 = 2*TIBIA_LEN*FEMUR_LEN
    local tibia = math.deg(math.acos(d1/d2)-math.rad(90))
    return {coxa, -femur, -tibia}
end

-- checks if the servo has moved to its expected position 
function servo_estimate(current_angle)
    local target = 0
    for j = 1, 12 do
        curr_target = math.abs(current_angle[j] - last_angle[j])
        if curr_target > target then
            target = curr_target
        end
    end
    local target_time = target * (0.24/60) * 1000
    return (millis() - start_time) > target_time
end

-- main_inverse_kinematics produces the inverse kinematic solution for each
-- leg joint servo by taking into consideration the initial_pos, gait offset and the body inverse kinematic values.
function main_inverse_kinematics()
    local ans_RB = body_forward_kinematics(endpoint_RB[1]+gait_pos_x[1],
                                           endpoint_RB[2]+gait_pos_y[1], 
                                           endpoint_RB[3]+gait_pos_z[1],
                                           -FRAME_LEN*0.5, FRAME_WIDTH*0.5, 
                                           gait_rot_z[1])
    local angles_RB = leg_inverse_kinematics(endpoint_RB[1]+ans_RB[1]+gait_pos_x[1],
                                             endpoint_RB[2]+ans_RB[2]+gait_pos_y[1], 
                                             endpoint_RB[3]+ans_RB[3]+gait_pos_z[1])
    angles_RB[1] = 45 + angles_RB[1]

    local ans_RF = body_forward_kinematics(endpoint_RF[1]+gait_pos_x[2],
                                           endpoint_RF[2]+gait_pos_y[2],
                                           endpoint_RF[3]+gait_pos_z[2],
                                          -FRAME_LEN*0.5, -FRAME_WIDTH*0.5,
                                           gait_rot_z[2])
    local angles_RF = leg_inverse_kinematics(endpoint_RF[1]-ans_RF[1]+gait_pos_x[2],
                                             endpoint_RF[2]-ans_RF[2]-gait_pos_y[2], 
                                             endpoint_RF[3]+ans_RF[3]+gait_pos_z[2])
    angles_RF[1] = 135 + angles_RF[1]

    local ans_LB = body_forward_kinematics(endpoint_LB[1]+gait_pos_x[3],
                                           endpoint_LB[2]+gait_pos_y[3], 
                                           endpoint_LB[3]+gait_pos_z[3], 
                                           FRAME_LEN*0.5, FRAME_WIDTH*0.5,
                                           gait_rot_z[3])
    local angles_LB = leg_inverse_kinematics(endpoint_LB[1]+ans_LB[1]+gait_pos_x[3],
                                             endpoint_LB[2]+ans_LB[2]+gait_pos_y[3], 
                                             endpoint_LB[3]+ans_LB[3]+gait_pos_z[3])
    angles_LB[1] = -45 + angles_LB[1]

    local ans_LF = body_forward_kinematics(endpoint_LF[1]+gait_pos_x[4],
                                           endpoint_LF[2]+gait_pos_y[4], 
                                           endpoint_LF[3]+gait_pos_z[4], 
                                           FRAME_LEN*0.5, -FRAME_WIDTH*0.5, 
                                           gait_rot_z[4])
    local angles_LF = leg_inverse_kinematics(endpoint_LF[1]-ans_LF[1]+gait_pos_x[4],
                                             endpoint_LF[2]-ans_LF[2]-gait_pos_y[4], 
                                             endpoint_LF[3]+ans_LF[3]+gait_pos_z[4])
    angles_LF[1] = -135 + angles_LF[1]
    Gaitselect()
    local current_angle = {angles_RF[1],angles_RF[2],angles_RF[3],
                           angles_LF[1],angles_LF[2],angles_LF[3],
                           angles_LB[1],angles_LB[2],angles_LB[3],
                           angles_RB[1],angles_RB[2],angles_RB[3]}

    if servo_estimate(current_angle) then
        start_time = millis()
        calc_gait_sequence()
        last_angle = current_angle
    end

    return current_angle
end

-- servo angles when robot is disarmed and resting body on the ground
local rest_angles = { 45, -90, 40,      -- front right leg (coxa, femur, tibia)
                     -45, -90, 40,      -- front left leg (coxa, femur, tibia)
                     -45, -90, 40,      -- back left leg (coxa, femur, tibia)
                      45, -90, 40}      -- back right leg (coxa, femur, tibia)

function update()
    local throttle = vehicle:get_control_output(control_input_throttle) * xy_travel_max
    local gait_direction
    if throttle > 0 then
        gait_direction = -1
        y_travel = throttle
    elseif throttle < 0 then
        gait_direction = 1
        y_travel = -throttle
    elseif throttle == 0 then
        gait_direction = 1
        y_travel = 0
    end

    yaw_travel = -vehicle:get_control_output(control_input_yaw) * yaw_travel_max
    body_rot_x = -vehicle:get_control_output(control_input_roll) * body_rot_max
    body_rot_y = -vehicle:get_control_output(control_input_pitch) * body_rot_max
    body_pos_z =  vehicle:get_control_output(control_input_height) * height_max

    local servo_direction = { gait_direction *  1, -1,  1,    -- front right leg (coxa, femur, tibia)
                              gait_direction *  1,  1, -1,    -- front left leg (coxa, femur, tibia)
                              gait_direction * -1, -1,  1,    -- back left leg (coxa, femur, tibia)
                              gait_direction * -1,  1, -1}    -- back right leg (coxa, femur, tibia)
                              
    local angles
    if arming:is_armed() then
        angles = main_inverse_kinematics()
    else
        angles = rest_angles
    end

    for i = 1, 12 do
        SRV_Channels:set_output_pwm_chan_timeout(i-1, math.floor(((angles[i] * servo_direction[i] * 1000)/90) + 1500), 1000)
    end

    return update,10
end

-- turn off rudder based arming/disarming
param:set_and_save('ARMING_RUDDER', 0)
gcs:send_text(0, "quadruped simulation")
return update()



================================================
File: examples/rangefinder_quality_test.lua
================================================

-- This test uses the Range Finder driver interface to simulate Range Finder
-- hardware and uses the Range Finder client interface to simulate a
-- client of the driver. The test sends distance data through the driver
-- interface and validates that it can be read through the client interface.

-- Parameters should be set as follows before this test is loaded.
-- "RNGFND1_TYPE": 36,
-- "RNGFND1_ORIENT": 25,
-- "RNGFND1_MIN": 0.10,
-- "RNGFND1_MAX": 50.00,

---@diagnostic disable: cast-local-type


-- UPDATE_PERIOD_MS is the time between when a distance is set and
-- when it is read. There is a periodic task that copies the set distance to
-- the state structure that it is read from. If UPDATE_PERIOD_MS is too short this periodic
-- task might not get a chance to run. A value of 25 seems to be too quick for sub.
local UPDATE_PERIOD_MS = 50
local TIMEOUT_MS = 5000

-- These strings must match the strings used by the test driver for interpreting the output from this test.
local TEST_ID_STR = "RQTL"
local COMPLETE_STR = "#complete#"
local SUCCESS_STR = "!!success!!"
local FAILURE_STR = "!!failure!!"


-- Copied from libraries/AP_Math/rotation.h enum Rotation {}.
local RNGFND_ORIENTATION_DOWN = 25
local RNGFND_ORIENTATION_FORWARD = 0
-- Copied from libraries/AP_RangeFinder/AP_RanggeFinder.h enum RangeFinder::Type {}.
local RNGFND_TYPE_LUA = 36.0
-- Copied from libraries/AP_RangeFinder/AP_RangeFinder.h enum RangeFinder::Status {}.
local RNDFND_STATUS_NOT_CONNECTED = 0
local RNDFND_STATUS_OUT_OF_RANGE_LOW = 2
local RNDFND_STATUS_OUT_OF_RANGE_HIGH = 3
local RNDFND_STATUS_GOOD = 4
-- Copied from libraries/AP_RangeFinder/AP_RangeFinder.h
local SIGNAL_QUALITY_MIN = 0
local SIGNAL_QUALITY_MAX = 100
local SIGNAL_QUALITY_UNKNOWN = -1

-- Read parameters for min and max valid range finder ranges.
local RNGFND1_MIN = Parameter("RNGFND1_MIN"):get()
local RNGFND1_MAX = Parameter("RNGFND1_MAX"):get()

local function send(str)
    gcs:send_text(3, string.format("%s %s", TEST_ID_STR, str))
end


-- The range finder backend is initialized in the update_prepare function.
---@type AP_RangeFinder_Backend_ud
local rngfnd_backend


local function test_dist_equal(dist_m_in, dist_in_factor, dist_out, signal_quality_pct_in, signal_quality_pct_out)
    if math.abs(dist_out - dist_m_in * dist_in_factor) > 1.0e-3 then
        return false
    end
    if signal_quality_pct_in < 0 and signal_quality_pct_out == -1 then
        return true
    end
    if signal_quality_pct_in > 100 and signal_quality_pct_out == -1 then
        return true
    end
    if signal_quality_pct_in == signal_quality_pct_out then
        return true
    end
    return false
end

local function get_and_eval(test_idx, dist_m_in, signal_quality_pct_in, status_expected)
    local status_actual = rangefinder:status_orient(RNGFND_ORIENTATION_DOWN)

    -- Check that the status is as expected
    if status_expected ~= status_actual then
        return string.format("Status test %i status incorrect - expected %i, actual %i", test_idx, status_expected, status_actual)
    end

    -- Not more checks if the status is poor
    if status_actual ~= RNDFND_STATUS_GOOD then
        send(string.format("Status test %i status correct - expected: %i actual: %i", test_idx, status_expected, status_actual))
        return nil
    end

    -- L U A   I N T E R F A C E   T E S T
    -- Check that the distance and signal_quality from the frontend are as expected
    local distance1_cm_out = rangefinder:distance_orient(RNGFND_ORIENTATION_DOWN) * 100
    local signal_quality1_pct_out = rangefinder:signal_quality_pct_orient(RNGFND_ORIENTATION_DOWN)

    -- Make sure data was returned
    if not distance1_cm_out or not signal_quality1_pct_out then
        return "No data returned from rangefinder:distance_orient()"
    end

    send(string.format("Frontend test %i dist in_m: %.2f out_cm: %.2f, signal_quality_pct in: %.1f out: %.1f",
        test_idx, dist_m_in, distance1_cm_out, signal_quality_pct_in, signal_quality1_pct_out))

    if not test_dist_equal(dist_m_in, 100.0, distance1_cm_out, signal_quality_pct_in, signal_quality1_pct_out) then
        return "Frontend expected and actual do not match"
    end

    -- L U A   I N T E R F A C E   T E S T
    -- Check that the distance and signal_quality from the backend are as expected
    local disttance2_m_out = rngfnd_backend:distance()
    local signal_quality2_pct_out = rngfnd_backend:signal_quality()

    send(string.format("Backend test %i dist in_m: %.2f out_m: %.2f, signal_quality_pct in: %.1f out: %.1f",
        test_idx, dist_m_in, disttance2_m_out, signal_quality_pct_in, signal_quality2_pct_out))

    if not test_dist_equal(dist_m_in, 1.0, disttance2_m_out, signal_quality_pct_in, signal_quality2_pct_out) then
        return "Backend expected and actual do not match"
    end

    -- L U A   I N T E R F A C E   T E S T
    -- Check that the state from the backend is as expected
    local rf_state = rngfnd_backend:get_state()
    local distance3_m_out = rf_state:distance()
    local signal_quality3_pct_out = rf_state:signal_quality()

    send(string.format("State test %i dist in_m: %.2f out_m: %.2f, signal_quality_pct in: %.1f out: %.1f",
        test_idx, dist_m_in, distance3_m_out, signal_quality_pct_in, signal_quality3_pct_out))

    if not test_dist_equal(dist_m_in, 1.0, distance3_m_out, signal_quality_pct_in, signal_quality3_pct_out) then
        return "State expected and actual do not match"
    end

    return nil
end

-- Test various status states
local function do_status_tests()
    send("Test initial status")
    local status_actual = rangefinder:status_orient(RNGFND_ORIENTATION_DOWN)
    if status_actual ~= RNDFND_STATUS_NOT_CONNECTED then
        return string.format("DOWN Status '%i' not NOT_CONNECTED on initialization.", status_actual)
    end
    status_actual = rangefinder:status_orient(RNGFND_ORIENTATION_FORWARD)
    if status_actual ~= RNDFND_STATUS_NOT_CONNECTED then
        return string.format("FORWARD Status '%i' not NOT_CONNECTED on initialization.", status_actual)
    end
    return nil
end


local test_data = {
    {20.0, -1, RNDFND_STATUS_GOOD},
    {20.5, -2, RNDFND_STATUS_GOOD},
    {21.0, 0, RNDFND_STATUS_GOOD},
    {22.0, 50, RNDFND_STATUS_GOOD},
    {23.0, 100, RNDFND_STATUS_GOOD},
    {24.0, 101, RNDFND_STATUS_GOOD},
    {25.0, -3, RNDFND_STATUS_GOOD},
    {26.0, 127, RNDFND_STATUS_GOOD},
    {27.0, 3, RNDFND_STATUS_GOOD},
    {28.0, 100, RNDFND_STATUS_GOOD},
    {29.0, 99, RNDFND_STATUS_GOOD},
    {100.0, 100, RNDFND_STATUS_OUT_OF_RANGE_HIGH},
    {0.0, 100, RNDFND_STATUS_OUT_OF_RANGE_LOW},
    {100.0, -2, RNDFND_STATUS_OUT_OF_RANGE_HIGH},
    {0.0, -2, RNDFND_STATUS_OUT_OF_RANGE_LOW},
}

-- Record the start time so we can timeout if initialization takes too long.
local time_start_ms = millis():tofloat()
local test_idx = 0


-- Called when tests are completed.
local function complete(error_str)
    -- Send a message indicating the success or failure of the test
    local status_str
    if not error_str or #error_str == 0 then
        status_str = SUCCESS_STR
    else
        send(error_str)
        status_str = FAILURE_STR
    end
    send(string.format("%s: %s", COMPLETE_STR, status_str))

    -- Returning nil will not queue an update routine so the test will stop running.
end


-- A state machine of update functions. The states progress:
--  prepare, wait, begin_test, eval_test, begin_test, eval_test, ... complete

local update_prepare
local update_wait
local update_begin_test
local update_eval_test

local function _update_prepare()
    if Parameter('RNGFND1_TYPE'):get() ~= RNGFND_TYPE_LUA then
        return complete("LUA range finder driver not enabled")
    end
    if rangefinder:num_sensors() < 1 then
        return complete("LUA range finder driver not connected")
    end
    rngfnd_backend = rangefinder:get_backend(0)
    if not rngfnd_backend then
        return complete("Range Finder 1 does not exist")
    end
    if (rngfnd_backend:type() ~= RNGFND_TYPE_LUA) then
        return complete("Range Finder 1 is not a LUA driver")
    end

    return update_wait()
end

local function _update_wait()
    -- Check for timeout while initializing
    if millis():tofloat() - time_start_ms > TIMEOUT_MS then
        return complete("Timeout while trying to initialize")
    end

    -- Wait until the prearm check passes. This ensures that the system is mostly initialized
    -- before starting the tests.
    if not arming:pre_arm_checks() then
        return update_wait, UPDATE_PERIOD_MS
    end

    -- Do some one time tests
    local error_str = do_status_tests()
    if error_str then
        return complete(error_str)
    end

    -- Continue on to the main list of tests.
    return update_begin_test()
end

local function _update_begin_test()
    test_idx = test_idx + 1
    if test_idx > #test_data then
        return complete()
    end

    local dist_m_in = test_data[test_idx][1]
    local signal_quality_pct_in = test_data[test_idx][2]

    -- L U A   I N T E R F A C E   T E S T
    -- Use the driver interface to simulate a data measurement being received and being passed to AP.
    local result
    -- -2 => use legacy interface
    if signal_quality_pct_in == -2 then
        result = rngfnd_backend:handle_script_msg(dist_m_in) -- number as arg (compatibility mode)

    else
        -- The full state udata must be initialized.
        local rf_state = RangeFinder_State()
        -- Set the status
        if dist_m_in < RNGFND1_MIN then
            rf_state:status(RNDFND_STATUS_OUT_OF_RANGE_LOW)
        elseif dist_m_in > RNGFND1_MAX then
            rf_state:status(RNDFND_STATUS_OUT_OF_RANGE_HIGH)
        else
            rf_state:status(RNDFND_STATUS_GOOD)
        end
        -- Sanitize signal_quality_pct_in
        if signal_quality_pct_in < SIGNAL_QUALITY_MIN or signal_quality_pct_in > SIGNAL_QUALITY_MAX then
            signal_quality_pct_in = SIGNAL_QUALITY_UNKNOWN
        end
        rf_state:last_reading(millis():toint())
        rf_state:range_valid_count(10)
        rf_state:distance(dist_m_in)
        rf_state:signal_quality(signal_quality_pct_in)
        rf_state:voltage(0)
        result = rngfnd_backend:handle_script_msg(rf_state) -- state as arg
    end

    if not result then
        return complete(string.format("Test %i, dist_m: %.2f, quality_pct: %3i failed to handle_script_msg2",
            test_idx, dist_m_in, signal_quality_pct_in))
    end

    return update_eval_test, UPDATE_PERIOD_MS
end

local function _update_eval_test()
    local dist_m_in = test_data[test_idx][1]
    local signal_quality_pct_in = test_data[test_idx][2]
    local status_expected = test_data[test_idx][3]

    -- Use the client interface to get distance data and ensure it matches the distance data
    -- that was sent through the driver interface.
    local error_str = get_and_eval(test_idx, dist_m_in, signal_quality_pct_in, status_expected)
    if error_str then
        return complete(string.format("Test %i, dist_m: %.2f, quality_pct: %3i failed because %s",
            test_idx, dist_m_in, signal_quality_pct_in, error_str))
    end

    -- Move to the next test in the list.
    return update_begin_test()
end

update_prepare = _update_prepare
update_wait = _update_wait
update_begin_test = _update_begin_test
update_eval_test = _update_eval_test

send("Loaded rangefinder_quality_test.lua")

return update_prepare, 0



================================================
File: examples/rangefinder_test.lua
================================================
-- This script checks RangeFinder

local rotation_downward = 25
local rotation_forward = 0

function update()
  local sensor_count = rangefinder:num_sensors()
  gcs:send_text(0, string.format("%d rangefinder sensors found.", sensor_count))

  for _ = 0, rangefinder:num_sensors() do
    if rangefinder:has_data_orient(rotation_downward) then
      info(rotation_downward)
    elseif rangefinder:has_data_orient(rotation_forward) then
      info(rotation_forward)
    end
  end

  return update, 1000 -- check again in 1Hz
end

function info(rotation)
  local ground_clearance = rangefinder:ground_clearance_orient(rotation)
  local distance_min = rangefinder:min_distance_orient(rotation)
  local distance_max = rangefinder:max_distance_orient(rotation)
  local offset = rangefinder:get_pos_offset_orient(rotation)
  local distance = rangefinder:distance_orient(rotation)

  gcs:send_text(
    0,
    string.format(
      "rot=%d distance=%.2f min=%.2f max=%.2f offset=(%.0f,%.0f,%.0f) ground-clearance=%.2f",
      rotation,
      distance,
      distance_min,
      distance_max,
      offset:x(),
      offset:y(),
      offset:z(),
      ground_clearance
    )
  )
end

return update(), 1000 -- first message may be displayed 1 seconds after start-up



================================================
File: examples/readstring_test.lua
================================================
--[[
   example demonstrating how to read from a serial port into a lua string
--]]

local baud_rate = 57600

local port = assert(serial:find_serial(0), "Could not find Scripting Serial Port")

port:begin(baud_rate)
port:set_flow_control(0)

--[[
  get a string by concatenating bytes from the serial port,
  suitable for ArduPilot 4.4.x
--]]
local function get_string_44(n)
   local ret = ""
   for _ = 1, n do
      local b = port:read()
      ret = ret .. string.char(b)
   end
   return ret
end

--[[
  get a string directly uisng readstring
  suitable for ArduPilot 4.5.x and later
--]]
local function get_string_45(n)
   return port:readstring(n)
end

function update()
   -- test using 4.5 method
   local n = port:available():toint()
   if n > 0 then
      local str = get_string_45(n)
      gcs:send_text(0, string.format("Received: '%s'", str))
   end

   -- test using 4.4 method (just so we don't have an unused function in lua check)
   n = port:available():toint()
   if n > 0 then
      local str = get_string_44(n)
      gcs:send_text(0, string.format("Received: '%s'", str))
    end
   return update, 100
end

return update, 100



================================================
File: examples/relay_control.lua
================================================

-- toggle a relay at 50Hz

local RELAY_NUM = 0

function update() -- this is the loop which periodically runs
   relay:toggle(RELAY_NUM)
   return update, 20 -- reschedules the loop at 50Hz
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/rgb_led_test.lua
================================================
-- This script is a test of led override

local count = 0

function update() -- this is the loop which periodically runs

  count = count + 1

  if count == 1 then
    -- solid red
    -- red,green,blue,rate hz, duration ms
    notify:handle_rgb(255,0,0,0)
  elseif count == 2 then
    -- solid green
    notify:handle_rgb(0,255,0,0)
  elseif count == 3 then
    -- solid blue
    notify:handle_rgb(0,0,255,0)
  elseif count == 4 then
    -- 1hz red  + green
    notify:handle_rgb(255,255,0,1)
  elseif count == 5 then
    -- 1hz green + blue
    notify:handle_rgb(0,255,255,1)
  elseif count == 6 then
    -- 1hz red + blue
    notify:handle_rgb(255,0,255,1)
  elseif count == 7 then
    -- fast white
    notify:handle_rgb(255,255,255,10)
    count = 0
  end

  return update, 15000 -- reschedules the loop in 15 seconds

end

return update() -- run immediately before starting to reschedule



================================================
File: examples/rgb_notify_patterns.lua
================================================
-- This script is a test of led override

local count = 0
local num_leds = 16

-- constrain a value between limits
function constrain(v, vmin, vmax)
  if v < vmin then
     v = vmin
  end
  if v > vmax then
     v = vmax
  end
  return v
end

--[[
Table of colors on a rainbow, red first
--]]
local rainbow = {
  { 255, 0, 0 },
  { 255, 127, 0 },
  { 255, 255, 0 },
  { 0,   255, 0 },
  { 0,   0,   255 },
  { 75,  0,   130 },
  { 143, 0,   255 },
}

--[[
Function to set a LED to a color on a classic rainbow spectrum, with v=0 giving red
--]]
function set_Rainbow(led, v)
  local num_rows = #rainbow
  local row = math.floor(constrain(v * (num_rows-1)+1, 1, num_rows-1))
  local v0 = (row-1) / (num_rows-1)
  local v1 = row / (num_rows-1)
  local p = (v - v0) / (v1 - v0)
  r = math.floor(rainbow[row][1] + p * (rainbow[row+1][1] - rainbow[row][1]))
  g = math.floor(rainbow[row][2] + p * (rainbow[row+1][2] - rainbow[row][2]))
  b = math.floor(rainbow[row][3] + p * (rainbow[row+1][3] - rainbow[row][3]))
  notify:handle_rgb_id(r, g, b, led)
end

function update() -- this is the loop which periodically runs
  count = count + 1
  if count > 16 then
    count = 0
  end
  for led = 0, num_leds-1 do
    local v  = ((count+led)%16)/16
    set_Rainbow(led, v)
  end
  return update, 20 -- reschedules the loop in 15 seconds

end

return update() -- run immediately before starting to reschedule



================================================
File: examples/rover-MinFixType.lua
================================================
--[[----------------------------------------------------------------------------

MinFixType ArduPilot Lua script

Checks for mission running and commands a hold/pause if the GPS fix type is less
than a threshold value.

CAUTION: This script is capable of engaging and disengaging autonomous control
of a vehicle.  Use this script AT YOUR OWN RISK.

-- Yuri -- Aug 2021, revised Apr 2022

LICENSE - GNU GPLv3 https://www.gnu.org/licenses/gpl-3.0.en.html
------------------------------------------------------------------------------]]

---@diagnostic disable: param-type-mismatch

local SCRIPT_NAME = 'MinFixType'

--------  MAVLINK/AUTOPILOT 'CONSTANTS'  --------
local ROVER_MODE_MANUAL       =  0
local ROVER_MODE_HOLD         =  4
local ROVER_MODE_AUTO         = 10
local MAV_SEVERITY_WARNING    =  4
local MAV_SEVERITY_INFO       =  6

--------  USER EDITABLE GLOBALS  --------
local GPS_INSTANCE = 0                 -- GPS to monitor (moving base, most likely)
local MIN_FIX_TYPE = 6                 -- see table below
local MSN_PAUSE_MODE     = ROVER_MODE_MANUAL  -- mode to command when GPS fix is inadequate
local THR_SAFEGUARD_MODE = ROVER_MODE_HOLD    -- mode to command if mission paused with non-zero throttle
local BAD_FIX_TIMEOUT  = 1600          -- how long a bad fix type must be present before pausing the mission
local GOOD_FIX_TIMEOUT =  600          -- how long a good fix type must be present before resuming the mission
local RUN_INTERVAL_MS  =  200          -- (ms) how often to run this script (50-250 should work fine)
local VERBOSE_MODE     =    2  -- 0 to suppress all GCS messages,
                               -- 1 for normal status messages
                               -- 2 for additional debug messages
local MSG_NORMAL = 1
local MSG_DEBUG  = 2

local FIX_TYPES = {
    [0] = 'No GPS',  -- Lua arrays are 1 based unless you specify discrete indices like this
    [1] = 'No Fix',
    [2] = '2D Fix',
    [3] = '3D Fix',
    [4] = 'DGPS Fix',
    [5] = 'RTK Float',
    [6] = 'RTK Fixed',
    [7] = 'Static Fixed',
    [8] = 'PPP, 3D'}

local MODE_THRESHOLDS = {1231, 1361, 1491, 1621, 1750, 2050}

local USER_MODES = {
    param:get('MODE1'),
    param:get('MODE2'),
    param:get('MODE3'),
    param:get('MODE4'),
    param:get('MODE5'),
    param:get('MODE6')
}

local MODE_CH  = param:get('MODE_CH')
local THR_CH   = param:get('RCMAP_THROTTLE')
local THR_TRIM = param:get(string.format('RC%d_TRIM', THR_CH))
local THR_DZ   = param:get(string.format('RC%d_DZ', THR_CH))

-- wrapper for gcs:send_text()
local function gcs_msg(msg_type, severity, txt)
    if type(msg_type) == 'string' then
    -- allow just a string to be passed for simple/routine messages
        txt      = msg_type
        msg_type = MSG_NORMAL
        severity = MAV_SEVERITY_INFO
    end
    if msg_type <= VERBOSE_MODE then
        gcs:send_text(severity, string.format('%s: %s', SCRIPT_NAME, txt))
    end
end

-- return RC transmitter selected mode
local function get_user_mode()
    local pwm = rc:get_pwm(MODE_CH)
    local mode_num = 6
    for i, threshold in pairs(MODE_THRESHOLDS) do
        if (pwm < threshold) then
            mode_num = i
            break
        end
    end
    return USER_MODES[mode_num]
end

local function get_pause_mode()
    if math.abs(rc:get_pwm(THR_CH) - THR_TRIM) > THR_DZ then
        return THR_SAFEGUARD_MODE
    end
    return MSN_PAUSE_MODE
end

function resume_mission()
    if get_user_mode() ~= ROVER_MODE_AUTO then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Pause Canceled - Mode Change')
        return standby, RUN_INTERVAL_MS
    end
    if not arming:is_armed() then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Pause Canceled - Disarmed')
        return standby, RUN_INTERVAL_MS
    end

    if gps:status(GPS_INSTANCE) < MIN_FIX_TYPE then
        return mission_paused, RUN_INTERVAL_MS
    end

    vehicle:set_mode(ROVER_MODE_AUTO)
    gcs_msg('Mission Resumed')
    return monitor, RUN_INTERVAL_MS
end

function mission_paused()
    if get_user_mode() ~= ROVER_MODE_AUTO then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Pause Canceled - Mode Change')
        return standby, RUN_INTERVAL_MS
    end
    if not arming:is_armed() then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Pause Canceled - Disarmed')
        return standby, RUN_INTERVAL_MS
    end

    local fix_type = gps:status(GPS_INSTANCE)
    if fix_type >= MIN_FIX_TYPE then
        return resume_mission, GOOD_FIX_TIMEOUT
    end

    if vehicle:get_mode() == THR_SAFEGUARD_MODE then
        local mode = get_pause_mode()
        if mode == MSN_PAUSE_MODE then
            gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Throttle neutral')
            vehicle:set_mode(mode)
        end
        return mission_paused, RUN_INTERVAL_MS
    end

    -- for edge cases where a non-RC command to resume was issued but fix type is still unsuitable
    if vehicle:get_mode() ~= MSN_PAUSE_MODE then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Cannot resume - ' .. FIX_TYPES[fix_type])
        vehicle:set_mode(get_pause_mode())
    end
    return mission_paused, RUN_INTERVAL_MS
end

function transition_to_pause()
    if mission:state() ~= mission.MISSION_RUNNING then
        return standby, RUN_INTERVAL_MS
    end

    local fix_type = gps:status(GPS_INSTANCE)

    if fix_type >= MIN_FIX_TYPE then
        return monitor, RUN_INTERVAL_MS
    end

    local mode = get_pause_mode()
    if mode == THR_SAFEGUARD_MODE then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Throttle not neutral!')
    end

    vehicle:set_mode(mode)
    gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Mission Paused - ' .. FIX_TYPES[fix_type])

    return mission_paused, RUN_INTERVAL_MS
end

function monitor()  -- monitor for reduced GPS fix state during auto mission
    if mission:state() ~= mission.MISSION_RUNNING then
        return standby, RUN_INTERVAL_MS
    end

    local fix_type = gps:status(GPS_INSTANCE)

    if fix_type < MIN_FIX_TYPE then
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_WARNING, 'GPS ' .. (GPS_INSTANCE + 1) .. ' - ' .. FIX_TYPES[fix_type])
        return transition_to_pause, BAD_FIX_TIMEOUT
    end

    return monitor, RUN_INTERVAL_MS
end

function standby()  -- wait here until an auto mission is active
    if mission:state() == mission.MISSION_RUNNING then
        return monitor, RUN_INTERVAL_MS
    end
    return standby, RUN_INTERVAL_MS
end

gcs_msg('Script active')

return standby()



================================================
File: examples/rover-SaveTurns.lua
================================================
--[[----------------------------------------------------------------------------

SaveTurns ArduPilot Lua script

Saves the locations of vehicle turns as waypoints in the current nav mission.

CAUTION: This script is capable of engaging and disengaging autonomous control
of a vehicle.  Use this script AT YOUR OWN RISK.

-- Yuri -- Nov 2021, revised Apr 2022

LICENSE - GNU GPLv3 https://www.gnu.org/licenses/gpl-3.0.en.html
------------------------------------------------------------------------------]]

---@diagnostic disable: cast-local-type
---@diagnostic disable: need-check-nil

local SCRIPT_NAME = 'SaveTurns'

--------  USER EDITABLE GLOBALS  --------
local RC_OPTION       = 300  -- RC option number for switched control (300, 301, etc)
local MIN_DIST        = 2.0  -- (m)   min distance between waypoints
local HDG_DELTA       = 8.0  -- (deg) save wp after heading change of this magnitude
local RUN_INTERVAL_MS = 200  -- (ms)  how often to run this script
local VERBOSE_MODE    =   2  -- 0 to suppress all GCS messages,
                             -- 1 for normal status messages
                             -- 2 for additional GPS/debug messages

--------  MAVLINK/AUTOPILOT 'CONSTANTS'  --------
local ROVER_MODE_AUTO = 10
local STANDBY         =  0
local SAVE_WPS        =  1
local CLEAR_WPS       =  2
local WAYPOINT        = 16   -- waypoint command
local MAV_SEVERITY_WARNING = 4
local MAV_SEVERITY_INFO    = 6
local MSG_NORMAL           = 1

local RC_CHAN = rc:find_channel_for_option(RC_OPTION)
local last_wp = Location()
local last_yaw = 999.0

-- wrapper for gcs:send_text()
local function gcs_msg(msg_type, severity, txt)
    if type(msg_type) == 'string' then
    -- allow just a string to be passed for simple/routine messages
        txt      = msg_type
        msg_type = MSG_NORMAL
        severity = MAV_SEVERITY_INFO
    end
    if msg_type <= VERBOSE_MODE then
        gcs:send_text(severity, string.format('%s: %s', SCRIPT_NAME, txt))
    end
end

local function yaw_diff(yaw1, yaw2)
    --https://stackoverflow.com/questions/5024375/getting-the-difference-between-two-headings
    return math.abs((yaw2 - yaw1 + 540.0) % 360.0 - 180.0)
end

local function new_mission()
    local home = ahrs:get_home()
    local item = mavlink_mission_item_int_t()

    mission:clear()

    item:command(WAYPOINT)
    item:x(home:lat())
    item:y(home:lng())
    item:z(home:alt())

    if not mission:set_item(0, item) then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Failed to create new mission')
        return false
    end

    return true
end

local function save_wp(position, index)
    local item = mavlink_mission_item_int_t()

    if (not position) then
		gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, string.format('WP %d - invalid position', index))
        return false
    end

    item:command(WAYPOINT)
    item:x(position:lat())
    item:y(position:lng())
    item:z(0)

    if not mission:set_item(index, item) then
        gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, string.format('WP %d - failed to save', index))
        return false
    end

    return true
end

function collect_breadcrumbs()
    if vehicle:get_mode() == ROVER_MODE_AUTO then
        gcs_msg('AUTO mode - saving canceled')
        return standby, RUN_INTERVAL_MS
    end
    local sw_pos = RC_CHAN:get_aux_switch_pos()
    if sw_pos ~= SAVE_WPS then return standby, RUN_INTERVAL_MS end

    if not ahrs:healthy() then return collect_breadcrumbs, RUN_INTERVAL_MS end

    local cur_pos = ahrs:get_location()
    local cur_yaw = ahrs:get_yaw_rad() * 180.0 / math.pi

    if cur_pos:get_distance(last_wp) < MIN_DIST then
        last_yaw = cur_yaw
        return collect_breadcrumbs, RUN_INTERVAL_MS
    end

    if yaw_diff(cur_yaw, last_yaw) > HDG_DELTA then
        local idx = mission:num_commands()
        if save_wp(cur_pos, idx) then
            gcs_msg(string.format('WP %d -  saved', idx))
            last_wp = cur_pos
            last_yaw = cur_yaw
        end
    end

    return collect_breadcrumbs, RUN_INTERVAL_MS
end

function await_switch_change()
    local sw_pos = RC_CHAN:get_aux_switch_pos()
    if sw_pos == STANDBY then return standby, RUN_INTERVAL_MS end
    if sw_pos == SAVE_WPS then return collect_breadcrumbs, RUN_INTERVAL_MS end
    return await_switch_change, RUN_INTERVAL_MS
end

function standby()
    if vehicle:get_mode() == ROVER_MODE_AUTO then return standby, RUN_INTERVAL_MS end
    local sw_pos = RC_CHAN:get_aux_switch_pos()
    if sw_pos == SAVE_WPS then
        last_wp = Location()
        last_yaw = 999.0
        return collect_breadcrumbs, RUN_INTERVAL_MS
    end
    if sw_pos == CLEAR_WPS then
        if new_mission() then
            gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Mission cleared')
        end
        return await_switch_change, RUN_INTERVAL_MS
    end
    return standby, RUN_INTERVAL_MS
end

function initialize()
    if not ahrs:healthy() then return initialize, RUN_INTERVAL_MS end
    gcs_msg('Ready')
    return standby, RUN_INTERVAL_MS
end

gcs_msg('Awaiting AHRS initialization...')

return initialize()



================================================
File: examples/rover-TerrainDetector.lua
================================================
--[[----------------------------------------------------------------------------

TerrainDetector ArduPilot Lua script

Uses gyro and accelerometer data to detect rough terrain and slow the
vehicle's speed accordingly during auto missions.

Provides a set of custom tuning parameters:
ROUGH_SPEED     : (m/s) rough terrain desired speed, set to -1 to disable detection
ROUGH_TIMEOUT_MS: (ms) min time to remain slowed down for rough terrain
ROUGH_GZ_MAX    : (G) slow down on Gz impulses greater than this value
ROUGH_RATE_MAX  : (deg/s) slow down on rate transients greater than this value

These gain values are used for smooth terrain detection.
Smaller values (less than 1.0) are more restrictive about resuming normal speed.
ROUGH_GZ_GAIN   : Gz impulse gain
ROUGH_RATE_GAIN : gyro transient rate gain

CAUTION: This script is capable of engaging and disengaging autonomous control
of a vehicle.  Use this script AT YOUR OWN RISK.

-- Yuri -- Jul 2022

LICENSE - GNU GPLv3 https://www.gnu.org/licenses/gpl-3.0.en.html

Concept first presented during this live stream:
https://www.youtube.com/watch?v=UdXGXjigxAo&t=7155s
Credit to @ktrussell for the idea and discussion!
------------------------------------------------------------------------------]]

---@diagnostic disable: param-type-mismatch

local SCRIPT_NAME     = 'TerrainDetector'
local RUN_INTERVAL_MS =  25  -- needs to be pretty fast for good detection
local SBY_INTERVAL_MS = 500  -- slower interval when detection is disabled
local PARAM_TABLE_KEY = 117  -- unique index value between 0 and 200

-- GCS messages
local VERBOSE_MODE = 1 -- 0 to suppress all GCS messages,
                       -- 1 for normal status messages
                       -- 2 for additional debug messages
local MSG_NORMAL   = 1
local MSG_DEBUG    = 2

-- MAVLink values
local MAV_SEVERITY_WARNING = 4
local MAV_SEVERITY_INFO    = 6

-- mathematical/physical constants
local G          = -9.81 -- m/s/s

-- create custom parameter set
local function add_params(key, prefix, tbl)
    assert(param:add_table(key, prefix, #tbl), string.format('Could not add %s param table.', prefix))
    for num = 1, #tbl do
        assert(param:add_param(key, num,  tbl[num][1], tbl[num][2]), string.format('Could not add %s%s.', prefix, tbl[num][1]))
    end
end

add_params(PARAM_TABLE_KEY, 'ROUGH_', {
    --  { name, default value },
        { 'SPEED',        0.7 },
        { 'GZ_MAX',      1.33 },
        { 'RATE_MAX',      28 },
        { 'GZ_GAIN',      0.9 },
        { 'RATE_GAIN',    0.8 },
        { 'TIMEOUT_MS',  7500 }
    })

-- wrapper for gcs:send_text()
local function gcs_msg(msg_type, severity, txt)
    if type(msg_type) == 'string' then
    -- allow just a string to be passed for simple/routine messages
        txt      = msg_type
        msg_type = MSG_NORMAL
        severity = MAV_SEVERITY_INFO
    end
    if type(severity) == 'string' then
    -- allow just severity and string to be passed for normal messages
        txt = severity
        severity = msg_type
        msg_type = MSG_NORMAL
    end
    if msg_type <= VERBOSE_MODE then
        gcs:send_text(severity, string.format('%s: %s', SCRIPT_NAME, txt))
    end
end

local last_g_z   = 0  -- to calculate impulse Gz
local timeout_ms = 0

-- debug values
local max_g_z       = 0
local max_gyro_rate = 0

local wp_speed_normal = nil
local wp_speed_rough = nil
local impulse_gz_threshold = nil
local gyro_rate_threshold = nil
local rough_terrain_timeout_ms = nil
local impulse_gain = nil
local gyro_gain = nil

function standby()
    wp_speed_rough = param:get('ROUGH_SPEED')
    if wp_speed_rough < 0 then return standby, SBY_INTERVAL_MS end

    if mission:state() == mission.MISSION_RUNNING then
        -- only poll remaining parameters at start of mission
        wp_speed_normal          = param:get('WP_SPEED')
        impulse_gz_threshold     = param:get('ROUGH_GZ_MAX')
        gyro_rate_threshold      = param:get('ROUGH_RATE_MAX')
        rough_terrain_timeout_ms = param:get('ROUGH_TIMEOUT_MS')
        impulse_gain             = param:get('ROUGH_GZ_GAIN')
        gyro_gain                = param:get('ROUGH_RATE_GAIN')
        -- if ROUGH_SPEED param not set or invalid, use half of WP_SPEED
        if wp_speed_rough == 0 or wp_speed_rough > wp_speed_normal then
            wp_speed_rough = wp_speed_normal / 2
            gcs_msg(MAV_SEVERITY_WARNING, 'ROUGH_SPEED invalid, using half WP_SPEED')
        end

        last_g_z = 0
        return do_normal_speed, RUN_INTERVAL_MS
    end
    return standby, SBY_INTERVAL_MS
end

function initiate_rough_speed()
    gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Slowing for rough terrain')
    vehicle:set_desired_speed(wp_speed_rough)
    last_g_z   = 0
    timeout_ms = millis() + rough_terrain_timeout_ms
    max_g_z       = 0
    max_gyro_rate = 0
    return do_rough_speed, RUN_INTERVAL_MS
end

function initiate_normal_speed()
    gcs_msg(MSG_NORMAL, MAV_SEVERITY_WARNING, 'Resuming normal speed')
    vehicle:set_desired_speed(wp_speed_normal)
    last_g_z = 0
    return do_normal_speed, RUN_INTERVAL_MS
end

function do_normal_speed()
    if mission:state() ~= mission.MISSION_RUNNING then
        return standby, SBY_INTERVAL_MS
    end

    local g_z         = ahrs:get_accel():z() / G  -- convert to G from m/s/s
    local gyro        = ahrs:get_gyro()
    -- sample max of roll/pitch rates
    local gyro_rate   = math.deg(math.max(math.abs(gyro:x()), math.abs(gyro:y())))
    local impulse_g_z = math.abs(g_z - last_g_z)  -- sample delta is the measured impulse
    last_g_z = g_z

    if impulse_g_z > impulse_gz_threshold then  -- slow down
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_INFO, string.format('Impulse - %.2f Gz', impulse_g_z))
        return initiate_rough_speed, RUN_INTERVAL_MS
    end

    if gyro_rate > gyro_rate_threshold then  -- slow down
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_INFO, string.format('Transient - %.2f deg/s', gyro_rate))
        return initiate_rough_speed, RUN_INTERVAL_MS
    end

    return do_normal_speed, RUN_INTERVAL_MS
end

function do_rough_speed()
    if mission:state() ~= mission.MISSION_RUNNING then
        return standby, SBY_INTERVAL_MS
    end

    local g_z         = ahrs:get_accel():z() / G  -- convert to G from m/s/s
    local gyro        = ahrs:get_gyro()
    -- sample max of roll/pitch rates
    local gyro_rate   = math.deg(math.max(math.abs(gyro:x()), math.abs(gyro:y())))
    local impulse_g_z = math.abs(g_z - last_g_z) -- sample delta is the measured impulse
    last_g_z = g_z

    max_g_z = math.max(g_z, max_g_z)
    max_gyro_rate = math.max(gyro_rate, max_gyro_rate)

    local now = millis()

    if impulse_g_z > impulse_gz_threshold * impulse_gain then  -- stay slow
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_INFO, string.format('Timer reset - %.2fGz', impulse_g_z))
        max_g_z = 0
        timeout_ms = now + rough_terrain_timeout_ms
        return do_rough_speed, RUN_INTERVAL_MS
    end

    if gyro_rate > gyro_rate_threshold * gyro_gain then  -- stay slow
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_INFO, string.format('Timer reset - %.2f deg/s', gyro_rate))
        max_gyro_rate = 0
        timeout_ms = now + rough_terrain_timeout_ms
        return do_rough_speed, RUN_INTERVAL_MS
    end

    if now > timeout_ms then  -- no longer in rough terrain
        gcs_msg(MSG_DEBUG, MAV_SEVERITY_INFO, string.format('Max - %.2fGz ... %.2f deg/s', max_g_z, max_gyro_rate))
        return initiate_normal_speed, RUN_INTERVAL_MS
    end

    return do_rough_speed, RUN_INTERVAL_MS
end

gcs_msg('Script active')

return standby, SBY_INTERVAL_MS



================================================
File: examples/rover-motor-driver.lua
================================================
-- Rover motor driver for an Ackerman style vehicle (i.e. the frame has separate throttle and steering controls)
--
-- The following parameters should be set:
--     SERVO1_FUNCTION = 94 (Script 1) 
--     SERVO3_FUNCTION = 96 (Script 3)
-- 
-- The Frame's steering control should be connected to the autopilot's output1, throttle control to output3
--
-- CAUTION: This script only works for Rover
-- This script retrieves the high level controller outputs that have been sent to the regular motor driver
-- and then outputs them to the "Script 1" and "Script 3" outputs.  This does not add any real value beyond
-- serving as an example of how lua scripts can be used to implement a custom motor driver 

local K_SCRIPTING1 = 94 -- for steering control
local K_SCRIPTING3 = 96 -- for throttle control
local CONTROL_OUTPUT_THROTTLE = 3
local CONTROL_OUTPUT_YAW = 4

function update()
  if not arming:is_armed() then
    -- if not armed move steering and throttle to mid
    SRV_Channels:set_output_norm(K_SCRIPTING1, 0)
    SRV_Channels:set_output_norm(K_SCRIPTING3, 0)
  else
    -- retrieve high level steering and throttle control outputs from vehicle in -1 to +1 range
    local steering = vehicle:get_control_output(CONTROL_OUTPUT_YAW)
    local throttle = vehicle:get_control_output(CONTROL_OUTPUT_THROTTLE)
    if (steering and throttle) then
      if throttle < 0 then
          steering = -steering
      end
      SRV_Channels:set_output_norm(K_SCRIPTING1, steering)
      SRV_Channels:set_output_norm(K_SCRIPTING3, throttle)
    end
  end
  return update, 10 -- run at 100hz
end

gcs:send_text(6, "rover-motor-driver.lua is running")
return update()



================================================
File: examples/rover-set-steering-and-throttle.lua
================================================
-- cause a rover to drive in a figure of eight pattern by directly controlling steering and throttle
--
-- CAUTION: This script only works for Rover
-- this script waits for the vehicle to be armed and RC6 input > 1800 and then:
--    a) switches to Guided mode
--    b) increases throttle to 30% and turns right at 20% for 10 seconds
--    c) keep throttle at 30% and turns left at 20% for 10 seconds
--    d) switches to Hold mode

local stage = 0
local stage_counter = 0
local rover_guided_mode_num = 15
local rover_hold_mode_num = 4

-- the main update function that directly sets throttle and steering out to drive a figure of eight pattern
function update()
  if not arming:is_armed() then -- reset state when disarmed
    stage = 0
    stage_counter = 0
  else
    pwm6 = rc:get_pwm(6)
    if pwm6 and pwm6 > 1800 then    -- check if RC6 input has moved high
      if (stage == 0) then          -- change to guided mode
        if (vehicle:set_mode(rover_guided_mode_num)) then     -- change to Guided mode
          stage = stage + 1
          stage_counter = 0
        end
      elseif (stage == 1) then      -- Stage1: increase throttle to 30% and turn right 20%
        if (vehicle:set_steering_and_throttle(0.2, 0.3)) then
          stage_counter = stage_counter + 1
          if (stage_counter >= 10) then
            stage = stage + 1
            stage_counter = 0
          end
        end
      elseif (stage == 2) then      -- Stage2: keep throttle at 30% and turn left 20%
        if (vehicle:set_steering_and_throttle(-0.2, 0.3)) then
          stage_counter = stage_counter + 1
          if (stage_counter >= 10) then
            stage = stage + 1
            stage_counter = 0
          end
        end
      elseif (stage == 3) then      -- Stage3: change to Hold mode
        vehicle:set_mode(rover_hold_mode_num)
        stage = stage + 1
        gcs:send_text(0, "finished, switching to Hold")
      end
    else -- RC6 has been moved low
      if stage > 3 then 
        stage = 0
        stage_counter = 0
      end
    end
  end

  return update, 1000
end

return update()



================================================
File: examples/rover-set-turn-rate.lua
================================================
-- This scirpt uses Rover's turn rate controller to make the vehicle move in circles of fixed radius

-- Edit these variables
local rad_xy_m = 0.5                -- circle radius in xy plane in m
local target_speed_xy_mps = 0.5     -- target speed in m/s
local rc_channel_switch = 7         -- switch this channel to "high" to get the script working
local cw_turn = true                -- change this to false for ccw circle instead of default cw



-- Fixed variables
local omega_radps = target_speed_xy_mps/rad_xy_m
local rover_guided_mode_num = 15
local direction = 1
if not cw_turn then
    direction = -1
end


-- Script Start --

gcs:send_text(0,"Script started")
gcs:send_text(0,"Trajectory period: " .. tostring(2 * math.rad(180) / omega_radps))

local circle_active = false
local last_mode = 0


function update()

    if not circle_active then
        last_mode = vehicle:get_mode()
    end

    if arming:is_armed() and rc:get_pwm(rc_channel_switch) > 1700 and not circle_active then
        -- set guided mode since rc switch is now high
        vehicle:set_mode(rover_guided_mode_num)
        circle_active = true
    elseif arming:is_armed() and rc:get_pwm(rc_channel_switch) < 1200 and circle_active then
        -- set back to last mode since rc switch is low
        vehicle:set_mode(last_mode)
        circle_active = false
    end

    if circle_active then
        --target turn rate in degrees including direction
        local target_turn_rate = math.deg(omega_radps * direction)

        -- send guided message
        if not vehicle:set_desired_turn_rate_and_speed(target_turn_rate, target_speed_xy_mps) then
            gcs:send_text(0, "Failed to send target ")
        end
    end

    return update, 100
end

return update()



================================================
File: examples/serial_test.lua
================================================
-- Lua script to write and read from a serial

---@diagnostic disable: need-check-nil

local port = serial:find_serial(0)

port:begin(115200)
port:set_flow_control(0)

local step = 65

function spit ()
  if port:available() > 0 then
    read = port:read()
    gcs:send_text(0, read .. " = " .. step)
  end
  if step > 122 then
    step = 65
  else
    step = step + 1
  end
  port:write(step)
  return spit, 1000
end

return spit, 1000



================================================
File: examples/servo_scan.lua
================================================
-- move a servo in a sinusoidal fashion

local SERVO_FUNCTION = 94
local FREQUENCY = 0.125

function update() -- this is the loop which periodically runs
  local t = 0.001 * millis():tofloat()
  local output = math.sin(math.pi * t * FREQUENCY * 2.0)
  local pwm = math.floor(1500 + 500 * output)
  SRV_Channels:set_output_pwm(SERVO_FUNCTION, pwm)
  return update, 20 -- reschedules the loop at 50Hz
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/servo_set_get.lua
================================================
-- Testing set_output_pwm_chan_timeout and get_output_pwm
--
-- This will set MAIN1 servo to 1700 pwm for 1 second,
-- then assigned function behavior for 1 second, and then 1100 pwm for 1 second

local flipflop = true
local K_AILERON = 4
local aileron_channel = assert(SRV_Channels:find_channel(K_AILERON))

function update()
    if flipflop then
        SRV_Channels:set_output_pwm_chan_timeout(aileron_channel, 1700, 1000)
        gcs:send_text(6, "flip---")
    else
        SRV_Channels:set_output_pwm_chan_timeout(aileron_channel, 1100, 1000)
        gcs:send_text(6, "---flop")
    end
    flipflop = not flipflop
    output_pwm = SRV_Channels:get_output_pwm(K_AILERON)
    gcs:send_text(6, "Function "..K_AILERON..", channel "..aileron_channel..", output "..output_pwm)
    return update, 2000
end

gcs:send_text(6, "servo_set_get.lua is running")
return update, 1000



================================================
File: examples/servo_slew.lua
================================================
-- move a servo in a sinusoidal fashion, with settable limits and frequency

local PARAM_TABLE_KEY = 135
local PARAM_TABLE_PREFIX = "STEST_"

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup script specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')

local STEST_CHAN      = bind_add_param('CHAN',          1, 0)
local STEST_PCT       = bind_add_param('PCT',           2, 100)
local STEST_PWM_MIN   = bind_add_param('PWM_MIN',       3, 1000)
local STEST_PWM_MAX   = bind_add_param('PWM_MAX',       4, 2000)
local STEST_FREQ      = bind_add_param('FREQ',          5, 1)

function update()
   local chan = STEST_CHAN:get()
   local freq = STEST_FREQ:get()
   if chan > 0 and freq > 0 then
      local t = 0.001 * millis():tofloat()
      local pi = 3.1415
      local output = math.sin(pi * t * freq * 2.0) * STEST_PCT:get() * 0.01
      local pwm_min = STEST_PWM_MIN:get()
      local pwm_max = STEST_PWM_MAX:get()
      local pwm_mid = 0.5*(pwm_min+pwm_max)
      local pwm = math.floor(pwm_mid + (pwm_max-pwm_mid) * output)
      SRV_Channels:set_output_pwm_chan_timeout(chan-1, pwm, 100)
      --gcs:send_text(0, string.format("pwm=%u", pwm))
   end
   return update, 5 -- 200Hz
end

return update()



================================================
File: examples/set-angle.lua
================================================
-- Example of guided mode angle control, yawing back and forth

local target_yaw_1 = 45
local target_yaw_2 = -45

local target_roll = 0 -- deg
local target_pitch = 0 -- deg

local climb_rate = 0 -- m/s
local use_yaw_rate = false
local yaw_rate = 0 -- degs/s

local flipflop = true
function update()
  if flipflop then
    vehicle:set_target_angle_and_climbrate(target_roll,target_pitch,target_yaw_1,climb_rate,use_yaw_rate,yaw_rate)
  else 
    vehicle:set_target_angle_and_climbrate(target_roll,target_pitch,target_yaw_2,climb_rate,use_yaw_rate,yaw_rate)
  end
  flipflop = not flipflop
  return update, 10000
end

return update()



================================================
File: examples/set-target-location.lua
================================================
-- performs the equivalent of a simple RTL in Guided mode using set_target_location
--
-- CAUTION: This script only works for Copter
-- this script checks for RC input > 1800 and then:
--    a) switches to Guided mode
--    b) sets the target location to be 10m above home
--    c) switches the vehicle to land once it is within a couple of meters of home

local wp_radius = 2
local target_alt_above_home = 10
local copter_guided_mode_num = 4
local copter_land_mode_num = 9
local sent_target = false

-- the main update function that performs a simplified version of RTL
function update()
  if not arming:is_armed() then -- reset state when disarmed
    sent_target = false
  else
    pwm7 = rc:get_pwm(7)
    if pwm7 and pwm7 > 1800 then                        -- check if RC input 7 has moved high
      local mode = vehicle:get_mode()                   -- get current mode
      if not sent_target then                           -- if we haven't sent the target yet
        if mode ~= copter_guided_mode_num then    -- change to guided mode
          vehicle:set_mode(copter_guided_mode_num)
        else
          local above_home = ahrs:get_home()            -- get home location
          if above_home then
            above_home:alt(above_home:alt() + (target_alt_above_home * 100))
            sent_target = vehicle:set_target_location(above_home)   -- set target above home
          end
        end
      else

        -- change to land mode when within 2m of home
        if mode ~= copter_land_mode_num then
          local home = ahrs:get_home()
          local curr_loc = ahrs:get_location()
          if home and curr_loc then
            local home_dist = curr_loc:get_distance(home)   -- get horizontal distance to home
            if (home_dist < wp_radius) then                 -- change to land mode if close
              vehicle:set_mode(copter_land_mode_num)
            end
          end
        end
      end
    end
  end

  return update, 1000
end

return update()



================================================
File: examples/set-target-velocity.lua
================================================
-- command a Copter to takeoff to 10m and fly a square pattern
--
-- CAUTION: This script only works for Copter
-- this script waits for the vehicle to be armed and RC6 input > 1800 and then:
--    a) switches to Guided mode
--    b) takeoff to 10m
--    c) flies a 20m x 20m square pattern using the velocity controller
--    d) switches to RTL mode

local takeoff_alt_above_home = 10
local copter_guided_mode_num = 4
local copter_rtl_mode_num = 6
local stage = 0
local bottom_left_loc   -- vehicle location when starting square
local square_side_length = 20   -- length of each side of square

-- the main update function that uses the takeoff and velocity controllers to fly a rough square pattern
function update()
  if not arming:is_armed() then -- reset state when disarmed
    stage = 0
  else
    pwm6 = rc:get_pwm(6)
    if pwm6 and pwm6 > 1800 then    -- check if RC7 input has moved high
      if (stage == 0) then          -- change to guided mode
        if (vehicle:set_mode(copter_guided_mode_num)) then     -- change to Guided mode
          stage = stage + 1
        end
      elseif (stage == 1) then      -- Stage1: takeoff
        if (vehicle:start_takeoff(takeoff_alt_above_home)) then
          stage = stage + 1
        end
      elseif (stage == 2) then      -- Stage2: check if vehicle has reached target altitude
        local home = ahrs:get_home()
        local curr_loc = ahrs:get_location()
        if home and curr_loc then
          local vec_from_home = home:get_distance_NED(curr_loc)
          gcs:send_text(0, "alt above home: " .. tostring(math.floor(-vec_from_home:z())))
          if (math.abs(takeoff_alt_above_home + vec_from_home:z()) < 1) then
            stage = stage + 1
            bottom_left_loc = curr_loc          -- record location when starting square
          end
        end
      elseif (stage >= 3 and stage <= 6) then   -- fly a square using velocity controller
        local curr_loc = ahrs:get_location()
        local target_vel = Vector3f()           -- create velocity vector
        if (bottom_left_loc and curr_loc) then
          local dist_NE = bottom_left_loc:get_distance_NE(curr_loc)

          -- Stage3 : fly North at 2m/s
          if (stage == 3) then
            target_vel:x(2)
            if (dist_NE:x() >= square_side_length) then
              stage = stage + 1
            end
          end

          -- Stage4 : fly East at 2m/s
          if (stage == 4) then
            target_vel:y(2) 
            if (dist_NE:y() >= square_side_length) then
              stage = stage + 1
            end
          end

          -- Stage5 : fly South at 2m/s
          if (stage == 5) then
            target_vel:x(-2)
            if (dist_NE:x() <= 2) then
              stage = stage + 1
            end
          end

          -- Stage6 : fly West at 2m/s
          if (stage == 6) then
            target_vel:y(-2)
            if (dist_NE:y() <= 2) then
              stage = stage + 1
            end
          end

          -- send velocity request
          if (vehicle:set_target_velocity_NED(target_vel)) then   -- send target velocity to vehicle
            gcs:send_text(0, "pos:" .. tostring(math.floor(dist_NE:x())) .. "," .. tostring(math.floor(dist_NE:y())) .. " sent vel x:" .. tostring(target_vel:x()) .. " y:" .. tostring(target_vel:y()))
          else
            gcs:send_text(0, "failed to execute velocity command")
          end
        end
      elseif (stage == 7) then  -- Stage7: change to RTL mode
        vehicle:set_mode(copter_rtl_mode_num)
        stage = stage + 1
        gcs:send_text(0, "finished square, switching to RTL")
      end
    end
  end

  return update, 1000
end

return update()



================================================
File: examples/set_CAMERA_INFORMATION.lua
================================================
 --[[
    Populate the fields of the CAMERA_INFORMATION message sent by the selected camera instance.
 --]]
 function set_camera_information()
    -- set the Camera Information data
    local cam_info = mavlink_camera_information_t()

    local INSTANCE = 0
    local vendor_name = 'Unknown'
    local model_name = 'Camera'
    local uri = ''

    -- "time_boot_ms" is populated automatically by the camera backend
    for i = 0, #vendor_name do
        cam_info:vendor_name(i, vendor_name:byte(i+1))
    end
    for i = 0, #model_name do
        cam_info:model_name(i, model_name:byte(i+1))
    end
    cam_info:firmware_version(0)
    cam_info:focal_length(1.6)
    cam_info:sensor_size_h(3840)
    cam_info:sensor_size_v(2160)
    cam_info:resolution_h(1920)
    cam_info:resolution_v(1080)
    -- "lens_id" is populated automatically by the camera backend
    cam_info:flags(256) -- CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM
    cam_info:cam_definition_version(0)
    for i = 0, #uri do
        cam_info:cam_definition_uri(i, uri:byte(i+1))
    end
    -- "gimbal_device_id" is populated automatically by the camera backend

    camera:set_camera_information(INSTANCE, cam_info)

end

return set_camera_information()



================================================
File: examples/set_target_posvel_circle.lua
================================================
-- Commands copter to fly circle trajectory using posvel method in guided mode. 
-- The trajectory start from the current location
-- 
-- CAUTION: This script only works for Copter.
-- This script start when the in GUIDED mode and above 5 meter.
--      1) arm and takeoff to above 5 m 
--      2) switch to GUIDED mode 
--      3) the vehilce will follow a circle in clockwise direction with increasing speed until ramp_up_time_s time has passed.
--      4) switch out of and into the GUIDED mode any time to restart the trajectory from the start.

---@diagnostic disable: cast-local-type
---@diagnostic disable: redundant-parameter

-- Edit these variables
local rad_xy_m = 10.0   -- circle radius in xy plane in m
local target_speed_xy_mps = 5.0     -- maximum target speed in m/s
local ramp_up_time_s = 10.0     -- time to reach target_speed_xy_mps in second
local sampling_time_s = 0.05    -- sampling time of script

-- Fixed variables
local omega_radps = target_speed_xy_mps/rad_xy_m
local copter_guided_mode_num = 4
local theta = 0.0
local time = 0.0
local test_start_location = Vector3f(0.0, 0.0, 0.0)

gcs:send_text(0,"Script started")
gcs:send_text(0,"Trajectory period: " .. tostring(2 * math.rad(180) / omega_radps))

function circle()
    local cur_freq
    -- increase target speed lineary with time until ramp_up_time_s is reached
    if time <= ramp_up_time_s then 
        cur_freq = omega_radps*(time/ramp_up_time_s)^2
    else 
        cur_freq = omega_radps
    end

    -- calculate circle reference position and velocity
    theta = theta + cur_freq*sampling_time_s

    local th_s = math.sin(theta)
    local th_c = math.cos(theta) 

    local pos = Vector3f()
    pos:x(rad_xy_m*th_s)
    pos:y(-rad_xy_m*(th_c-1))
    pos:z(0)

    local vel = Vector3f()
    vel:x(cur_freq*rad_xy_m*th_c)
    vel:y(cur_freq*rad_xy_m*th_s)
    vel:z(0)

    return pos, vel
end

function update()
    if arming:is_armed() and vehicle:get_mode() == copter_guided_mode_num and -test_start_location:z()>=5 then

        -- calculate current position and velocity for circle trajectory
        local target_pos, target_vel = circle()

        -- advance the time
        time = time + sampling_time_s

        -- send posvel request
        if not vehicle:set_target_posvel_NED(target_pos+test_start_location, target_vel) then
            gcs:send_text(0, "Failed to send target posvel at " .. tostring(time) .. " seconds")
        end
    else 
        -- calculate test starting location in NED
        local cur_loc = ahrs:get_location()        
        if cur_loc then
             test_start_location = cur_loc.get_vector_from_origin_NEU_cm(cur_loc)             
             if test_start_location then
                test_start_location:x(test_start_location:x() * 0.01) 
                test_start_location:y(test_start_location:y() * 0.01) 
                test_start_location:z(-test_start_location:z() * 0.01) 
             end             
        end

        -- reset some variable as soon as we are not in guided mode
        time = 0
        theta = 0
    end

    return update, sampling_time_s * 1000
end

return update()


================================================
File: examples/ship_vel_match.lua
================================================
-- support takeoff with velocity matching for quadplanes

---@diagnostic disable: need-check-nil

local PARAM_TABLE_KEY = 35
local PARAM_TABLE_PREFIX = "SHIPV_"

local MODE_AUTO = 10

local NAV_TAKEOFF = 22
local NAV_VTOL_TAKEOFF = 84

local ALT_FRAME_ABSOLUTE = 0

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

-- setup SHIPV specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 3), 'could not add param table')
SHIPV_ENABLE     = bind_add_param('ENABLE', 1, 0)

local takeoff_vel = nil
local takeoff_pos = nil

-- main update function
function update()
   if SHIPV_ENABLE:get() < 1 then
      return
   end

   local vehicle_mode = vehicle:get_mode()

   if not arming:is_armed() then
      -- when not armed record position and velocity
      takeoff_vel = ahrs:get_velocity_NED()
      takeoff_pos = ahrs:get_position()
      takeoff_pos:change_alt_frame(ALT_FRAME_ABSOLUTE)
   else
      if vehicle_mode == MODE_AUTO and takeoff_pos and takeoff_vel then
         local id = mission:get_current_nav_id()
         if id == NAV_VTOL_TAKEOFF or id == NAV_TAKEOFF then
            local next_WP = vehicle:get_target_location()
            if not next_WP then
               return
            end
            vehicle:set_velocity_match(takeoff_vel:xy())
            local tpos = takeoff_pos:copy()
            tpos:alt(next_WP:alt())
            vehicle:update_target_location(next_WP, tpos)
         else
            takeoff_pos = nil
            takeoff_vel = nil
         end
      end
   end
end

function loop()
   update()
   -- run at 20Hz
   return loop, 50
end

-- wrapper around update(). This calls update() at 20Hz,
-- and if update faults then an error is displayed, but the script is not
-- stopped
function protected_wrapper()
  local success, err = pcall(update)
  if not success then
     gcs:send_text(0, "Internal Error: " .. err)
     -- when we fault we run the update function again after 1s, slowing it
     -- down a bit so we don't flood the console with errors
     return protected_wrapper, 1000
  end
  return protected_wrapper, 50
end

gcs:send_text(0, "Loaded quadplane takeoff velmatch")

-- start running update loop
return protected_wrapper()




================================================
File: examples/sim_arming_pos.lua
================================================
--[[
    allow for force the position of the simulated vehicle when armed
--]]

local PARAM_TABLE_KEY = 16
local PARAM_TABLE_PREFIX = "SIM_APOS_"

-- setup package place specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 16), 'could not add param table')

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return Parameter(PARAM_TABLE_PREFIX .. name)
end

local SIM_APOS_ENABLE = bind_add_param('ENABLE', 1, 0)
local SIM_APOS_POS_N = bind_add_param('POS_N', 2, 0)
local SIM_APOS_POS_E = bind_add_param('POS_E', 3, 0)
local SIM_APOS_POS_D = bind_add_param('POS_D', 4, 0)
local SIM_APOS_VEL_X = bind_add_param('VEL_X', 5, 0)
local SIM_APOS_VEL_Y = bind_add_param('VEL_Y', 6, 0)
local SIM_APOS_VEL_Z = bind_add_param('VEL_Z', 7, 0)
local SIM_APOS_RLL = bind_add_param('RLL', 8, 0)
local SIM_APOS_PIT = bind_add_param('PIT', 9, 0)
local SIM_APOS_YAW = bind_add_param('YAW', 10, 0)
local SIM_APOS_GX = bind_add_param('GX', 11, 0)
local SIM_APOS_GY = bind_add_param('GY', 12, 0)
local SIM_APOS_GZ = bind_add_param('GZ', 13, 0)
local SIM_APOS_MODE = bind_add_param('MODE', 14, -1)

local was_armed = false

local function update()
    if SIM_APOS_ENABLE:get() == 0 then
        return
    end
    local armed = arming:is_armed()
    local set_pos = armed and not was_armed

    if set_pos then
        gcs:send_text(0, "Forcing arm pose")
        local quat = Quaternion()
        quat:from_euler(math.rad(SIM_APOS_RLL:get()), math.rad(SIM_APOS_PIT:get()), math.rad(SIM_APOS_YAW:get()))

        local vel = Vector3f()
        vel:x(SIM_APOS_VEL_X:get())
        vel:y(SIM_APOS_VEL_Y:get())
        vel:z(SIM_APOS_VEL_Z:get())
        quat:earth_to_body(vel)

        local loc = ahrs:get_origin()
        if not loc then
            return
        end
        loc:offset(SIM_APOS_POS_N:get(), SIM_APOS_POS_E:get())
        loc:alt(loc:alt() - SIM_APOS_POS_D:get()*100)

        local gyro = Vector3f()
        gyro:x(math.rad(SIM_APOS_GX:get()))
        gyro:y(math.rad(SIM_APOS_GY:get()))
        gyro:z(math.rad(SIM_APOS_GZ:get()))

        sim:set_pose(0, loc, quat, vel, gyro)

        if SIM_APOS_MODE:get() >= 0 then
            vehicle:set_mode(SIM_APOS_MODE:get())
        end
    end

    was_armed = armed
end

local function loop()
    if SIM_APOS_ENABLE:get() == 0 then
        return loop, 500
    end
    update()
    return loop, 50
end

gcs:send_text(0, "Loaded arm pose")
return loop,1000



================================================
File: examples/simple_loop.lua
================================================
-- This script is an example of saying hello.  A lot.
-- Pick a random number to send back
local number = math.random()

function update() -- this is the loop which periodically runs
  gcs:send_text(0, "hello, world") -- send the traditional message

  gcs:send_named_float('Lua Float',number) -- send a value
  number = number +  math.random() -- change the value

  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/sitl_standby_sim.lua
================================================
-- This script is a allow to switch the standby function by the switch of the remote controller on 2 simulated fcus.

-- variable to limit the number of messages sent to GCS
local last_rc_input = 0

-- constants
local switch_high = 2
local switch_low = 0

-- Standby function number in ArduPilot
local standby_function = 76
-- RC pin to use to select the FCU
local rc_input_pin = 8


-- for fast param access it is better to get a param object,
-- this saves the code searching for the param by name every time
local JSON_MASTER = Parameter()
if not JSON_MASTER:init('SIM_JSON_MASTER') then
  gcs:send_text(6, 'get SIM_JSON_MASTER failed')
end

local MAV_SYSID = Parameter()
if not MAV_SYSID:init('MAV_SYSID') then
  gcs:send_text(6, 'get MAV_SYSID failed')
end

local sysid = MAV_SYSID:get()

gcs:send_text(6, 'LUA: Standby LUA loaded')

-- The loop check the value of the switch of the remote controller and switch the standby function of the simulated fcus.
-- FCU should have MAV_SYSID set to 1 or 2.
-- The switch is on the channel 8 (default) of the remote controller.
-- fcu1 and fcu2 have mirrored standby function, so only one is active at a time.
-- As this is for simulation, the SIM_JSON_MASTER param is also update to select which fcu control the motors.

function update() -- this is the loop which periodically runs
  rc_input = rc:get_pwm(rc_input_pin)

  if rc_input == nil then
    gcs:send_text(6, 'LUA: rc_input is nil')
    return update, 1000 -- reschedules the loop
  end

  if rc_input ~= last_rc_input then
      if sysid == 2 then
          if rc_input > 1500 then
              if not JSON_MASTER:set(0) then
                  gcs:send_text(6, string.format('LUA: failed to set SIM_JSON_MASTER'))
              else
                  rc:run_aux_function(standby_function, switch_high)
                  gcs:send_text(6, string.format('LUA: set SIM_JSON_MASTER to 0'))
              end
          else
              if not JSON_MASTER:set(1) then
                  gcs:send_text(6, string.format('LUA: failed to set SIM_JSON_MASTER'))
              else
                  rc:run_aux_function(standby_function, switch_low)
                  gcs:send_text(6, string.format('LUA: set SIM_JSON_MASTER to 1'))
              end
          end
      end
      if sysid == 1 then
          if rc_input > 1500 then
              if not JSON_MASTER:set(0) then
                  gcs:send_text(6, string.format('LUA: failed to set SIM_JSON_MASTER'))
              else
                  rc:run_aux_function(standby_function, switch_low)
                  gcs:send_text(6, string.format('LUA: set SIM_JSON_MASTER to 0'))
              end
          else
              if not JSON_MASTER:set(1) then
                  gcs:send_text(6, string.format('LUA: failed to set SIM_JSON_MASTER'))
              else
                  rc:run_aux_function(standby_function, switch_high)
                  gcs:send_text(6, string.format('LUA: set SIM_JSON_MASTER to 1'))
              end
          end
      end
      last_rc_input = rc_input
  end

  return update, 1000 -- reschedules the loop
end

return update() -- run immediately before starting to reschedule



================================================
File: examples/smbus-check-cycles.lua
================================================
-- This script checks SMBus battery cycle count

local warning_cycles = 100
local battery_instance = 0

function update()
  if not arming:is_armed() then -- only run check when disarmed
    local cycle_count = battery:get_cycle_count(battery_instance)
    if cycle_count then
      if cycle_count >= warning_cycles then
        gcs:send_text(0, string.format("Battery needs replacing (%d cycles)", cycle_count))
      end
    else
      gcs:send_text(0, "failed to get battery cycles")
    end
  end

  return update, 15000 -- check again in 15 seconds
end

return update(), 15000 -- first message may be displayed 15 seconds after start-up



================================================
File: examples/sub_test_synthetic_seafloor.lua
================================================

-- sub_test_synthetic_seafloor.lua
-- A simulated range finder driver returns distances based on the
-- vehicle location over a simulated seafloor topography. Used for
-- testing bottom tracking modes in ArduSub.
--
-- The synthetic seafloor topography is defined as a 1-D height profile (h=f(x)) that is extruded 
-- in the perpendicular direction to define a 2-D height function (h=f(x,y)).
--
-- The following Parameters can be set by the test script to control how this driver behaves
--  SCR_USER1 is an index into a table of configuration bundles
--  SCR_USER2 is the average bottom depth in meters
--  SCR_USER3 is a bit field that controls driver logging
--  SRC_USER4 is the rangefinder target in meters
--

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type

local UPDATE_PERIOD_MS = 50

local TEST_ID_STR = "STSS"
local SCRIPT_NAME = "sub_test_synthetic_seafloor.lua"

local enable_logger_write = true
local enable_gcs_send_data = false
local enable_gcs_send_range = false

-- Copied from libraries/AP_RangeFinder/AP_RangeFinder.h enum RangeFinder::Type {}.
local RNGFND_TYPE_LUA = 36.0
-- Copied from libraries/AP_RangeFinder/AP_RangeFinder.h enum RangeFinder::Status {}.
local RNGFND_STATUS_NO_DATA = 1
local RNGFND_STATUS_GOOD = 4
-- Copied from libraries/AP_RangeFinder/AP_RangeFinder.h
local SIGNAL_QUALITY_MIN = 0
local SIGNAL_QUALITY_MAX = 100
-- Copied from ArduSub/mode.h enum Mode::Number {}.
local MODE_SURFTRAK = 21



-------------------------------------------------------------------------------

-- gcs messaging function. Pass two strings and the function will drop frequent messages

local gcs_send_funcfactory = function(name, eat_messages_period_s, msg_severity)
    local gcs_send_times = {}
    local gcs_eaten_count = {}

    ---@param str1 string
    ---@param str2 string|nil
    return function(str1, str2)
        if not str1 or #str1 == 0 then return end
        if not msg_severity then msg_severity = 6 end
        if not eat_messages_period_s then eat_messages_period_s = 1.0 end
        
        local send_str

        if not str2 or #str2 == 0 then
            send_str = string.format("%s: %s", name, str1)
        
        else
            local time_curr_s = millis():tofloat() / 1000.0
            local time_first_s = gcs_send_times[str1]
            if (time_first_s) then
                local dur_since_first = time_curr_s - time_first_s
                if dur_since_first < eat_messages_period_s then
                    if not gcs_eaten_count[str1] then
                        gcs_eaten_count[str1] = 0
                    end
                    gcs_eaten_count[str1] = gcs_eaten_count[str1] + 1
                    return
                end
            end

            local eaten_count = gcs_eaten_count[str1]
            if eaten_count then
                gcs_eaten_count[str1] = nil
                send_str = string.format("%s: %s %s (+%i)", name, str1, str2, eaten_count)
            else
                send_str = string.format("%s: %s %s", name, str1, str2)
            end

            gcs_send_times[str1] = time_curr_s
        end

        gcs:send_text(msg_severity, send_str)
    end
end

local send = gcs_send_funcfactory(TEST_ID_STR, 1.0, 3)
-- A send function used to send true range messages at a different rate.
local send_quick = gcs_send_funcfactory(TEST_ID_STR, 0.5, 3)

local function fatal_error(error)
    send(string.format("FATAL ERROR '%s': %s", SCRIPT_NAME, error))
end

-------------------------------------------------------------------------------

-- Profile definition and intersection used in Sea Floor Model

local function section_factory(x0, z0, x1, z1)

    -- Use cross product to see if self intersects with seg.
    -- Lines are defined by the two points (x0, z0) and (x0 + vx, z0 + vz).
    local function intersect(self, seg)
        local den = - self.vx*seg.vz + self.vz*seg.vx
        if math.abs(den) < 1.0e-6 then
            return nil
        end
        local x1m0 = seg.x0 - self.x0
        local z1m0 = seg.z0 - self.z0
        local t0 = - x1m0*seg.vz + z1m0*seg.vx
        local t1 = self.vx*z1m0 - self.vz*x1m0
        -- The returned values are the distance along the lines where the intersection occurs.
        -- The first is along self and the second is along seg
        return t0 / den, t1 / den
    end

    return {
        x0 = x0,
        z0 = z0,
        vx = x1 - x0,
        vz = z1 - z0,
        intersect = intersect,
    }
end

-- psi is an angle in radians rotating around the y axis with zero at the z axis
local function ray_factory(x, z, psi)
    return section_factory(x, z, x + math.sin(psi), z + math.cos(psi))
end

local function profile_factory(vertices)
    local sections = {}

    -- The first section covers to -infinity
    if #vertices > 0 then
        local vertex1 = vertices[1]
        table.insert(sections, section_factory(vertex1[1], vertex1[2], vertex1[1] - 1, vertex1[2]))
    end

    local last_vertex
    for _, vertex in pairs(vertices) do
        if not last_vertex then
            last_vertex = vertex
        else
            local section = section_factory(last_vertex[1], last_vertex[2], vertex[1], vertex[2])
            if math.abs(section.vx) > 1.0e-6 or math.abs(section.vy) > 1.0e-6 then
                -- Only add section if it has non-zero length, otherwise ignore this vertex.
                table.insert(sections, section)
                last_vertex = vertex
            end
        end
    end

    -- The last section covers to +infinity
    if last_vertex then
        table.insert(sections, section_factory(last_vertex[1], last_vertex[2], last_vertex[1] + 1, last_vertex[2]))
    end


    -- Returns the distance to the closest section.
    sections.intersect = function(self, ray)
        local d

        for i, segment in ipairs(self) do

            -- Return the distance from the start of the ray to the intersection
            -- with the segment. If there is no intersection or the intersection is
            -- not on the segment s < 0 or s > 1 then return nil. Note: the r distance
            -- can be negative if the intersection is on the ray before its start (r < 0)
            local function find_valid_intersection()
                local s, r = segment:intersect(ray)
                if not s then
                    return nil
                end
                if s < 0 then
                    return nil
                end
                if i ~= 1 and i ~= #self then
                    if s > 1 then
                        return nil
                    end
                end
                return r
            end

            local d1 = find_valid_intersection()
            if d1 then
                -- Found a valid intersection, look for the shortest distance
                if not d or d > d1 then
                    d = d1
                end
            end
        end

        return d
    end

    return sections
end

do  -- Some code to test functionality and illustrate usage
    local section = section_factory(0, 1, 1, 1)

    local function test(x, z, psi, s_expected, r_expected)
        local ray = ray_factory(x, z, psi)

        -- Test the section:intersect method.
        local s_actual, r_actual = section:intersect(ray)

        if not s_actual or not s_expected then
            if s_actual or s_expected then
                local actual_str = not s_actual and "nil" or string.format("%.2f", s_actual)
                local expected_str = not s_expected and "nil" or string.format("%.2f", s_expected)
                send(string.format("intersect not nil  : x %.2f, z %.2f, psi %.2f", x, z, psi) ..
                    string.format(" : s_actual %s, s_expected %s", actual_str, expected_str))
            end
        else
            if math.abs(s_actual - s_expected) > 1.0e-6 or math.abs(r_actual - r_expected) > 1.0e-6 then
                send(string.format("intersect failed  : x %.2f, z %.2f, psi %.2f", x, z, psi) ..
                    string.format(" : s_actual %.2f, s_expected %.2f, r_actual %.2f, r_expected %.2f", 
                        s_actual, s_expected, r_actual, r_expected))
            end
        end
    end

    test(-1, 0, 0,  -1, 1)
    test(0, 0, 0,  0, 1)
    test(1, 0, 0,  1, 1)
    test(2, 0, 0,  2, 1)

    test(-1, 0.5, 0,  -1, .5)
    test(0, 0.5, 0,  0, .5)
    test(1, 0.5, 0,  1, .5)
    test(2, 0.5, 0,  2, .5)

    test(-1, 1, 0,  -1, 0)
    test(0, 1, 0,  0, 0)
    test(1, 1, 0,  1, 0)
    test(2, 1, 0,  2, 0)

    test(-1, 2, 0,  -1, -1)
    test(0, 2, 0,  0, -1)
    test(1, 2, 0,  1, -1)
    test(2, 2, 0,  2, -1)

    test(0, 0, math.pi/2,  nil, 0)
    test(0, 1, math.pi/2,  nil, 0)
    test(1, 1, math.pi/2,  nil, 0)
    test(1, 2, math.pi/2,  nil, 0)

    test(0, 0, math.pi/4,  1, math.sqrt(2))
    test(1, 0, math.pi/4,  2, math.sqrt(2))
    test(0, 0, -math.pi/4,  -1, math.sqrt(2))
    test(1, 0, -math.pi/4,  0, math.sqrt(2))
end

do  -- Some code to test functionality and illustrate usage
    local profile = profile_factory({{0, 1}, {1, 2}})

    local function test(x, z, psi, d_expected)
        local ray = ray_factory(x, z, psi)

        -- Test the profile:intersect method.
        local d_actual = profile:intersect(ray)

        if math.abs(d_actual - d_expected) > 1.0e-6 then
            send(string.format("intersect failed x %.2f, z %.2f, psi %.2f, d_actual %.2f, d_expected %.2f",
                x, z, psi, d_actual, d_expected))
        end
    end

    test(-20, 0, 0, 1)
    test(-1, 0, 0, 1)
    test(0, 0, 0, 1)
    test(0.5, 0, 0, 1.5)
    test(1, 0, 0, 2)
    test(1.5, 0, 0, 2)
    test(20, 0, 0, 2)

    test(-20, 1, 0, 0)
    test(-1, 1, 0, 0)
    test(0, 1, 0, 0)
    test(0.5, 1, 0, 0.5)
    test(1, 1, 0, 1)
    test(1.5, 1, 0, 1)
    test(20, 1, 0, 1)

    test(-20, 2, 0, -1)
    test(-1, 2, 0, -1)
    test(0, 2, 0, -1)
    test(0.5, 2, 0, -0.5)
    test(1, 2, 0, 0)
    test(1.5, 2, 0, 0)
    test(20, 2, 0, 0)

    test(-20, 0, math.pi/4, math.sqrt(2))
    test(-1, 0, math.pi/4, math.sqrt(2))
    test(-0.99, 0, math.pi/4, 2*math.sqrt(2))
    test(0, 0, math.pi/4, 2*math.sqrt(2))
    test(0.5, 0, math.pi/4, 2*math.sqrt(2))
    test(1, 0, math.pi/4, 2*math.sqrt(2))
    test(1.5, 0, math.pi/4, 2*math.sqrt(2))
    test(20, 0, math.pi/4, 2*math.sqrt(2))

    test(-20, 0, -math.pi/4, math.sqrt(2))
    test(-1, 0, -math.pi/4, math.sqrt(2))
    test(0, 0, -math.pi/4, math.sqrt(2))
    test(0.5, 0, -math.pi/4, math.sqrt(2))
    test(1, 0, -math.pi/4, math.sqrt(2))
    test(1.5, 0, -math.pi/4, 1.25*math.sqrt(2))
    test(2, 0, -math.pi/4, 1.5*math.sqrt(2))
    test(3, 0, -math.pi/4, 2*math.sqrt(2))
    test(20, 0, -math.pi/4, 2*math.sqrt(2))
end


-------------------------------------------------------------------------------

-- NoiseModel

---@class NoiseModelConfig
---@field mean number                   -- Mean of the noise distribution (mean == 0 and std_dev == 0 => no gaussian noise)
---@field std_dev number                -- Standard deviation of the noise distribution
---@field outlier_rate_ops number       -- Rate of outliers outliers/second (0 => no outliers)
---@field outlier_mean number           -- Mean of outliers distribution
---@field outlier_std_dev number        -- Stardard deviation of outliers distribution
---@field delay_s number                -- Delay between measurement request and measurement return (0 => no delay)
---@field callback_interval_ms number   -- Delay between calls of the add noise function

-- This factory creates a function that will take a measurement m and add noise to it
---@param config NoiseModelConfig
local function add_noise_funcfactory(config)

    local function identity_funcfactory(pre_func)
        if pre_func then
            return pre_func
        end
        return function(m) return m end
    end


    local function noise_funcfactory(mean, std_dev, rate_ops, callback_interval_ms, pre_func)

        -- Use the Box-Muller algorithm to generate normally distributed error that is added to the sample.
        local function box_muller_func(m)
            return m + mean + std_dev * math.sqrt(-2 * math.log(math.random())) * math.cos(2 * math.pi * math.random())
        end

        local function gaussian_noise_funcfactory()
            if std_dev == 0.0 and pre_func then
                return function(m) return pre_func(m) + mean end
            end

            if std_dev == 0.0 then
                return function(m) return m + mean end
            end

            if pre_func then
                return function(m) return box_muller_func(pre_func(m)) end
            end

            return box_muller_func
        end

        -- Just simple normally distributed noise
        if rate_ops == 0.0 then
            return gaussian_noise_funcfactory()
        end

        -- Use poisson distribution to generate outliers

        -- Create a function to generate outliers
        local outlier_func = gaussian_noise_funcfactory()

        -- Rate of outlier events in a callback interval
        local rate_opi = rate_ops * callback_interval_ms / 1000.0

        -- Poisson probability of zero events in an interval - Poisson formula is just exp in this case
        local poisson_prob_zero = math.exp(-rate_opi)

        return function(m)
            -- Poisson probability of 1 or more events in this interval is 1-P(0)
            if math.random() > poisson_prob_zero then
                return outlier_func(m)  -- NOTE: pre_func is invoked in outlier_func.
            end
            if pre_func then
                return pre_func(m)
            end
            return m
        end
    end


    local function delay_funcfactory(delay_s, callback_interval_ms, pre_func)

        if delay_s == 0.0 or callback_interval_ms == 0 then
            return identity_funcfactory(pre_func)
        end

        local delay_line = {}
        local delay_count = math.ceil(delay_s / callback_interval_ms * 1000.0)
        if delay_count <= 0 then
            return identity_funcfactory(pre_func)
        end

        local next_idx = -1
        local function delay_func(m)
            if pre_func then
                m = pre_func(m)
            end

            if next_idx < 1 then
                for i = 1, delay_count do
                    delay_line[i] = m
                end
                next_idx = 1
            end

            local m_delay = delay_line[next_idx]
            delay_line[next_idx] = m
            next_idx = next_idx + 1
            if next_idx > #delay_line then
                next_idx = 1
            end
            return m_delay
        end

        return delay_func
    end

    local func

    -- Check for adding gaussian noise to measrement
    if config.mean ~= 0.0 or config.std_dev ~= 0.0 then
        func = noise_funcfactory(config.mean, config.std_dev, 0.0, 0.0)
    end

    -- Check for adding an outlier measurement
    if config.outlier_rate_ops ~= 0 then
        func = noise_funcfactory(config.outlier_mean, config.outlier_std_dev,
            config.outlier_rate_ops, config.callback_interval_ms, func)
    end

    -- Check for delaying the measurement
    if config.delay_s ~= 0.0 then
        func = delay_funcfactory(config.delay_s, config.callback_interval_ms, func)
    end

    if func == nil then
        func = identity_funcfactory()
    end

    return func
end

-------------------------------------------------------------------------------

-- Range Model

---@class RangeModel
---@field get_range function(RangeModel, location_ud): number
---@field sub_z_m number
---@field bottom_z_m number
---@field range_m number
---@field set_origin function(RangeModel, location_ud)
---@field is_origin_valid function(RangeModel)

---@return RangeModel
local function range_model_factory(model_bearing_N_rad, model_depth_m, vertices)

    ---@type Location_ud
    local origin_loc

    local profile = profile_factory(vertices)
  
    ---@param sub_loc Location_ud
    local function get_range(self, sub_loc)

        -- Figure out the depth of the sub in absolute frame
        sub_loc:change_alt_frame(0)
        self.sub_z_m = -sub_loc:alt()/100

        -- If the origin has not been set then do not use the profile.
        -- The seafloor model needs to have an origin. The origin of the model is set to
        -- the location of the sub when it is armed. If the model’s origin hasn’t been set,
        -- the driver returns distances based on a constant depth sea floor.
        if not origin_loc then
            self.bottom_z_m = model_depth_m
            self.range_m = model_depth_m - self.sub_z_m
            return self.range_m
        end

        -- The model origin has been set so use the profile.
        -- N in name means relative to Earth frame, M in name means relative to Sea floor model frame.
        local sub_bearing_N_rad = origin_loc:get_bearing(sub_loc)
        local sub_distance_M_m = origin_loc:get_distance(sub_loc)

        local sub_bearing_M_rad = sub_bearing_N_rad - model_bearing_N_rad
        local sub_northly_M_m = math.cos(sub_bearing_M_rad) * sub_distance_M_m

        -- profile:intersect has an origin at zero so we have to add in the model
        -- depth to get the seafloor depth at this location.
        -- For the sea floor depth:
        -- bottom_z = model_depth_m - profile(0)
        -- Positive z is down, positive profile is up
        local bottom_ray = ray_factory(sub_northly_M_m, 0, 0)
        self.bottom_z_m = model_depth_m - profile:intersect(bottom_ray)

        -- For the sub range measurement:
        -- model_range = model_depth_m - sub_z
        self.range_m = self.bottom_z_m - self.sub_z_m
        return self.range_m
    end

    return {
        get_range = get_range,
        sub_z_m = 0,
        bottom_z_m = model_depth_m,
        range_m = model_depth_m,
        set_origin = function(origin) origin_loc = origin end,
        is_origin_valid = function() return origin_loc ~= nil end,
    }
end

-------------------------------------------------------------------------------

-- Range Finder Driver

-- The range finder backend is initialized in the update_init function.
---@type AP_RangeFinder_Backend_ud
local rngfnd_backend

-- The range_model and add_noise_func are initialized when vehicle is armed
---@type RangeModel
local range_model

local measurement_noise_func
local signal_quality_func



local function range_finder_driver(sub_loc)
    local rf_state = RangeFinder_State()

    -- The full state udata must be initialized.
    rf_state:last_reading(millis():toint())
    rf_state:voltage(0)

    -- If no location, then return no data
    if not sub_loc then
        rf_state:status(RNGFND_STATUS_NO_DATA)
        rf_state:range_valid_count(0)
        rf_state:distance(0)
        rf_state:signal_quality(SIGNAL_QUALITY_MIN)
        rngfnd_backend:handle_script_msg(rf_state) -- state as arg
        return
    end

    -- Generate a simulated range measurement
    local true_range_m = range_model:get_range(sub_loc)
    local range_m = measurement_noise_func(true_range_m)
    local signal_quality = signal_quality_func(range_m, true_range_m)

    -- Return this measurement to the range finder backend
    rf_state:status(RNGFND_STATUS_GOOD)
    rf_state:range_valid_count(10)
    rf_state:distance(range_m)
    rf_state:signal_quality(signal_quality)
    rngfnd_backend:handle_script_msg(rf_state) -- state as arg

    -- Log this data
    if enable_logger_write then
        logger:write('RNFN', 'sub_z,bottom_z,true_range,range,quality', 'fffff', 'mmmmm', '-----',
            range_model.sub_z_m, range_model.bottom_z_m, true_range_m, range_m, signal_quality)
        -- This data can be viewed in mavexplorer with the following command:
        -- graph RNFN.sub_z RNFN.bottom_z RNFN.true_range RNFN.range
    end
    if enable_gcs_send_data then
        send("RNGFND", string.format("true range %.2f, range %.2f, sub_z %.2f, bottom_z %.2f",
            true_range_m, range_m, range_model.sub_z_m, range_model.bottom_z_m))
    end
    if enable_gcs_send_range then
        send_quick("#TR#", string.format("%7.2f", true_range_m))
    end
end

-------------------------------------------------------------------------------

local function initialize_model()

    -- query SCR_USERx for parameters
    -- SCR_USER1 is a code for which config bundle to use
    local config_index = param:get('SCR_USER1')
    if not config_index then
        config_index = 1
    end
    -- SCR_USER2 is the bottom depth
    local bottom_depth_m = param:get('SCR_USER2')
    if not bottom_depth_m or bottom_depth_m < 1 then
        bottom_depth_m = 50
    end
    -- SCR_USER3 contains bits for logging
    local logging_bits = param:get('SCR_USER3')
    if not logging_bits then
        logging_bits = 1
    end


    -- Set logging flags from logging_bits
    local lb_str = tostring(math.floor(logging_bits))
    enable_logger_write = string.sub(lb_str, -1, -1) == '1'
    enable_gcs_send_data = string.sub(lb_str, -2, -2) == '1'
    enable_gcs_send_range = string.sub(lb_str, -3, -3) == '1'

    local config_simple_ridge = {{5, 0}, {30, 10}, {40, 10}, {50, 0}}
    local config_ridge_plateau = {{5, 0}, {30, 10}, {40, 10}, {50, 0}, {70, 0}, {90, -10}}

    local config_range_model = {
        model_bearing_N_rad = math.pi,
        vertices = config_simple_ridge,
    }

    local config_measurement_noise = {
        mean = 0.0,
        std_dev = 0.0,
        outlier_rate_ops = 0.0,
        outlier_mean = 0.0,
        outlier_std_dev = 0.0,
        outlier_good_sq_limit = 0.0,
        delay_s = 0.0,
        callback_interval_ms = UPDATE_PERIOD_MS,
    }

    -- config_index = 1 is default with no noise
    -- config_index = 2 has a little noise
    if config_index == 2 then
        config_range_model.vertices = config_ridge_plateau
        config_measurement_noise.std_dev = .1
        config_measurement_noise.outlier_rate_ops = .2
        config_measurement_noise.outlier_mean = 5
        config_measurement_noise.outlier_std_dev = 2
        config_measurement_noise.outlier_good_sq_limit = 1
        config_measurement_noise.delay_s = 0.00
    end

    range_model = range_model_factory(config_range_model.model_bearing_N_rad,
    bottom_depth_m, config_range_model.vertices)
    measurement_noise_func = add_noise_funcfactory(config_measurement_noise)


    -- A rapid series of large outliers can cause test failure
    -- Mark large outliers with a poor signal quality to minimize flakiness
    -- This also exercises signal_quality handling
    signal_quality_func = function(m, true_m)
        if math.abs(m - true_m) > config_measurement_noise.outlier_good_sq_limit then
            return 50
        else
            return SIGNAL_QUALITY_MAX
        end
    end

end

-------------------------------------------------------------------------------

-- update functions


-- SCR_USER4 is the rangefinder target in meters
local rf_target_cm = param:get('SCR_USER4') * 100
if not rf_target_cm or rf_target_cm < 50 or rf_target_cm > 5000 then
    rf_target_cm = 1500
end

local function update_run()

    local loc_c = ahrs:get_location()

    -- Check if we have to set or clear the origin
    if arming:is_armed() ~= range_model.is_origin_valid() then
        if arming:is_armed() then
            if loc_c then
                send("Starting to use the sea floor model for range data.")
                range_model.set_origin(loc_c)
            end
        else
            send("Stopping sea floor model range data. Starting to use flat sea floor for range data.")
            range_model.set_origin(nil)
        end
    end

    -- Check if we have to set the rangefinder target
    if vehicle:get_mode() == MODE_SURFTRAK and sub:get_rangefinder_target_cm() ~= rf_target_cm then
        gcs:send_text(6, string.format("Set rangefinder target to %g cm", rf_target_cm))
        sub:set_rangefinder_target_cm(rf_target_cm)
    end

    -- Update with range finder driver
    range_finder_driver(loc_c)

    return update_run, UPDATE_PERIOD_MS
end

local function update_init()
    if Parameter('RNGFND1_TYPE'):get() ~= RNGFND_TYPE_LUA then
        return fatal_error("LUA range finder driver not enabled")
    end
    if rangefinder:num_sensors() < 1 then
        return fatal_error("LUA range finder driver not connected")
    end
    rngfnd_backend = rangefinder:get_backend(0)
    if not rngfnd_backend then
        return fatal_error("Range Finder 1 does not exist")
    end
    if (rngfnd_backend:type() ~= RNGFND_TYPE_LUA) then
        return fatal_error("Range Finder 1 is not a LUA driver")
    end

    initialize_model()

    if not range_model or not measurement_noise_func or not signal_quality_func then
        return fatal_error("Could not initialize model")
     end

    return update_run, 0
end

send(string.format("Loaded %s", SCRIPT_NAME))

return update_init, 0



================================================
File: examples/temperature_sensor.lua
================================================
--[[
   simple example of reading a temperature sensor
--]]

local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

--[[
   main update function, called at 1Hz
--]]
function update()
   local temperature_C = temperature_sensor:get_temperature(0)
   gcs:send_text(MAV_SEVERITY.INFO, string.format("Temperature: %f", temperature_C))
   return update, 1000
end

-- start running update loop
return update, 1000




================================================
File: examples/terrain_warning.lua
================================================
-- height above terrain warning script

-- min altitude above terrain, script will warn if lower than this
local terrain_min_alt = 20

-- warning is only enabled further than this distance from home
local home_dist_enable = 25

-- must have climbed at least this distance above terrain since arming to enable warning
local height_enable = 10

-- warning repeat time in ms
local warn_ms = 10000


local height_threshold_passed = false
function update()

  if not arming:is_armed() then
    -- not armed, nothing to do, reset height threshold
    height_threshold_passed = false
    return update, 1000
  end

  -- get the height above terrain, allowing extrapolation
  -- this used the terrain database only, not considering rangefinders
  local terrain_height = terrain:height_above_terrain(true)
  if not terrain_height then
    -- could not get a valid terrain alt
    return update, 1000
  end

  if (not height_threshold_passed) and (terrain_height < height_enable) then
    -- not climbed far enough to enable, nothing to do
    return update, 1000
  end
  height_threshold_passed = true

  local home_dist = ahrs:get_relative_position_NED_home()
  if home_dist then
    -- only check home dist if we have a valid home
    -- do not consider altitude above home in radius calc
    home_dist:z(0)
    if home_dist:length() < home_dist_enable then
      -- to close to home
      return update, 1000
    end
  end

  if terrain_height < terrain_min_alt then
    -- send message at severity level 2 (MAV_SEVERITY_CRITICAL), this will appear on the MP HUD and be read out if speech is enabled
    gcs:send_text(2, string.format("Terrain Warning: %0.1f meters",terrain_height))
    return update, warn_ms
  end

  return update, 1000
end

return update, 10000



================================================
File: examples/test_get_target_location.lua
================================================
-- test get_target_location functions for copter
-- https://discuss.ardupilot.org/t/vehicle-get-target-location-in-lua-copter/108901

function update()
    local next_WP = vehicle:get_target_location()
    if not next_WP then
        -- not in a flight mode with a target location
        gcs:send_text(0,"not in a flight mode with target loc")
    else
        gcs:send_text(0,"target loc : " .. next_WP:lat() .. " ; " .. next_WP:lng())
    end

    return update, 10000
end

return update()



================================================
File: examples/test_load.lua
================================================
--[[
 test the load function for loading new code from strings
--]]
---@diagnostic disable: undefined-global

gcs:send_text(0,"Testing load() method")

-- a function written as a string. This could come from a file
-- or any other source (eg. mavlink)
-- Note that the [[ xxx ]] syntax is just a multi-line string

local func_str = [[
function TestFunc(x,y)
  return math.sin(x) + math.cos(y)
end
]]

function test_load()
   -- load the code into the global environment
   local f,errloc,err = load(func_str,"TestFunc", "t", _ENV)
   if not f then
      gcs:send_text(0,string.format("Error %s: %s", errloc, err))
      return
   end
   -- run the code within a protected call to catch any errors
   local success, err2 = pcall(f)
   if not success then
      gcs:send_text(0, string.format("Failed to load TestFunc: %s", err2))
      return
   end

   -- we now have the new function
   gcs:send_text(0, string.format("TestFunc(3,4) -> %f", TestFunc(3,4)))
end

test_load()



================================================
File: examples/test_script_button.lua
================================================
-- Test ArduSub script buttons

-- This will map the script buttons to the _shifted_ XBox controller buttons A, B, Z, Y:
-- param set BTN0_SFUNCTION  108
-- param set BTN1_SFUNCTION  109
-- param set BTN2_SFUNCTION  110
-- param set BTN3_SFUNCTION  111

function update()
  -- called every 5s

  -- show current status of the buttons
  local is_pressed = {}
  for i = 1, 4 do
    is_pressed[i] = sub:is_button_pressed(i)
  end

  gcs:send_text(6, string.format("is script button pressed? %s, %s, %s, %s",
      tostring(is_pressed[1]), tostring(is_pressed[2]), tostring(is_pressed[3]), tostring(is_pressed[4])))

  -- count how many times the buttons were pressed in the last five seconds
  local count = {}
  for i = 1, 4 do
    count[i] = sub:get_and_clear_button_count(i)
  end

  gcs:send_text(6, string.format("script button counts: %d, %d, %d, %d",
      count[1], count[2], count[3], count[4]))

  return update, 5000
end

return update(), 5000



================================================
File: examples/test_update_target_location.lua
================================================
-- test update_target_location functions for copter

local current_target = nil
local cur_loc = nil
local new_target= nil

function update()

    if vehicle:get_mode() ~= 4 then
        gcs:send_text(0, "not in Guided")
        return update, 1000
    end

    current_target = vehicle:get_target_location()
    if not current_target then
        return update, 1000
    end

    gcs:send_text(6, string.format("Current target %d %d %d frame %d", current_target:lat(), current_target:lng(), current_target:alt(), current_target:get_alt_frame()))

    cur_loc = ahrs:get_position()
    if not cur_loc then
        gcs:send_text(0, "current position is not good")
        return update, 1000
    end

    gcs:send_text(6, string.format("alt is %f", cur_loc:alt()*0.01))
    if cur_loc:alt()*0.01 < 650 then
        gcs:send_text(0, "too low")
        return update, 1000
    end

    -- just add some offset to current location
    new_target = cur_loc:copy()
    new_target:lat(cur_loc:lat() + 1000)
    new_target:lng(cur_loc:lng() + 1000)
    new_target:alt(cur_loc:alt() + 1000)

    gcs:send_text(6, string.format("New target %d %d %d frame %d", new_target:lat(), new_target:lng(), new_target:alt(), new_target:get_alt_frame()))

    vehicle:update_target_location(current_target, new_target)

    return update, 2000
end

return update()



================================================
File: examples/trisonica-mini.lua
================================================
-- Script decodes and logs wind sensor data for Trisonica LI-550 mini
-- https://www.licor.com/products/trisonica/LI-550-mini

-- Parameters:
-- SCR_ENABLE 1
-- SERIAL5_PROTOCOL 28

-- In SITL, you can enable serial ports to connect to the real device.
-- https://ardupilot.org/dev/docs/learning-ardupilot-uarts-and-the-console.html#the-8-uarts
-- ./Tools/autotest/sim_vehicle.py -v Plane --console --map -A "--serial5=uart:/dev/ttyUSB0" -D

-- Remember to change baud to 230k in the sensor setup and enable the fields you want.
-- Also, enable 10Hz output instead of the default 5Hz.

-- Example data string (excluding quotes, excluding the carriage return line feed ending)
-- "S  00.08 S2  00.07 D  245 DV  033 U  00.06 V  00.03 W  00.05 T  55889220.00 C  346.68 H  17.92 DP  03.68 P -099.70 AD  0.0000000 AX  -2913 AY  -3408 AZ -16600 PI  011.4 RO  009.8 MX   -619 MY    845 MZ    782 MD  337 TD  337"

-- Log severities
local MAV_SEVERITY = {EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6, DEBUG=7}

-- find the serial first (0) scripting serial port instance
local port = serial:find_serial(0)

if not port then
    gcs:send_text(MAV_SEVERITY.EMERGENCY, "no trisonica scripting port")
    return
end

-- begin the serial port
port:begin(230400)
port:set_flow_control(0)

local function parse_wind_data(buf)
    -- Split the string up into key and values splitting on the default space delimiter.

    local parsed_values = {}

    -- Match any key-value pair where key is a string and value is a number
    for key, value in buf:gmatch("(%a+)%s*([%-%.%d]+)") do
        parsed_values[key] = tonumber(value) -- Store key-value pair in the table
    end

    return parsed_values
end

local tag_ids = nil
local tag_id_str = ""
local value_format = ""
local last_keys = nil

local function log_wind_data(parsed)
    -- Given a table of parsed data, log it.

    -- Collect keys from parsed and store as a list
    local current_keys = {}
    for k in pairs(parsed) do
        table.insert(current_keys, k)
    end
    table.sort(current_keys)

    -- First packet, we must set last_keys.
    if not last_keys then
        last_keys = current_keys
        return
    end

    -- Bail early if the first packet parsed only contained some of the keys. 
    -- After the 2nd packet, it will stabilize.
    if #current_keys ~= #last_keys then
        last_keys = current_keys
        return
    end

    for i = 1, #current_keys do
        if current_keys[i] ~= last_keys[i] then
            last_keys = current_keys
            return
        end
    end

    -- Keys are now stable, so store them as tag_ids
    if not tag_ids then
        tag_ids = current_keys
        tag_id_str = table.concat(tag_ids, ',')
        value_format = string.rep('f', #tag_ids)
        gcs:send_text(MAV_SEVERITY.INFO, "Using tag_ids: " .. tag_id_str)
    end
    

    -- Build ordered values from tag_ids
    local values = {}
    for _, tag_id in ipairs(tag_ids) do
        table.insert(values, parsed[tag_id] or 0)
    end

    assert(#tag_ids < 15, "#tag_ids=" .. #tag_ids)
    logger:write('W3D', tag_id_str, value_format, table.unpack(values))
end

local buffer = ""
-- the main update function that is used to read in data from serial port
local function update()


    local n_bytes = port:available()
    while n_bytes > 0 do
        local byte = port:read()

        if byte > -1 then
            local c = string.char(byte)
            buffer = buffer .. c

            --ignore the \n because \r is sufficient to end parsing.
            if c == "\r" then
                local result = parse_wind_data(buffer)
                log_wind_data(result)
                buffer = ""
            end
        end
        n_bytes = n_bytes - 1
    end
    return update, 100
end

gcs:send_text(MAV_SEVERITY.INFO, "trisonica-mini.lua running...")

return update, 100



================================================
File: examples/trisonicia-mini.md
================================================
# Trisonica LI-550 Mini Wind Sensor Logger

This Lua script reads and logs wind sensor data from the **Trisonica LI-550 Mini** ultrasonic wind sensor connected via serial. It decodes ASCII-formatted key-value pairs and logs the data using dynamic field tags on the `W3D` logging stream.

For sensor details, visit:  
🔗 https://www.licor.com/products/trisonica/LI-550-mini

## Features

- Parses and logs ASCII data strings from the Trisonica LI-550 Mini in BIN logs 
- Logs fields using a dynamically generated tag list from the **first packet**
- Ignores extraneous fields in subsequent messages not present in the first
- Compatible with **ArduPilot scripting serial port** interface
- Supports high-speed 230400 baud data stream
- Uses BIN log name `W3D` for all data

## Parameters

Set the following parameters:

| Parameter       | Value   | Description                    |
|----------------|----------|--------------------------------|
| `SCR_ENABLE`   | `1`      | Enable Lua scripting           |
| `SERIALx_PROTOCOL` | `28` | Scripting protocol for SERIALx |


> Replace `SERIALx` with the appropriate serial port used on your hardware.

## Sensor configuration

Use Trisonica's [CLI](logger:write) to configure the unit. On Linux, you can use `screen` to interract with the device:
```bash
screen /dev/ttyUSB0 230400
```
You should see data displayed. Enter configuration mode with `Ctrl+C`.
You should now see data streaming stop and a terminal prompt `>`.

Set the Trisonica sensor baudrate to **230400** in its configuration software using the `baudrate` command like so:
```bash
baudrate 230400
```

You must also **enable all fields you want to log**. A recommended set is as follows. See the `Enabled` column.

```bash
display
```

```
-----------------------------------------------------------------------------------------
|     Name |            Description |  Tagged |      Tag | Decimals | Enabled |  Units  |
-----------------------------------------------------------------------------------------
|    IDTag |                 ID Tag |   Yes   |          |          |         |         |
|        S |          Wind Speed 3D |   Yes   |        S |     2    |         | m/s     |
|      S2D |          Wind Speed 2D |   Yes   |       S2 |     2    |         | m/s     |
|        D |   Horiz Wind Direction |   Yes   |        D |     0    |         | Degrees |
|       DV |    Vert Wind Direction |   Yes   |       DV |     0    |         | Degrees |
|        U |               U Vector |   Yes   |        U |     2    |   Yes   | m/s     |
|        V |               V Vector |   Yes   |        V |     2    |   Yes   | m/s     |
|        W |               W Vector |   Yes   |        W |     2    |   Yes   | m/s     |
|        T |            Temperature |   Yes   |        T |     2    |   Yes   | C       |
|       Cs |         Speed of Sound |   Yes   |        C |     2    |         | m/s     |
|   RHTemp |         RH Temp Sensor |   Yes   |     RHST |     2    |         | C       |
|       RH |     RH Humidity Sensor |   Yes   |     RHSH |     2    |         | %       |
|        H |               Humidity |   Yes   |        H |     2    |   Yes   | %       |
|       DP |               DewPoint |   Yes   |       DP |     2    |         | C       |
|    PTemp |   Pressure Temp Sensor |   Yes   |      PST |     2    |         | C       |
|        P |        Pressure Sensor |   Yes   |        P |          |   Yes   | hPa     |
|  Density |            Air Density |   Yes   |       AD |          |   Yes   | kg/m^3  |
|   LevelX |                Level X |   Yes   |       AX |          |   Yes   |         |
|   LevelY |                Level Y |   Yes   |       AY |          |   Yes   |         |
|   LevelZ |                Level Z |   Yes   |       AZ |          |   Yes   |         |
|    Pitch |                  Pitch |   Yes   |       PI |     1    |   Yes   | Degrees |
|     Roll |                   Roll |   Yes   |       RO |     1    |   Yes   | Degrees |
|    CTemp |           Compass Temp |   Yes   |       MT |     1    |         | C       |
|     MagX |              Compass X |   Yes   |       MX |          |         |         |
|     MagY |              Compass Y |   Yes   |       MY |          |         |         |
|     MagZ |              Compass Z |   Yes   |       MZ |          |         |         |
|  Heading |        Compass Heading |   Yes   |       MD |     0    |   Yes   | Degrees |
| TrueHead |           True Heading |   Yes   |       TD |     0    |   Yes   | Degrees |
-----------------------------------------------------------------------------------------
```

You can enable tags like so:
```bash
show T
```

Or disable them from the data stream like so:
```bash
hide T
```

You must not enable more than 12 outputs due to limitations in this script and ArduPilot's dataflash logger.

Finally, increase the output rate to the maximum of **10 Hz**.
```bash
outputrate 10
```

Once configuration is complete, exit screen with
```bash
ctr+A k y
```

If you take longer than a minute to configure, the unit will re-enter streaming mode.

## SITL Testing

You can connect a real serial device to SITL using a passthrough UART setup.
For example, using SERIAL5 connected to ttyUSB0.

```bash
./Tools/autotest/sim_vehicle.py -v Plane --console --map -A "--serial5=uart:/dev/ttyUSB0" -D
```

Then view the `W3D` entries in your favorite dataflash (BIN) log analyzer.
For  MAVExplorer, try graphing wind speeds against airspeed.

```bash
graph W3D.U W3D.W W3D.V ARSP.Airspeed
```

## Future Improvements

* Use the wind data as input to the EKF for wind speed
* Use the Trisonica API to have ArduPilot configure the correct data outputs and rates



================================================
File: examples/wp_test.lua
================================================
-- Example script for accessing waypoint info

local wp_index
local wp_distance
local wp_bearing
local wp_error


function on_wp_change(index, distance)
    wp_index = index
    wp_distance = distance
    wp_distance_max = distance;
    gcs:send_text(0, string.format("NEW WP: idx=%d, dist=%.01fm", index, distance))
end

function refresh_wp_info()
    local index = mission:get_current_nav_index()
    local distance = vehicle:get_wp_distance_m()
    local bearing = vehicle:get_wp_bearing_deg()
    local error = vehicle:get_wp_crosstrack_error_m()

    if index ~= nil and index ~= wp_index and distance ~= nil then
        on_wp_change(index, distance)
    end 

    if index ~= nil and distance ~= nil and bearing ~= nil and error ~= nil then
        wp_index = index
        wp_bearing = bearing
        wp_distance = distance
        wp_error = error
        wp_distance_max = math.max(wp_distance_max, wp_distance)
    end
end

function log_wp_info(index, distance, bearing, error)
    if index ~= nil and distance ~= nil and bearing ~= nil and error ~= nil then
        local perc = wp_distance_max > 0 and 100-(100*(distance/wp_distance_max)) or 0
        gcs:send_text(0, string.format("WP: %d, %.01fm (%.01f%%), b: %d°, xe:%.01fm", index, distance, perc, math.floor(bearing+0.5), error))
    end
end

function update()
    refresh_wp_info()
    log_wp_info(wp_index, wp_distance, wp_bearing, wp_error)
    return update, 1000 -- 1Hz
end
  
return update(), 1000 -- start with a 1 sec delay


================================================
File: examples/wrap32_test.lua
================================================
--[[
a script to test handling of 32 bit micros timer wrap with BDShot

- Requires bdshot output on SERVO9 to 12
- Requires a wire from one of SERVO9 to 12 to SERVO14 (AUX6, pin 55)
- needs SERVO13_FUNCTION and SERVO14_FUNCTION set to -1
- needs firmware with change for time to start 30s before 32 bit usec wrap and to allow lua reboot
- BRD_SAFETY_DFLT must be 0
- BDShot must be enabled on outputs 9-12
--]]
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: cast-local-type

local PARAM_TABLE_KEY = 138
local PARAM_TABLE_PREFIX = "WRAP32_"

-- setup quicktune specific parameters
assert(param:add_table(PARAM_TABLE_KEY, PARAM_TABLE_PREFIX, 10), 'could not add param table')

-- bind a parameter to a variable
function bind_param(name)
   local p = Parameter()
   assert(p:init(name), string.format('could not find %s parameter', name))
   return p
end

-- add a parameter and bind it to a variable
function bind_add_param(name, idx, default_value)
   assert(param:add_param(PARAM_TABLE_KEY, idx, name, default_value), string.format('could not add param %s', name))
   return bind_param(PARAM_TABLE_PREFIX .. name)
end

local WRAP32_COUNT = bind_add_param('COUNT', 1, 0)
local WRAP32_FAIL = bind_add_param('FAIL', 2, 0)
local WRAP32_ERR = bind_add_param('ERR', 3, 0)
local WRAP32_PIN = bind_add_param('PIN', 4, 55)
local WRAP32_PASS = bind_add_param('PASS', 5, 0)

local wrap_time_ms = uint32_t(0x418937)

--[[
   return number of seconds until we wrap. This will be negative after the wrap
--]]
function time_to_wrap()
   local tnow = millis()
   if tnow < wrap_time_ms then
      return (wrap_time_ms - tnow):tofloat()*0.001
   else
      return -(tnow - wrap_time_ms):tofloat()*0.001
   end
end

function count_changes(wait_ms)
   local start_ms = millis()
   local last_pin_value = 0
   local change_count = 0
   local pin = math.floor(WRAP32_PIN:get())
   local pin_check = pin-1
   gpio:pinMode(pin,0)
   gpio:pinMode(pin_check,1)
   gpio:write(pin-1, 0)
   while millis() - start_ms < wait_ms do
      gpio:toggle(pin_check)
      local v = gpio:read(pin)
      if v ~= last_pin_value then
         change_count = change_count + 1
      end
      last_pin_value = v
   end
   return change_count
end

local done_pre_wrap = false
local done_post_wrap = false

function check_failure()
   local changes = count_changes(100)
   local to_wrap = time_to_wrap()
   gcs:send_text(0,string.format("changes: %u ttw: %.1f", changes, to_wrap))
   if not done_pre_wrap and to_wrap > 5 and to_wrap < 10 then
      -- pre-wrap, should have dshot
      if changes < 4 then
         WRAP32_ERR:set_and_save(WRAP32_ERR:get()+1)
      end
      done_pre_wrap = true
   end
   if not done_post_wrap and to_wrap < -2 and to_wrap > -4 then
      -- post-wrap, should have dshot
      if changes < 4 then
         WRAP32_FAIL:set_and_save(WRAP32_FAIL:get()+1)
      else
         WRAP32_PASS:set_and_save(WRAP32_PASS:get()+1)
      end
      done_post_wrap = true
   end
end

function update()
   check_failure()
   gcs:send_text(0,string.format("Boots:%.0f fail:%.0f err:%.0f pass:%.0f",
                                 WRAP32_COUNT:get(),
                                 WRAP32_FAIL:get(),
                                 WRAP32_ERR:get(),
                                 WRAP32_PASS:get()))
   if done_post_wrap and time_to_wrap() < -6 then
      gcs:send_text(0,string.format("REBOOTING"))
      vehicle:reboot(false)
   end
   return update, 1000
end

-- incremement on boot
WRAP32_COUNT:set_and_save(WRAP32_COUNT:get()+1)

return update()



================================================
File: generator/description/bindings.desc
================================================
-- Location stuff (this is a commented line)

include AP_Common/Location.h

userdata Location field lat int32_t read write -900000000 900000000
userdata Location field lng int32_t read write -1800000000 1800000000
userdata Location field alt int32_t read write (-LOCATION_ALT_MAX_M*100+1) (LOCATION_ALT_MAX_M*100-1)
userdata Location field relative_alt boolean read write
userdata Location field terrain_alt boolean read write
userdata Location field origin_alt boolean read write
userdata Location field loiter_xtrack boolean read write

userdata Location method get_distance float Location
userdata Location method offset void float'skip_check float'skip_check
userdata Location method offset_bearing void float'skip_check float'skip_check
userdata Location method offset_bearing_and_pitch void float'skip_check float'skip_check float'skip_check
userdata Location method get_vector_from_origin_NEU_m boolean Vector3f'Null
userdata Location method get_vector_from_origin_NEU_m depends AP_AHRS_ENABLED
userdata Location method get_vector_from_origin_NEU_cm boolean Vector3f'Null
userdata Location method get_vector_from_origin_NEU_cm depends AP_AHRS_ENABLED
userdata Location method get_vector_from_origin_NEU boolean Vector3f'Null
userdata Location method get_vector_from_origin_NEU depends AP_AHRS_ENABLED
userdata Location method get_vector_from_origin_NEU deprecate Use get_vector_from_origin_NEU_cm or get_vector_from_origin_NEU_m
userdata Location method get_bearing float Location
userdata Location method get_distance_NED Vector3f Location
userdata Location method get_distance_NE Vector2f Location
userdata Location method get_alt_frame uint8_t
userdata Location method change_alt_frame boolean Location::AltFrame'enum Location::AltFrame::ABSOLUTE Location::AltFrame::ABOVE_TERRAIN
userdata Location method copy Location

include AP_AHRS/AP_AHRS.h

singleton AP_AHRS rename ahrs
singleton AP_AHRS depends AP_AHRS_ENABLED
singleton AP_AHRS semaphore
singleton AP_AHRS method get_roll_rad float
singleton AP_AHRS method get_roll float
singleton AP_AHRS method get_roll deprecate Use get_roll_rad
singleton AP_AHRS method get_pitch_rad float
singleton AP_AHRS method get_pitch float
singleton AP_AHRS method get_pitch deprecate Use get_pitch_rad
singleton AP_AHRS method get_yaw_rad float
singleton AP_AHRS method get_yaw float
singleton AP_AHRS method get_yaw deprecate Use get_yaw_rad
singleton AP_AHRS method get_location boolean Location'Null
singleton AP_AHRS method get_location alias get_position
singleton AP_AHRS method get_home Location
singleton AP_AHRS method get_gyro Vector3f
singleton AP_AHRS method get_accel Vector3f
singleton AP_AHRS method get_hagl boolean float'Null
singleton AP_AHRS method wind_estimate Vector3f
singleton AP_AHRS method wind_alignment float'skip_check float'skip_check
singleton AP_AHRS method head_wind float'skip_check
singleton AP_AHRS method groundspeed_vector Vector2f
singleton AP_AHRS method get_velocity_NED boolean Vector3f'Null
singleton AP_AHRS method get_relative_position_NED_home boolean Vector3f'Null
singleton AP_AHRS method get_relative_position_NED_origin_float boolean Vector3f'Null
singleton AP_AHRS method get_relative_position_NED_origin_float rename get_relative_position_NED_origin

singleton AP_AHRS method get_relative_position_D_home void float'Ref
singleton AP_AHRS method home_is_set boolean
singleton AP_AHRS method healthy boolean
singleton AP_AHRS method airspeed_estimate boolean float'Null
singleton AP_AHRS method get_vibration Vector3f
singleton AP_AHRS method earth_to_body Vector3f Vector3f
singleton AP_AHRS method body_to_earth Vector3f Vector3f
singleton AP_AHRS method get_EAS2TAS float
singleton AP_AHRS method get_variances boolean float'Null float'Null float'Null Vector3f'Null float'Null
singleton AP_AHRS method set_posvelyaw_source_set void AP_NavEKF_Source::SourceSetSelection'enum AP_NavEKF_Source::SourceSetSelection::PRIMARY AP_NavEKF_Source::SourceSetSelection::TERTIARY
singleton AP_AHRS method get_vel_innovations_and_variances_for_source boolean uint8_t 3 6 Vector3f'Null Vector3f'Null
singleton AP_AHRS method set_home boolean Location
singleton AP_AHRS method get_origin boolean Location'Null
singleton AP_AHRS method set_origin boolean Location
singleton AP_AHRS method initialised boolean
singleton AP_AHRS method get_posvelyaw_source_set uint8_t
singleton AP_AHRS method get_quaternion boolean Quaternion'Null
singleton AP_AHRS method handle_external_position_estimate boolean Location float'skip_check uint32_t'skip_check
singleton AP_AHRS method handle_external_position_estimate depends AP_AHRS_EXTERNAL_ENABLED

include AP_Arming/AP_Arming.h

singleton AP_Arming rename arming
singleton AP_Arming depends AP_ARMING_ENABLED
singleton AP_Arming method disarm boolean AP_Arming::Method::SCRIPTING'literal
singleton AP_Arming method is_armed boolean
singleton AP_Arming method pre_arm_checks boolean false'literal
singleton AP_Arming method arm boolean AP_Arming::Method::SCRIPTING'literal
singleton AP_Arming method arm_force boolean AP_Arming::Method::SCRIPTING'literal
singleton AP_Arming method get_aux_auth_id boolean uint8_t'Null
singleton AP_Arming method set_aux_auth_passed void uint8_t'skip_check
singleton AP_Arming method set_aux_auth_failed void uint8_t'skip_check string

include AP_BattMonitor/AP_BattMonitor.h

include AP_BattMonitor/AP_BattMonitor_Scripting.h
userdata BattMonitorScript_State depends AP_BATTERY_SCRIPTING_ENABLED
userdata BattMonitorScript_State field healthy boolean write
userdata BattMonitorScript_State field voltage float'skip_check write
userdata BattMonitorScript_State field cell_count uint8_t'skip_check write
userdata BattMonitorScript_State field capacity_remaining_pct uint8_t'skip_check write
userdata BattMonitorScript_State field cell_voltages'array int(ARRAY_SIZE(ud->cell_voltages)) uint16_t'skip_check write
userdata BattMonitorScript_State field cycle_count uint16_t'skip_check write
userdata BattMonitorScript_State field current_amps float'skip_check write
userdata BattMonitorScript_State field consumed_mah float'skip_check write
userdata BattMonitorScript_State field consumed_wh float'skip_check write
userdata BattMonitorScript_State field temperature float'skip_check write
userdata BattMonitorScript_State field state_of_health_pct uint8_t'skip_check write

singleton AP_BattMonitor rename battery
singleton AP_BattMonitor depends AP_BATTERY_ENABLED
singleton AP_BattMonitor method num_instances uint8_t
singleton AP_BattMonitor method healthy boolean uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method voltage float uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method get_resistance float uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method voltage_resting_estimate float uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method current_amps boolean float'Null uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method consumed_mah boolean float'Null uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method consumed_wh boolean float'Null uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method capacity_remaining_pct boolean uint8_t'Null uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method pack_capacity_mah int32_t uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method has_failsafed boolean
singleton AP_BattMonitor method overpower_detected boolean uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method get_temperature boolean float'Null uint8_t 0 ud->num_instances()
singleton AP_BattMonitor method get_cycle_count boolean uint8_t 0 ud->num_instances() uint16_t'Null
singleton AP_BattMonitor method reset_remaining boolean uint8_t 0 ud->num_instances() float 0 100
singleton AP_BattMonitor method get_cell_voltage boolean uint8_t'skip_check uint8_t'skip_check float'Null
singleton AP_BattMonitor method handle_scripting boolean uint8_t'skip_check BattMonitorScript_State
singleton AP_BattMonitor method handle_scripting depends AP_BATTERY_SCRIPTING_ENABLED

include AP_GPS/AP_GPS.h

singleton AP_GPS depends AP_GPS_ENABLED
singleton AP_GPS rename gps
singleton AP_GPS enum NO_GPS NO_FIX GPS_OK_FIX_2D GPS_OK_FIX_3D GPS_OK_FIX_3D_DGPS GPS_OK_FIX_3D_RTK_FLOAT GPS_OK_FIX_3D_RTK_FIXED
singleton AP_GPS method num_sensors uint8_t
singleton AP_GPS method primary_sensor uint8_t
singleton AP_GPS method status uint8_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method location Location uint8_t 0 ud->num_sensors()
singleton AP_GPS method speed_accuracy boolean uint8_t 0 ud->num_sensors() float'Null
singleton AP_GPS method horizontal_accuracy boolean uint8_t 0 ud->num_sensors() float'Null
singleton AP_GPS method vertical_accuracy boolean uint8_t 0 ud->num_sensors() float'Null
singleton AP_GPS method velocity Vector3f uint8_t 0 ud->num_sensors()
singleton AP_GPS method ground_speed float uint8_t 0 ud->num_sensors()
singleton AP_GPS method ground_course float uint8_t 0 ud->num_sensors()
singleton AP_GPS method num_sats uint8_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method time_week uint16_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method time_week_ms uint32_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method get_hdop uint16_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method get_vdop uint16_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method last_fix_time_ms uint32_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method last_message_time_ms uint32_t uint8_t 0 ud->num_sensors()
singleton AP_GPS method have_vertical_velocity boolean uint8_t 0 ud->num_sensors()
singleton AP_GPS method get_antenna_offset Vector3f uint8_t 0 ud->num_sensors()
singleton AP_GPS method first_unconfigured_gps boolean uint8_t'Null
singleton AP_GPS method gps_yaw_deg boolean uint8_t 0 ud->num_sensors() float'Null float'Null uint32_t'Null
singleton AP_GPS method time_epoch_usec uint64_t uint8_t 0 ud->num_sensors()

include AP_Math/AP_Math.h

userdata Vector3f field x float'skip_check read write
userdata Vector3f field y float'skip_check read write
userdata Vector3f field z float'skip_check read write
userdata Vector3f method length float
userdata Vector3f method normalize void
userdata Vector3f method is_nan boolean
userdata Vector3f method is_inf boolean
userdata Vector3f method is_zero boolean
userdata Vector3f operator +
userdata Vector3f operator -
userdata Vector3f method dot float Vector3f
userdata Vector3f method cross Vector3f Vector3f
userdata Vector3f method scale Vector3f float'skip_check
userdata Vector3f method copy Vector3f
userdata Vector3f method xy Vector2f
userdata Vector3f method rotate_xy void float'skip_check
userdata Vector3f method angle float Vector3f

userdata Vector2f field x float'skip_check read write
userdata Vector2f field y float'skip_check read write
userdata Vector2f method length float
userdata Vector2f method normalize void
userdata Vector2f method is_nan boolean
userdata Vector2f method is_inf boolean
userdata Vector2f method is_zero boolean
userdata Vector2f method angle float
userdata Vector2f method rotate void float'skip_check
userdata Vector2f operator +
userdata Vector2f operator -
userdata Vector2f method copy Vector2f

userdata Quaternion depends AP_AHRS_ENABLED
userdata Quaternion field q1 float'skip_check read write
userdata Quaternion field q2 float'skip_check read write
userdata Quaternion field q3 float'skip_check read write
userdata Quaternion field q4 float'skip_check read write
userdata Quaternion method length float
userdata Quaternion method normalize void
userdata Quaternion operator *
userdata Quaternion method get_euler_roll float
userdata Quaternion method get_euler_pitch float
userdata Quaternion method get_euler_yaw float
userdata Quaternion method from_euler void float'skip_check float'skip_check float'skip_check 
userdata Quaternion method inverse Quaternion
userdata Quaternion method earth_to_body void Vector3f
userdata Quaternion method to_axis_angle void Vector3f
userdata Quaternion method from_axis_angle  void Vector3f float'skip_check
userdata Quaternion method from_angular_velocity void Vector3f float'skip_check

include AP_Notify/AP_Notify.h
singleton AP_Notify rename notify
singleton AP_Notify depends (!defined(HAL_BUILD_AP_PERIPH) || AP_PERIPH_NOTIFY_ENABLED)
singleton AP_Notify method play_tune void string
singleton AP_Notify method handle_rgb void uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check
singleton AP_Notify method handle_rgb_id void uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check
singleton AP_Notify method send_text_scripting void string uint8_t'skip_check
singleton AP_Notify method send_text_scripting rename send_text
singleton AP_Notify method release_text_scripting void uint8_t'skip_check
singleton AP_Notify method release_text_scripting rename release_text

include AP_Proximity/AP_Proximity.h
include AP_Proximity/AP_Proximity_Backend.h

singleton AP_Proximity depends HAL_PROXIMITY_ENABLED == 1
ap_object AP_Proximity_Backend depends HAL_PROXIMITY_ENABLED == 1
ap_object AP_Proximity_Backend method handle_script_distance_msg boolean float'skip_check float'skip_check float'skip_check boolean
ap_object AP_Proximity_Backend method handle_script_3d_msg boolean Vector3f boolean
ap_object AP_Proximity_Backend method type uint8_t
ap_object AP_Proximity_Backend method set_distance_min_max boolean float'skip_check float'skip_check
ap_object AP_Proximity_Backend method update_virtual_boundary boolean

singleton AP_Proximity rename proximity
singleton AP_Proximity method get_status uint8_t
singleton AP_Proximity method num_sensors uint8_t
singleton AP_Proximity method get_object_count uint8_t
singleton AP_Proximity method get_closest_object boolean float'Null float'Null
singleton AP_Proximity method get_object_angle_and_distance boolean uint8_t'skip_check float'Null float'Null
singleton AP_Proximity method get_backend AP_Proximity_Backend uint8_t'skip_check

include AP_RangeFinder/AP_RangeFinder.h
include AP_RangeFinder/AP_RangeFinder_Backend.h

userdata RangeFinder::RangeFinder_State depends AP_RANGEFINDER_ENABLED
userdata RangeFinder::RangeFinder_State rename RangeFinder_State
userdata RangeFinder::RangeFinder_State field last_reading_ms uint32_t'skip_check read write
userdata RangeFinder::RangeFinder_State field last_reading_ms rename last_reading
userdata RangeFinder::RangeFinder_State field status RangeFinder::Status'enum read write RangeFinder::Status::NotConnected RangeFinder::Status::Good
userdata RangeFinder::RangeFinder_State field range_valid_count uint8_t'skip_check read write
userdata RangeFinder::RangeFinder_State field distance_m float'skip_check read write
userdata RangeFinder::RangeFinder_State field distance_m rename distance
userdata RangeFinder::RangeFinder_State field signal_quality_pct int8_t'skip_check read write
userdata RangeFinder::RangeFinder_State field signal_quality_pct rename signal_quality
userdata RangeFinder::RangeFinder_State field voltage_mv uint16_t'skip_check read write
userdata RangeFinder::RangeFinder_State field voltage_mv rename voltage

ap_object AP_RangeFinder_Backend depends AP_RANGEFINDER_ENABLED
ap_object AP_RangeFinder_Backend method distance float
ap_object AP_RangeFinder_Backend method signal_quality_pct float
ap_object AP_RangeFinder_Backend method signal_quality_pct rename signal_quality
ap_object AP_RangeFinder_Backend method orientation Rotation'enum
ap_object AP_RangeFinder_Backend method type uint8_t
ap_object AP_RangeFinder_Backend method status uint8_t
ap_object AP_RangeFinder_Backend manual handle_script_msg lua_range_finder_handle_script_msg 1 1
ap_object AP_RangeFinder_Backend method get_state void RangeFinder::RangeFinder_State'Ref

singleton RangeFinder depends AP_RANGEFINDER_ENABLED
singleton RangeFinder rename rangefinder
singleton RangeFinder method num_sensors uint8_t
singleton RangeFinder method has_orientation boolean Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method distance_cm_orient uint16_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method distance_cm_orient deprecate Use distance_orient (in metres)
singleton RangeFinder method distance_orient float Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method signal_quality_pct_orient int8_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method max_distance_cm_orient int32_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method max_distance_cm_orient deprecate Use max_distance_orient (in metres)
singleton RangeFinder method min_distance_cm_orient int32_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method min_distance_cm_orient deprecate Use min_distance_orient (in metres)
singleton RangeFinder method ground_clearance_cm_orient uint16_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method ground_clearance_cm_orient deprecate Use ground_clearance_orient (in metres)
singleton RangeFinder method max_distance_orient float Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method min_distance_orient float Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method ground_clearance_orient float Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method status_orient uint8_t Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method has_data_orient boolean Rotation'enum ROTATION_NONE ROTATION_MAX-1
singleton RangeFinder method get_pos_offset_orient Vector3f Rotation'enum ROTATION_NONE ROTATION_MAX-1

singleton RangeFinder method get_backend AP_RangeFinder_Backend uint8_t'skip_check

include AP_Terrain/AP_Terrain.h

singleton AP_Terrain depends defined(AP_TERRAIN_AVAILABLE) && AP_TERRAIN_AVAILABLE == 1
singleton AP_Terrain rename terrain
singleton AP_Terrain method enabled boolean
singleton AP_Terrain enum TerrainStatusDisabled TerrainStatusUnhealthy TerrainStatusOK
singleton AP_Terrain method status uint8_t
singleton AP_Terrain method height_amsl boolean Location float'Null boolean
singleton AP_Terrain method height_terrain_difference_home boolean float'Null boolean
singleton AP_Terrain method height_above_terrain boolean float'Null boolean

include AP_Relay/AP_Relay.h

singleton AP_Relay depends AP_RELAY_ENABLED
singleton AP_Relay rename relay
singleton AP_Relay method on void uint8_t 0 AP_RELAY_NUM_RELAYS
singleton AP_Relay method off void uint8_t 0 AP_RELAY_NUM_RELAYS
singleton AP_Relay method enabled boolean uint8_t 0 AP_RELAY_NUM_RELAYS
singleton AP_Relay method toggle void uint8_t 0 AP_RELAY_NUM_RELAYS
singleton AP_Relay method get uint8_t uint8_t 0 AP_RELAY_NUM_RELAYS

include GCS_MAVLink/GCS.h
singleton GCS depends (HAL_GCS_ENABLED && !defined(HAL_BUILD_AP_PERIPH))
singleton GCS rename gcs
singleton GCS method send_text void MAV_SEVERITY'enum MAV_SEVERITY_EMERGENCY MAV_SEVERITY_DEBUG "%s"'literal string
singleton GCS method set_message_interval MAV_RESULT'enum uint8_t 0 MAVLINK_COMM_NUM_BUFFERS uint32_t'skip_check int32_t -1 INT32_MAX
singleton GCS method send_named_float void string float'skip_check
singleton GCS method frame_type MAV_TYPE'enum
singleton GCS method get_hud_throttle int16_t
singleton GCS method sysid_mygcs_last_seen_time_ms uint32_t
singleton GCS method sysid_mygcs_last_seen_time_ms rename last_seen

singleton GCS method get_high_latency_status boolean
singleton GCS method get_high_latency_status depends HAL_HIGH_LATENCY2_ENABLED == 1

singleton GCS method enable_high_latency_connections void boolean
singleton GCS method enable_high_latency_connections depends HAL_HIGH_LATENCY2_ENABLED == 1
singleton GCS manual run_command_int lua_GCS_command_int 2 1

-- GCS methods to enable/disable setting of parameters via the GCS
--   PARAM_SET handling and the MAVFTP param-file-upload method:
singleton GCS method get_allow_param_set boolean
singleton GCS method set_allow_param_set void boolean

include AP_ONVIF/AP_ONVIF.h depends ENABLE_ONVIF == 1
singleton AP_ONVIF depends ENABLE_ONVIF == 1
singleton AP_ONVIF rename onvif
singleton AP_ONVIF method start boolean string string string
singleton AP_ONVIF method set_absolutemove boolean float'skip_check float'skip_check float'skip_check
singleton AP_ONVIF method get_pan_tilt_limit_min Vector2f
singleton AP_ONVIF method get_pan_tilt_limit_max Vector2f

ap_object AP_Vehicle::custom_mode_state depends (!defined(HAL_BUILD_AP_PERIPH))
ap_object AP_Vehicle::custom_mode_state field allow_entry boolean read write

include AP_Vehicle/AP_Vehicle.h
singleton AP_Vehicle depends (!defined(HAL_BUILD_AP_PERIPH))
singleton AP_Vehicle rename vehicle
singleton AP_Vehicle scheduler-semaphore
singleton AP_Vehicle method set_mode boolean uint8_t'skip_check ModeReason::SCRIPTING'literal
singleton AP_Vehicle method get_mode uint8_t
singleton AP_Vehicle method get_control_mode_reason uint8_t
singleton AP_Vehicle method get_likely_flying boolean
singleton AP_Vehicle method get_time_flying_ms uint32_t
singleton AP_Vehicle method get_control_output boolean AP_Vehicle::ControlOutput'enum AP_Vehicle::ControlOutput::Roll ((uint32_t)AP_Vehicle::ControlOutput::Last_ControlOutput-1) float'Null
singleton AP_Vehicle method start_takeoff boolean float (-LOCATION_ALT_MAX_M*100+1) (LOCATION_ALT_MAX_M*100-1)
singleton AP_Vehicle method set_target_location boolean Location
singleton AP_Vehicle method get_target_location boolean Location'Null
singleton AP_Vehicle method update_target_location boolean Location Location
singleton AP_Vehicle method set_target_pos_NED boolean Vector3f boolean float -360 +360 boolean float'skip_check boolean boolean
singleton AP_Vehicle method set_target_posvel_NED boolean Vector3f Vector3f
singleton AP_Vehicle method set_target_posvelaccel_NED boolean Vector3f Vector3f Vector3f boolean float -360 +360 boolean float'skip_check boolean
singleton AP_Vehicle method set_target_velaccel_NED boolean Vector3f Vector3f boolean float -360 +360 boolean float'skip_check boolean
singleton AP_Vehicle method set_target_velocity_NED boolean Vector3f
singleton AP_Vehicle method set_target_angle_and_climbrate boolean float -180 180 float -90 90 float -360 360 float'skip_check boolean float'skip_check
singleton AP_Vehicle method set_target_rate_and_throttle boolean float'skip_check float'skip_check float'skip_check float'skip_check
singleton AP_Vehicle method get_circle_radius boolean float'Null
singleton AP_Vehicle method set_circle_rate boolean float'skip_check
singleton AP_Vehicle method set_steering_and_throttle boolean float -1 1 float -1 1
singleton AP_Vehicle method get_steering_and_throttle boolean float'Null float'Null
singleton AP_Vehicle method get_wp_distance_m boolean float'Null
singleton AP_Vehicle method get_wp_bearing_deg boolean float'Null
singleton AP_Vehicle method get_wp_crosstrack_error_m boolean float'Null
singleton AP_Vehicle method get_pan_tilt_norm boolean float'Null float'Null
singleton AP_Vehicle method nav_script_time boolean uint16_t'Null uint8_t'Null float'Null float'Null int16_t'Null int16_t'Null
singleton AP_Vehicle method nav_script_time_done void uint16_t'skip_check
singleton AP_Vehicle method set_target_throttle_rate_rpy void float -100 100 float'skip_check float'skip_check float'skip_check
singleton AP_Vehicle method set_rudder_offset void float'skip_check boolean
singleton AP_Vehicle method set_desired_turn_rate_and_speed boolean float'skip_check float'skip_check
singleton AP_Vehicle method set_desired_speed boolean float'skip_check
singleton AP_Vehicle method nav_scripting_enable boolean uint8_t'skip_check
singleton AP_Vehicle method set_velocity_match boolean Vector2f
singleton AP_Vehicle method set_land_descent_rate boolean float'skip_check
singleton AP_Vehicle method has_ekf_failsafed boolean
singleton AP_Vehicle method reboot void boolean
singleton AP_Vehicle method is_landing boolean
singleton AP_Vehicle method is_taking_off boolean
singleton AP_Vehicle method set_crosstrack_start boolean Location
singleton AP_Vehicle method register_custom_mode AP_Vehicle::custom_mode_state uint8_t'skip_check string string


include AP_SerialLED/AP_SerialLED.h
singleton AP_SerialLED rename serialLED
singleton AP_SerialLED depends AP_SERIALLED_ENABLED
singleton AP_SerialLED method set_num_neopixel boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_num_neopixel_rgb boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_num_profiled boolean uint8_t 1 16 uint8_t 0 AP_SERIALLED_MAX_LEDS
singleton AP_SerialLED method set_RGB boolean uint8_t 1 16 int8_t -1 INT8_MAX uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check
singleton AP_SerialLED method send boolean uint8_t 1 16

include SRV_Channel/SRV_Channel.h
singleton SRV_Channels depends (!defined(HAL_BUILD_AP_PERIPH) || AP_PERIPH_RC_OUT_ENABLED)
singleton SRV_Channels rename SRV_Channels
singleton SRV_Channels method find_channel boolean SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint8_t'Null
singleton SRV_Channels method set_output_pwm void SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan void uint8_t 0 NUM_SERVO_CHANNELS-1 uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan_timeout void uint8_t 0 NUM_SERVO_CHANNELS-1 uint16_t'skip_check uint16_t'skip_check
singleton SRV_Channels method set_output_pwm_chan_timeout depends (!defined(HAL_BUILD_AP_PERIPH))
singleton SRV_Channels method set_output_scaled void SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 float'skip_check
singleton SRV_Channels method get_output_pwm boolean SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'Null
singleton SRV_Channels method get_output_pwm_chan boolean uint8_t 0 NUM_SERVO_CHANNELS-1 uint16_t'Null
singleton SRV_Channels method get_output_scaled float SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1
singleton SRV_Channels method set_output_norm void SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 float -1 1
singleton SRV_Channels method set_angle void SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method set_range void SRV_Channel::Function'enum SRV_Channel::k_none SRV_Channel::k_nr_aux_servo_functions-1 uint16_t'skip_check
singleton SRV_Channels method get_emergency_stop boolean
singleton SRV_Channels manual get_safety_state SRV_Channels_get_safety_state 0 1

ap_object RC_Channel depends AP_RC_CHANNEL_ENABLED
ap_object RC_Channel method norm_input float
ap_object RC_Channel method norm_input_dz float
ap_object RC_Channel method get_aux_switch_pos uint8_t
ap_object RC_Channel method norm_input_ignore_trim float
ap_object RC_Channel method set_override void uint16_t 0 2200 0'literal

include RC_Channel/RC_Channel.h
singleton RC_Channels depends AP_RC_CHANNEL_ENABLED
singleton RC_Channels rename rc
singleton RC_Channels scheduler-semaphore
singleton RC_Channels method get_pwm boolean uint8_t 1 NUM_RC_CHANNELS uint16_t'Null
singleton RC_Channels method find_channel_for_option RC_Channel RC_Channel::AUX_FUNC'enum 0 UINT16_MAX
singleton RC_Channels method run_aux_function boolean RC_Channel::AUX_FUNC'enum 0 UINT16_MAX RC_Channel::AuxSwitchPos'enum RC_Channel::AuxSwitchPos::LOW RC_Channel::AuxSwitchPos::HIGH RC_Channel::AuxFuncTrigger::Source::SCRIPTING'literal 0'literal
singleton RC_Channels method has_valid_input boolean
singleton RC_Channels method lua_rc_channel RC_Channel uint8_t 1 NUM_RC_CHANNELS
singleton RC_Channels method lua_rc_channel rename get_channel
singleton RC_Channels method get_aux_cached boolean RC_Channel::AUX_FUNC'enum 0 UINT16_MAX uint8_t'Null

include AP_Scripting/AP_Scripting_SerialAccess.h
-- don't let user create access objects
userdata AP_Scripting_SerialAccess creation null -1
userdata AP_Scripting_SerialAccess method begin void uint32_t 1U UINT32_MAX
userdata AP_Scripting_SerialAccess method configure_parity void uint8_t 0 2
userdata AP_Scripting_SerialAccess method set_stop_bits void uint8_t 1 2
userdata AP_Scripting_SerialAccess method write uint32_t uint8_t'skip_check
userdata AP_Scripting_SerialAccess manual writestring lua_serial_writestring 1 1
userdata AP_Scripting_SerialAccess method read int16_t
userdata AP_Scripting_SerialAccess manual readstring lua_serial_readstring 1 1
userdata AP_Scripting_SerialAccess method available uint32_t
userdata AP_Scripting_SerialAccess method set_flow_control void AP_HAL::UARTDriver::flow_control'enum AP_HAL::UARTDriver::FLOW_CONTROL_DISABLE AP_HAL::UARTDriver::FLOW_CONTROL_RTS_DE

-- serial is not a real C++ type here, but its name never gets used in C++ as we only have manual methods
singleton serial depends AP_SERIALMANAGER_ENABLED
singleton serial manual find_serial lua_serial_find_serial 1 1
singleton serial manual find_simulated_device lua_serial_find_simulated_device 2 1 depends AP_SCRIPTING_SERIALDEVICE_ENABLED

include AP_Baro/AP_Baro.h
singleton AP_Baro depends AP_BARO_ENABLED
singleton AP_Baro rename baro
singleton AP_Baro method get_pressure float
singleton AP_Baro method get_temperature float
singleton AP_Baro method get_external_temperature float
singleton AP_Baro method get_altitude float
singleton AP_Baro method healthy boolean uint8_t'skip_check
singleton AP_Baro method get_altitude_difference float float'skip_check float'skip_check

include AP_OpticalFlow/AP_OpticalFlow.h
singleton AP_OpticalFlow depends AP_OPTICALFLOW_ENABLED
singleton AP_OpticalFlow rename optical_flow
singleton AP_OpticalFlow method enabled boolean
singleton AP_OpticalFlow method healthy boolean
singleton AP_OpticalFlow method quality uint8_t

include AP_ESC_Telem/AP_ESC_Telem.h

userdata AP_ESC_Telem_Backend::TelemetryData depends (HAL_WITH_ESC_TELEM == 1)
userdata AP_ESC_Telem_Backend::TelemetryData rename ESCTelemetryData
userdata AP_ESC_Telem_Backend::TelemetryData field temperature_cdeg int16_t'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field voltage float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field current float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field consumption_mah float'skip_check write
userdata AP_ESC_Telem_Backend::TelemetryData field motor_temp_cdeg int16_t'skip_check write

singleton AP_ESC_Telem depends HAL_WITH_ESC_TELEM == 1
singleton AP_ESC_Telem rename esc_telem
singleton AP_ESC_Telem method get_rpm boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_temperature boolean uint8_t'skip_check int16_t'Null
singleton AP_ESC_Telem method get_motor_temperature boolean uint8_t'skip_check int16_t'Null
singleton AP_ESC_Telem method get_current boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_voltage boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_consumption_mah boolean uint8_t'skip_check float'Null
singleton AP_ESC_Telem method get_usage_seconds boolean uint8_t'skip_check uint32_t'Null
singleton AP_ESC_Telem method update_rpm void uint8_t 0 ESC_TELEM_MAX_ESCS uint16_t'skip_check float'skip_check
singleton AP_ESC_Telem method update_telem_data void uint8_t 0 ESC_TELEM_MAX_ESCS AP_ESC_Telem_Backend::TelemetryData uint16_t'skip_check
singleton AP_ESC_Telem method set_rpm_scale void uint8_t 0 ESC_TELEM_MAX_ESCS float'skip_check
singleton AP_ESC_Telem method get_last_telem_data_ms uint32_t uint8_t 0 ESC_TELEM_MAX_ESCS

include AP_Param/AP_Param.h
singleton AP_Param rename param
singleton AP_Param method get boolean string float'Null
singleton AP_Param method set_by_name boolean string float'skip_check
singleton AP_Param method set_by_name rename set
singleton AP_Param method set_and_save_by_name boolean string float'skip_check
singleton AP_Param method set_and_save_by_name rename set_and_save
singleton AP_Param method set_default_by_name boolean string float'skip_check
singleton AP_Param method set_default_by_name rename set_default
singleton AP_Param method add_table boolean uint8_t 0 200 string uint8_t 1 63
singleton AP_Param method add_table depends AP_PARAM_DYNAMIC_ENABLED
singleton AP_Param method add_param boolean uint8_t 0 200 uint8_t 1 63 string float'skip_check
singleton AP_Param method add_param depends AP_PARAM_DYNAMIC_ENABLED

include AP_Scripting/AP_Scripting_helpers.h
userdata Parameter creation lua_new_Parameter 0
userdata Parameter method init boolean string
userdata Parameter method init_by_info boolean uint16_t'skip_check uint32_t'skip_check ap_var_type'enum AP_PARAM_INT8 AP_PARAM_FLOAT
userdata Parameter method get boolean float'Null
userdata Parameter method set boolean float'skip_check
userdata Parameter method set_and_save boolean float'skip_check
userdata Parameter method configured boolean
userdata Parameter method set_default boolean float'skip_check

include AP_Scripting/AP_Scripting.h
singleton AP_Scripting rename scripting
singleton AP_Scripting method restart_all void

include AP_Mission/AP_Mission.h
singleton AP_Mission depends AP_MISSION_ENABLED
singleton AP_Mission rename mission
singleton AP_Mission scheduler-semaphore
singleton AP_Mission enum MISSION_STOPPED MISSION_RUNNING MISSION_COMPLETE
singleton AP_Mission method state uint8_t
singleton AP_Mission method get_current_nav_index uint16_t
singleton AP_Mission method set_current_cmd boolean uint16_t 0 (ud->num_commands()-1)
singleton AP_Mission method get_prev_nav_cmd_id uint16_t
singleton AP_Mission method get_current_nav_id uint16_t
singleton AP_Mission method get_current_do_cmd_id uint16_t
singleton AP_Mission method num_commands uint16_t
singleton AP_Mission method get_item boolean uint16_t'skip_check mavlink_mission_item_int_t'Null
singleton AP_Mission method set_item boolean uint16_t'skip_check mavlink_mission_item_int_t
singleton AP_Mission method clear boolean
singleton AP_Mission method cmd_has_location boolean uint16_t'skip_check
singleton AP_Mission method jump_to_tag boolean uint16_t 0 UINT16_MAX
singleton AP_Mission method get_index_of_jump_tag uint16_t uint16_t 0 UINT16_MAX
singleton AP_Mission method get_last_jump_tag boolean uint16_t'Null uint16_t'Null
singleton AP_Mission method jump_to_landing_sequence boolean
singleton AP_Mission method jump_to_abort_landing_sequence boolean


userdata mavlink_mission_item_int_t depends AP_MISSION_ENABLED
userdata mavlink_mission_item_int_t field param1 float'skip_check read write
userdata mavlink_mission_item_int_t field param2 float'skip_check read write
userdata mavlink_mission_item_int_t field param3 float'skip_check read write
userdata mavlink_mission_item_int_t field param4 float'skip_check read write
userdata mavlink_mission_item_int_t field x int32_t'skip_check read write
userdata mavlink_mission_item_int_t field y int32_t'skip_check read write
userdata mavlink_mission_item_int_t field z float'skip_check read write
userdata mavlink_mission_item_int_t field seq uint16_t'skip_check read write
userdata mavlink_mission_item_int_t field command uint16_t'skip_check read write
-- userdata mavlink_mission_item_int_t field target_system uint8_t'skip_check read write
-- userdata mavlink_mission_item_int_t field target_component uint8_t'skip_check read write
userdata mavlink_mission_item_int_t field frame uint8_t'skip_check read write
userdata mavlink_mission_item_int_t field current uint8_t'skip_check read write
-- userdata mavlink_mission_item_int_t field autocontinue uint8_t'skip_check read write


include AP_RPM/AP_RPM.h
singleton AP_RPM rename RPM
singleton AP_RPM depends AP_RPM_ENABLED
singleton AP_RPM method get_rpm boolean uint8_t 0 RPM_MAX_INSTANCES float'Null

include AP_Button/AP_Button.h
singleton AP_Button depends HAL_BUTTON_ENABLED == 1
singleton AP_Button rename button
singleton AP_Button method get_button_state boolean uint8_t 1 AP_BUTTON_NUM_PINS

include AP_Notify/ScriptingLED.h depends AP_NOTIFY_SCRIPTING_LED_ENABLED
include AP_Notify/AP_Notify_config.h
singleton ScriptingLED depends AP_NOTIFY_SCRIPTING_LED_ENABLED
singleton ScriptingLED rename LED
singleton ScriptingLED method get_rgb void uint8_t'Ref uint8_t'Ref uint8_t'Ref

include ../ArduPlane/quadplane.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)
singleton QuadPlane rename quadplane
singleton QuadPlane depends APM_BUILD_TYPE(APM_BUILD_ArduPlane) && HAL_QUADPLANE_ENABLED
singleton QuadPlane method in_vtol_mode boolean
singleton QuadPlane method in_assisted_flight boolean
singleton QuadPlane method abort_landing boolean
singleton QuadPlane method in_vtol_land_descent boolean

include ../ArduSub/Sub.h depends APM_BUILD_TYPE(APM_BUILD_ArduSub)
singleton Sub rename sub
singleton Sub depends APM_BUILD_TYPE(APM_BUILD_ArduSub)
singleton Sub method get_and_clear_button_count uint8_t uint8_t 1 4
singleton Sub method is_button_pressed boolean uint8_t 1 4
singleton Sub method rangefinder_alt_ok boolean
singleton Sub method rangefinder_alt_ok depends AP_RANGEFINDER_ENABLED
singleton Sub method get_rangefinder_target_cm float
singleton Sub method get_rangefinder_target_cm depends AP_RANGEFINDER_ENABLED
singleton Sub method set_rangefinder_target_cm boolean float'skip_check
singleton Sub method set_rangefinder_target_cm depends AP_RANGEFINDER_ENABLED

include AP_Motors/AP_MotorsMatrix.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix rename MotorsMatrix
singleton AP_MotorsMatrix method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix method add_motor_raw void int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float'skip_check float'skip_check float'skip_check uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix method set_throttle_factor boolean int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float 0 FLT_MAX
singleton AP_MotorsMatrix method get_lost_motor uint8_t
singleton AP_MotorsMatrix method get_thrust_boost boolean

include AP_Frsky_Telem/AP_Frsky_SPort.h
singleton AP_Frsky_SPort rename frsky_sport
singleton AP_Frsky_SPort depends AP_FRSKY_SPORT_TELEM_ENABLED
singleton AP_Frsky_SPort method sport_telemetry_push boolean uint8_t'skip_check uint8_t'skip_check uint16_t'skip_check int32_t'skip_check
singleton AP_Frsky_SPort method prep_number uint16_t int32_t'skip_check uint8_t'skip_check uint8_t'skip_check

include AC_AttitudeControl/AC_AttitudeControl_Multi_6DoF.h depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AC_AttitudeControl_Multi_6DoF depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AC_AttitudeControl_Multi_6DoF rename attitude_control
singleton AC_AttitudeControl_Multi_6DoF method set_lateral_enable void boolean
singleton AC_AttitudeControl_Multi_6DoF method set_forward_enable void boolean
singleton AC_AttitudeControl_Multi_6DoF method set_offset_roll_pitch void float'skip_check float'skip_check


include AP_Motors/AP_MotorsMatrix_6DoF_Scripting.h  depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AP_MotorsMatrix_6DoF_Scripting depends APM_BUILD_TYPE(APM_BUILD_ArduCopter)
singleton AP_MotorsMatrix_6DoF_Scripting rename Motors_6DoF
singleton AP_MotorsMatrix_6DoF_Scripting method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_6DoF_Scripting method add_motor void int8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) float'skip_check float'skip_check float'skip_check float'skip_check float'skip_check float'skip_check boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS

include AP_HAL/I2CDevice.h
ap_object AP_HAL::I2CDevice semaphore-pointer
ap_object AP_HAL::I2CDevice method set_retries void uint8_t 0 20
ap_object AP_HAL::I2CDevice method write_register boolean uint8_t'skip_check uint8_t'skip_check
ap_object AP_HAL::I2CDevice manual read_registers AP_HAL__I2CDevice_read_registers 2 1
ap_object AP_HAL::I2CDevice manual transfer AP_HAL__I2CDevice_transfer 2 1
ap_object AP_HAL::I2CDevice method set_address void uint8_t'skip_check

include AP_HAL/utility/Socket.h depends (AP_NETWORKING_ENABLED==1)
global manual Socket lua_get_SocketAPM 1 1 depends (AP_NETWORKING_ENABLED==1)
global manual ipv4_addr_to_string SocketAPM_ipv4_addr_to_string 1 1 depends (AP_NETWORKING_ENABLED==1)
global manual string_to_ipv4_addr SocketAPM_string_to_ipv4_addr 1 1 depends (AP_NETWORKING_ENABLED==1)

ap_object SocketAPM depends (AP_NETWORKING_ENABLED==1)
ap_object SocketAPM method connect boolean string uint16_t'skip_check
ap_object SocketAPM method bind boolean string uint16_t'skip_check
ap_object SocketAPM method send int32_t string uint32_t'skip_check
ap_object SocketAPM method sendto int32_t string uint32_t'skip_check uint32_t'skip_check uint16_t'skip_check
ap_object SocketAPM method listen boolean uint8_t'skip_check
ap_object SocketAPM method set_blocking boolean boolean
ap_object SocketAPM method is_connected boolean
ap_object SocketAPM method pollout boolean uint32_t'skip_check
ap_object SocketAPM method pollin boolean uint32_t'skip_check
ap_object SocketAPM method reuseaddress boolean
ap_object SocketAPM manual sendfile SocketAPM_sendfile 1 1
ap_object SocketAPM manual close SocketAPM_close 0 0
ap_object SocketAPM manual recv SocketAPM_recv 1 3
ap_object SocketAPM manual accept SocketAPM_accept 0 1

ap_object AP_HAL::AnalogSource depends !defined(HAL_DISABLE_ADC_DRIVER)
ap_object AP_HAL::AnalogSource method set_pin boolean uint8_t'skip_check
ap_object AP_HAL::AnalogSource method voltage_average float
ap_object AP_HAL::AnalogSource method voltage_latest float
ap_object AP_HAL::AnalogSource method voltage_average_ratiometric float

global manual PWMSource lua_get_PWMSource 0 1

ap_object AP_HAL::PWMSource method set_pin boolean uint8_t'skip_check "Scripting"'literal
ap_object AP_HAL::PWMSource method get_pwm_us uint16_t
ap_object AP_HAL::PWMSource method get_pwm_avg_us uint16_t

singleton hal.gpio rename gpio
singleton hal.gpio literal
singleton hal.gpio method read boolean uint8_t'skip_check
singleton hal.gpio method write void uint8_t'skip_check uint8_t 0 1
singleton hal.gpio method toggle void uint8_t'skip_check
singleton hal.gpio method pinMode void uint8_t'skip_check uint8_t 0 1
singleton hal.gpio method get_mode boolean uint8_t'skip_check uint32_t'Null
singleton hal.gpio method get_mode alias getPinFullMode
singleton hal.gpio method set_mode void uint8_t'skip_check uint32_t'skip_check
singleton hal.gpio method set_mode alias setPinFullMode

singleton hal.analogin depends !defined(HAL_DISABLE_ADC_DRIVER)
singleton hal.analogin rename analog
singleton hal.analogin literal
singleton hal.analogin method channel AP_HAL::AnalogSource ANALOG_INPUT_NONE'literal
singleton hal.analogin method mcu_temperature float
singleton hal.analogin method mcu_temperature depends HAL_WITH_MCU_MONITORING
singleton hal.analogin method mcu_voltage float
singleton hal.analogin method mcu_voltage depends HAL_WITH_MCU_MONITORING

include AP_Motors/AP_MotorsMatrix_Scripting_Dynamic.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix_Scripting_Dynamic depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP_MotorsMatrix_Scripting_Dynamic rename Motors_dynamic
singleton AP_MotorsMatrix_Scripting_Dynamic method init boolean uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_Scripting_Dynamic method add_motor void uint8_t 0 (AP_MOTORS_MAX_NUM_MOTORS-1) uint8_t 0 AP_MOTORS_MAX_NUM_MOTORS
singleton AP_MotorsMatrix_Scripting_Dynamic method load_factors void AP_MotorsMatrix_Scripting_Dynamic::factor_table

userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table rename motor_factor_table
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field roll'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field pitch'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field yaw'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write
userdata AP_MotorsMatrix_Scripting_Dynamic::factor_table field throttle'array AP_MOTORS_MAX_NUM_MOTORS float'skip_check read write

include AP_InertialSensor/AP_InertialSensor.h
singleton AP_InertialSensor depends AP_INERTIALSENSOR_ENABLED
singleton AP_InertialSensor rename ins
singleton AP_InertialSensor method get_temperature float uint8_t 0 INS_MAX_INSTANCES
singleton AP_InertialSensor method get_gyro_health boolean uint8_t'skip_check
singleton AP_InertialSensor method accels_consistent boolean float'skip_check
singleton AP_InertialSensor method get_accel_health boolean uint8_t'skip_check
singleton AP_InertialSensor method calibrating boolean
singleton AP_InertialSensor method get_gyro Vector3f uint8_t'skip_check
singleton AP_InertialSensor method get_accel Vector3f uint8_t'skip_check
singleton AP_InertialSensor method gyros_consistent boolean uint8_t'skip_check

singleton CAN manual get_device lua_get_CAN_device 1 1
singleton CAN manual get_device2 lua_get_CAN_device2 1 1
singleton CAN depends AP_SCRIPTING_CAN_SENSOR_ENABLED

include AP_Scripting/AP_Scripting_CANSensor.h
include AP_HAL/AP_HAL.h

userdata AP_HAL::CANFrame depends AP_SCRIPTING_CAN_SENSOR_ENABLED
userdata AP_HAL::CANFrame rename CANFrame
userdata AP_HAL::CANFrame field id uint32_t'skip_check read write
userdata AP_HAL::CANFrame field data'array int(ARRAY_SIZE(ud->data)) uint8_t'skip_check read write
userdata AP_HAL::CANFrame field dlc uint8_t read write 0 int(ARRAY_SIZE(ud->data))
userdata AP_HAL::CANFrame method id_signed int32_t
userdata AP_HAL::CANFrame method isExtended boolean
userdata AP_HAL::CANFrame method isRemoteTransmissionRequest boolean
userdata AP_HAL::CANFrame method isErrorFrame boolean

ap_object ScriptingCANBuffer depends AP_SCRIPTING_CAN_SENSOR_ENABLED
ap_object ScriptingCANBuffer method write_frame boolean AP_HAL::CANFrame uint32_t'skip_check
ap_object ScriptingCANBuffer method read_frame boolean AP_HAL::CANFrame'Null
ap_object ScriptingCANBuffer method add_filter boolean uint32_t'skip_check uint32_t'skip_check

include AP_Scripting/AP_Scripting_CRSFMenu.h
userdata CRSFParameter depends AP_CRSF_SCRIPTING_ENABLED
userdata CRSFParameter method id uint8_t'skip_check
userdata CRSFParameter manual data lua_CRSF_param_data 0 1

userdata CRSFMenu depends AP_CRSF_SCRIPTING_ENABLED
userdata CRSFMenu creation lua_CRSF_new_menu 1
userdata CRSFMenu method id uint8_t'skip_check
userdata CRSFMenu method name string
userdata CRSFMenu method num_params uint8_t'skip_check
userdata CRSFMenu manual add_parameter lua_CRSF_add_parameter 1 1
userdata CRSFMenu manual add_menu lua_CRSF_add_menu 1 1

singleton AP::crsf_telem() depends AP_CRSF_SCRIPTING_ENABLED
singleton AP::crsf_telem() literal
singleton AP::crsf_telem() rename crsf
singleton AP::crsf_telem() manual add_menu lua_CRSF_add_root_menu 1 1
singleton AP::crsf_telem() manual get_menu_event lua_CRSF_get_menu_event 1 3
singleton AP::crsf_telem() manual send_write_response lua_CRSF_send_response 1 1

include AP_DroneCAN/AP_DroneCAN.h
global manual DroneCAN_get_FlexDebug lua_DroneCAN_get_FlexDebug 4 2 depends (HAL_ENABLE_DRONECAN_DRIVERS==1)

include ../Tools/AP_Periph/AP_Periph.h depends defined(HAL_BUILD_AP_PERIPH)
singleton AP_Periph_FW depends defined(HAL_BUILD_AP_PERIPH)
singleton AP_Periph_FW rename periph
singleton AP_Periph_FW method get_yaw_earth float
singleton AP_Periph_FW method get_vehicle_state uint32_t
singleton AP_Periph_FW method can_printf void "%s"'literal string
singleton AP_Periph_FW method reboot void boolean

include AP_Motors/AP_Motors_Class.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP::motors() depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AP::motors() literal
singleton AP::motors() rename motors
singleton AP::motors() method set_frame_string void string
singleton AP::motors() method get_interlock boolean
singleton AP::motors() method get_desired_spool_state uint8_t
singleton AP::motors() method get_roll float
singleton AP::motors() method get_roll_ff float
singleton AP::motors() method get_pitch float
singleton AP::motors() method get_pitch_ff float
singleton AP::motors() method get_yaw float
singleton AP::motors() method get_yaw_ff float
singleton AP::motors() method get_throttle float
singleton AP::motors() method get_forward float
singleton AP::motors() method get_lateral float
singleton AP::motors() method get_spool_state uint8_t
singleton AP::motors() method set_external_limits void boolean boolean boolean boolean boolean

include AP_Common/AP_FWVersion.h
singleton AP::fwversion() literal
singleton AP::fwversion() reference
singleton AP::fwversion() rename FWVersion
singleton AP::fwversion() field fw_short_string string read
singleton AP::fwversion() field fw_short_string rename string
singleton AP::fwversion() field vehicle_type uint8_t read
singleton AP::fwversion() field vehicle_type rename type
singleton AP::fwversion() field major uint8_t read
singleton AP::fwversion() field minor uint8_t read
singleton AP::fwversion() field patch uint8_t read
singleton AP::fwversion() field fw_hash_str string read
singleton AP::fwversion() field fw_hash_str rename hash

include AP_Follow/AP_Follow.h
singleton AP_Follow depends AP_FOLLOW_ENABLED && (APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI||APM_BUILD_TYPE(APM_BUILD_Rover))
singleton AP_Follow rename follow
singleton AP_Follow method have_target boolean
singleton AP_Follow method get_last_update_ms uint32_t
singleton AP_Follow method get_target_location_and_velocity boolean Location'Null Vector3f'Null
singleton AP_Follow method get_target_location_and_velocity_ofs boolean Location'Null Vector3f'Null
singleton AP_Follow method get_target_heading_deg boolean float'Null

include AC_PrecLand/AC_PrecLand.h
singleton AC_PrecLand depends AC_PRECLAND_ENABLED && (APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI)
singleton AC_PrecLand rename precland
singleton AC_PrecLand method healthy boolean
singleton AC_PrecLand method target_acquired boolean
singleton AC_PrecLand method get_last_valid_target_ms uint32_t
singleton AC_PrecLand method get_target_velocity boolean Vector2f'Null
singleton AC_PrecLand method get_target_location boolean Location'Null

include AC_AttitudeControl/AC_AttitudeControl.h depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AC_AttitudeControl depends APM_BUILD_TYPE(APM_BUILD_ArduPlane)||APM_BUILD_COPTER_OR_HELI
singleton AC_AttitudeControl method get_rpy_srate void float'Ref float'Ref float'Ref
singleton AC_AttitudeControl method get_att_error_angle_deg float

include AC_AttitudeControl/AC_PosControl.h depends APM_BUILD_COPTER_OR_HELI
singleton AC_PosControl depends APM_BUILD_COPTER_OR_HELI
singleton AC_PosControl rename poscontrol
singleton AC_PosControl method set_posvelaccel_offset boolean Vector3f Vector3f Vector3f
singleton AC_PosControl method get_posvelaccel_offset boolean Vector3f'Null Vector3f'Null Vector3f'Null
singleton AC_PosControl method get_vel_target boolean Vector3f'Null
singleton AC_PosControl method get_accel_target boolean Vector3f'Null

include APM_Control/AR_AttitudeControl.h depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_AttitudeControl depends APM_BUILD_TYPE(APM_BUILD_Rover)
singleton AR_AttitudeControl method get_srate void float'Ref float'Ref

include AP_Mount/AP_Mount.h
singleton AP_Mount depends HAL_MOUNT_ENABLED == 1
singleton AP_Mount rename mount
singleton AP_Mount method get_mode MAV_MOUNT_MODE'enum uint8_t'skip_check
singleton AP_Mount method set_mode void uint8_t'skip_check MAV_MOUNT_MODE'enum MAV_MOUNT_MODE_RETRACT MAV_MOUNT_MODE_HOME_LOCATION
singleton AP_Mount method set_angle_target void uint8_t'skip_check float'skip_check float'skip_check float'skip_check boolean
singleton AP_Mount method set_rate_target void uint8_t'skip_check float'skip_check float'skip_check float'skip_check boolean
singleton AP_Mount method set_roi_target void uint8_t'skip_check Location
singleton AP_Mount method get_attitude_euler boolean uint8_t'skip_check float'Null float'Null float'Null
singleton AP_Mount method get_rate_target boolean uint8_t'skip_check float'Null float'Null float'Null boolean'Null
singleton AP_Mount method get_angle_target boolean uint8_t'skip_check float'Null float'Null float'Null boolean'Null
singleton AP_Mount method get_location_target boolean uint8_t'skip_check Location'Null
singleton AP_Mount method set_attitude_euler void uint8_t'skip_check float'skip_check float'skip_check float'skip_check

userdata mavlink_camera_information_t depends AP_CAMERA_INFO_FROM_SCRIPT_ENABLED
userdata mavlink_camera_information_t field time_boot_ms uint32_t'skip_check read write
userdata mavlink_camera_information_t field firmware_version uint32_t'skip_check read write
userdata mavlink_camera_information_t field focal_length float'skip_check read write
userdata mavlink_camera_information_t field sensor_size_h float'skip_check read write
userdata mavlink_camera_information_t field sensor_size_v float'skip_check read write
userdata mavlink_camera_information_t field flags uint32_t'skip_check read write
userdata mavlink_camera_information_t field resolution_h uint16_t'skip_check read write
userdata mavlink_camera_information_t field resolution_v uint16_t'skip_check read write
userdata mavlink_camera_information_t field cam_definition_version uint16_t'skip_check read write
userdata mavlink_camera_information_t field vendor_name'array 32 uint8_t'skip_check read write
userdata mavlink_camera_information_t field model_name'array 32 uint8_t'skip_check read write
userdata mavlink_camera_information_t field lens_id uint8_t'skip_check read write
userdata mavlink_camera_information_t field cam_definition_uri'array 140 uint8_t'skip_check read write
userdata mavlink_camera_information_t field gimbal_device_id uint8_t'skip_check read write

userdata mavlink_video_stream_information_t depends AP_CAMERA_INFO_FROM_SCRIPT_ENABLED
userdata mavlink_video_stream_information_t field framerate float'skip_check read write
userdata mavlink_video_stream_information_t field bitrate uint32_t'skip_check read write
userdata mavlink_video_stream_information_t field flags uint16_t'skip_check read write
userdata mavlink_video_stream_information_t field resolution_h uint16_t'skip_check read write
userdata mavlink_video_stream_information_t field resolution_v uint16_t'skip_check read write
userdata mavlink_video_stream_information_t field rotation uint16_t'skip_check read write
userdata mavlink_video_stream_information_t field hfov uint16_t'skip_check read write
userdata mavlink_video_stream_information_t field stream_id uint8_t'skip_check read write
userdata mavlink_video_stream_information_t field count uint8_t'skip_check read write
userdata mavlink_video_stream_information_t field type uint8_t'skip_check read write
userdata mavlink_video_stream_information_t field name'array 32 uint8_t'skip_check read write
userdata mavlink_video_stream_information_t field uri'array 160 uint8_t'skip_check read write
userdata mavlink_video_stream_information_t field encoding uint8_t'skip_check read write

include AP_Camera/AP_Camera.h
singleton AP_Camera depends AP_CAMERA_ENABLED && (AP_CAMERA_SCRIPTING_ENABLED == 1)
singleton AP_Camera rename camera
singleton AP_Camera semaphore
singleton AP_Camera method take_picture void uint8_t'skip_check
singleton AP_Camera method record_video boolean uint8_t'skip_check boolean
singleton AP_Camera method set_trigger_distance void uint8_t'skip_check float'skip_check
userdata AP_Camera::camera_state_t depends AP_CAMERA_ENABLED && (AP_CAMERA_SCRIPTING_ENABLED == 1)
userdata AP_Camera::camera_state_t field take_pic_incr uint16_t'skip_check read
userdata AP_Camera::camera_state_t field recording_video boolean read
userdata AP_Camera::camera_state_t field zoom_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field zoom_value float'skip_check read
userdata AP_Camera::camera_state_t field focus_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field focus_value float'skip_check read
userdata AP_Camera::camera_state_t field tracking_type uint8_t'skip_check read
userdata AP_Camera::camera_state_t field tracking_p1 Vector2f read
userdata AP_Camera::camera_state_t field tracking_p2 Vector2f read
singleton AP_Camera method get_state boolean uint8_t'skip_check AP_Camera::camera_state_t'Null
singleton AP_Camera method change_setting boolean uint8_t'skip_check CameraSetting'enum CameraSetting::THERMAL_PALETTE CameraSetting::THERMAL_RAW_DATA float'skip_check
singleton AP_Camera method set_camera_information void uint8_t'skip_check mavlink_camera_information_t
singleton AP_Camera method set_camera_information depends AP_CAMERA_INFO_FROM_SCRIPT_ENABLED
singleton AP_Camera method set_stream_information void uint8_t'skip_check mavlink_video_stream_information_t
singleton AP_Camera method set_stream_information depends AP_CAMERA_INFO_FROM_SCRIPT_ENABLED

include AP_Winch/AP_Winch.h
singleton AP_Winch depends AP_WINCH_ENABLED && APM_BUILD_COPTER_OR_HELI
singleton AP_Winch rename winch
singleton AP_Winch method healthy boolean
singleton AP_Winch method relax void
singleton AP_Winch method release_length void float'skip_check
singleton AP_Winch method set_desired_rate void float'skip_check
singleton AP_Winch method get_rate_max float

include AP_IOMCU/AP_IOMCU.h
singleton AP_IOMCU depends HAL_WITH_IO_MCU
singleton AP_IOMCU rename iomcu
singleton AP_IOMCU method healthy boolean

include AP_Compass/AP_Compass.h
singleton Compass rename compass
singleton Compass depends AP_COMPASS_ENABLED
singleton Compass method healthy boolean uint8_t'skip_check

-- ----EFI Library----
include AP_EFI/AP_EFI.h depends HAL_EFI_ENABLED
include AP_EFI/AP_EFI_Scripting.h depends AP_EFI_SCRIPTING_ENABLED
include AP_EFI/AP_EFI_config.h

userdata Cylinder_Status depends (AP_EFI_SCRIPTING_ENABLED == 1)
userdata Cylinder_Status field ignition_timing_deg float'skip_check read write
userdata Cylinder_Status field injection_time_ms float'skip_check read write
userdata Cylinder_Status field cylinder_head_temperature float'skip_check read write
userdata Cylinder_Status field cylinder_head_temperature2 float'skip_check read write
userdata Cylinder_Status field exhaust_gas_temperature float'skip_check read write
userdata Cylinder_Status field exhaust_gas_temperature2 float'skip_check read write
userdata Cylinder_Status field lambda_coefficient float'skip_check read write

userdata EFI_State depends (AP_EFI_SCRIPTING_ENABLED == 1)
userdata EFI_State field last_updated_ms uint32_t'skip_check read write
userdata EFI_State field general_error boolean read write
userdata EFI_State field engine_load_percent uint8_t'skip_check read write
userdata EFI_State field engine_speed_rpm uint32_t'skip_check read write
userdata EFI_State field spark_dwell_time_ms float'skip_check read write
userdata EFI_State field atmospheric_pressure_kpa float'skip_check read write
userdata EFI_State field intake_manifold_pressure_kpa float'skip_check read write
userdata EFI_State field intake_manifold_temperature float'skip_check read write
userdata EFI_State field coolant_temperature float'skip_check read write
userdata EFI_State field oil_pressure float'skip_check read write
userdata EFI_State field oil_temperature float'skip_check read write
userdata EFI_State field fuel_pressure float'skip_check read write
userdata EFI_State field fuel_pressure_status Fuel_Pressure_Status'enum read write Fuel_Pressure_Status::NOT_SUPPORTED Fuel_Pressure_Status::ABOVE_NOMINAL
userdata EFI_State field fuel_consumption_rate_cm3pm float'skip_check read write
userdata EFI_State field estimated_consumed_fuel_volume_cm3 float'skip_check read write
userdata EFI_State field throttle_position_percent uint8_t'skip_check read write
userdata EFI_State field ecu_index uint8_t'skip_check read write
userdata EFI_State field cylinder_status Cylinder_Status read write
userdata EFI_State field ignition_voltage float'skip_check read write
userdata EFI_State field throttle_out float'skip_check read write
userdata EFI_State field pt_compensation float'skip_check read write

ap_object AP_EFI_Backend depends (AP_EFI_SCRIPTING_ENABLED == 1)
ap_object AP_EFI_Backend method handle_scripting boolean EFI_State

singleton AP_EFI depends (AP_EFI_SCRIPTING_ENABLED == 1)
singleton AP_EFI rename efi
singleton AP_EFI method get_backend AP_EFI_Backend uint8_t'skip_check
singleton AP_EFI method get_state void EFI_State'Ref
singleton AP_EFI method get_last_update_ms uint32_t 

-- ----END EFI Library----

include AP_Logger/AP_Logger.h
singleton AP_Logger depends HAL_LOGGING_ENABLED
singleton AP_Logger rename logger
singleton AP_Logger manual write AP_Logger_Write 6 0
singleton AP_Logger method log_file_content void string
singleton AP_Logger method log_file_content depends HAL_LOGGER_FILE_CONTENTS_ENABLED

singleton i2c manual get_device lua_get_i2c_device 4 1

global manual millis lua_millis 0 1
global manual micros lua_micros 0 1
global manual mission_receive lua_mission_receive 0 5 depends AP_MISSION_ENABLED

userdata uint32_t creation lua_new_uint32_t 1
userdata uint32_t operator_getter coerce_to_uint32_t
userdata uint32_t operator +
userdata uint32_t operator -
userdata uint32_t operator *
userdata uint32_t operator /
-- We know name of the generated function so we can point at it again with a manual operator so idiv is the same as div
userdata uint32_t manual_operator __idiv uint32_t___div
userdata uint32_t operator %
userdata uint32_t operator &
userdata uint32_t operator |
userdata uint32_t operator ^
userdata uint32_t operator <<
userdata uint32_t operator >>
userdata uint32_t operator ==
userdata uint32_t operator <
userdata uint32_t operator <=
userdata uint32_t operator ~
userdata uint32_t manual_operator __tostring uint32_t___tostring
userdata uint32_t manual toint uint32_t_toint 0 1
userdata uint32_t manual tofloat uint32_t_tofloat 0 1

userdata uint64_t creation lua_new_uint64_t 2
userdata uint64_t operator_getter coerce_to_uint64_t
userdata uint64_t operator +
userdata uint64_t operator -
userdata uint64_t operator *
userdata uint64_t operator /
userdata uint64_t operator %
userdata uint64_t operator &
userdata uint64_t operator |
userdata uint64_t operator ^
userdata uint64_t operator <<
userdata uint64_t operator >>
userdata uint64_t operator ==
userdata uint64_t operator <
userdata uint64_t operator <=
userdata uint64_t operator ~
userdata uint64_t manual_operator __tostring uint64_t___tostring
userdata uint64_t manual toint uint64_t_toint 0 1
userdata uint64_t manual tofloat uint64_t_tofloat 0 1
userdata uint64_t manual split uint64_t_split 0 2

global manual dirlist lua_dirlist 1 2
global manual remove lua_removefile 1 3
global manual print lua_print 1 0

singleton mavlink depends (HAL_GCS_ENABLED && !defined(HAL_BUILD_AP_PERIPH))
singleton mavlink manual init lua_mavlink_init 2 0
singleton mavlink manual register_rx_msgid lua_mavlink_register_rx_msgid 1 1
singleton mavlink manual send_chan lua_mavlink_send_chan 3 1
singleton mavlink manual receive_chan lua_mavlink_receive_chan 0 3
singleton mavlink manual block_command lua_mavlink_block_command 1 1

include AC_Fence/AC_Fence.h depends AP_FENCE_ENABLED
include AC_Fence/AC_Fence_config.h
singleton AC_Fence depends AP_FENCE_ENABLED
singleton AC_Fence rename fence
singleton AC_Fence method get_breaches uint8_t
singleton AC_Fence method get_breach_time uint32_t
singleton AC_Fence method get_margin_breaches uint8_t
singleton AC_Fence method get_margin_breach_time uint32_t
singleton AC_Fence method get_breach_distance float uint8_t'skip_check

include AP_Filesystem/AP_Filesystem.h depends AP_FILESYSTEM_FILE_READING_ENABLED
include AP_Filesystem/AP_Filesystem_config.h
userdata AP_Filesystem::stat_t depends AP_FILESYSTEM_FILE_READING_ENABLED
userdata AP_Filesystem::stat_t rename stat_t
userdata AP_Filesystem::stat_t field size uint32_t read
userdata AP_Filesystem::stat_t field mode int32_t read
userdata AP_Filesystem::stat_t field mtime uint32_t read
userdata AP_Filesystem::stat_t field atime uint32_t read
userdata AP_Filesystem::stat_t field ctime uint32_t read
userdata AP_Filesystem::stat_t method is_directory boolean

singleton AP_Filesystem rename fs
singleton AP_Filesystem method stat boolean string AP_Filesystem::stat_t'Null
singleton AP_Filesystem method format boolean
singleton AP_Filesystem method format depends AP_FILESYSTEM_FORMAT_ENABLED
singleton AP_Filesystem method get_format_status uint8_t'skip_check
singleton AP_Filesystem method get_format_status depends AP_FILESYSTEM_FORMAT_ENABLED
singleton AP_Filesystem method crc32 boolean string uint32_t'Null

include AP_RTC/AP_RTC.h depends AP_RTC_ENABLED
include AP_RTC/AP_RTC_config.h
singleton AP_RTC depends AP_RTC_ENABLED
singleton AP_RTC rename rtc
singleton AP_RTC method clock_s_to_date_fields boolean uint32_t'skip_check uint16_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null uint8_t'Null
singleton AP_RTC method date_fields_to_clock_s uint32_t uint16_t'skip_check int8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check uint8_t'skip_check

include AP_Networking/AP_Networking.h depends AP_NETWORKING_ENABLED
include AP_Networking/AP_Networking_Config.h
singleton AP_Networking depends AP_NETWORKING_ENABLED
singleton AP_Networking rename networking
singleton AP_Networking method get_ip_active uint32_t
singleton AP_Networking method get_netmask_active uint32_t
singleton AP_Networking method get_gateway_active uint32_t
singleton AP_Networking method address_to_str string uint32_t'skip_check

include AP_VisualOdom/AP_VisualOdom.h
singleton AP_VisualOdom depends HAL_VISUALODOM_ENABLED
singleton AP_VisualOdom rename visual_odom
singleton AP_VisualOdom method healthy boolean
singleton AP_VisualOdom method quality int8_t

-- ----AP_TemperatureSensor Library----
include AP_TemperatureSensor/AP_TemperatureSensor.h
singleton AP_TemperatureSensor depends AP_TEMPERATURE_SENSOR_ENABLED
singleton AP_TemperatureSensor rename temperature_sensor
singleton AP_TemperatureSensor method get_temperature boolean float'Null uint8_t'skip_check

include AP_Servo_Telem/AP_Servo_Telem.h depends AP_SERVO_TELEM_ENABLED
include AP_Servo_Telem/AP_Servo_Telem_config.h
singleton AP_Servo_Telem depends AP_SERVO_TELEM_ENABLED
singleton AP_Servo_Telem rename servo_telem
singleton AP_Servo_Telem method get_telem boolean uint8_t'skip_check AP_Servo_Telem::TelemetryData'Null

userdata AP_Servo_Telem::TelemetryData depends AP_SERVO_TELEM_ENABLED
userdata AP_Servo_Telem::TelemetryData rename AP_Servo_Telem_Data
userdata AP_Servo_Telem::TelemetryData field command_position float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::COMMANDED_POSITION
userdata AP_Servo_Telem::TelemetryData field measured_position float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::MEASURED_POSITION
userdata AP_Servo_Telem::TelemetryData field force float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::FORCE
userdata AP_Servo_Telem::TelemetryData field speed float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::SPEED
userdata AP_Servo_Telem::TelemetryData field voltage float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::VOLTAGE
userdata AP_Servo_Telem::TelemetryData field current float'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::CURRENT
userdata AP_Servo_Telem::TelemetryData field duty_cycle uint8_t'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::DUTY_CYCLE
userdata AP_Servo_Telem::TelemetryData field motor_temperature_cdeg int16_t'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::MOTOR_TEMP
userdata AP_Servo_Telem::TelemetryData field pcb_temperature_cdeg int16_t'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::PCB_TEMP
userdata AP_Servo_Telem::TelemetryData field status_flags uint8_t'skip_check read valid_mask present_types AP_Servo_Telem::TelemetryData::Types::STATUS
userdata AP_Servo_Telem::TelemetryData field last_update_ms uint32_t'skip_check read

-- simulator only bindings
include SITL/SITL.h depends AP_SIM_ENABLED
singleton SITL::SIM depends AP_SIM_ENABLED
singleton SITL::SIM rename sim
singleton SITL::SIM method set_pose boolean uint8_t'skip_check Location Quaternion Vector3f Vector3f

userdata DroneCAN_Handle depends HAL_ENABLE_DRONECAN_DRIVERS
userdata DroneCAN_Handle creation DroneCAN_Handle::new_handle 4
userdata DroneCAN_Handle manual broadcast DroneCAN_Handle::broadcast 1 1
userdata DroneCAN_Handle manual request DroneCAN_Handle::request 2 1
userdata DroneCAN_Handle method subscribe boolean
userdata DroneCAN_Handle manual check_message DroneCAN_Handle::check_message 0 4
userdata DroneCAN_Handle manual_operator __gc DroneCAN_Handle::__gc





================================================
File: lua/Makefile
================================================
# Makefile for installing Lua
# See doc/readme.html for installation and customization instructions.

# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================

# Your platform. See PLATS for possible values.
PLAT= none

# Where to install. The installation starts in the src and doc directories,
# so take care if INSTALL_TOP is not an absolute path. See the local target.
# You may want to make INSTALL_LMOD and INSTALL_CMOD consistent with
# LUA_ROOT, LUA_LDIR, and LUA_CDIR in luaconf.h.
INSTALL_TOP= /usr/local
INSTALL_BIN= $(INSTALL_TOP)/bin
INSTALL_INC= $(INSTALL_TOP)/include
INSTALL_LIB= $(INSTALL_TOP)/lib
INSTALL_MAN= $(INSTALL_TOP)/man/man1
INSTALL_LMOD= $(INSTALL_TOP)/share/lua/$V
INSTALL_CMOD= $(INSTALL_TOP)/lib/lua/$V

# How to install. If your install program does not support "-p", then
# you may have to run ranlib on the installed liblua.a.
INSTALL= install -p
INSTALL_EXEC= $(INSTALL) -m 0755
INSTALL_DATA= $(INSTALL) -m 0644
#
# If you don't have "install" you can use "cp" instead.
# INSTALL= cp -p
# INSTALL_EXEC= $(INSTALL)
# INSTALL_DATA= $(INSTALL)

# Other utilities.
MKDIR= mkdir -p
RM= rm -f

# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======

# Convenience platforms targets.
PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris

# What to install.
TO_BIN= lua luac
TO_INC= lua.h luaconf.h lualib.h lauxlib.h lua.hpp
TO_LIB= liblua.a
TO_MAN= lua.1 luac.1

# Lua version and release.
V= 5.3
R= $V.6

# Targets start here.
all:	$(PLAT)

$(PLATS) clean:
	cd src && $(MAKE) $@

test:	dummy
	src/lua -v

install: dummy
	cd src && $(MKDIR) $(INSTALL_BIN) $(INSTALL_INC) $(INSTALL_LIB) $(INSTALL_MAN) $(INSTALL_LMOD) $(INSTALL_CMOD)
	cd src && $(INSTALL_EXEC) $(TO_BIN) $(INSTALL_BIN)
	cd src && $(INSTALL_DATA) $(TO_INC) $(INSTALL_INC)
	cd src && $(INSTALL_DATA) $(TO_LIB) $(INSTALL_LIB)
	cd doc && $(INSTALL_DATA) $(TO_MAN) $(INSTALL_MAN)

uninstall:
	cd src && cd $(INSTALL_BIN) && $(RM) $(TO_BIN)
	cd src && cd $(INSTALL_INC) && $(RM) $(TO_INC)
	cd src && cd $(INSTALL_LIB) && $(RM) $(TO_LIB)
	cd doc && cd $(INSTALL_MAN) && $(RM) $(TO_MAN)

local:
	$(MAKE) install INSTALL_TOP=../install

none:
	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
	@echo "   $(PLATS)"
	@echo "See doc/readme.html for complete instructions."

# make may get confused with test/ and install/
dummy:

# echo config parameters
echo:
	@cd src && $(MAKE) -s echo
	@echo "PLAT= $(PLAT)"
	@echo "V= $V"
	@echo "R= $R"
	@echo "TO_BIN= $(TO_BIN)"
	@echo "TO_INC= $(TO_INC)"
	@echo "TO_LIB= $(TO_LIB)"
	@echo "TO_MAN= $(TO_MAN)"
	@echo "INSTALL_TOP= $(INSTALL_TOP)"
	@echo "INSTALL_BIN= $(INSTALL_BIN)"
	@echo "INSTALL_INC= $(INSTALL_INC)"
	@echo "INSTALL_LIB= $(INSTALL_LIB)"
	@echo "INSTALL_MAN= $(INSTALL_MAN)"
	@echo "INSTALL_LMOD= $(INSTALL_LMOD)"
	@echo "INSTALL_CMOD= $(INSTALL_CMOD)"
	@echo "INSTALL_EXEC= $(INSTALL_EXEC)"
	@echo "INSTALL_DATA= $(INSTALL_DATA)"

# echo pkg-config data
pc:
	@echo "version=$R"
	@echo "prefix=$(INSTALL_TOP)"
	@echo "libdir=$(INSTALL_LIB)"
	@echo "includedir=$(INSTALL_INC)"

# list targets that do not create files (but not all makes understand .PHONY)
.PHONY: all $(PLATS) clean test install local none dummy echo pecho lecho

# (end of Makefile)



================================================
File: lua/README
================================================

This is Lua 5.3.6, released on 14 Sep 2020.

For installation instructions, license details, and
further information about Lua, see doc/readme.html.




================================================
File: lua/doc/contents.html
================================================
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 Reference Manual - contents</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="index.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="http://www.lua.org/"><IMG SRC="logo.gif" ALT="Lua"></A>
Lua 5.3 Reference Manual
</H1>

<P>
The reference manual is the official definition of the Lua language.
<BR>
For a complete introduction to Lua programming, see the book
<A HREF="http://www.lua.org/pil/">Programming in Lua</A>.

<DIV CLASS="menubar">
<A HREF="manual.html">start</A>
&middot;
<A HREF="#contents">contents</A>
&middot;
<A HREF="#index">index</A>
&middot;
<A HREF="http://www.lua.org/manual/">other versions</A>
</DIV>

<P>
<SMALL>
Copyright &copy; 2015&ndash;2020 Lua.org, PUC-Rio.
Freely available under the terms of the
<A HREF="http://www.lua.org/license.html">Lua license</A>.
</SMALL>

<H2><A NAME="contents">Contents</A></H2>
<UL CLASS="contents menubar">
<LI><A HREF="manual.html">1 &ndash; Introduction</A>
<P>
<LI><A HREF="manual.html#2">2 &ndash; Basic Concepts</A>
<UL>
<LI><A HREF="manual.html#2.1">2.1 &ndash; Values and Types</A>
<LI><A HREF="manual.html#2.2">2.2 &ndash; Environments and the Global Environment</A>
<LI><A HREF="manual.html#2.3">2.3 &ndash; Error Handling</A>
<LI><A HREF="manual.html#2.4">2.4 &ndash; Metatables and Metamethods</A>
<LI><A HREF="manual.html#2.5">2.5 &ndash; Garbage Collection</A>
<UL>
<LI><A HREF="manual.html#2.5.1">2.5.1 &ndash; Garbage-Collection Metamethods</A>
<LI><A HREF="manual.html#2.5.2">2.5.2 &ndash; Weak Tables</A>
</UL>
<LI><A HREF="manual.html#2.6">2.6 &ndash; Coroutines</A>
</UL>
<P>
<LI><A HREF="manual.html#3">3 &ndash; The Language</A>
<UL>
<LI><A HREF="manual.html#3.1">3.1 &ndash; Lexical Conventions</A>
<LI><A HREF="manual.html#3.2">3.2 &ndash; Variables</A>
<LI><A HREF="manual.html#3.3">3.3 &ndash; Statements</A>
<UL>
<LI><A HREF="manual.html#3.3.1">3.3.1 &ndash; Blocks</A>
<LI><A HREF="manual.html#3.3.2">3.3.2 &ndash; Chunks</A>
<LI><A HREF="manual.html#3.3.3">3.3.3 &ndash; Assignment</A>
<LI><A HREF="manual.html#3.3.4">3.3.4 &ndash; Control Structures</A>
<LI><A HREF="manual.html#3.3.5">3.3.5 &ndash; For Statement</A>
<LI><A HREF="manual.html#3.3.6">3.3.6 &ndash; Function Calls as Statements</A>
<LI><A HREF="manual.html#3.3.7">3.3.7 &ndash; Local Declarations</A>
</UL>
<LI><A HREF="manual.html#3.4">3.4 &ndash; Expressions</A>
<UL>
<LI><A HREF="manual.html#3.4.1">3.4.1 &ndash; Arithmetic Operators</A>
<LI><A HREF="manual.html#3.4.2">3.4.2 &ndash; Bitwise Operators</A>
<LI><A HREF="manual.html#3.4.3">3.4.3 &ndash; Coercions and Conversions</A>
<LI><A HREF="manual.html#3.4.4">3.4.4 &ndash; Relational Operators</A>
<LI><A HREF="manual.html#3.4.5">3.4.5 &ndash; Logical Operators</A>
<LI><A HREF="manual.html#3.4.6">3.4.6 &ndash; Concatenation</A>
<LI><A HREF="manual.html#3.4.7">3.4.7 &ndash; The Length Operator</A>
<LI><A HREF="manual.html#3.4.8">3.4.8 &ndash; Precedence</A>
<LI><A HREF="manual.html#3.4.9">3.4.9 &ndash; Table Constructors</A>
<LI><A HREF="manual.html#3.4.10">3.4.10 &ndash; Function Calls</A>
<LI><A HREF="manual.html#3.4.11">3.4.11 &ndash; Function Definitions</A>
</UL>
<LI><A HREF="manual.html#3.5">3.5 &ndash; Visibility Rules</A>
</UL>
<P>
<LI><A HREF="manual.html#4">4 &ndash; The Application Program Interface</A>
<UL>
<LI><A HREF="manual.html#4.1">4.1 &ndash; The Stack</A>
<LI><A HREF="manual.html#4.2">4.2 &ndash; Stack Size</A>
<LI><A HREF="manual.html#4.3">4.3 &ndash; Valid and Acceptable Indices</A>
<LI><A HREF="manual.html#4.4">4.4 &ndash; C Closures</A>
<LI><A HREF="manual.html#4.5">4.5 &ndash; Registry</A>
<LI><A HREF="manual.html#4.6">4.6 &ndash; Error Handling in C</A>
<LI><A HREF="manual.html#4.7">4.7 &ndash; Handling Yields in C</A>
<LI><A HREF="manual.html#4.8">4.8 &ndash; Functions and Types</A>
<LI><A HREF="manual.html#4.9">4.9 &ndash; The Debug Interface</A>
</UL>
<P>
<LI><A HREF="manual.html#5">5 &ndash; The Auxiliary Library</A>
<UL>
<LI><A HREF="manual.html#5.1">5.1 &ndash; Functions and Types</A>
</UL>
<P>
<LI><A HREF="manual.html#6">6 &ndash; Standard Libraries</A>
<UL>
<LI><A HREF="manual.html#6.1">6.1 &ndash; Basic Functions</A>
<LI><A HREF="manual.html#6.2">6.2 &ndash; Coroutine Manipulation</A>
<LI><A HREF="manual.html#6.3">6.3 &ndash; Modules</A>
<LI><A HREF="manual.html#6.4">6.4 &ndash; String Manipulation</A>
<UL>
<LI><A HREF="manual.html#6.4.1">6.4.1 &ndash; Patterns</A>
<LI><A HREF="manual.html#6.4.2">6.4.2 &ndash; Format Strings for Pack and Unpack</A>
</UL>
<LI><A HREF="manual.html#6.5">6.5 &ndash; UTF-8 Support</A>
<LI><A HREF="manual.html#6.6">6.6 &ndash; Table Manipulation</A>
<LI><A HREF="manual.html#6.7">6.7 &ndash; Mathematical Functions</A>
<LI><A HREF="manual.html#6.8">6.8 &ndash; Input and Output Facilities</A>
<LI><A HREF="manual.html#6.9">6.9 &ndash; Operating System Facilities</A>
<LI><A HREF="manual.html#6.10">6.10 &ndash; The Debug Library</A>
</UL>
<P>
<LI><A HREF="manual.html#7">7 &ndash; Lua Standalone</A>
<P>
<LI><A HREF="manual.html#8">8 &ndash; Incompatibilities with the Previous Version</A>
<UL>
<LI><A HREF="manual.html#8.1">8.1 &ndash; Changes in the Language</A>
<LI><A HREF="manual.html#8.2">8.2 &ndash; Changes in the Libraries</A>
<LI><A HREF="manual.html#8.3">8.3 &ndash; Changes in the API</A>
</UL>
<P>
<LI><A HREF="manual.html#9">9 &ndash; The Complete Syntax of Lua</A>
</UL>

<H2><A NAME="index">Index</A></H2>
<TABLE CLASS="menubar" WIDTH="100%">
<TR>
<TD>
<H3><A NAME="functions">Lua functions</A></H3>
<P>
<A HREF="manual.html#6.1">basic</A><BR>
<A HREF="manual.html#pdf-_G">_G</A><BR>
<A HREF="manual.html#pdf-_VERSION">_VERSION</A><BR>
<A HREF="manual.html#pdf-assert">assert</A><BR>
<A HREF="manual.html#pdf-collectgarbage">collectgarbage</A><BR>
<A HREF="manual.html#pdf-dofile">dofile</A><BR>
<A HREF="manual.html#pdf-error">error</A><BR>
<A HREF="manual.html#pdf-getmetatable">getmetatable</A><BR>
<A HREF="manual.html#pdf-ipairs">ipairs</A><BR>
<A HREF="manual.html#pdf-load">load</A><BR>
<A HREF="manual.html#pdf-loadfile">loadfile</A><BR>
<A HREF="manual.html#pdf-next">next</A><BR>
<A HREF="manual.html#pdf-pairs">pairs</A><BR>
<A HREF="manual.html#pdf-pcall">pcall</A><BR>
<A HREF="manual.html#pdf-print">print</A><BR>
<A HREF="manual.html#pdf-rawequal">rawequal</A><BR>
<A HREF="manual.html#pdf-rawget">rawget</A><BR>
<A HREF="manual.html#pdf-rawlen">rawlen</A><BR>
<A HREF="manual.html#pdf-rawset">rawset</A><BR>
<A HREF="manual.html#pdf-require">require</A><BR>
<A HREF="manual.html#pdf-select">select</A><BR>
<A HREF="manual.html#pdf-setmetatable">setmetatable</A><BR>
<A HREF="manual.html#pdf-tonumber">tonumber</A><BR>
<A HREF="manual.html#pdf-tostring">tostring</A><BR>
<A HREF="manual.html#pdf-type">type</A><BR>
<A HREF="manual.html#pdf-xpcall">xpcall</A><BR>

<P>
<A HREF="manual.html#6.2">coroutine</A><BR>
<A HREF="manual.html#pdf-coroutine.create">coroutine.create</A><BR>
<A HREF="manual.html#pdf-coroutine.isyieldable">coroutine.isyieldable</A><BR>
<A HREF="manual.html#pdf-coroutine.resume">coroutine.resume</A><BR>
<A HREF="manual.html#pdf-coroutine.running">coroutine.running</A><BR>
<A HREF="manual.html#pdf-coroutine.status">coroutine.status</A><BR>
<A HREF="manual.html#pdf-coroutine.wrap">coroutine.wrap</A><BR>
<A HREF="manual.html#pdf-coroutine.yield">coroutine.yield</A><BR>

<P>
<A HREF="manual.html#6.10">debug</A><BR>
<A HREF="manual.html#pdf-debug.debug">debug.debug</A><BR>
<A HREF="manual.html#pdf-debug.gethook">debug.gethook</A><BR>
<A HREF="manual.html#pdf-debug.getinfo">debug.getinfo</A><BR>
<A HREF="manual.html#pdf-debug.getlocal">debug.getlocal</A><BR>
<A HREF="manual.html#pdf-debug.getmetatable">debug.getmetatable</A><BR>
<A HREF="manual.html#pdf-debug.getregistry">debug.getregistry</A><BR>
<A HREF="manual.html#pdf-debug.getupvalue">debug.getupvalue</A><BR>
<A HREF="manual.html#pdf-debug.getuservalue">debug.getuservalue</A><BR>
<A HREF="manual.html#pdf-debug.sethook">debug.sethook</A><BR>
<A HREF="manual.html#pdf-debug.setlocal">debug.setlocal</A><BR>
<A HREF="manual.html#pdf-debug.setmetatable">debug.setmetatable</A><BR>
<A HREF="manual.html#pdf-debug.setupvalue">debug.setupvalue</A><BR>
<A HREF="manual.html#pdf-debug.setuservalue">debug.setuservalue</A><BR>
<A HREF="manual.html#pdf-debug.traceback">debug.traceback</A><BR>
<A HREF="manual.html#pdf-debug.upvalueid">debug.upvalueid</A><BR>
<A HREF="manual.html#pdf-debug.upvaluejoin">debug.upvaluejoin</A><BR>

<P>
<A HREF="manual.html#6.8">io</A><BR>
<A HREF="manual.html#pdf-io.close">io.close</A><BR>
<A HREF="manual.html#pdf-io.flush">io.flush</A><BR>
<A HREF="manual.html#pdf-io.input">io.input</A><BR>
<A HREF="manual.html#pdf-io.lines">io.lines</A><BR>
<A HREF="manual.html#pdf-io.open">io.open</A><BR>
<A HREF="manual.html#pdf-io.output">io.output</A><BR>
<A HREF="manual.html#pdf-io.popen">io.popen</A><BR>
<A HREF="manual.html#pdf-io.read">io.read</A><BR>
<A HREF="manual.html#pdf-io.stderr">io.stderr</A><BR>
<A HREF="manual.html#pdf-io.stdin">io.stdin</A><BR>
<A HREF="manual.html#pdf-io.stdout">io.stdout</A><BR>
<A HREF="manual.html#pdf-io.tmpfile">io.tmpfile</A><BR>
<A HREF="manual.html#pdf-io.type">io.type</A><BR>
<A HREF="manual.html#pdf-io.write">io.write</A><BR>

<A HREF="manual.html#pdf-file:close">file:close</A><BR>
<A HREF="manual.html#pdf-file:flush">file:flush</A><BR>
<A HREF="manual.html#pdf-file:lines">file:lines</A><BR>
<A HREF="manual.html#pdf-file:read">file:read</A><BR>
<A HREF="manual.html#pdf-file:seek">file:seek</A><BR>
<A HREF="manual.html#pdf-file:setvbuf">file:setvbuf</A><BR>
<A HREF="manual.html#pdf-file:write">file:write</A><BR>

</TD>
<TD>
<H3>&nbsp;</H3>
<P>
<A HREF="manual.html#6.7">math</A><BR>
<A HREF="manual.html#pdf-math.abs">math.abs</A><BR>
<A HREF="manual.html#pdf-math.acos">math.acos</A><BR>
<A HREF="manual.html#pdf-math.asin">math.asin</A><BR>
<A HREF="manual.html#pdf-math.atan">math.atan</A><BR>
<A HREF="manual.html#pdf-math.ceil">math.ceil</A><BR>
<A HREF="manual.html#pdf-math.cos">math.cos</A><BR>
<A HREF="manual.html#pdf-math.deg">math.deg</A><BR>
<A HREF="manual.html#pdf-math.exp">math.exp</A><BR>
<A HREF="manual.html#pdf-math.floor">math.floor</A><BR>
<A HREF="manual.html#pdf-math.fmod">math.fmod</A><BR>
<A HREF="manual.html#pdf-math.huge">math.huge</A><BR>
<A HREF="manual.html#pdf-math.log">math.log</A><BR>
<A HREF="manual.html#pdf-math.max">math.max</A><BR>
<A HREF="manual.html#pdf-math.maxinteger">math.maxinteger</A><BR>
<A HREF="manual.html#pdf-math.min">math.min</A><BR>
<A HREF="manual.html#pdf-math.mininteger">math.mininteger</A><BR>
<A HREF="manual.html#pdf-math.modf">math.modf</A><BR>
<A HREF="manual.html#pdf-math.pi">math.pi</A><BR>
<A HREF="manual.html#pdf-math.rad">math.rad</A><BR>
<A HREF="manual.html#pdf-math.random">math.random</A><BR>
<A HREF="manual.html#pdf-math.randomseed">math.randomseed</A><BR>
<A HREF="manual.html#pdf-math.sin">math.sin</A><BR>
<A HREF="manual.html#pdf-math.sqrt">math.sqrt</A><BR>
<A HREF="manual.html#pdf-math.tan">math.tan</A><BR>
<A HREF="manual.html#pdf-math.tointeger">math.tointeger</A><BR>
<A HREF="manual.html#pdf-math.type">math.type</A><BR>
<A HREF="manual.html#pdf-math.ult">math.ult</A><BR>

<P>
<A HREF="manual.html#6.9">os</A><BR>
<A HREF="manual.html#pdf-os.clock">os.clock</A><BR>
<A HREF="manual.html#pdf-os.date">os.date</A><BR>
<A HREF="manual.html#pdf-os.difftime">os.difftime</A><BR>
<A HREF="manual.html#pdf-os.execute">os.execute</A><BR>
<A HREF="manual.html#pdf-os.exit">os.exit</A><BR>
<A HREF="manual.html#pdf-os.getenv">os.getenv</A><BR>
<A HREF="manual.html#pdf-os.remove">os.remove</A><BR>
<A HREF="manual.html#pdf-os.rename">os.rename</A><BR>
<A HREF="manual.html#pdf-os.setlocale">os.setlocale</A><BR>
<A HREF="manual.html#pdf-os.time">os.time</A><BR>
<A HREF="manual.html#pdf-os.tmpname">os.tmpname</A><BR>

<P>
<A HREF="manual.html#6.3">package</A><BR>
<A HREF="manual.html#pdf-package.config">package.config</A><BR>
<A HREF="manual.html#pdf-package.cpath">package.cpath</A><BR>
<A HREF="manual.html#pdf-package.loaded">package.loaded</A><BR>
<A HREF="manual.html#pdf-package.loadlib">package.loadlib</A><BR>
<A HREF="manual.html#pdf-package.path">package.path</A><BR>
<A HREF="manual.html#pdf-package.preload">package.preload</A><BR>
<A HREF="manual.html#pdf-package.searchers">package.searchers</A><BR>
<A HREF="manual.html#pdf-package.searchpath">package.searchpath</A><BR>

<P>
<A HREF="manual.html#6.4">string</A><BR>
<A HREF="manual.html#pdf-string.byte">string.byte</A><BR>
<A HREF="manual.html#pdf-string.char">string.char</A><BR>
<A HREF="manual.html#pdf-string.dump">string.dump</A><BR>
<A HREF="manual.html#pdf-string.find">string.find</A><BR>
<A HREF="manual.html#pdf-string.format">string.format</A><BR>
<A HREF="manual.html#pdf-string.gmatch">string.gmatch</A><BR>
<A HREF="manual.html#pdf-string.gsub">string.gsub</A><BR>
<A HREF="manual.html#pdf-string.len">string.len</A><BR>
<A HREF="manual.html#pdf-string.lower">string.lower</A><BR>
<A HREF="manual.html#pdf-string.match">string.match</A><BR>
<A HREF="manual.html#pdf-string.pack">string.pack</A><BR>
<A HREF="manual.html#pdf-string.packsize">string.packsize</A><BR>
<A HREF="manual.html#pdf-string.rep">string.rep</A><BR>
<A HREF="manual.html#pdf-string.reverse">string.reverse</A><BR>
<A HREF="manual.html#pdf-string.sub">string.sub</A><BR>
<A HREF="manual.html#pdf-string.unpack">string.unpack</A><BR>
<A HREF="manual.html#pdf-string.upper">string.upper</A><BR>

<P>
<A HREF="manual.html#6.6">table</A><BR>
<A HREF="manual.html#pdf-table.concat">table.concat</A><BR>
<A HREF="manual.html#pdf-table.insert">table.insert</A><BR>
<A HREF="manual.html#pdf-table.move">table.move</A><BR>
<A HREF="manual.html#pdf-table.pack">table.pack</A><BR>
<A HREF="manual.html#pdf-table.remove">table.remove</A><BR>
<A HREF="manual.html#pdf-table.sort">table.sort</A><BR>
<A HREF="manual.html#pdf-table.unpack">table.unpack</A><BR>

<P>
<A HREF="manual.html#6.5">utf8</A><BR>
<A HREF="manual.html#pdf-utf8.char">utf8.char</A><BR>
<A HREF="manual.html#pdf-utf8.charpattern">utf8.charpattern</A><BR>
<A HREF="manual.html#pdf-utf8.codepoint">utf8.codepoint</A><BR>
<A HREF="manual.html#pdf-utf8.codes">utf8.codes</A><BR>
<A HREF="manual.html#pdf-utf8.len">utf8.len</A><BR>
<A HREF="manual.html#pdf-utf8.offset">utf8.offset</A><BR>

<H3><A NAME="metamethods">metamethods</A></H3>
<P>
<A HREF="manual.html#2.4">__add</A><BR>
<A HREF="manual.html#2.4">__band</A><BR>
<A HREF="manual.html#2.4">__bnot</A><BR>
<A HREF="manual.html#2.4">__bor</A><BR>
<A HREF="manual.html#2.4">__bxor</A><BR>
<A HREF="manual.html#2.4">__call</A><BR>
<A HREF="manual.html#2.4">__concat</A><BR>
<A HREF="manual.html#2.4">__div</A><BR>
<A HREF="manual.html#2.4">__eq</A><BR>
<A HREF="manual.html#2.5.1">__gc</A><BR>
<A HREF="manual.html#2.4">__idiv</A><BR>
<A HREF="manual.html#2.4">__index</A><BR>
<A HREF="manual.html#2.4">__le</A><BR>
<A HREF="manual.html#2.4">__len</A><BR>
<A HREF="manual.html#2.4">__lt</A><BR>
<A HREF="manual.html#pdf-getmetatable">__metatable</A><BR>
<A HREF="manual.html#2.4">__mod</A><BR>
<A HREF="manual.html#2.5.2">__mode</A><BR>
<A HREF="manual.html#2.4">__mul</A><BR>
<A HREF="manual.html#luaL_newmetatable">__name</A><BR>
<A HREF="manual.html#2.4">__newindex</A><BR>
<A HREF="manual.html#pdf-pairs">__pairs</A><BR>
<A HREF="manual.html#2.4">__pow</A><BR>
<A HREF="manual.html#2.4">__shl</A><BR>
<A HREF="manual.html#2.4">__shr</A><BR>
<A HREF="manual.html#2.4">__sub</A><BR>
<A HREF="manual.html#pdf-tostring">__tostring</A><BR>
<A HREF="manual.html#2.4">__unm</A><BR>

<H3><A NAME="env">environment<BR>variables</A></H3>
<P>
<A HREF="manual.html#pdf-LUA_CPATH">LUA_CPATH</A><BR>
<A HREF="manual.html#pdf-LUA_CPATH_5_3">LUA_CPATH_5_3</A><BR>
<A HREF="manual.html#pdf-LUA_INIT">LUA_INIT</A><BR>
<A HREF="manual.html#pdf-LUA_INIT_5_3">LUA_INIT_5_3</A><BR>
<A HREF="manual.html#pdf-LUA_PATH">LUA_PATH</A><BR>
<A HREF="manual.html#pdf-LUA_PATH_5_3">LUA_PATH_5_3</A><BR>

</TD>
<TD>
<H3><A NAME="api">C API</A></H3>
<P>
<A HREF="manual.html#lua_Alloc">lua_Alloc</A><BR>
<A HREF="manual.html#lua_CFunction">lua_CFunction</A><BR>
<A HREF="manual.html#lua_Debug">lua_Debug</A><BR>
<A HREF="manual.html#lua_Hook">lua_Hook</A><BR>
<A HREF="manual.html#lua_Integer">lua_Integer</A><BR>
<A HREF="manual.html#lua_KContext">lua_KContext</A><BR>
<A HREF="manual.html#lua_KFunction">lua_KFunction</A><BR>
<A HREF="manual.html#lua_Number">lua_Number</A><BR>
<A HREF="manual.html#lua_Reader">lua_Reader</A><BR>
<A HREF="manual.html#lua_State">lua_State</A><BR>
<A HREF="manual.html#lua_Unsigned">lua_Unsigned</A><BR>
<A HREF="manual.html#lua_Writer">lua_Writer</A><BR>

<P>
<A HREF="manual.html#lua_absindex">lua_absindex</A><BR>
<A HREF="manual.html#lua_arith">lua_arith</A><BR>
<A HREF="manual.html#lua_atpanic">lua_atpanic</A><BR>
<A HREF="manual.html#lua_call">lua_call</A><BR>
<A HREF="manual.html#lua_callk">lua_callk</A><BR>
<A HREF="manual.html#lua_checkstack">lua_checkstack</A><BR>
<A HREF="manual.html#lua_close">lua_close</A><BR>
<A HREF="manual.html#lua_compare">lua_compare</A><BR>
<A HREF="manual.html#lua_concat">lua_concat</A><BR>
<A HREF="manual.html#lua_copy">lua_copy</A><BR>
<A HREF="manual.html#lua_createtable">lua_createtable</A><BR>
<A HREF="manual.html#lua_dump">lua_dump</A><BR>
<A HREF="manual.html#lua_error">lua_error</A><BR>
<A HREF="manual.html#lua_gc">lua_gc</A><BR>
<A HREF="manual.html#lua_getallocf">lua_getallocf</A><BR>
<A HREF="manual.html#lua_getextraspace">lua_getextraspace</A><BR>
<A HREF="manual.html#lua_getfield">lua_getfield</A><BR>
<A HREF="manual.html#lua_getglobal">lua_getglobal</A><BR>
<A HREF="manual.html#lua_gethook">lua_gethook</A><BR>
<A HREF="manual.html#lua_gethookcount">lua_gethookcount</A><BR>
<A HREF="manual.html#lua_gethookmask">lua_gethookmask</A><BR>
<A HREF="manual.html#lua_geti">lua_geti</A><BR>
<A HREF="manual.html#lua_getinfo">lua_getinfo</A><BR>
<A HREF="manual.html#lua_getlocal">lua_getlocal</A><BR>
<A HREF="manual.html#lua_getmetatable">lua_getmetatable</A><BR>
<A HREF="manual.html#lua_getstack">lua_getstack</A><BR>
<A HREF="manual.html#lua_gettable">lua_gettable</A><BR>
<A HREF="manual.html#lua_gettop">lua_gettop</A><BR>
<A HREF="manual.html#lua_getupvalue">lua_getupvalue</A><BR>
<A HREF="manual.html#lua_getuservalue">lua_getuservalue</A><BR>
<A HREF="manual.html#lua_insert">lua_insert</A><BR>
<A HREF="manual.html#lua_isboolean">lua_isboolean</A><BR>
<A HREF="manual.html#lua_iscfunction">lua_iscfunction</A><BR>
<A HREF="manual.html#lua_isfunction">lua_isfunction</A><BR>
<A HREF="manual.html#lua_isinteger">lua_isinteger</A><BR>
<A HREF="manual.html#lua_islightuserdata">lua_islightuserdata</A><BR>
<A HREF="manual.html#lua_isnil">lua_isnil</A><BR>
<A HREF="manual.html#lua_isnone">lua_isnone</A><BR>
<A HREF="manual.html#lua_isnoneornil">lua_isnoneornil</A><BR>
<A HREF="manual.html#lua_isnumber">lua_isnumber</A><BR>
<A HREF="manual.html#lua_isstring">lua_isstring</A><BR>
<A HREF="manual.html#lua_istable">lua_istable</A><BR>
<A HREF="manual.html#lua_isthread">lua_isthread</A><BR>
<A HREF="manual.html#lua_isuserdata">lua_isuserdata</A><BR>
<A HREF="manual.html#lua_isyieldable">lua_isyieldable</A><BR>
<A HREF="manual.html#lua_len">lua_len</A><BR>
<A HREF="manual.html#lua_load">lua_load</A><BR>
<A HREF="manual.html#lua_newstate">lua_newstate</A><BR>
<A HREF="manual.html#lua_newtable">lua_newtable</A><BR>
<A HREF="manual.html#lua_newthread">lua_newthread</A><BR>
<A HREF="manual.html#lua_newuserdata">lua_newuserdata</A><BR>
<A HREF="manual.html#lua_next">lua_next</A><BR>
<A HREF="manual.html#lua_numbertointeger">lua_numbertointeger</A><BR>
<A HREF="manual.html#lua_pcall">lua_pcall</A><BR>
<A HREF="manual.html#lua_pcallk">lua_pcallk</A><BR>
<A HREF="manual.html#lua_pop">lua_pop</A><BR>
<A HREF="manual.html#lua_pushboolean">lua_pushboolean</A><BR>
<A HREF="manual.html#lua_pushcclosure">lua_pushcclosure</A><BR>
<A HREF="manual.html#lua_pushcfunction">lua_pushcfunction</A><BR>
<A HREF="manual.html#lua_pushfstring">lua_pushfstring</A><BR>
<A HREF="manual.html#lua_pushglobaltable">lua_pushglobaltable</A><BR>
<A HREF="manual.html#lua_pushinteger">lua_pushinteger</A><BR>
<A HREF="manual.html#lua_pushlightuserdata">lua_pushlightuserdata</A><BR>
<A HREF="manual.html#lua_pushliteral">lua_pushliteral</A><BR>
<A HREF="manual.html#lua_pushlstring">lua_pushlstring</A><BR>
<A HREF="manual.html#lua_pushnil">lua_pushnil</A><BR>
<A HREF="manual.html#lua_pushnumber">lua_pushnumber</A><BR>
<A HREF="manual.html#lua_pushstring">lua_pushstring</A><BR>
<A HREF="manual.html#lua_pushthread">lua_pushthread</A><BR>
<A HREF="manual.html#lua_pushvalue">lua_pushvalue</A><BR>
<A HREF="manual.html#lua_pushvfstring">lua_pushvfstring</A><BR>
<A HREF="manual.html#lua_rawequal">lua_rawequal</A><BR>
<A HREF="manual.html#lua_rawget">lua_rawget</A><BR>
<A HREF="manual.html#lua_rawgeti">lua_rawgeti</A><BR>
<A HREF="manual.html#lua_rawgetp">lua_rawgetp</A><BR>
<A HREF="manual.html#lua_rawlen">lua_rawlen</A><BR>
<A HREF="manual.html#lua_rawset">lua_rawset</A><BR>
<A HREF="manual.html#lua_rawseti">lua_rawseti</A><BR>
<A HREF="manual.html#lua_rawsetp">lua_rawsetp</A><BR>
<A HREF="manual.html#lua_register">lua_register</A><BR>
<A HREF="manual.html#lua_remove">lua_remove</A><BR>
<A HREF="manual.html#lua_replace">lua_replace</A><BR>
<A HREF="manual.html#lua_resume">lua_resume</A><BR>
<A HREF="manual.html#lua_rotate">lua_rotate</A><BR>
<A HREF="manual.html#lua_setallocf">lua_setallocf</A><BR>
<A HREF="manual.html#lua_setfield">lua_setfield</A><BR>
<A HREF="manual.html#lua_setglobal">lua_setglobal</A><BR>
<A HREF="manual.html#lua_sethook">lua_sethook</A><BR>
<A HREF="manual.html#lua_seti">lua_seti</A><BR>
<A HREF="manual.html#lua_setlocal">lua_setlocal</A><BR>
<A HREF="manual.html#lua_setmetatable">lua_setmetatable</A><BR>
<A HREF="manual.html#lua_settable">lua_settable</A><BR>
<A HREF="manual.html#lua_settop">lua_settop</A><BR>
<A HREF="manual.html#lua_setupvalue">lua_setupvalue</A><BR>
<A HREF="manual.html#lua_setuservalue">lua_setuservalue</A><BR>
<A HREF="manual.html#lua_status">lua_status</A><BR>
<A HREF="manual.html#lua_stringtonumber">lua_stringtonumber</A><BR>
<A HREF="manual.html#lua_toboolean">lua_toboolean</A><BR>
<A HREF="manual.html#lua_tocfunction">lua_tocfunction</A><BR>
<A HREF="manual.html#lua_tointeger">lua_tointeger</A><BR>
<A HREF="manual.html#lua_tointegerx">lua_tointegerx</A><BR>
<A HREF="manual.html#lua_tolstring">lua_tolstring</A><BR>
<A HREF="manual.html#lua_tonumber">lua_tonumber</A><BR>
<A HREF="manual.html#lua_tonumberx">lua_tonumberx</A><BR>
<A HREF="manual.html#lua_topointer">lua_topointer</A><BR>
<A HREF="manual.html#lua_tostring">lua_tostring</A><BR>
<A HREF="manual.html#lua_tothread">lua_tothread</A><BR>
<A HREF="manual.html#lua_touserdata">lua_touserdata</A><BR>
<A HREF="manual.html#lua_type">lua_type</A><BR>
<A HREF="manual.html#lua_typename">lua_typename</A><BR>
<A HREF="manual.html#lua_upvalueid">lua_upvalueid</A><BR>
<A HREF="manual.html#lua_upvalueindex">lua_upvalueindex</A><BR>
<A HREF="manual.html#lua_upvaluejoin">lua_upvaluejoin</A><BR>
<A HREF="manual.html#lua_version">lua_version</A><BR>
<A HREF="manual.html#lua_xmove">lua_xmove</A><BR>
<A HREF="manual.html#lua_yield">lua_yield</A><BR>
<A HREF="manual.html#lua_yieldk">lua_yieldk</A><BR>

</TD>
<TD>
<H3><A NAME="auxlib">auxiliary library</A></H3>
<P>
<A HREF="manual.html#luaL_Buffer">luaL_Buffer</A><BR>
<A HREF="manual.html#luaL_Reg">luaL_Reg</A><BR>
<A HREF="manual.html#luaL_Stream">luaL_Stream</A><BR>

<P>
<A HREF="manual.html#luaL_addchar">luaL_addchar</A><BR>
<A HREF="manual.html#luaL_addlstring">luaL_addlstring</A><BR>
<A HREF="manual.html#luaL_addsize">luaL_addsize</A><BR>
<A HREF="manual.html#luaL_addstring">luaL_addstring</A><BR>
<A HREF="manual.html#luaL_addvalue">luaL_addvalue</A><BR>
<A HREF="manual.html#luaL_argcheck">luaL_argcheck</A><BR>
<A HREF="manual.html#luaL_argerror">luaL_argerror</A><BR>
<A HREF="manual.html#luaL_buffinit">luaL_buffinit</A><BR>
<A HREF="manual.html#luaL_buffinitsize">luaL_buffinitsize</A><BR>
<A HREF="manual.html#luaL_callmeta">luaL_callmeta</A><BR>
<A HREF="manual.html#luaL_checkany">luaL_checkany</A><BR>
<A HREF="manual.html#luaL_checkinteger">luaL_checkinteger</A><BR>
<A HREF="manual.html#luaL_checklstring">luaL_checklstring</A><BR>
<A HREF="manual.html#luaL_checknumber">luaL_checknumber</A><BR>
<A HREF="manual.html#luaL_checkoption">luaL_checkoption</A><BR>
<A HREF="manual.html#luaL_checkstack">luaL_checkstack</A><BR>
<A HREF="manual.html#luaL_checkstring">luaL_checkstring</A><BR>
<A HREF="manual.html#luaL_checktype">luaL_checktype</A><BR>
<A HREF="manual.html#luaL_checkudata">luaL_checkudata</A><BR>
<A HREF="manual.html#luaL_checkversion">luaL_checkversion</A><BR>
<A HREF="manual.html#luaL_dofile">luaL_dofile</A><BR>
<A HREF="manual.html#luaL_dostring">luaL_dostring</A><BR>
<A HREF="manual.html#luaL_error">luaL_error</A><BR>
<A HREF="manual.html#luaL_execresult">luaL_execresult</A><BR>
<A HREF="manual.html#luaL_fileresult">luaL_fileresult</A><BR>
<A HREF="manual.html#luaL_getmetafield">luaL_getmetafield</A><BR>
<A HREF="manual.html#luaL_getmetatable">luaL_getmetatable</A><BR>
<A HREF="manual.html#luaL_getsubtable">luaL_getsubtable</A><BR>
<A HREF="manual.html#luaL_gsub">luaL_gsub</A><BR>
<A HREF="manual.html#luaL_len">luaL_len</A><BR>
<A HREF="manual.html#luaL_loadbuffer">luaL_loadbuffer</A><BR>
<A HREF="manual.html#luaL_loadbufferx">luaL_loadbufferx</A><BR>
<A HREF="manual.html#luaL_loadfile">luaL_loadfile</A><BR>
<A HREF="manual.html#luaL_loadfilex">luaL_loadfilex</A><BR>
<A HREF="manual.html#luaL_loadstring">luaL_loadstring</A><BR>
<A HREF="manual.html#luaL_newlib">luaL_newlib</A><BR>
<A HREF="manual.html#luaL_newlibtable">luaL_newlibtable</A><BR>
<A HREF="manual.html#luaL_newmetatable">luaL_newmetatable</A><BR>
<A HREF="manual.html#luaL_newstate">luaL_newstate</A><BR>
<A HREF="manual.html#luaL_openlibs">luaL_openlibs</A><BR>
<A HREF="manual.html#luaL_opt">luaL_opt</A><BR>
<A HREF="manual.html#luaL_optinteger">luaL_optinteger</A><BR>
<A HREF="manual.html#luaL_optlstring">luaL_optlstring</A><BR>
<A HREF="manual.html#luaL_optnumber">luaL_optnumber</A><BR>
<A HREF="manual.html#luaL_optstring">luaL_optstring</A><BR>
<A HREF="manual.html#luaL_prepbuffer">luaL_prepbuffer</A><BR>
<A HREF="manual.html#luaL_prepbuffsize">luaL_prepbuffsize</A><BR>
<A HREF="manual.html#luaL_pushresult">luaL_pushresult</A><BR>
<A HREF="manual.html#luaL_pushresultsize">luaL_pushresultsize</A><BR>
<A HREF="manual.html#luaL_ref">luaL_ref</A><BR>
<A HREF="manual.html#luaL_requiref">luaL_requiref</A><BR>
<A HREF="manual.html#luaL_setfuncs">luaL_setfuncs</A><BR>
<A HREF="manual.html#luaL_setmetatable">luaL_setmetatable</A><BR>
<A HREF="manual.html#luaL_testudata">luaL_testudata</A><BR>
<A HREF="manual.html#luaL_tolstring">luaL_tolstring</A><BR>
<A HREF="manual.html#luaL_traceback">luaL_traceback</A><BR>
<A HREF="manual.html#luaL_typename">luaL_typename</A><BR>
<A HREF="manual.html#luaL_unref">luaL_unref</A><BR>
<A HREF="manual.html#luaL_where">luaL_where</A><BR>

<H3><A NAME="library">standard library</A></H3>
<P>
<A HREF="manual.html#pdf-luaopen_base">luaopen_base</A><BR>
<A HREF="manual.html#pdf-luaopen_coroutine">luaopen_coroutine</A><BR>
<A HREF="manual.html#pdf-luaopen_debug">luaopen_debug</A><BR>
<A HREF="manual.html#pdf-luaopen_io">luaopen_io</A><BR>
<A HREF="manual.html#pdf-luaopen_math">luaopen_math</A><BR>
<A HREF="manual.html#pdf-luaopen_os">luaopen_os</A><BR>
<A HREF="manual.html#pdf-luaopen_package">luaopen_package</A><BR>
<A HREF="manual.html#pdf-luaopen_string">luaopen_string</A><BR>
<A HREF="manual.html#pdf-luaopen_table">luaopen_table</A><BR>
<A HREF="manual.html#pdf-luaopen_utf8">luaopen_utf8</A><BR>

<H3><A NAME="constants">constants</A></H3>
<P>
<A HREF="manual.html#pdf-LUA_ERRERR">LUA_ERRERR</A><BR>
<A HREF="manual.html#pdf-LUA_ERRFILE">LUA_ERRFILE</A><BR>
<A HREF="manual.html#pdf-LUA_ERRGCMM">LUA_ERRGCMM</A><BR>
<A HREF="manual.html#pdf-LUA_ERRMEM">LUA_ERRMEM</A><BR>
<A HREF="manual.html#pdf-LUA_ERRRUN">LUA_ERRRUN</A><BR>
<A HREF="manual.html#pdf-LUA_ERRSYNTAX">LUA_ERRSYNTAX</A><BR>
<A HREF="manual.html#pdf-LUA_HOOKCALL">LUA_HOOKCALL</A><BR>
<A HREF="manual.html#pdf-LUA_HOOKCOUNT">LUA_HOOKCOUNT</A><BR>
<A HREF="manual.html#pdf-LUA_HOOKLINE">LUA_HOOKLINE</A><BR>
<A HREF="manual.html#pdf-LUA_HOOKRET">LUA_HOOKRET</A><BR>
<A HREF="manual.html#pdf-LUA_HOOKTAILCALL">LUA_HOOKTAILCALL</A><BR>
<A HREF="manual.html#pdf-LUA_MASKCALL">LUA_MASKCALL</A><BR>
<A HREF="manual.html#pdf-LUA_MASKCOUNT">LUA_MASKCOUNT</A><BR>
<A HREF="manual.html#pdf-LUA_MASKLINE">LUA_MASKLINE</A><BR>
<A HREF="manual.html#pdf-LUA_MASKRET">LUA_MASKRET</A><BR>
<A HREF="manual.html#pdf-LUA_MAXINTEGER">LUA_MAXINTEGER</A><BR>
<A HREF="manual.html#pdf-LUA_MININTEGER">LUA_MININTEGER</A><BR>
<A HREF="manual.html#pdf-LUA_MINSTACK">LUA_MINSTACK</A><BR>
<A HREF="manual.html#pdf-LUA_MULTRET">LUA_MULTRET</A><BR>
<A HREF="manual.html#pdf-LUA_NOREF">LUA_NOREF</A><BR>
<A HREF="manual.html#pdf-LUA_OK">LUA_OK</A><BR>
<A HREF="manual.html#pdf-LUA_OPADD">LUA_OPADD</A><BR>
<A HREF="manual.html#pdf-LUA_OPBAND">LUA_OPBAND</A><BR>
<A HREF="manual.html#pdf-LUA_OPBNOT">LUA_OPBNOT</A><BR>
<A HREF="manual.html#pdf-LUA_OPBOR">LUA_OPBOR</A><BR>
<A HREF="manual.html#pdf-LUA_OPBXOR">LUA_OPBXOR</A><BR>
<A HREF="manual.html#pdf-LUA_OPDIV">LUA_OPDIV</A><BR>
<A HREF="manual.html#pdf-LUA_OPEQ">LUA_OPEQ</A><BR>
<A HREF="manual.html#pdf-LUA_OPIDIV">LUA_OPIDIV</A><BR>
<A HREF="manual.html#pdf-LUA_OPLE">LUA_OPLE</A><BR>
<A HREF="manual.html#pdf-LUA_OPLT">LUA_OPLT</A><BR>
<A HREF="manual.html#pdf-LUA_OPMOD">LUA_OPMOD</A><BR>
<A HREF="manual.html#pdf-LUA_OPMUL">LUA_OPMUL</A><BR>
<A HREF="manual.html#pdf-LUA_OPPOW">LUA_OPPOW</A><BR>
<A HREF="manual.html#pdf-LUA_OPSHL">LUA_OPSHL</A><BR>
<A HREF="manual.html#pdf-LUA_OPSHR">LUA_OPSHR</A><BR>
<A HREF="manual.html#pdf-LUA_OPSUB">LUA_OPSUB</A><BR>
<A HREF="manual.html#pdf-LUA_OPUNM">LUA_OPUNM</A><BR>
<A HREF="manual.html#pdf-LUA_REFNIL">LUA_REFNIL</A><BR>
<A HREF="manual.html#pdf-LUA_REGISTRYINDEX">LUA_REGISTRYINDEX</A><BR>
<A HREF="manual.html#pdf-LUA_RIDX_GLOBALS">LUA_RIDX_GLOBALS</A><BR>
<A HREF="manual.html#pdf-LUA_RIDX_MAINTHREAD">LUA_RIDX_MAINTHREAD</A><BR>
<A HREF="manual.html#pdf-LUA_TBOOLEAN">LUA_TBOOLEAN</A><BR>
<A HREF="manual.html#pdf-LUA_TFUNCTION">LUA_TFUNCTION</A><BR>
<A HREF="manual.html#pdf-LUA_TLIGHTUSERDATA">LUA_TLIGHTUSERDATA</A><BR>
<A HREF="manual.html#pdf-LUA_TNIL">LUA_TNIL</A><BR>
<A HREF="manual.html#pdf-LUA_TNONE">LUA_TNONE</A><BR>
<A HREF="manual.html#pdf-LUA_TNUMBER">LUA_TNUMBER</A><BR>
<A HREF="manual.html#pdf-LUA_TSTRING">LUA_TSTRING</A><BR>
<A HREF="manual.html#pdf-LUA_TTABLE">LUA_TTABLE</A><BR>
<A HREF="manual.html#pdf-LUA_TTHREAD">LUA_TTHREAD</A><BR>
<A HREF="manual.html#pdf-LUA_TUSERDATA">LUA_TUSERDATA</A><BR>
<A HREF="manual.html#pdf-LUA_USE_APICHECK">LUA_USE_APICHECK</A><BR>
<A HREF="manual.html#pdf-LUA_YIELD">LUA_YIELD</A><BR>
<A HREF="manual.html#pdf-LUAL_BUFFERSIZE">LUAL_BUFFERSIZE</A><BR>

</TD>
</TR>
</TABLE>

<P CLASS="footer">
Last update:
Tue Aug 25 13:45:14 UTC 2020
</P>
<!--
Last change: revised for Lua 5.3.6
-->

</BODY>
</HTML>



================================================
File: lua/doc/index.css
================================================
ul {
	list-style-type: none ;
}

ul.contents {
	padding: 0 ;
}

table {
	border: none ;
	border-spacing: 0 ;
	border-collapse: collapse ;
}

td {
	vertical-align: top ;
	padding: 0 ;
	text-align: left ;
	line-height: 1.25 ;
	width: 15% ;
}



================================================
File: lua/doc/lua.1
================================================
.\" $Id: lua.man,v 1.14 2016/10/17 15:43:50 lhf Exp $
.TH LUA 1 "$Date: 2016/10/17 15:43:50 $"
.SH NAME
lua \- Lua interpreter
.SH SYNOPSIS
.B lua
[
.I options
]
[
.I script
[
.I args
]
]
.SH DESCRIPTION
.B lua
is the standalone Lua interpreter.
It loads and executes Lua programs,
either in textual source form or
in precompiled binary form.
(Precompiled binaries are output by
.BR luac ,
the Lua compiler.)
.B lua
can be used as a batch interpreter and also interactively.
.LP
The given
.I options
are handled in order and then
the Lua program in file
.I script
is loaded and executed.
The given
.I args
are available to
.I script
as strings in a global table named
.BR arg .
If no options or arguments are given,
then
.B "\-v \-i"
is assumed when the standard input is a terminal;
otherwise,
.B "\-"
is assumed.
.LP
In interactive mode,
.B lua
prompts the user,
reads lines from the standard input,
and executes them as they are read.
If the line contains an expression or list of expressions,
then the line is evaluated and the results are printed.
If a line does not contain a complete statement,
then a secondary prompt is displayed and
lines are read until a complete statement is formed or
a syntax error is found.
.LP
At the very start,
before even handling the command line,
.B lua
checks the contents of the environment variables
.B LUA_INIT_5_3
or
.BR LUA_INIT ,
in that order.
If the contents is of the form
.RI '@ filename ',
then
.I filename
is executed.
Otherwise, the string is assumed to be a Lua statement and is executed.
.SH OPTIONS
.TP
.BI \-e " stat"
execute statement
.IR stat .
.TP
.B \-i
enter interactive mode after executing
.IR script .
.TP
.BI \-l " name"
execute the equivalent of
.IB name =require(' name ')
before executing
.IR script .
.TP
.B \-v
show version information.
.TP
.B \-E
ignore environment variables.
.TP
.B \-\-
stop handling options.
.TP
.B \-
stop handling options and execute the standard input as a file.
.SH "SEE ALSO"
.BR luac (1)
.br
The documentation at lua.org,
especially section 7 of the reference manual.
.SH DIAGNOSTICS
Error messages should be self explanatory.
.SH AUTHORS
R. Ierusalimschy,
L. H. de Figueiredo,
W. Celes
.\" EOF



================================================
File: lua/doc/lua.css
================================================
html {
	background-color: #F8F8F8 ;
}

body {
	background-color: #FFFFFF ;
	color: #000000 ;
	font-family: Helvetica, Arial, sans-serif ;
	text-align: justify ;
	line-height: 1.25 ;
	margin: 16px auto ;
	padding: 32px ;
	border: solid #ccc 1px ;
	border-radius: 20px ;
	max-width: 70em ;
	width: 90% ;
}

h1, h2, h3, h4 {
	color: #000080 ;
	font-family: Verdana, Geneva, sans-serif ;
	font-weight: normal ;
	font-style: normal ;
	text-align: left ;
}

h1 {
	font-size: 28pt ;
}

h1 img {
	vertical-align: text-bottom ;
}

h2:before {
	content: "\2756" ;
	padding-right: 0.5em ;
}

a {
	text-decoration: none ;
}

a:link {
	color: #000080 ;
}

a:link:hover, a:visited:hover {
	background-color: #D0D0FF ;
	color: #000080 ;
	border-radius: 4px ;
}

a:link:active, a:visited:active {
	color: #FF0000 ;
}

div.menubar {
	padding-bottom: 0.5em ;
}

p.menubar {
	margin-left: 2.5em ;
}

.menubar a:hover  {
	margin: -3px -3px -3px -3px ;
	padding: 3px  3px  3px  3px ;
	border-radius: 4px ;
}

:target {
	background-color: #F0F0F0 ;
	margin: -8px ;
	padding: 8px ;
	border-radius: 8px ;
	outline: none ;
}

hr {
	display: none ;
}

table hr {
	background-color: #a0a0a0 ;
	color: #a0a0a0 ;
	border: 0 ;
	height: 1px ;
	display: block ;
}

.footer {
	color: gray ;
	font-size: x-small ;
	text-transform: lowercase ;
}

input[type=text] {
	border: solid #a0a0a0 2px ;
	border-radius: 2em ;
	background-image: url('images/search.png') ;
	background-repeat: no-repeat ;
	background-position: 4px center ;
	padding-left: 20px ;
	height: 2em ;
}

pre.session {
	background-color: #F8F8F8 ;
	padding: 1em ;
	border-radius: 8px ;
}

table {
	border: none ;
	border-spacing: 0 ;
	border-collapse: collapse ;
}

td {
	padding: 0 ;
	margin: 0 ;
}

td.gutter {
	width: 4% ;
}

table.columns td {
	vertical-align: top ;
	padding-bottom: 1em ;
	text-align: justify ;
	line-height: 1.25 ;
}

table.book td {
	vertical-align: top ;
}

table.book td.cover {
	padding-right: 1em ;
}

table.book img {
	border: solid #000080 1px ;
}

table.book span {
	font-size: small ;
	text-align: left ;
	display: block ;
	margin-top: 0.25em ;
}

p.logos a:link:hover, p.logos a:visited:hover {
	background-color: inherit ;
}

img {
	background-color: white ;
}



================================================
File: lua/doc/luac.1
================================================
.\" $Id: luac.man,v 1.29 2011/11/16 13:53:40 lhf Exp $
.TH LUAC 1 "$Date: 2011/11/16 13:53:40 $"
.SH NAME
luac \- Lua compiler
.SH SYNOPSIS
.B luac
[
.I options
] [
.I filenames
]
.SH DESCRIPTION
.B luac
is the Lua compiler.
It translates programs written in the Lua programming language
into binary files containing precompiled chunks
that can be later loaded and executed.
.LP
The main advantages of precompiling chunks are:
faster loading,
protecting source code from accidental user changes,
and
off-line syntax checking.
Precompiling does not imply faster execution
because in Lua chunks are always compiled into bytecodes before being executed.
.B luac
simply allows those bytecodes to be saved in a file for later execution.
Precompiled chunks are not necessarily smaller than the corresponding source.
The main goal in precompiling is faster loading.
.LP
In the command line,
you can mix
text files containing Lua source and
binary files containing precompiled chunks.
.B luac
produces a single output file containing the combined bytecodes
for all files given.
Executing the combined file is equivalent to executing the given files.
By default,
the output file is named
.BR luac.out ,
but you can change this with the
.B \-o
option.
.LP
Precompiled chunks are
.I not
portable across different architectures.
Moreover,
the internal format of precompiled chunks
is likely to change when a new version of Lua is released.
Make sure you save the source files of all Lua programs that you precompile.
.LP
.SH OPTIONS
.TP
.B \-l
produce a listing of the compiled bytecode for Lua's virtual machine.
Listing bytecodes is useful to learn about Lua's virtual machine.
If no files are given, then
.B luac
loads
.B luac.out
and lists its contents.
Use
.B \-l \-l
for a full listing.
.TP
.BI \-o " file"
output to
.IR file ,
instead of the default
.BR luac.out .
(You can use
.B "'\-'"
for standard output,
but not on platforms that open standard output in text mode.)
The output file may be one of the given files because
all files are loaded before the output file is written.
Be careful not to overwrite precious files.
.TP
.B \-p
load files but do not generate any output file.
Used mainly for syntax checking and for testing precompiled chunks:
corrupted files will probably generate errors when loaded.
If no files are given, then
.B luac
loads
.B luac.out
and tests its contents.
No messages are displayed if the file loads without errors.
.TP
.B \-s
strip debug information before writing the output file.
This saves some space in very large chunks,
but if errors occur when running a stripped chunk,
then the error messages may not contain the full information they usually do.
In particular,
line numbers and names of local variables are lost.
.TP
.B \-v
show version information.
.TP
.B \-\-
stop handling options.
.TP
.B \-
stop handling options and process standard input.
.SH "SEE ALSO"
.BR lua (1)
.br
The documentation at lua.org.
.SH DIAGNOSTICS
Error messages should be self explanatory.
.SH AUTHORS
R. Ierusalimschy,
L. H. de Figueiredo,
W. Celes
.\" EOF



================================================
File: lua/doc/manual.css
================================================
h3 code {
	font-family: inherit ;
	font-size: inherit ;
}

pre, code {
	font-size: 12pt ;
}

span.apii {
	color: gray ;
	float: right ;
	font-family: inherit ;
	font-style: normal ;
	font-size: small ;
}

h2:before {
	content: "" ;
	padding-right: 0em ;
}



================================================
File: lua/doc/manual.html
================================================
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 Reference Manual</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="lua.css">
<LINK REL="stylesheet" TYPE="text/css" HREF="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
</HEAD>

<BODY>

<H1>
<A HREF="http://www.lua.org/"><IMG SRC="logo.gif" ALT="Lua"></A>
Lua 5.3 Reference Manual
</H1>

<P>
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes

<P>
<SMALL>
Copyright &copy; 2015&ndash;2020 Lua.org, PUC-Rio.
Freely available under the terms of the
<a href="http://www.lua.org/license.html">Lua license</a>.
</SMALL>

<DIV CLASS="menubar">
<A HREF="contents.html#contents">contents</A>
&middot;
<A HREF="contents.html#index">index</A>
&middot;
<A HREF="http://www.lua.org/manual/">other versions</A>
</DIV>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.167.1.2 2018/06/26 15:49:07 roberto Exp $ -->




<h1>1 &ndash; <a name="1">Introduction</a></h1>

<p>
Lua is a powerful, efficient, lightweight, embeddable scripting language.
It supports procedural programming,
object-oriented programming, functional programming,
data-driven programming, and data description.


<p>
Lua combines simple procedural syntax with powerful data description
constructs based on associative arrays and extensible semantics.
Lua is dynamically typed,
runs by interpreting bytecode with a register-based
virtual machine,
and has automatic memory management with
incremental garbage collection,
making it ideal for configuration, scripting,
and rapid prototyping.


<p>
Lua is implemented as a library, written in <em>clean C</em>,
the common subset of Standard&nbsp;C and C++.
The Lua distribution includes a host program called <code>lua</code>,
which uses the Lua library to offer a complete,
standalone Lua interpreter,
for interactive or batch use.
Lua is intended to be used both as a powerful, lightweight,
embeddable scripting language for any program that needs one,
and as a powerful but lightweight and efficient stand-alone language.


<p>
As an extension language, Lua has no notion of a "main" program:
it works <em>embedded</em> in a host client,
called the <em>embedding program</em> or simply the <em>host</em>.
(Frequently, this host is the stand-alone <code>lua</code> program.)
The host program can invoke functions to execute a piece of Lua code,
can write and read Lua variables,
and can register C&nbsp;functions to be called by Lua code.
Through the use of C&nbsp;functions, Lua can be augmented to cope with
a wide range of different domains,
thus creating customized programming languages sharing a syntactical framework.


<p>
Lua is free software,
and is provided as usual with no guarantees,
as stated in its license.
The implementation described in this manual is available
at Lua's official web site, <code>www.lua.org</code>.


<p>
Like any other reference manual,
this document is dry in places.
For a discussion of the decisions behind the design of Lua,
see the technical papers available at Lua's web site.
For a detailed introduction to programming in Lua,
see Roberto's book, <em>Programming in Lua</em>.



<h1>2 &ndash; <a name="2">Basic Concepts</a></h1>

<p>
This section describes the basic concepts of the language.



<h2>2.1 &ndash; <a name="2.1">Values and Types</a></h2>

<p>
Lua is a <em>dynamically typed language</em>.
This means that
variables do not have types; only values do.
There are no type definitions in the language.
All values carry their own type.


<p>
All values in Lua are <em>first-class values</em>.
This means that all values can be stored in variables,
passed as arguments to other functions, and returned as results.


<p>
There are eight basic types in Lua:
<em>nil</em>, <em>boolean</em>, <em>number</em>,
<em>string</em>, <em>function</em>, <em>userdata</em>,
<em>thread</em>, and <em>table</em>.
The type <em>nil</em> has one single value, <b>nil</b>,
whose main property is to be different from any other value;
it usually represents the absence of a useful value.
The type <em>boolean</em> has two values, <b>false</b> and <b>true</b>.
Both <b>nil</b> and <b>false</b> make a condition false;
any other value makes it true.
The type <em>number</em> represents both
integer numbers and real (floating-point) numbers.
The type <em>string</em> represents immutable sequences of bytes.

Lua is 8-bit clean:
strings can contain any 8-bit value,
including embedded zeros ('<code>\0</code>').
Lua is also encoding-agnostic;
it makes no assumptions about the contents of a string.


<p>
The type <em>number</em> uses two internal representations,
or two subtypes,
one called <em>integer</em> and the other called <em>float</em>.
Lua has explicit rules about when each representation is used,
but it also converts between them automatically as needed (see <a href="#3.4.3">&sect;3.4.3</a>).
Therefore,
the programmer may choose to mostly ignore the difference
between integers and floats
or to assume complete control over the representation of each number.
Standard Lua uses 64-bit integers and double-precision (64-bit) floats,
but you can also compile Lua so that it
uses 32-bit integers and/or single-precision (32-bit) floats.
The option with 32 bits for both integers and floats
is particularly attractive
for small machines and embedded systems.
(See macro <code>LUA_32BITS</code> in file <code>luaconf.h</code>.)


<p>
Lua can call (and manipulate) functions written in Lua and
functions written in C (see <a href="#3.4.10">&sect;3.4.10</a>).
Both are represented by the type <em>function</em>.


<p>
The type <em>userdata</em> is provided to allow arbitrary C&nbsp;data to
be stored in Lua variables.
A userdata value represents a block of raw memory.
There are two kinds of userdata:
<em>full userdata</em>,
which is an object with a block of memory managed by Lua,
and <em>light userdata</em>,
which is simply a C&nbsp;pointer value.
Userdata has no predefined operations in Lua,
except assignment and identity test.
By using <em>metatables</em>,
the programmer can define operations for full userdata values
(see <a href="#2.4">&sect;2.4</a>).
Userdata values cannot be created or modified in Lua,
only through the C&nbsp;API.
This guarantees the integrity of data owned by the host program.


<p>
The type <em>thread</em> represents independent threads of execution
and it is used to implement coroutines (see <a href="#2.6">&sect;2.6</a>).
Lua threads are not related to operating-system threads.
Lua supports coroutines on all systems,
even those that do not support threads natively.


<p>
The type <em>table</em> implements associative arrays,
that is, arrays that can have as indices not only numbers,
but any Lua value except <b>nil</b> and NaN.
(<em>Not a Number</em> is a special value used to represent
undefined or unrepresentable numerical results, such as <code>0/0</code>.)
Tables can be <em>heterogeneous</em>;
that is, they can contain values of all types (except <b>nil</b>).
Any key with value <b>nil</b> is not considered part of the table.
Conversely, any key that is not part of a table has
an associated value <b>nil</b>.


<p>
Tables are the sole data-structuring mechanism in Lua;
they can be used to represent ordinary arrays, lists,
symbol tables, sets, records, graphs, trees, etc.
To represent records, Lua uses the field name as an index.
The language supports this representation by
providing <code>a.name</code> as syntactic sugar for <code>a["name"]</code>.
There are several convenient ways to create tables in Lua
(see <a href="#3.4.9">&sect;3.4.9</a>).


<p>
Like indices,
the values of table fields can be of any type.
In particular,
because functions are first-class values,
table fields can contain functions.
Thus tables can also carry <em>methods</em> (see <a href="#3.4.11">&sect;3.4.11</a>).


<p>
The indexing of tables follows
the definition of raw equality in the language.
The expressions <code>a[i]</code> and <code>a[j]</code>
denote the same table element
if and only if <code>i</code> and <code>j</code> are raw equal
(that is, equal without metamethods).
In particular, floats with integral values
are equal to their respective integers
(e.g., <code>1.0 == 1</code>).
To avoid ambiguities,
any float with integral value used as a key
is converted to its respective integer.
For instance, if you write <code>a[2.0] = true</code>,
the actual key inserted into the table will be the
integer <code>2</code>.
(On the other hand,
2 and "<code>2</code>" are different Lua values and therefore
denote different table entries.)


<p>
Tables, functions, threads, and (full) userdata values are <em>objects</em>:
variables do not actually <em>contain</em> these values,
only <em>references</em> to them.
Assignment, parameter passing, and function returns
always manipulate references to such values;
these operations do not imply any kind of copy.


<p>
The library function <a href="#pdf-type"><code>type</code></a> returns a string describing the type
of a given value (see <a href="#6.1">&sect;6.1</a>).





<h2>2.2 &ndash; <a name="2.2">Environments and the Global Environment</a></h2>

<p>
As will be discussed in <a href="#3.2">&sect;3.2</a> and <a href="#3.3.3">&sect;3.3.3</a>,
any reference to a free name
(that is, a name not bound to any declaration) <code>var</code>
is syntactically translated to <code>_ENV.var</code>.
Moreover, every chunk is compiled in the scope of
an external local variable named <code>_ENV</code> (see <a href="#3.3.2">&sect;3.3.2</a>),
so <code>_ENV</code> itself is never a free name in a chunk.


<p>
Despite the existence of this external <code>_ENV</code> variable and
the translation of free names,
<code>_ENV</code> is a completely regular name.
In particular,
you can define new variables and parameters with that name.
Each reference to a free name uses the <code>_ENV</code> that is
visible at that point in the program,
following the usual visibility rules of Lua (see <a href="#3.5">&sect;3.5</a>).


<p>
Any table used as the value of <code>_ENV</code> is called an <em>environment</em>.


<p>
Lua keeps a distinguished environment called the <em>global environment</em>.
This value is kept at a special index in the C registry (see <a href="#4.5">&sect;4.5</a>).
In Lua, the global variable <a href="#pdf-_G"><code>_G</code></a> is initialized with this same value.
(<a href="#pdf-_G"><code>_G</code></a> is never used internally.)


<p>
When Lua loads a chunk,
the default value for its <code>_ENV</code> upvalue
is the global environment (see <a href="#pdf-load"><code>load</code></a>).
Therefore, by default,
free names in Lua code refer to entries in the global environment
(and, therefore, they are also called <em>global variables</em>).
Moreover, all standard libraries are loaded in the global environment
and some functions there operate on that environment.
You can use <a href="#pdf-load"><code>load</code></a> (or <a href="#pdf-loadfile"><code>loadfile</code></a>)
to load a chunk with a different environment.
(In C, you have to load the chunk and then change the value
of its first upvalue.)





<h2>2.3 &ndash; <a name="2.3">Error Handling</a></h2>

<p>
Because Lua is an embedded extension language,
all Lua actions start from C&nbsp;code in the host program
calling a function from the Lua library.
(When you use Lua standalone,
the <code>lua</code> application is the host program.)
Whenever an error occurs during
the compilation or execution of a Lua chunk,
control returns to the host,
which can take appropriate measures
(such as printing an error message).


<p>
Lua code can explicitly generate an error by calling the
<a href="#pdf-error"><code>error</code></a> function.
If you need to catch errors in Lua,
you can use <a href="#pdf-pcall"><code>pcall</code></a> or <a href="#pdf-xpcall"><code>xpcall</code></a>
to call a given function in <em>protected mode</em>.


<p>
Whenever there is an error,
an <em>error object</em> (also called an <em>error message</em>)
is propagated with information about the error.
Lua itself only generates errors whose error object is a string,
but programs may generate errors with
any value as the error object.
It is up to the Lua program or its host to handle such error objects.


<p>
When you use <a href="#pdf-xpcall"><code>xpcall</code></a> or <a href="#lua_pcall"><code>lua_pcall</code></a>,
you may give a <em>message handler</em>
to be called in case of errors.
This function is called with the original error object
and returns a new error object.
It is called before the error unwinds the stack,
so that it can gather more information about the error,
for instance by inspecting the stack and creating a stack traceback.
This message handler is still protected by the protected call;
so, an error inside the message handler
will call the message handler again.
If this loop goes on for too long,
Lua breaks it and returns an appropriate message.
(The message handler is called only for regular runtime errors.
It is not called for memory-allocation errors
nor for errors while running finalizers.)





<h2>2.4 &ndash; <a name="2.4">Metatables and Metamethods</a></h2>

<p>
Every value in Lua can have a <em>metatable</em>.
This <em>metatable</em> is an ordinary Lua table
that defines the behavior of the original value
under certain special operations.
You can change several aspects of the behavior
of operations over a value by setting specific fields in its metatable.
For instance, when a non-numeric value is the operand of an addition,
Lua checks for a function in the field "<code>__add</code>" of the value's metatable.
If it finds one,
Lua calls this function to perform the addition.


<p>
The key for each event in a metatable is a string
with the event name prefixed by two underscores;
the corresponding values are called <em>metamethods</em>.
In the previous example, the key is "<code>__add</code>"
and the metamethod is the function that performs the addition.
Unless stated otherwise,
metamethods should be function values.


<p>
You can query the metatable of any value
using the <a href="#pdf-getmetatable"><code>getmetatable</code></a> function.
Lua queries metamethods in metatables using a raw access (see <a href="#pdf-rawget"><code>rawget</code></a>).
So, to retrieve the metamethod for event <code>ev</code> in object <code>o</code>,
Lua does the equivalent to the following code:

<pre>
     rawget(getmetatable(<em>o</em>) or {}, "__<em>ev</em>")
</pre>

<p>
You can replace the metatable of tables
using the <a href="#pdf-setmetatable"><code>setmetatable</code></a> function.
You cannot change the metatable of other types from Lua code
(except by using the debug library (<a href="#6.10">&sect;6.10</a>));
you should use the C&nbsp;API for that.


<p>
Tables and full userdata have individual metatables
(although multiple tables and userdata can share their metatables).
Values of all other types share one single metatable per type;
that is, there is one single metatable for all numbers,
one for all strings, etc.
By default, a value has no metatable,
but the string library sets a metatable for the string type (see <a href="#6.4">&sect;6.4</a>).


<p>
A metatable controls how an object behaves in
arithmetic operations, bitwise operations,
order comparisons, concatenation, length operation, calls, and indexing.
A metatable also can define a function to be called
when a userdata or a table is garbage collected (<a href="#2.5">&sect;2.5</a>).


<p>
For the unary operators (negation, length, and bitwise NOT),
the metamethod is computed and called with a dummy second operand,
equal to the first one.
This extra operand is only to simplify Lua's internals
(by making these operators behave like a binary operation)
and may be removed in future versions.
(For most uses this extra operand is irrelevant.)


<p>
A detailed list of events controlled by metatables is given next.
Each operation is identified by its corresponding key.



<ul>

<li><b><code>__add</code>: </b>
the addition (<code>+</code>) operation.
If any operand for an addition is not a number
(nor a string coercible to a number),
Lua will try to call a metamethod.
First, Lua will check the first operand (even if it is valid).
If that operand does not define a metamethod for <code>__add</code>,
then Lua will check the second operand.
If Lua can find a metamethod,
it calls the metamethod with the two operands as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
Otherwise,
it raises an error.
</li>

<li><b><code>__sub</code>: </b>
the subtraction (<code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mul</code>: </b>
the multiplication (<code>*</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__div</code>: </b>
the division (<code>/</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__mod</code>: </b>
the modulo (<code>%</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__pow</code>: </b>
the exponentiation (<code>^</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__unm</code>: </b>
the negation (unary <code>-</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__idiv</code>: </b>
the floor division (<code>//</code>) operation.
Behavior similar to the addition operation.
</li>

<li><b><code>__band</code>: </b>
the bitwise AND (<code>&amp;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither an integer
nor a value coercible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>).
</li>

<li><b><code>__bor</code>: </b>
the bitwise OR (<code>|</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bxor</code>: </b>
the bitwise exclusive OR (binary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__bnot</code>: </b>
the bitwise NOT (unary <code>~</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shl</code>: </b>
the bitwise left shift (<code>&lt;&lt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__shr</code>: </b>
the bitwise right shift (<code>&gt;&gt;</code>) operation.
Behavior similar to the bitwise AND operation.
</li>

<li><b><code>__concat</code>: </b>
the concatenation (<code>..</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod
if any operand is neither a string nor a number
(which is always coercible to a string).
</li>

<li><b><code>__len</code>: </b>
the length (<code>#</code>) operation.
If the object is not a string,
Lua will try its metamethod.
If there is a metamethod,
Lua calls it with the object as argument,
and the result of the call
(always adjusted to one value)
is the result of the operation.
If there is no metamethod but the object is a table,
then Lua uses the table length operation (see <a href="#3.4.7">&sect;3.4.7</a>).
Otherwise, Lua raises an error.
</li>

<li><b><code>__eq</code>: </b>
the equal (<code>==</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are either both tables or both full userdata
and they are not primitively equal.
The result of the call is always converted to a boolean.
</li>

<li><b><code>__lt</code>: </b>
the less than (<code>&lt;</code>) operation.
Behavior similar to the addition operation,
except that Lua will try a metamethod only when the values
being compared are neither both numbers nor both strings.
The result of the call is always converted to a boolean.
</li>

<li><b><code>__le</code>: </b>
the less equal (<code>&lt;=</code>) operation.
Unlike other operations,
the less-equal operation can use two different events.
First, Lua looks for the <code>__le</code> metamethod in both operands,
like in the less than operation.
If it cannot find such a metamethod,
then it will try the <code>__lt</code> metamethod,
assuming that <code>a &lt;= b</code> is equivalent to <code>not (b &lt; a)</code>.
As with the other comparison operators,
the result is always a boolean.
(This use of the <code>__lt</code> event can be removed in future versions;
it is also slower than a real <code>__le</code> metamethod.)
</li>

<li><b><code>__index</code>: </b>
The indexing access operation <code>table[key]</code>.
This event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metamethod is looked up in <code>table</code>.


<p>
Despite the name,
the metamethod for this event can be either a function or a table.
If it is a function,
it is called with <code>table</code> and <code>key</code> as arguments,
and the result of the call
(adjusted to one value)
is the result of the operation.
If it is a table,
the final result is the result of indexing this table with <code>key</code>.
(This indexing is regular, not raw,
and therefore can trigger another metamethod.)
</li>

<li><b><code>__newindex</code>: </b>
The indexing assignment <code>table[key] = value</code>.
Like the index event,
this event happens when <code>table</code> is not a table or
when <code>key</code> is not present in <code>table</code>.
The metamethod is looked up in <code>table</code>.


<p>
Like with indexing,
the metamethod for this event can be either a function or a table.
If it is a function,
it is called with <code>table</code>, <code>key</code>, and <code>value</code> as arguments.
If it is a table,
Lua does an indexing assignment to this table with the same key and value.
(This assignment is regular, not raw,
and therefore can trigger another metamethod.)


<p>
Whenever there is a <code>__newindex</code> metamethod,
Lua does not perform the primitive assignment.
(If necessary,
the metamethod itself can call <a href="#pdf-rawset"><code>rawset</code></a>
to do the assignment.)
</li>

<li><b><code>__call</code>: </b>
The call operation <code>func(args)</code>.
This event happens when Lua tries to call a non-function value
(that is, <code>func</code> is not a function).
The metamethod is looked up in <code>func</code>.
If present,
the metamethod is called with <code>func</code> as its first argument,
followed by the arguments of the original call (<code>args</code>).
All results of the call
are the result of the operation.
(This is the only metamethod that allows multiple results.)
</li>

</ul>

<p>
It is a good practice to add all needed metamethods to a table
before setting it as a metatable of some object.
In particular, the <code>__gc</code> metamethod works only when this order
is followed (see <a href="#2.5.1">&sect;2.5.1</a>).


<p>
Because metatables are regular tables,
they can contain arbitrary fields,
not only the event names defined above.
Some functions in the standard library
(e.g., <a href="#pdf-tostring"><code>tostring</code></a>)
use other fields in metatables for their own purposes.





<h2>2.5 &ndash; <a name="2.5">Garbage Collection</a></h2>

<p>
Lua performs automatic memory management.
This means that
you do not have to worry about allocating memory for new objects
or freeing it when the objects are no longer needed.
Lua manages memory automatically by running
a <em>garbage collector</em> to collect all <em>dead objects</em>
(that is, objects that are no longer accessible from Lua).
All memory used by Lua is subject to automatic management:
strings, tables, userdata, functions, threads, internal structures, etc.


<p>
Lua implements an incremental mark-and-sweep collector.
It uses two numbers to control its garbage-collection cycles:
the <em>garbage-collector pause</em> and
the <em>garbage-collector step multiplier</em>.
Both use percentage points as units
(e.g., a value of 100 means an internal value of 1).


<p>
The garbage-collector pause
controls how long the collector waits before starting a new cycle.
Larger values make the collector less aggressive.
Values smaller than 100 mean the collector will not wait to
start a new cycle.
A value of 200 means that the collector waits for the total memory in use
to double before starting a new cycle.


<p>
The garbage-collector step multiplier
controls the relative speed of the collector relative to
memory allocation.
Larger values make the collector more aggressive but also increase
the size of each incremental step.
You should not use values smaller than 100,
because they make the collector too slow and
can result in the collector never finishing a cycle.
The default is 200,
which means that the collector runs at "twice"
the speed of memory allocation.


<p>
If you set the step multiplier to a very large number
(larger than 10% of the maximum number of
bytes that the program may use),
the collector behaves like a stop-the-world collector.
If you then set the pause to 200,
the collector behaves as in old Lua versions,
doing a complete collection every time Lua doubles its
memory usage.


<p>
You can change these numbers by calling <a href="#lua_gc"><code>lua_gc</code></a> in C
or <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> in Lua.
You can also use these functions to control
the collector directly (e.g., stop and restart it).



<h3>2.5.1 &ndash; <a name="2.5.1">Garbage-Collection Metamethods</a></h3>

<p>
You can set garbage-collector metamethods for tables
and, using the C&nbsp;API,
for full userdata (see <a href="#2.4">&sect;2.4</a>).
These metamethods are also called <em>finalizers</em>.
Finalizers allow you to coordinate Lua's garbage collection
with external resource management
(such as closing files, network or database connections,
or freeing your own memory).


<p>
For an object (table or userdata) to be finalized when collected,
you must <em>mark</em> it for finalization.

You mark an object for finalization when you set its metatable
and the metatable has a field indexed by the string "<code>__gc</code>".
Note that if you set a metatable without a <code>__gc</code> field
and later create that field in the metatable,
the object will not be marked for finalization.


<p>
When a marked object becomes garbage,
it is not collected immediately by the garbage collector.
Instead, Lua puts it in a list.
After the collection,
Lua goes through that list.
For each object in the list,
it checks the object's <code>__gc</code> metamethod:
If it is a function,
Lua calls it with the object as its single argument;
if the metamethod is not a function,
Lua simply ignores it.


<p>
At the end of each garbage-collection cycle,
the finalizers for objects are called in
the reverse order that the objects were marked for finalization,
among those collected in that cycle;
that is, the first finalizer to be called is the one associated
with the object marked last in the program.
The execution of each finalizer may occur at any point during
the execution of the regular code.


<p>
Because the object being collected must still be used by the finalizer,
that object (and other objects accessible only through it)
must be <em>resurrected</em> by Lua.
Usually, this resurrection is transient,
and the object memory is freed in the next garbage-collection cycle.
However, if the finalizer stores the object in some global place
(e.g., a global variable),
then the resurrection is permanent.
Moreover, if the finalizer marks a finalizing object for finalization again,
its finalizer will be called again in the next cycle where the
object is unreachable.
In any case,
the object memory is freed only in a GC cycle where
the object is unreachable and not marked for finalization.


<p>
When you close a state (see <a href="#lua_close"><code>lua_close</code></a>),
Lua calls the finalizers of all objects marked for finalization,
following the reverse order that they were marked.
If any finalizer marks objects for collection during that phase,
these marks have no effect.





<h3>2.5.2 &ndash; <a name="2.5.2">Weak Tables</a></h3>

<p>
A <em>weak table</em> is a table whose elements are
<em>weak references</em>.
A weak reference is ignored by the garbage collector.
In other words,
if the only references to an object are weak references,
then the garbage collector will collect that object.


<p>
A weak table can have weak keys, weak values, or both.
A table with weak values allows the collection of its values,
but prevents the collection of its keys.
A table with both weak keys and weak values allows the collection of
both keys and values.
In any case, if either the key or the value is collected,
the whole pair is removed from the table.
The weakness of a table is controlled by the
<code>__mode</code> field of its metatable.
If the <code>__mode</code> field is a string containing the character&nbsp;'<code>k</code>',
the keys in the table are weak.
If <code>__mode</code> contains '<code>v</code>',
the values in the table are weak.


<p>
A table with weak keys and strong values
is also called an <em>ephemeron table</em>.
In an ephemeron table,
a value is considered reachable only if its key is reachable.
In particular,
if the only reference to a key comes through its value,
the pair is removed.


<p>
Any change in the weakness of a table may take effect only
at the next collect cycle.
In particular, if you change the weakness to a stronger mode,
Lua may still collect some items from that table
before the change takes effect.


<p>
Only objects that have an explicit construction
are removed from weak tables.
Values, such as numbers and light C&nbsp;functions,
are not subject to garbage collection,
and therefore are not removed from weak tables
(unless their associated values are collected).
Although strings are subject to garbage collection,
they do not have an explicit construction,
and therefore are not removed from weak tables.


<p>
Resurrected objects
(that is, objects being finalized
and objects accessible only through objects being finalized)
have a special behavior in weak tables.
They are removed from weak values before running their finalizers,
but are removed from weak keys only in the next collection
after running their finalizers, when such objects are actually freed.
This behavior allows the finalizer to access properties
associated with the object through weak tables.


<p>
If a weak table is among the resurrected objects in a collection cycle,
it may not be properly cleared until the next cycle.







<h2>2.6 &ndash; <a name="2.6">Coroutines</a></h2>

<p>
Lua supports coroutines,
also called <em>collaborative multithreading</em>.
A coroutine in Lua represents an independent thread of execution.
Unlike threads in multithread systems, however,
a coroutine only suspends its execution by explicitly calling
a yield function.


<p>
You create a coroutine by calling <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>.
Its sole argument is a function
that is the main function of the coroutine.
The <code>create</code> function only creates a new coroutine and
returns a handle to it (an object of type <em>thread</em>);
it does not start the coroutine.


<p>
You execute a coroutine by calling <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
When you first call <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
passing as its first argument
a thread returned by <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the coroutine starts its execution by
calling its main function.
Extra arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> are passed
as arguments to that function.
After the coroutine starts running,
it runs until it terminates or <em>yields</em>.


<p>
A coroutine can terminate its execution in two ways:
normally, when its main function returns
(explicitly or implicitly, after the last instruction);
and abnormally, if there is an unprotected error.
In case of normal termination,
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>true</b>,
plus any values returned by the coroutine main function.
In case of errors, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns <b>false</b>
plus an error object.


<p>
A coroutine yields by calling <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
When a coroutine yields,
the corresponding <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> returns immediately,
even if the yield happens inside nested function calls
(that is, not in the main function,
but in a function directly or indirectly called by the main function).
In the case of a yield, <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> also returns <b>true</b>,
plus any values passed to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>.
The next time you resume the same coroutine,
it continues its execution from the point where it yielded,
with the call to <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> returning any extra
arguments passed to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.


<p>
Like <a href="#pdf-coroutine.create"><code>coroutine.create</code></a>,
the <a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> function also creates a coroutine,
but instead of returning the coroutine itself,
it returns a function that, when called, resumes the coroutine.
Any arguments passed to this function
go as extra arguments to <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>.
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> returns all the values returned by <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
except the first one (the boolean error code).
Unlike <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>,
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> does not catch errors;
any error is propagated to the caller.


<p>
As an example of how coroutines work,
consider the following code:

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
When you run it, it produces the following output:

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
You can also create and manipulate coroutines through the C API:
see functions <a href="#lua_newthread"><code>lua_newthread</code></a>, <a href="#lua_resume"><code>lua_resume</code></a>,
and <a href="#lua_yield"><code>lua_yield</code></a>.





<h1>3 &ndash; <a name="3">The Language</a></h1>

<p>
This section describes the lexis, the syntax, and the semantics of Lua.
In other words,
this section describes
which tokens are valid,
how they can be combined,
and what their combinations mean.


<p>
Language constructs will be explained using the usual extended BNF notation,
in which
{<em>a</em>}&nbsp;means&nbsp;0 or more <em>a</em>'s, and
[<em>a</em>]&nbsp;means an optional <em>a</em>.
Non-terminals are shown like non-terminal,
keywords are shown like <b>kword</b>,
and other terminal symbols are shown like &lsquo;<b>=</b>&rsquo;.
The complete syntax of Lua can be found in <a href="#9">&sect;9</a>
at the end of this manual.



<h2>3.1 &ndash; <a name="3.1">Lexical Conventions</a></h2>

<p>
Lua is a free-form language.
It ignores spaces (including new lines) and comments
between lexical elements (tokens),
except as delimiters between names and keywords.


<p>
<em>Names</em>
(also called <em>identifiers</em>)
in Lua can be any string of letters,
digits, and underscores,
not beginning with a digit and
not being a reserved word.
Identifiers are used to name variables, table fields, and labels.


<p>
The following <em>keywords</em> are reserved
and cannot be used as names:


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua is a case-sensitive language:
<code>and</code> is a reserved word, but <code>And</code> and <code>AND</code>
are two different, valid names.
As a convention,
programs should avoid creating
names that start with an underscore followed by
one or more uppercase letters (such as <a href="#pdf-_VERSION"><code>_VERSION</code></a>).


<p>
The following strings denote other tokens:

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
A <em>short literal string</em>
can be delimited by matching single or double quotes,
and can contain the following C-like escape sequences:
'<code>\a</code>' (bell),
'<code>\b</code>' (backspace),
'<code>\f</code>' (form feed),
'<code>\n</code>' (newline),
'<code>\r</code>' (carriage return),
'<code>\t</code>' (horizontal tab),
'<code>\v</code>' (vertical tab),
'<code>\\</code>' (backslash),
'<code>\"</code>' (quotation mark [double quote]),
and '<code>\'</code>' (apostrophe [single quote]).
A backslash followed by a line break
results in a newline in the string.
The escape sequence '<code>\z</code>' skips the following span
of white-space characters,
including line breaks;
it is particularly useful to break and indent a long literal string
into multiple lines without adding the newlines and spaces
into the string contents.
A short literal string cannot contain unescaped line breaks
nor escapes not forming a valid escape sequence.


<p>
We can specify any byte in a short literal string by its numeric value
(including embedded zeros).
This can be done
with the escape sequence <code>\x<em>XX</em></code>,
where <em>XX</em> is a sequence of exactly two hexadecimal digits,
or with the escape sequence <code>\<em>ddd</em></code>,
where <em>ddd</em> is a sequence of up to three decimal digits.
(Note that if a decimal escape sequence is to be followed by a digit,
it must be expressed using exactly three digits.)


<p>
The UTF-8 encoding of a Unicode character
can be inserted in a literal string with
the escape sequence <code>\u{<em>XXX</em>}</code>
(note the mandatory enclosing brackets),
where <em>XXX</em> is a sequence of one or more hexadecimal digits
representing the character code point.


<p>
Literal strings can also be defined using a long format
enclosed by <em>long brackets</em>.
We define an <em>opening long bracket of level <em>n</em></em> as an opening
square bracket followed by <em>n</em> equal signs followed by another
opening square bracket.
So, an opening long bracket of level&nbsp;0 is written as <code>[[</code>, 
an opening long bracket of level&nbsp;1 is written as <code>[=[</code>, 
and so on.
A <em>closing long bracket</em> is defined similarly;
for instance,
a closing long bracket of level&nbsp;4 is written as  <code>]====]</code>.
A <em>long literal</em> starts with an opening long bracket of any level and
ends at the first closing long bracket of the same level.
It can contain any text except a closing bracket of the same level.
Literals in this bracketed form can run for several lines,
do not interpret any escape sequences,
and ignore long brackets of any other level.
Any kind of end-of-line sequence
(carriage return, newline, carriage return followed by newline,
or newline followed by carriage return)
is converted to a simple newline.


<p>
For convenience,
when the opening long bracket is immediately followed by a newline,
the newline is not included in the string.
As an example, in a system using ASCII
(in which '<code>a</code>' is coded as&nbsp;97,
newline is coded as&nbsp;10, and '<code>1</code>' is coded as&nbsp;49),
the five literal strings below denote the same string:

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
Any byte in a literal string not
explicitly affected by the previous rules represents itself.
However, Lua opens files for parsing in text mode,
and the system file functions may have problems with
some control characters.
So, it is safer to represent
non-text data as a quoted literal with
explicit escape sequences for the non-text characters.


<p>
A <em>numeric constant</em> (or <em>numeral</em>)
can be written with an optional fractional part
and an optional decimal exponent,
marked by a letter '<code>e</code>' or '<code>E</code>'.
Lua also accepts hexadecimal constants,
which start with <code>0x</code> or <code>0X</code>.
Hexadecimal constants also accept an optional fractional part
plus an optional binary exponent,
marked by a letter '<code>p</code>' or '<code>P</code>'.
A numeric constant with a radix point or an exponent
denotes a float;
otherwise,
if its value fits in an integer,
it denotes an integer.
Examples of valid integer constants are

<pre>
     3   345   0xff   0xBEBADA
</pre><p>
Examples of valid float constants are

<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
A <em>comment</em> starts with a double hyphen (<code>--</code>)
anywhere outside a string.
If the text immediately after <code>--</code> is not an opening long bracket,
the comment is a <em>short comment</em>,
which runs until the end of the line.
Otherwise, it is a <em>long comment</em>,
which runs until the corresponding closing long bracket.
Long comments are frequently used to disable code temporarily.





<h2>3.2 &ndash; <a name="3.2">Variables</a></h2>

<p>
Variables are places that store values.
There are three kinds of variables in Lua:
global variables, local variables, and table fields.


<p>
A single name can denote a global variable or a local variable
(or a function's formal parameter,
which is a particular kind of local variable):

<pre>
	var ::= Name
</pre><p>
Name denotes identifiers, as defined in <a href="#3.1">&sect;3.1</a>.


<p>
Any variable name is assumed to be global unless explicitly declared
as a local (see <a href="#3.3.7">&sect;3.3.7</a>).
Local variables are <em>lexically scoped</em>:
local variables can be freely accessed by functions
defined inside their scope (see <a href="#3.5">&sect;3.5</a>).


<p>
Before the first assignment to a variable, its value is <b>nil</b>.


<p>
Square brackets are used to index a table:

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
The meaning of accesses to table fields can be changed via metatables
(see <a href="#2.4">&sect;2.4</a>).


<p>
The syntax <code>var.Name</code> is just syntactic sugar for
<code>var["Name"]</code>:

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
An access to a global variable <code>x</code>
is equivalent to <code>_ENV.x</code>.
Due to the way that chunks are compiled,
<code>_ENV</code> is never a global name (see <a href="#2.2">&sect;2.2</a>).





<h2>3.3 &ndash; <a name="3.3">Statements</a></h2>

<p>
Lua supports an almost conventional set of statements,
similar to those in Pascal or C.
This set includes
assignments, control structures, function calls,
and variable declarations.



<h3>3.3.1 &ndash; <a name="3.3.1">Blocks</a></h3>

<p>
A block is a list of statements,
which are executed sequentially:

<pre>
	block ::= {stat}
</pre><p>
Lua has <em>empty statements</em>
that allow you to separate statements with semicolons,
start a block with a semicolon
or write two semicolons in sequence:

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
Function calls and assignments
can start with an open parenthesis.
This possibility leads to an ambiguity in Lua's grammar.
Consider the following fragment:

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
The grammar could see it in two ways:

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
The current parser always sees such constructions
in the first way,
interpreting the open parenthesis
as the start of the arguments to a call.
To avoid this ambiguity,
it is a good practice to always precede with a semicolon
statements that start with a parenthesis:

<pre>
     ;(print or io.write)('done')
</pre>

<p>
A block can be explicitly delimited to produce a single statement:

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
Explicit blocks are useful
to control the scope of variable declarations.
Explicit blocks are also sometimes used to
add a <b>return</b> statement in the middle
of another block (see <a href="#3.3.4">&sect;3.3.4</a>).





<h3>3.3.2 &ndash; <a name="3.3.2">Chunks</a></h3>

<p>
The unit of compilation of Lua is called a <em>chunk</em>.
Syntactically,
a chunk is simply a block:

<pre>
	chunk ::= block
</pre>

<p>
Lua handles a chunk as the body of an anonymous function
with a variable number of arguments
(see <a href="#3.4.11">&sect;3.4.11</a>).
As such, chunks can define local variables,
receive arguments, and return values.
Moreover, such anonymous function is compiled as in the
scope of an external local variable called <code>_ENV</code> (see <a href="#2.2">&sect;2.2</a>).
The resulting function always has <code>_ENV</code> as its only upvalue,
even if it does not use that variable.


<p>
A chunk can be stored in a file or in a string inside the host program.
To execute a chunk,
Lua first <em>loads</em> it,
precompiling the chunk's code into instructions for a virtual machine,
and then Lua executes the compiled code
with an interpreter for the virtual machine.


<p>
Chunks can also be precompiled into binary form;
see program <code>luac</code> and function <a href="#pdf-string.dump"><code>string.dump</code></a> for details.
Programs in source and compiled forms are interchangeable;
Lua automatically detects the file type and acts accordingly (see <a href="#pdf-load"><code>load</code></a>).





<h3>3.3.3 &ndash; <a name="3.3.3">Assignment</a></h3>

<p>
Lua allows multiple assignments.
Therefore, the syntax for assignment
defines a list of variables on the left side
and a list of expressions on the right side.
The elements in both lists are separated by commas:

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
Expressions are discussed in <a href="#3.4">&sect;3.4</a>.


<p>
Before the assignment,
the list of values is <em>adjusted</em> to the length of
the list of variables.
If there are more values than needed,
the excess values are thrown away.
If there are fewer values than needed,
the list is extended with as many  <b>nil</b>'s as needed.
If the list of expressions ends with a function call,
then all values returned by that call enter the list of values,
before the adjustment
(except when the call is enclosed in parentheses; see <a href="#3.4">&sect;3.4</a>).


<p>
The assignment statement first evaluates all its expressions
and only then the assignments are performed.
Thus the code

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
sets <code>a[3]</code> to 20, without affecting <code>a[4]</code>
because the <code>i</code> in <code>a[i]</code> is evaluated (to 3)
before it is assigned&nbsp;4.
Similarly, the line

<pre>
     x, y = y, x
</pre><p>
exchanges the values of <code>x</code> and <code>y</code>,
and

<pre>
     x, y, z = y, z, x
</pre><p>
cyclically permutes the values of <code>x</code>, <code>y</code>, and <code>z</code>.


<p>
An assignment to a global name <code>x = val</code>
is equivalent to the assignment
<code>_ENV.x = val</code> (see <a href="#2.2">&sect;2.2</a>).


<p>
The meaning of assignments to table fields and
global variables (which are actually table fields, too)
can be changed via metatables (see <a href="#2.4">&sect;2.4</a>).





<h3>3.3.4 &ndash; <a name="3.3.4">Control Structures</a></h3><p>
The control structures
<b>if</b>, <b>while</b>, and <b>repeat</b> have the usual meaning and
familiar syntax:




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua also has a <b>for</b> statement, in two flavors (see <a href="#3.3.5">&sect;3.3.5</a>).


<p>
The condition expression of a
control structure can return any value.
Both <b>false</b> and <b>nil</b> are considered false.
All values different from <b>nil</b> and <b>false</b> are considered true
(in particular, the number 0 and the empty string are also true).


<p>
In the <b>repeat</b>&ndash;<b>until</b> loop,
the inner block does not end at the <b>until</b> keyword,
but only after the condition.
So, the condition can refer to local variables
declared inside the loop block.


<p>
The <b>goto</b> statement transfers the program control to a label.
For syntactical reasons,
labels in Lua are considered statements too:



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
A label is visible in the entire block where it is defined,
except
inside nested blocks where a label with the same name is defined and
inside nested functions.
A goto may jump to any visible label as long as it does not
enter into the scope of a local variable.


<p>
Labels and empty statements are called <em>void statements</em>,
as they perform no actions.


<p>
The <b>break</b> statement terminates the execution of a
<b>while</b>, <b>repeat</b>, or <b>for</b> loop,
skipping to the next statement after the loop:


<pre>
	stat ::= <b>break</b>
</pre><p>
A <b>break</b> ends the innermost enclosing loop.


<p>
The <b>return</b> statement is used to return values
from a function or a chunk
(which is an anonymous function).

Functions can return more than one value,
so the syntax for the <b>return</b> statement is

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
The <b>return</b> statement can only be written
as the last statement of a block.
If it is really necessary to <b>return</b> in the middle of a block,
then an explicit inner block can be used,
as in the idiom <code>do return end</code>,
because now <b>return</b> is the last statement in its (inner) block.





<h3>3.3.5 &ndash; <a name="3.3.5">For Statement</a></h3>

<p>

The <b>for</b> statement has two forms:
one numerical and one generic.


<p>
The numerical <b>for</b> loop repeats a block of code while a
control variable runs through an arithmetic progression.
It has the following syntax:

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
The <em>block</em> is repeated for <em>name</em> starting at the value of
the first <em>exp</em>, until it passes the second <em>exp</em> by steps of the
third <em>exp</em>.
More precisely, a <b>for</b> statement like

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
is equivalent to the code:

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
Note the following:

<ul>

<li>
All three control expressions are evaluated only once,
before the loop starts.
They must all result in numbers.
</li>

<li>
<code><em>var</em></code>, <code><em>limit</em></code>, and <code><em>step</em></code> are invisible variables.
The names shown here are for explanatory purposes only.
</li>

<li>
If the third expression (the step) is absent,
then a step of&nbsp;1 is used.
</li>

<li>
You can use <b>break</b> and <b>goto</b> to exit a <b>for</b> loop.
</li>

<li>
The loop variable <code>v</code> is local to the loop body.
If you need its value after the loop,
assign it to another variable before exiting the loop.
</li>

</ul>

<p>
The generic <b>for</b> statement works over functions,
called <em>iterators</em>.
On each iteration, the iterator function is called to produce a new value,
stopping when this new value is <b>nil</b>.
The generic <b>for</b> loop has the following syntax:

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
A <b>for</b> statement like

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
is equivalent to the code:

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
Note the following:

<ul>

<li>
<code><em>explist</em></code> is evaluated only once.
Its results are an <em>iterator</em> function,
a <em>state</em>,
and an initial value for the first <em>iterator variable</em>.
</li>

<li>
<code><em>f</em></code>, <code><em>s</em></code>, and <code><em>var</em></code> are invisible variables.
The names are here for explanatory purposes only.
</li>

<li>
You can use <b>break</b> to exit a <b>for</b> loop.
</li>

<li>
The loop variables <code><em>var_i</em></code> are local to the loop;
you cannot use their values after the <b>for</b> ends.
If you need these values,
then assign them to other variables before breaking or exiting the loop.
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">Function Calls as Statements</a></h3><p>
To allow possible side-effects,
function calls can be executed as statements:

<pre>
	stat ::= functioncall
</pre><p>
In this case, all returned values are thrown away.
Function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>.





<h3>3.3.7 &ndash; <a name="3.3.7">Local Declarations</a></h3><p>
Local variables can be declared anywhere inside a block.
The declaration can include an initial assignment:

<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
If present, an initial assignment has the same semantics
of a multiple assignment (see <a href="#3.3.3">&sect;3.3.3</a>).
Otherwise, all variables are initialized with <b>nil</b>.


<p>
A chunk is also a block (see <a href="#3.3.2">&sect;3.3.2</a>),
and so local variables can be declared in a chunk outside any explicit block.


<p>
The visibility rules for local variables are explained in <a href="#3.5">&sect;3.5</a>.







<h2>3.4 &ndash; <a name="3.4">Expressions</a></h2>

<p>
The basic expressions in Lua are the following:

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
Numerals and literal strings are explained in <a href="#3.1">&sect;3.1</a>;
variables are explained in <a href="#3.2">&sect;3.2</a>;
function definitions are explained in <a href="#3.4.11">&sect;3.4.11</a>;
function calls are explained in <a href="#3.4.10">&sect;3.4.10</a>;
table constructors are explained in <a href="#3.4.9">&sect;3.4.9</a>.
Vararg expressions,
denoted by three dots ('<code>...</code>'), can only be used when
directly inside a vararg function;
they are explained in <a href="#3.4.11">&sect;3.4.11</a>.


<p>
Binary operators comprise arithmetic operators (see <a href="#3.4.1">&sect;3.4.1</a>),
bitwise operators (see <a href="#3.4.2">&sect;3.4.2</a>),
relational operators (see <a href="#3.4.4">&sect;3.4.4</a>), logical operators (see <a href="#3.4.5">&sect;3.4.5</a>),
and the concatenation operator (see <a href="#3.4.6">&sect;3.4.6</a>).
Unary operators comprise the unary minus (see <a href="#3.4.1">&sect;3.4.1</a>),
the unary bitwise NOT (see <a href="#3.4.2">&sect;3.4.2</a>),
the unary logical <b>not</b> (see <a href="#3.4.5">&sect;3.4.5</a>),
and the unary <em>length operator</em> (see <a href="#3.4.7">&sect;3.4.7</a>).


<p>
Both function calls and vararg expressions can result in multiple values.
If a function call is used as a statement (see <a href="#3.3.6">&sect;3.3.6</a>),
then its return list is adjusted to zero elements,
thus discarding all returned values.
If an expression is used as the last (or the only) element
of a list of expressions,
then no adjustment is made
(unless the expression is enclosed in parentheses).
In all other contexts,
Lua adjusts the result list to one element,
either discarding all values except the first one
or adding a single <b>nil</b> if there are no values.


<p>
Here are some examples:

<pre>
     f()                -- adjusted to 0 results
     g(f(), x)          -- f() is adjusted to 1 result
     g(x, f())          -- g gets x plus all results from f()
     a,b,c = f(), x     -- f() is adjusted to 1 result (c gets nil)
     a,b = ...          -- a gets the first vararg argument, b gets
                        -- the second (both a and b can get nil if there
                        -- is no corresponding vararg argument)
     
     a,b,c = x, f()     -- f() is adjusted to 2 results
     a,b,c = f()        -- f() is adjusted to 3 results
     return f()         -- returns all results from f()
     return ...         -- returns all received vararg arguments
     return x,y,f()     -- returns x, y, and all results from f()
     {f()}              -- creates a list with all results from f()
     {...}              -- creates a list with all vararg arguments
     {f(), nil}         -- f() is adjusted to 1 result
</pre>

<p>
Any expression enclosed in parentheses always results in only one value.
Thus,
<code>(f(x,y,z))</code> is always a single value,
even if <code>f</code> returns several values.
(The value of <code>(f(x,y,z))</code> is the first value returned by <code>f</code>
or <b>nil</b> if <code>f</code> does not return any values.)



<h3>3.4.1 &ndash; <a name="3.4.1">Arithmetic Operators</a></h3><p>
Lua supports the following arithmetic operators:

<ul>
<li><b><code>+</code>: </b>addition</li>
<li><b><code>-</code>: </b>subtraction</li>
<li><b><code>*</code>: </b>multiplication</li>
<li><b><code>/</code>: </b>float division</li>
<li><b><code>//</code>: </b>floor division</li>
<li><b><code>%</code>: </b>modulo</li>
<li><b><code>^</code>: </b>exponentiation</li>
<li><b><code>-</code>: </b>unary minus</li>
</ul>

<p>
With the exception of exponentiation and float division,
the arithmetic operators work as follows:
If both operands are integers,
the operation is performed over integers and the result is an integer.
Otherwise, if both operands are numbers
or strings that can be converted to
numbers (see <a href="#3.4.3">&sect;3.4.3</a>),
then they are converted to floats,
the operation is performed following the usual rules
for floating-point arithmetic
(usually the IEEE 754 standard),
and the result is a float.


<p>
Exponentiation and float division (<code>/</code>)
always convert their operands to floats
and the result is always a float.
Exponentiation uses the ISO&nbsp;C function <code>pow</code>,
so that it works for non-integer exponents too.


<p>
Floor division (<code>//</code>) is a division
that rounds the quotient towards minus infinity,
that is, the floor of the division of its operands.


<p>
Modulo is defined as the remainder of a division
that rounds the quotient towards minus infinity (floor division).


<p>
In case of overflows in integer arithmetic,
all operations <em>wrap around</em>,
according to the usual rules of two-complement arithmetic.
(In other words,
they return the unique representable integer
that is equal modulo <em>2<sup>64</sup></em> to the mathematical result.)



<h3>3.4.2 &ndash; <a name="3.4.2">Bitwise Operators</a></h3><p>
Lua supports the following bitwise operators:

<ul>
<li><b><code>&amp;</code>: </b>bitwise AND</li>
<li><b><code>&#124;</code>: </b>bitwise OR</li>
<li><b><code>~</code>: </b>bitwise exclusive OR</li>
<li><b><code>&gt;&gt;</code>: </b>right shift</li>
<li><b><code>&lt;&lt;</code>: </b>left shift</li>
<li><b><code>~</code>: </b>unary bitwise NOT</li>
</ul>

<p>
All bitwise operations convert its operands to integers
(see <a href="#3.4.3">&sect;3.4.3</a>),
operate on all bits of those integers,
and result in an integer.


<p>
Both right and left shifts fill the vacant bits with zeros.
Negative displacements shift to the other direction;
displacements with absolute values equal to or higher than
the number of bits in an integer
result in zero (as all bits are shifted out).





<h3>3.4.3 &ndash; <a name="3.4.3">Coercions and Conversions</a></h3><p>
Lua provides some automatic conversions between some
types and representations at run time.
Bitwise operators always convert float operands to integers.
Exponentiation and float division
always convert integer operands to floats.
All other arithmetic operations applied to mixed numbers
(integers and floats) convert the integer operand to a float;
this is called the <em>usual rule</em>.
The C API also converts both integers to floats and
floats to integers, as needed.
Moreover, string concatenation accepts numbers as arguments,
besides strings.


<p>
Lua also converts strings to numbers,
whenever a number is expected.


<p>
In a conversion from integer to float,
if the integer value has an exact representation as a float,
that is the result.
Otherwise,
the conversion gets the nearest higher or
the nearest lower representable value.
This kind of conversion never fails.


<p>
The conversion from float to integer
checks whether the float has an exact representation as an integer
(that is, the float has an integral value and
it is in the range of integer representation).
If it does, that representation is the result.
Otherwise, the conversion fails.


<p>
The conversion from strings to numbers goes as follows:
First, the string is converted to an integer or a float,
following its syntax and the rules of the Lua lexer.
(The string may have also leading and trailing spaces and a sign.)
Then, the resulting number (float or integer)
is converted to the type (float or integer) required by the context
(e.g., the operation that forced the conversion).


<p>
All conversions from strings to numbers
accept both a dot and the current locale mark
as the radix character.
(The Lua lexer, however, accepts only a dot.)


<p>
The conversion from numbers to strings uses a
non-specified human-readable format.
For complete control over how numbers are converted to strings,
use the <code>format</code> function from the string library
(see <a href="#pdf-string.format"><code>string.format</code></a>).





<h3>3.4.4 &ndash; <a name="3.4.4">Relational Operators</a></h3><p>
Lua supports the following relational operators:

<ul>
<li><b><code>==</code>: </b>equality</li>
<li><b><code>~=</code>: </b>inequality</li>
<li><b><code>&lt;</code>: </b>less than</li>
<li><b><code>&gt;</code>: </b>greater than</li>
<li><b><code>&lt;=</code>: </b>less or equal</li>
<li><b><code>&gt;=</code>: </b>greater or equal</li>
</ul><p>
These operators always result in <b>false</b> or <b>true</b>.


<p>
Equality (<code>==</code>) first compares the type of its operands.
If the types are different, then the result is <b>false</b>.
Otherwise, the values of the operands are compared.
Strings are compared in the obvious way.
Numbers are equal if they denote the same mathematical value.


<p>
Tables, userdata, and threads
are compared by reference:
two objects are considered equal only if they are the same object.
Every time you create a new object
(a table, userdata, or thread),
this new object is different from any previously existing object.
A closure is always equal to itself.
Closures with any detectable difference
(different behavior, different definition) are always different.
Closures created at different times but with no detectable differences
may be classified as equal or not
(depending on internal caching details).


<p>
You can change the way that Lua compares tables and userdata
by using the "eq" metamethod (see <a href="#2.4">&sect;2.4</a>).


<p>
Equality comparisons do not convert strings to numbers
or vice versa.
Thus, <code>"0"==0</code> evaluates to <b>false</b>,
and <code>t[0]</code> and <code>t["0"]</code> denote different
entries in a table.


<p>
The operator <code>~=</code> is exactly the negation of equality (<code>==</code>).


<p>
The order operators work as follows.
If both arguments are numbers,
then they are compared according to their mathematical values
(regardless of their subtypes).
Otherwise, if both arguments are strings,
then their values are compared according to the current locale.
Otherwise, Lua tries to call the "lt" or the "le"
metamethod (see <a href="#2.4">&sect;2.4</a>).
A comparison <code>a &gt; b</code> is translated to <code>b &lt; a</code>
and <code>a &gt;= b</code> is translated to <code>b &lt;= a</code>.


<p>
Following the IEEE 754 standard,
NaN is considered neither smaller than,
nor equal to, nor greater than any value (including itself).





<h3>3.4.5 &ndash; <a name="3.4.5">Logical Operators</a></h3><p>
The logical operators in Lua are
<b>and</b>, <b>or</b>, and <b>not</b>.
Like the control structures (see <a href="#3.3.4">&sect;3.3.4</a>),
all logical operators consider both <b>false</b> and <b>nil</b> as false
and anything else as true.


<p>
The negation operator <b>not</b> always returns <b>false</b> or <b>true</b>.
The conjunction operator <b>and</b> returns its first argument
if this value is <b>false</b> or <b>nil</b>;
otherwise, <b>and</b> returns its second argument.
The disjunction operator <b>or</b> returns its first argument
if this value is different from <b>nil</b> and <b>false</b>;
otherwise, <b>or</b> returns its second argument.
Both <b>and</b> and <b>or</b> use short-circuit evaluation;
that is,
the second operand is evaluated only if necessary.
Here are some examples:

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
(In this manual,
<code>--&gt;</code> indicates the result of the preceding expression.)





<h3>3.4.6 &ndash; <a name="3.4.6">Concatenation</a></h3><p>
The string concatenation operator in Lua is
denoted by two dots ('<code>..</code>').
If both operands are strings or numbers, then they are converted to
strings according to the rules described in <a href="#3.4.3">&sect;3.4.3</a>.
Otherwise, the <code>__concat</code> metamethod is called (see <a href="#2.4">&sect;2.4</a>).





<h3>3.4.7 &ndash; <a name="3.4.7">The Length Operator</a></h3>

<p>
The length operator is denoted by the unary prefix operator <code>#</code>.


<p>
The length of a string is its number of bytes
(that is, the usual meaning of string length when each
character is one byte).


<p>
The length operator applied on a table
returns a border in that table.
A <em>border</em> in a table <code>t</code> is any natural number
that satisfies the following condition:

<pre>
     (border == 0 or t[border] ~= nil) and t[border + 1] == nil
</pre><p>
In words,
a border is any (natural) index in a table
where a non-nil value is followed by a nil value
(or zero, when index 1 is nil).


<p>
A table with exactly one border is called a <em>sequence</em>.
For instance, the table <code>{10, 20, 30, 40, 50}</code> is a sequence,
as it has only one border (5).
The table <code>{10, 20, 30, nil, 50}</code> has two borders (3 and 5),
and therefore it is not a sequence.
The table <code>{nil, 20, 30, nil, nil, 60, nil}</code>
has three borders (0, 3, and 6),
so it is not a sequence, too.
The table <code>{}</code> is a sequence with border 0.
Note that non-natural keys do not interfere
with whether a table is a sequence.


<p>
When <code>t</code> is a sequence,
<code>#t</code> returns its only border,
which corresponds to the intuitive notion of the length of the sequence.
When <code>t</code> is not a sequence,
<code>#t</code> can return any of its borders.
(The exact one depends on details of
the internal representation of the table,
which in turn can depend on how the table was populated and
the memory addresses of its non-numeric keys.)


<p>
The computation of the length of a table
has a guaranteed worst time of <em>O(log n)</em>,
where <em>n</em> is the largest natural key in the table.


<p>
A program can modify the behavior of the length operator for
any value but strings through the <code>__len</code> metamethod (see <a href="#2.4">&sect;2.4</a>).





<h3>3.4.8 &ndash; <a name="3.4.8">Precedence</a></h3><p>
Operator precedence in Lua follows the table below,
from lower to higher priority:

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>
As usual,
you can use parentheses to change the precedences of an expression.
The concatenation ('<code>..</code>') and exponentiation ('<code>^</code>')
operators are right associative.
All other binary operators are left associative.





<h3>3.4.9 &ndash; <a name="3.4.9">Table Constructors</a></h3><p>
Table constructors are expressions that create tables.
Every time a constructor is evaluated, a new table is created.
A constructor can be used to create an empty table
or to create a table and initialize some of its fields.
The general syntax for constructors is

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
Each field of the form <code>[exp1] = exp2</code> adds to the new table an entry
with key <code>exp1</code> and value <code>exp2</code>.
A field of the form <code>name = exp</code> is equivalent to
<code>["name"] = exp</code>.
Finally, fields of the form <code>exp</code> are equivalent to
<code>[i] = exp</code>, where <code>i</code> are consecutive integers
starting with 1.
Fields in the other formats do not affect this counting.
For example,

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
is equivalent to

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>
The order of the assignments in a constructor is undefined.
(This order would be relevant only when there are repeated keys.)


<p>
If the last field in the list has the form <code>exp</code>
and the expression is a function call or a vararg expression,
then all values returned by this expression enter the list consecutively
(see <a href="#3.4.10">&sect;3.4.10</a>).


<p>
The field list can have an optional trailing separator,
as a convenience for machine-generated code.





<h3>3.4.10 &ndash; <a name="3.4.10">Function Calls</a></h3><p>
A function call in Lua has the following syntax:

<pre>
	functioncall ::= prefixexp args
</pre><p>
In a function call,
first prefixexp and args are evaluated.
If the value of prefixexp has type <em>function</em>,
then this function is called
with the given arguments.
Otherwise, the prefixexp "call" metamethod is called,
having as first argument the value of prefixexp,
followed by the original call arguments
(see <a href="#2.4">&sect;2.4</a>).


<p>
The form

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
can be used to call "methods".
A call <code>v:name(<em>args</em>)</code>
is syntactic sugar for <code>v.name(v,<em>args</em>)</code>,
except that <code>v</code> is evaluated only once.


<p>
Arguments have the following syntax:

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
All argument expressions are evaluated before the call.
A call of the form <code>f{<em>fields</em>}</code> is
syntactic sugar for <code>f({<em>fields</em>})</code>;
that is, the argument list is a single new table.
A call of the form <code>f'<em>string</em>'</code>
(or <code>f"<em>string</em>"</code> or <code>f[[<em>string</em>]]</code>)
is syntactic sugar for <code>f('<em>string</em>')</code>;
that is, the argument list is a single literal string.


<p>
A call of the form <code>return <em>functioncall</em></code> is called
a <em>tail call</em>.
Lua implements <em>proper tail calls</em>
(or <em>proper tail recursion</em>):
in a tail call,
the called function reuses the stack entry of the calling function.
Therefore, there is no limit on the number of nested tail calls that
a program can execute.
However, a tail call erases any debug information about the
calling function.
Note that a tail call only happens with a particular syntax,
where the <b>return</b> has one single function call as argument;
this syntax makes the calling function return exactly
the returns of the called function.
So, none of the following examples are tail calls:

<pre>
     return (f(x))        -- results adjusted to 1
     return 2 * f(x)
     return x, f(x)       -- additional results
     f(x); return         -- results discarded
     return x or f(x)     -- results adjusted to 1
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">Function Definitions</a></h3>

<p>
The syntax for function definition is

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
The following syntactic sugar simplifies function definitions:

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
The statement

<pre>
     function f () <em>body</em> end
</pre><p>
translates to

<pre>
     f = function () <em>body</em> end
</pre><p>
The statement

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
translates to

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
The statement

<pre>
     local function f () <em>body</em> end
</pre><p>
translates to

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
not to

<pre>
     local f = function () <em>body</em> end
</pre><p>
(This only makes a difference when the body of the function
contains references to <code>f</code>.)


<p>
A function definition is an executable expression,
whose value has type <em>function</em>.
When Lua precompiles a chunk,
all its function bodies are precompiled too.
Then, whenever Lua executes the function definition,
the function is <em>instantiated</em> (or <em>closed</em>).
This function instance (or <em>closure</em>)
is the final value of the expression.


<p>
Parameters act as local variables that are
initialized with the argument values:

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
When a function is called,
the list of arguments is adjusted to
the length of the list of parameters,
unless the function is a <em>vararg function</em>,
which is indicated by three dots ('<code>...</code>')
at the end of its parameter list.
A vararg function does not adjust its argument list;
instead, it collects all extra arguments and supplies them
to the function through a <em>vararg expression</em>,
which is also written as three dots.
The value of this expression is a list of all actual extra arguments,
similar to a function with multiple results.
If a vararg expression is used inside another expression
or in the middle of a list of expressions,
then its return list is adjusted to one element.
If the expression is used as the last element of a list of expressions,
then no adjustment is made
(unless that last expression is enclosed in parentheses).


<p>
As an example, consider the following definitions:

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
Then, we have the following mapping from arguments to parameters and
to the vararg expression:

<pre>
     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
Results are returned using the <b>return</b> statement (see <a href="#3.3.4">&sect;3.3.4</a>).
If control reaches the end of a function
without encountering a <b>return</b> statement,
then the function returns with no results.


<p>

There is a system-dependent limit on the number of values
that a function may return.
This limit is guaranteed to be larger than 1000.


<p>
The <em>colon</em> syntax
is used for defining <em>methods</em>,
that is, functions that have an implicit extra parameter <code>self</code>.
Thus, the statement

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
is syntactic sugar for

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">Visibility Rules</a></h2>

<p>

Lua is a lexically scoped language.
The scope of a local variable begins at the first statement after
its declaration and lasts until the last non-void statement
of the innermost block that includes the declaration.
Consider the following example:

<pre>
     x = 10                -- global variable
     do                    -- new block
       local x = x         -- new 'x', with value 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- another block
         local x = x+1     -- another 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10  (the global one)
</pre>

<p>
Notice that, in a declaration like <code>local x = x</code>,
the new <code>x</code> being declared is not in scope yet,
and so the second <code>x</code> refers to the outside variable.


<p>
Because of the lexical scoping rules,
local variables can be freely accessed by functions
defined inside their scope.
A local variable used by an inner function is called
an <em>upvalue</em>, or <em>external local variable</em>,
inside the inner function.


<p>
Notice that each execution of a <b>local</b> statement
defines new local variables.
Consider the following example:

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
The loop creates ten closures
(that is, ten instances of the anonymous function).
Each of these closures uses a different <code>y</code> variable,
while all of them share the same <code>x</code>.





<h1>4 &ndash; <a name="4">The Application Program Interface</a></h1>

<p>

This section describes the C&nbsp;API for Lua, that is,
the set of C&nbsp;functions available to the host program to communicate
with Lua.
All API functions and related types and constants
are declared in the header file <a name="pdf-lua.h"><code>lua.h</code></a>.


<p>
Even when we use the term "function",
any facility in the API may be provided as a macro instead.
Except where stated otherwise,
all such macros use each of their arguments exactly once
(except for the first argument, which is always a Lua state),
and so do not generate any hidden side-effects.


<p>
As in most C&nbsp;libraries,
the Lua API functions do not check their arguments for validity or consistency.
However, you can change this behavior by compiling Lua
with the macro <a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a> defined.


<p>
The Lua library is fully reentrant:
it has no global variables.
It keeps all information it needs in a dynamic structure,
called the <em>Lua state</em>.


<p>
Each Lua state has one or more threads,
which correspond to independent, cooperative lines of execution.
The type <a href="#lua_State"><code>lua_State</code></a> (despite its name) refers to a thread.
(Indirectly, through the thread, it also refers to the
Lua state associated to the thread.)


<p>
A pointer to a thread must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch and returns a pointer
to the <em>main thread</em> in the new state.



<h2>4.1 &ndash; <a name="4.1">The Stack</a></h2>

<p>
Lua uses a <em>virtual stack</em> to pass values to and from C.
Each element in this stack represents a Lua value
(<b>nil</b>, number, string, etc.).
Functions in the API can access this stack through the
Lua state parameter that they receive.


<p>
Whenever Lua calls C, the called function gets a new stack,
which is independent of previous stacks and of stacks of
C&nbsp;functions that are still active.
This stack initially contains any arguments to the C&nbsp;function
and it is where the C&nbsp;function can store temporary
Lua values and must push its results
to be returned to the caller (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
For convenience,
most query operations in the API do not follow a strict stack discipline.
Instead, they can refer to any element in the stack
by using an <em>index</em>:
A positive index represents an absolute stack position
(starting at&nbsp;1);
a negative index represents an offset relative to the top of the stack.
More specifically, if the stack has <em>n</em> elements,
then index&nbsp;1 represents the first element
(that is, the element that was pushed onto the stack first)
and
index&nbsp;<em>n</em> represents the last element;
index&nbsp;-1 also represents the last element
(that is, the element at the&nbsp;top)
and index <em>-n</em> represents the first element.





<h2>4.2 &ndash; <a name="4.2">Stack Size</a></h2>

<p>
When you interact with the Lua API,
you are responsible for ensuring consistency.
In particular,
<em>you are responsible for controlling stack overflow</em>.
You can use the function <a href="#lua_checkstack"><code>lua_checkstack</code></a>
to ensure that the stack has enough space for pushing new elements.


<p>
Whenever Lua calls C,
it ensures that the stack has space for
at least <a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a> extra slots.
<code>LUA_MINSTACK</code> is defined as 20,
so that usually you do not have to worry about stack space
unless your code has loops pushing elements onto the stack.


<p>
When you call a Lua function
without a fixed number of results (see <a href="#lua_call"><code>lua_call</code></a>),
Lua ensures that the stack has enough space for all results,
but it does not ensure any extra space.
So, before pushing anything in the stack after such a call
you should use <a href="#lua_checkstack"><code>lua_checkstack</code></a>.





<h2>4.3 &ndash; <a name="4.3">Valid and Acceptable Indices</a></h2>

<p>
Any function in the API that receives stack indices
works only with <em>valid indices</em> or <em>acceptable indices</em>.


<p>
A <em>valid index</em> is an index that refers to a
position that stores a modifiable Lua value.
It comprises stack indices between&nbsp;1 and the stack top
(<code>1 &le; abs(index) &le; top</code>)

plus <em>pseudo-indices</em>,
which represent some positions that are accessible to C&nbsp;code
but that are not in the stack.
Pseudo-indices are used to access the registry (see <a href="#4.5">&sect;4.5</a>)
and the upvalues of a C&nbsp;function (see <a href="#4.4">&sect;4.4</a>).


<p>
Functions that do not need a specific mutable position,
but only a value (e.g., query functions),
can be called with acceptable indices.
An <em>acceptable index</em> can be any valid index,
but it also can be any positive index after the stack top
within the space allocated for the stack,
that is, indices up to the stack size.
(Note that 0 is never an acceptable index.)
Except when noted otherwise,
functions in the API work with acceptable indices.


<p>
Acceptable indices serve to avoid extra tests
against the stack top when querying the stack.
For instance, a C&nbsp;function can query its third argument
without the need to first check whether there is a third argument,
that is, without the need to check whether 3 is a valid index.


<p>
For functions that can be called with acceptable indices,
any non-valid index is treated as if it
contains a value of a virtual type <a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a>,
which behaves like a nil value.





<h2>4.4 &ndash; <a name="4.4">C Closures</a></h2>

<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
thus creating a <em>C&nbsp;closure</em>
(see <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>);
these values are called <em>upvalues</em> and are
accessible to the function whenever it is called.


<p>
Whenever a C&nbsp;function is called,
its upvalues are located at specific pseudo-indices.
These pseudo-indices are produced by the macro
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>.
The first upvalue associated with a function is at index
<code>lua_upvalueindex(1)</code>, and so on.
Any access to <code>lua_upvalueindex(<em>n</em>)</code>,
where <em>n</em> is greater than the number of upvalues of the
current function
(but not greater than 256,
which is one plus the maximum number of upvalues in a closure),
produces an acceptable but invalid index.





<h2>4.5 &ndash; <a name="4.5">Registry</a></h2>

<p>
Lua provides a <em>registry</em>,
a predefined table that can be used by any C&nbsp;code to
store whatever Lua values it needs to store.
The registry table is always located at pseudo-index
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a>.
Any C&nbsp;library can store data into this table,
but it must take care to choose keys
that are different from those used
by other libraries, to avoid collisions.
Typically, you should use as key a string containing your library name,
or a light userdata with the address of a C&nbsp;object in your code,
or any Lua object created by your code.
As with variable names,
string keys starting with an underscore followed by
uppercase letters are reserved for Lua.


<p>
The integer keys in the registry are used
by the reference mechanism (see <a href="#luaL_ref"><code>luaL_ref</code></a>)
and by some predefined values.
Therefore, integer keys must not be used for other purposes.


<p>
When you create a new Lua state,
its registry comes with some predefined values.
These predefined values are indexed with integer keys
defined as constants in <code>lua.h</code>.
The following constants are defined:

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b> At this index the registry has
the main thread of the state.
(The main thread is the one created together with the state.)
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> At this index the registry has
the global environment.
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">Error Handling in C</a></h2>

<p>
Internally, Lua uses the C <code>longjmp</code> facility to handle errors.
(Lua will use exceptions if you compile it as C++;
search for <code>LUAI_THROW</code> in the source code for details.)
When Lua faces any error
(such as a memory allocation error or a type error)
it <em>raises</em> an error;
that is, it does a long jump.
A <em>protected environment</em> uses <code>setjmp</code>
to set a recovery point;
any error jumps to the most recent active recovery point.


<p>
Inside a C&nbsp;function you can raise an error by calling <a href="#lua_error"><code>lua_error</code></a>.


<p>
Most functions in the API can raise an error,
for instance due to a memory allocation error.
The documentation for each function indicates whether
it can raise errors.


<p>
If an error happens outside any protected environment,
Lua calls a <em>panic function</em> (see <a href="#lua_atpanic"><code>lua_atpanic</code></a>)
and then calls <code>abort</code>,
thus exiting the host application.
Your panic function can avoid this exit by
never returning
(e.g., doing a long jump to your own recovery point outside Lua).


<p>
The panic function,
as its name implies,
is a mechanism of last resort.
Programs should avoid it.
As a general rule,
when a C&nbsp;function is called by Lua with a Lua state,
it can do whatever it wants on that Lua state,
as it should be already protected.
However,
when C code operates on other Lua states
(e.g., a Lua argument to the function,
a Lua state stored in the registry, or
the result of <a href="#lua_newthread"><code>lua_newthread</code></a>),
it should use them only in API calls that cannot raise errors.


<p>
The panic function runs as if it were a message handler (see <a href="#2.3">&sect;2.3</a>);
in particular, the error object is at the top of the stack.
However, there is no guarantee about stack space.
To push anything on the stack,
the panic function must first check the available space (see <a href="#4.2">&sect;4.2</a>).





<h2>4.7 &ndash; <a name="4.7">Handling Yields in C</a></h2>

<p>
Internally, Lua uses the C <code>longjmp</code> facility to yield a coroutine.
Therefore, if a C&nbsp;function <code>foo</code> calls an API function
and this API function yields
(directly or indirectly by calling another function that yields),
Lua cannot return to <code>foo</code> any more,
because the <code>longjmp</code> removes its frame from the C stack.


<p>
To avoid this kind of problem,
Lua raises an error whenever it tries to yield across an API call,
except for three functions:
<a href="#lua_yieldk"><code>lua_yieldk</code></a>, <a href="#lua_callk"><code>lua_callk</code></a>, and <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
All those functions receive a <em>continuation function</em>
(as a parameter named <code>k</code>) to continue execution after a yield.


<p>
We need to set some terminology to explain continuations.
We have a C&nbsp;function called from Lua which we will call
the <em>original function</em>.
This original function then calls one of those three functions in the C API,
which we will call the <em>callee function</em>,
that then yields the current thread.
(This can happen when the callee function is <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
or when the callee function is either <a href="#lua_callk"><code>lua_callk</code></a> or <a href="#lua_pcallk"><code>lua_pcallk</code></a>
and the function called by them yields.)


<p>
Suppose the running thread yields while executing the callee function.
After the thread resumes,
it eventually will finish running the callee function.
However,
the callee function cannot return to the original function,
because its frame in the C stack was destroyed by the yield.
Instead, Lua calls a <em>continuation function</em>,
which was given as an argument to the callee function.
As the name implies,
the continuation function should continue the task
of the original function.


<p>
As an illustration, consider the following function:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>
Now we want to allow
the Lua code being run by <a href="#lua_pcall"><code>lua_pcall</code></a> to yield.
First, we can rewrite our function like here:

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
In the above code,
the new function <code>k</code> is a
<em>continuation function</em> (with type <a href="#lua_KFunction"><code>lua_KFunction</code></a>),
which should do all the work that the original function
was doing after calling <a href="#lua_pcall"><code>lua_pcall</code></a>.
Now, we must inform Lua that it must call <code>k</code> if the Lua code
being executed by <a href="#lua_pcall"><code>lua_pcall</code></a> gets interrupted in some way
(errors or yielding),
so we rewrite the code as here,
replacing <a href="#lua_pcall"><code>lua_pcall</code></a> by <a href="#lua_pcallk"><code>lua_pcallk</code></a>:

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
Note the external, explicit call to the continuation:
Lua will call the continuation only if needed, that is,
in case of errors or resuming after a yield.
If the called function returns normally without ever yielding,
<a href="#lua_pcallk"><code>lua_pcallk</code></a> (and <a href="#lua_callk"><code>lua_callk</code></a>) will also return normally.
(Of course, instead of calling the continuation in that case,
you can do the equivalent work directly inside the original function.)


<p>
Besides the Lua state,
the continuation function has two other parameters:
the final status of the call plus the context value (<code>ctx</code>) that
was passed originally to <a href="#lua_pcallk"><code>lua_pcallk</code></a>.
(Lua does not use this context value;
it only passes this value from the original function to the
continuation function.)
For <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
the status is the same value that would be returned by <a href="#lua_pcallk"><code>lua_pcallk</code></a>,
except that it is <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> when being executed after a yield
(instead of <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>).
For <a href="#lua_yieldk"><code>lua_yieldk</code></a> and <a href="#lua_callk"><code>lua_callk</code></a>,
the status is always <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> when Lua calls the continuation.
(For these two functions,
Lua will not call the continuation in case of errors,
because they do not handle errors.)
Similarly, when using <a href="#lua_callk"><code>lua_callk</code></a>,
you should call the continuation function
with <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> as the status.
(For <a href="#lua_yieldk"><code>lua_yieldk</code></a>, there is not much point in calling
directly the continuation function,
because <a href="#lua_yieldk"><code>lua_yieldk</code></a> usually does not return.)


<p>
Lua treats the continuation function as if it were the original function.
The continuation function receives the same Lua stack
from the original function,
in the same state it would be if the callee function had returned.
(For instance,
after a <a href="#lua_callk"><code>lua_callk</code></a> the function and its arguments are
removed from the stack and replaced by the results from the call.)
It also has the same upvalues.
Whatever it returns is handled by Lua as if it were the return
of the original function.





<h2>4.8 &ndash; <a name="4.8">Functions and Types</a></h2>

<p>
Here we list all functions and types from the C&nbsp;API in
alphabetical order.
Each function has an indicator like this:
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
The first field, <code>o</code>,
is how many elements the function pops from the stack.
The second field, <code>p</code>,
is how many elements the function pushes onto the stack.
(Any function always pushes its results after popping its arguments.)
A field in the form <code>x|y</code> means the function can push (or pop)
<code>x</code> or <code>y</code> elements,
depending on the situation;
an interrogation mark '<code>?</code>' means that
we cannot know how many elements the function pops/pushes
by looking only at its arguments
(e.g., they may depend on what is on the stack).
The third field, <code>x</code>,
tells whether the function may raise errors:
'<code>-</code>' means the function never raises any error;
'<code>m</code>' means the function may raise out-of-memory errors
and errors running a <code>__gc</code> metamethod;
'<code>e</code>' means the function may raise any errors
(it can run arbitrary Lua code,
either directly or through metamethods);
'<code>v</code>' means the function may raise an error on purpose.



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
Converts the acceptable index <code>idx</code>
into an equivalent absolute index
(that is, one that does not depend on the stack top).





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
The type of the memory-allocation function used by Lua states.
The allocator function must provide a
functionality similar to <code>realloc</code>,
but not exactly the same.
Its arguments are
<code>ud</code>, an opaque pointer passed to <a href="#lua_newstate"><code>lua_newstate</code></a>;
<code>ptr</code>, a pointer to the block being allocated/reallocated/freed;
<code>osize</code>, the original size of the block or some code about what
is being allocated;
and <code>nsize</code>, the new size of the block.


<p>
When <code>ptr</code> is not <code>NULL</code>,
<code>osize</code> is the size of the block pointed by <code>ptr</code>,
that is, the size given when it was allocated or reallocated.


<p>
When <code>ptr</code> is <code>NULL</code>,
<code>osize</code> encodes the kind of object that Lua is allocating.
<code>osize</code> is any of
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>, <a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>, <a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>, or <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> when (and only when)
Lua is creating a new object of that type.
When <code>osize</code> is some other value,
Lua is allocating memory for something else.


<p>
Lua assumes the following behavior from the allocator function:


<p>
When <code>nsize</code> is zero,
the allocator must behave like <code>free</code>
and return <code>NULL</code>.


<p>
When <code>nsize</code> is not zero,
the allocator must behave like <code>realloc</code>.
The allocator returns <code>NULL</code>
if and only if it cannot fulfill the request.
Lua assumes that the allocator never fails when
<code>osize &gt;= nsize</code>.


<p>
Here is a simple implementation for the allocator function.
It is used in the auxiliary library by <a href="#luaL_newstate"><code>luaL_newstate</code></a>.

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
Note that Standard&nbsp;C ensures
that <code>free(NULL)</code> has no effect and that
<code>realloc(NULL,size)</code> is equivalent to <code>malloc(size)</code>.
This code assumes that <code>realloc</code> does not fail when shrinking a block.
(Although Standard&nbsp;C does not ensure this behavior,
it seems to be a safe assumption.)





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
Performs an arithmetic or bitwise operation over the two values
(or one, in the case of negations)
at the top of the stack,
with the value at the top being the second operand,
pops these values, and pushes the result of the operation.
The function follows the semantics of the corresponding Lua operator
(that is, it may call metamethods).


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> performs addition (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> performs subtraction (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> performs multiplication (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> performs float division (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> performs floor division (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> performs modulo (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> performs exponentiation (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> performs mathematical negation (unary <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> performs bitwise NOT (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> performs bitwise AND (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> performs bitwise OR (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> performs bitwise exclusive OR (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> performs left shift (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> performs right shift (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
Sets a new panic function and returns the old one (see <a href="#4.6">&sect;4.6</a>).





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
Calls a function.


<p>
To call a function you must use the following protocol:
first, the function to be called is pushed onto the stack;
then, the arguments to the function are pushed
in direct order;
that is, the first argument is pushed first.
Finally you call <a href="#lua_call"><code>lua_call</code></a>;
<code>nargs</code> is the number of arguments that you pushed onto the stack.
All arguments and the function value are popped from the stack
when the function is called.
The function results are pushed onto the stack when the function returns.
The number of results is adjusted to <code>nresults</code>,
unless <code>nresults</code> is <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>.
In this case, all results from the function are pushed;
Lua takes care that the returned values fit into the stack space,
but it does not ensure any extra space in the stack.
The function results are pushed onto the stack in direct order
(the first result is pushed first),
so that after the call the last result is on the top of the stack.


<p>
Any error inside the called function is propagated upwards
(with a <code>longjmp</code>).


<p>
The following example shows how the host program can do the
equivalent to this Lua code:

<pre>
     a = f("how", t.x, 14)
</pre><p>
Here it is in&nbsp;C:

<pre>
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>
Note that the code above is <em>balanced</em>:
at its end, the stack is back to its original configuration.
This is considered good programming practice.





<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_call"><code>lua_call</code></a>,
but allows the called function to yield (see <a href="#4.7">&sect;4.7</a>).





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
Type for C&nbsp;functions.


<p>
In order to communicate properly with Lua,
a C&nbsp;function must use the following protocol,
which defines the way parameters and results are passed:
a C&nbsp;function receives its arguments from Lua in its stack
in direct order (the first argument is pushed first).
So, when the function starts,
<code>lua_gettop(L)</code> returns the number of arguments received by the function.
The first argument (if any) is at index 1
and its last argument is at index <code>lua_gettop(L)</code>.
To return values to Lua, a C&nbsp;function just pushes them onto the stack,
in direct order (the first result is pushed first),
and returns the number of results.
Any other value in the stack below the results will be properly
discarded by Lua.
Like a Lua function, a C&nbsp;function called by Lua can also return
many results.


<p>
As an example, the following function receives a variable number
of numeric arguments and returns their average and their sum:

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* number of arguments */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* first result */
       lua_pushnumber(L, sum);         /* second result */
       return 2;                   /* number of results */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
Ensures that the stack has space for at least <code>n</code> extra slots
(that is, that you can safely push up to <code>n</code> values into it).
It returns false if it cannot fulfill the request,
either because it would cause the stack
to be larger than a fixed maximum size
(typically at least several thousand elements) or
because it cannot allocate memory for the extra space.
This function never shrinks the stack;
if the stack already has space for the extra slots,
it is left unchanged.





<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
Destroys all objects in the given Lua state
(calling the corresponding garbage-collection metamethods, if any)
and frees all dynamic memory used by this state.
In several platforms, you may not need to call this function,
because all resources are naturally released when the host program ends.
On the other hand, long-running programs that create multiple states,
such as daemons or web servers,
will probably need to close states as soon as they are not needed.





<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
Compares two Lua values.
Returns 1 if the value at index <code>index1</code> satisfies <code>op</code>
when compared with the value at index <code>index2</code>,
following the semantics of the corresponding Lua operator
(that is, it may call metamethods).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices is not valid.


<p>
The value of <code>op</code> must be one of the following constants:

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> compares for equality (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> compares for less than (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> compares for less or equal (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
Concatenates the <code>n</code> values at the top of the stack,
pops them, and leaves the result at the top.
If <code>n</code>&nbsp;is&nbsp;1, the result is the single value on the stack
(that is, the function does nothing);
if <code>n</code> is 0, the result is the empty string.
Concatenation is performed following the usual semantics of Lua
(see <a href="#3.4.6">&sect;3.4.6</a>).





<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
Copies the element at index <code>fromidx</code>
into the valid index <code>toidx</code>,
replacing the value at that position.
Values at other positions are not affected.





<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
Parameter <code>narr</code> is a hint for how many elements the table
will have as a sequence;
parameter <code>nrec</code> is a hint for how many other elements
the table will have.
Lua may use these hints to preallocate memory for the new table.
This preallocation is useful for performance when you know in advance
how many elements the table will have.
Otherwise you can use the function <a href="#lua_newtable"><code>lua_newtable</code></a>.





<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
Dumps a function as a binary chunk.
Receives a Lua function on the top of the stack
and produces a binary chunk that,
if loaded again,
results in a function equivalent to the one dumped.
As it produces parts of the chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls function <code>writer</code> (see <a href="#lua_Writer"><code>lua_Writer</code></a>)
with the given <code>data</code>
to write them.


<p>
If <code>strip</code> is true,
the binary representation may not include all debug information
about the function,
to save space.


<p>
The value returned is the error code returned by the last
call to the writer;
0&nbsp;means no errors.


<p>
This function does not pop the Lua function from the stack.





<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
Generates a Lua error,
using the value at the top of the stack as the error object.
This function does a long jump,
and therefore never returns
(see <a href="#luaL_error"><code>luaL_error</code></a>).





<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
Controls the garbage collector.


<p>
This function performs several tasks,
according to the value of the parameter <code>what</code>:

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
stops the garbage collector.
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
restarts the garbage collector.
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
performs a full garbage-collection cycle.
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
returns the current amount of memory (in Kbytes) in use by Lua.
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
returns the remainder of dividing the current amount of bytes of
memory in use by Lua by 1024.
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
performs an incremental step of garbage collection.
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
sets <code>data</code> as the new value
for the <em>pause</em> of the collector (see <a href="#2.5">&sect;2.5</a>)
and returns the previous value of the pause.
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
sets <code>data</code> as the new value for the <em>step multiplier</em> of
the collector (see <a href="#2.5">&sect;2.5</a>)
and returns the previous value of the step multiplier.
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
returns a boolean that tells whether the collector is running
(i.e., not stopped).
</li>

</ul>

<p>
For more details about these options,
see <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>.





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
Returns the memory-allocation function of a given state.
If <code>ud</code> is not <code>NULL</code>, Lua stores in <code>*ud</code> the
opaque pointer given when the memory-allocator function was set.





<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
Returns a pointer to a raw memory area associated with the
given Lua state.
The application can use this area for any purpose;
Lua does not use it for anything.


<p>
Each new thread has this area initialized with a copy
of the area of the main thread.


<p>
By default, this area has the size of a pointer to void,
but you can recompile Lua with a different size for this area.
(See <code>LUA_EXTRASPACE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
Pushes onto the stack the value of the global <code>name</code>.
Returns the type of that value.





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Pushes onto the stack the value <code>t[i]</code>,
where <code>t</code> is the value at the given index.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
If the value at the given index has a metatable,
the function pushes that metatable onto the stack and returns&nbsp;1.
Otherwise,
the function returns&nbsp;0 and pushes nothing on the stack.





<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the value at the given index
and <code>k</code> is the value at the top of the stack.


<p>
This function pops the key from the stack,
pushing the resulting value in its place.
As in Lua, this function may trigger a metamethod
for the "index" event (see <a href="#2.4">&sect;2.4</a>).


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
Returns the index of the top element in the stack.
Because indices start at&nbsp;1,
this result is equal to the number of elements in the stack;
in particular, 0&nbsp;means an empty stack.





<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
Pushes onto the stack the Lua value associated with the full userdata
at the given index.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index,
shifting up the elements above this index to open space.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
The type of integers in Lua.


<p>
By default this type is <code>long long</code>,
(usually a 64-bit two-complement integer),
but that can be changed to <code>long</code> or <code>int</code>
(usually a 32-bit two-complement integer).
(See <code>LUA_INT_TYPE</code> in <code>luaconf.h</code>.)


<p>
Lua also defines the constants
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> and <a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>,
with the minimum and the maximum values that fit in this type.





<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a boolean,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a C&nbsp;function,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a function
(either C or Lua), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is an integer
(that is, the value is a number and is represented as an integer),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a light userdata,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
Returns 1 if the given index is not valid
or if the value at this index is <b>nil</b>,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a number
or a string convertible to a number,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a string
or a number (which is always convertible to a string),
and 0&nbsp;otherwise.





<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a table,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a thread,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
Returns 1 if the value at the given index is a userdata
(either full or light), and 0&nbsp;otherwise.





<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
Returns 1 if the given coroutine can yield,
and 0&nbsp;otherwise.





<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
The type for continuation-function contexts.
It must be a numeric type.
This type is defined as <code>intptr_t</code>
when <code>intptr_t</code> is available,
so that it can store pointers too.
Otherwise, it is defined as <code>ptrdiff_t</code>.





<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
Type for continuation functions (see <a href="#4.7">&sect;4.7</a>).





<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
Returns the length of the value at the given index.
It is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">&sect;3.4.7</a>) and
may trigger a metamethod for the "length" event (see <a href="#2.4">&sect;2.4</a>).
The result is pushed on the stack.





<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
Loads a Lua chunk without running it.
If there are no errors,
<code>lua_load</code> pushes the compiled chunk as a Lua
function on top of the stack.
Otherwise, it pushes an error message.


<p>
The return values of <code>lua_load</code> are:

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> no errors;</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
syntax error during precompilation;</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
memory allocation (out-of-memory) error;</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
error while running a <code>__gc</code> metamethod.
(This error has no relation with the chunk being loaded.
It is generated by the garbage collector.)
</li>

</ul>

<p>
The <code>lua_load</code> function uses a user-supplied <code>reader</code> function
to read the chunk (see <a href="#lua_Reader"><code>lua_Reader</code></a>).
The <code>data</code> argument is an opaque value passed to the reader function.


<p>
The <code>chunkname</code> argument gives a name to the chunk,
which is used for error messages and in debug information (see <a href="#4.9">&sect;4.9</a>).


<p>
<code>lua_load</code> automatically detects whether the chunk is text or binary
and loads it accordingly (see program <code>luac</code>).
The string <code>mode</code> works as in function <a href="#pdf-load"><code>load</code></a>,
with the addition that
a <code>NULL</code> value is equivalent to the string "<code>bt</code>".


<p>
<code>lua_load</code> uses the stack internally,
so the reader function must always leave the stack
unmodified when returning.


<p>
If the resulting function has upvalues,
its first upvalue is set to the value of the global environment
stored at index <code>LUA_RIDX_GLOBALS</code> in the registry (see <a href="#4.5">&sect;4.5</a>).
When loading main chunks,
this upvalue will be the <code>_ENV</code> variable (see <a href="#2.2">&sect;2.2</a>).
Other upvalues are initialized with <b>nil</b>.





<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
Creates a new thread running in a new, independent state.
Returns <code>NULL</code> if it cannot create the thread or the state
(due to lack of memory).
The argument <code>f</code> is the allocator function;
Lua does all memory allocation for this state
through this function (see <a href="#lua_Alloc"><code>lua_Alloc</code></a>).
The second argument, <code>ud</code>, is an opaque pointer that Lua
passes to the allocator in every call.





<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
Creates a new empty table and pushes it onto the stack.
It is equivalent to <code>lua_createtable(L, 0, 0)</code>.





<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
Creates a new thread, pushes it on the stack,
and returns a pointer to a <a href="#lua_State"><code>lua_State</code></a> that represents this new thread.
The new thread returned by this function shares with the original thread
its global environment,
but has an independent execution stack.


<p>
There is no explicit function to close or to destroy a thread.
Threads are subject to garbage collection,
like any Lua object.





<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
This function allocates a new block of memory with the given size,
pushes onto the stack a new full userdata with the block address,
and returns this address.
The host program can freely use this memory.





<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
Pops a key from the stack,
and pushes a key&ndash;value pair from the table at the given index
(the "next" pair after the given key).
If there are no more elements in the table,
then <a href="#lua_next"><code>lua_next</code></a> returns 0 (and pushes nothing).


<p>
A typical traversal looks like this:

<pre>
     /* table is in the stack at index 't' */
     lua_pushnil(L);  /* first key */
     while (lua_next(L, t) != 0) {
       /* uses 'key' (at index -2) and 'value' (at index -1) */
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* removes 'value'; keeps 'key' for next iteration */
       lua_pop(L, 1);
     }
</pre>

<p>
While traversing a table,
do not call <a href="#lua_tolstring"><code>lua_tolstring</code></a> directly on a key,
unless you know that the key is actually a string.
Recall that <a href="#lua_tolstring"><code>lua_tolstring</code></a> may change
the value at the given index;
this confuses the next call to <a href="#lua_next"><code>lua_next</code></a>.


<p>
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.





<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef ... lua_Number;</pre>

<p>
The type of floats in Lua.


<p>
By default this type is double,
but that can be changed to a single float or a long double.
(See <code>LUA_FLOAT_TYPE</code> in <code>luaconf.h</code>.)





<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
Converts a Lua float to a Lua integer.
This macro assumes that <code>n</code> has an integral value.
If that value is within the range of Lua integers,
it is converted to an integer and assigned to <code>*p</code>.
The macro results in a boolean indicating whether the
conversion was successful.
(Note that this range test can be tricky to do
correctly without this macro,
due to roundings.)


<p>
This macro may evaluate its arguments more than once.





<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
Calls a function in protected mode.


<p>
Both <code>nargs</code> and <code>nresults</code> have the same meaning as
in <a href="#lua_call"><code>lua_call</code></a>.
If there are no errors during the call,
<a href="#lua_pcall"><code>lua_pcall</code></a> behaves exactly like <a href="#lua_call"><code>lua_call</code></a>.
However, if there is any error,
<a href="#lua_pcall"><code>lua_pcall</code></a> catches it,
pushes a single value on the stack (the error object),
and returns an error code.
Like <a href="#lua_call"><code>lua_call</code></a>,
<a href="#lua_pcall"><code>lua_pcall</code></a> always removes the function
and its arguments from the stack.


<p>
If <code>msgh</code> is 0,
then the error object returned on the stack
is exactly the original error object.
Otherwise, <code>msgh</code> is the stack index of a
<em>message handler</em>.
(This index cannot be a pseudo-index.)
In case of runtime errors,
this function will be called with the error object
and its return value will be the object
returned on the stack by <a href="#lua_pcall"><code>lua_pcall</code></a>.


<p>
Typically, the message handler is used to add more debug
information to the error object, such as a stack traceback.
Such information cannot be gathered after the return of <a href="#lua_pcall"><code>lua_pcall</code></a>,
since by then the stack has unwound.


<p>
The <a href="#lua_pcall"><code>lua_pcall</code></a> function returns one of the following constants
(defined in <code>lua.h</code>):

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
success.</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
a runtime error.
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
memory allocation error.
For such errors, Lua does not call the message handler.
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
error while running the message handler.
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
error while running a <code>__gc</code> metamethod.
For such errors, Lua does not call the message handler
(as this kind of error typically has no relation
with the function being called).
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
This function behaves exactly like <a href="#lua_pcall"><code>lua_pcall</code></a>,
but allows the called function to yield (see <a href="#4.7">&sect;4.7</a>).





<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
Pops <code>n</code> elements from the stack.





<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
Pushes a boolean value with value <code>b</code> onto the stack.





<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>m</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
Pushes a new C&nbsp;closure onto the stack.


<p>
When a C&nbsp;function is created,
it is possible to associate some values with it,
thus creating a C&nbsp;closure (see <a href="#4.4">&sect;4.4</a>);
these values are then accessible to the function whenever it is called.
To associate values with a C&nbsp;function,
first these values must be pushed onto the stack
(when there are multiple values, the first value is pushed first).
Then <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
is called to create and push the C&nbsp;function onto the stack,
with the argument <code>n</code> telling how many values will be
associated with the function.
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> also pops these values from the stack.


<p>
The maximum value for <code>n</code> is 255.


<p>
When <code>n</code> is zero,
this function creates a <em>light C&nbsp;function</em>,
which is just a pointer to the C&nbsp;function.
In that case, it never raises a memory error.





<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
Pushes a C&nbsp;function onto the stack.
This function receives a pointer to a C&nbsp;function
and pushes onto the stack a Lua value of type <code>function</code> that,
when called, invokes the corresponding C&nbsp;function.


<p>
Any function to be callable by Lua must
follow the correct protocol to receive its parameters
and return its results (see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).





<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
Pushes onto the stack a formatted string
and returns a pointer to this string.
It is similar to the ISO&nbsp;C function <code>sprintf</code>,
but has some important differences:

<ul>

<li>
You do not have to allocate space for the result:
the result is a Lua string and Lua takes care of memory allocation
(and deallocation, through garbage collection).
</li>

<li>
The conversion specifiers are quite restricted.
There are no flags, widths, or precisions.
The conversion specifiers can only be
'<code>%%</code>' (inserts the character '<code>%</code>'),
'<code>%s</code>' (inserts a zero-terminated string, with no size restrictions),
'<code>%f</code>' (inserts a <a href="#lua_Number"><code>lua_Number</code></a>),
'<code>%I</code>' (inserts a <a href="#lua_Integer"><code>lua_Integer</code></a>),
'<code>%p</code>' (inserts a pointer as a hexadecimal numeral),
'<code>%d</code>' (inserts an <code>int</code>),
'<code>%c</code>' (inserts an <code>int</code> as a one-byte character), and
'<code>%U</code>' (inserts a <code>long int</code> as a UTF-8 byte sequence).
</li>

</ul>

<p>
Unlike other push functions,
this function checks for the stack space it needs,
including the slot for its result.





<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
Pushes the global environment onto the stack.





<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
Pushes an integer with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
Pushes a light userdata onto the stack.


<p>
Userdata represent C&nbsp;values in Lua.
A <em>light userdata</em> represents a pointer, a <code>void*</code>.
It is a value (like a number):
you do not create it, it has no individual metatable,
and it is not collected (as it was never created).
A light userdata is equal to "any"
light userdata with the same C&nbsp;address.





<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
This macro is equivalent to <a href="#lua_pushstring"><code>lua_pushstring</code></a>,
but should be used only when <code>s</code> is a literal string.





<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
Pushes the string pointed to by <code>s</code> with size <code>len</code>
onto the stack.
Lua makes (or reuses) an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.
The string can contain any binary data,
including embedded zeros.


<p>
Returns a pointer to the internal copy of the string.





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
Pushes a nil value onto the stack.





<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
Pushes a float with value <code>n</code> onto the stack.





<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
Pushes the zero-terminated string pointed to by <code>s</code>
onto the stack.
Lua makes (or reuses) an internal copy of the given string,
so the memory at <code>s</code> can be freed or reused immediately after
the function returns.


<p>
Returns a pointer to the internal copy of the string.


<p>
If <code>s</code> is <code>NULL</code>, pushes <b>nil</b> and returns <code>NULL</code>.





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
Pushes the thread represented by <code>L</code> onto the stack.
Returns 1 if this thread is the main thread of its state.





<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
Pushes a copy of the element at the given index
onto the stack.





<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
Equivalent to <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>, except that it receives a <code>va_list</code>
instead of a variable number of arguments.





<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
Returns 1 if the two values in indices <code>index1</code> and
<code>index2</code> are primitively equal
(that is, without calling the <code>__eq</code> metamethod).
Otherwise returns&nbsp;0.
Also returns&nbsp;0 if any of the indices are not valid.





<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_gettable"><code>lua_gettable</code></a>, but does a raw access
(i.e., without metamethods).





<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Pushes onto the stack the value <code>t[n]</code>,
where <code>t</code> is the table at the given index.
The access is raw,
that is, it does not invoke the <code>__index</code> metamethod.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
Pushes onto the stack the value <code>t[k]</code>,
where <code>t</code> is the table at the given index and
<code>k</code> is the pointer <code>p</code> represented as a light userdata.
The access is raw;
that is, it does not invoke the <code>__index</code> metamethod.


<p>
Returns the type of the pushed value.





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
Returns the raw "length" of the value at the given index:
for strings, this is the string length;
for tables, this is the result of the length operator ('<code>#</code>')
with no metamethods;
for userdata, this is the size of the block of memory allocated
for the userdata;
for other values, it is&nbsp;0.





<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>m</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
Similar to <a href="#lua_settable"><code>lua_settable</code></a>, but does a raw assignment
(i.e., without metamethods).





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
Does the equivalent of <code>t[i] = v</code>,
where <code>t</code> is the table at the given index
and <code>v</code> is the value at the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not invoke the <code>__newindex</code> metamethod.





<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
Does the equivalent of <code>t[p] = v</code>,
where <code>t</code> is the table at the given index,
<code>p</code> is encoded as a light userdata,
and <code>v</code> is the value at the top of the stack.


<p>
This function pops the value from the stack.
The assignment is raw,
that is, it does not invoke <code>__newindex</code> metamethod.





<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
The reader function used by <a href="#lua_load"><code>lua_load</code></a>.
Every time it needs another piece of the chunk,
<a href="#lua_load"><code>lua_load</code></a> calls the reader,
passing along its <code>data</code> parameter.
The reader must return a pointer to a block of memory
with a new piece of the chunk
and set <code>size</code> to the block size.
The block must exist until the reader function is called again.
To signal the end of the chunk,
the reader must return <code>NULL</code> or set <code>size</code> to zero.
The reader function may return pieces of any size greater than zero.





<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
Sets the C&nbsp;function <code>f</code> as the new value of global <code>name</code>.
It is defined as a macro:

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
Removes the element at the given valid index,
shifting down the elements above this index to fill the gap.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
Moves the top element into the given valid index
without shifting any element
(therefore replacing the value at that given index),
and then pops the top element.





<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
Starts and resumes a coroutine in the given thread <code>L</code>.


<p>
To start a coroutine,
you push onto the thread stack the main function plus any arguments;
then you call <a href="#lua_resume"><code>lua_resume</code></a>,
with <code>nargs</code> being the number of arguments.
This call returns when the coroutine suspends or finishes its execution.
When it returns, the stack contains all values passed to <a href="#lua_yield"><code>lua_yield</code></a>,
or all values returned by the body function.
<a href="#lua_resume"><code>lua_resume</code></a> returns
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the coroutine yields,
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a> if the coroutine finishes its execution
without errors,
or an error code in case of errors (see <a href="#lua_pcall"><code>lua_pcall</code></a>).


<p>
In case of errors,
the stack is not unwound,
so you can use the debug API over it.
The error object is on the top of the stack.


<p>
To resume a coroutine,
you remove any results from the last <a href="#lua_yield"><code>lua_yield</code></a>,
put on its stack only the values to
be passed as results from <code>yield</code>,
and then call <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
The parameter <code>from</code> represents the coroutine that is resuming <code>L</code>.
If there is no such coroutine,
this parameter can be <code>NULL</code>.





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
Rotates the stack elements between the valid index <code>idx</code>
and the top of the stack.
The elements are rotated <code>n</code> positions in the direction of the top,
for a positive <code>n</code>,
or <code>-n</code> positions in the direction of the bottom,
for a negative <code>n</code>.
The absolute value of <code>n</code> must not be greater than the size
of the slice being rotated.
This function cannot be called with a pseudo-index,
because a pseudo-index is not an actual stack position.





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
Changes the allocator function of a given state to <code>f</code>
with user data <code>ud</code>.





<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value at the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
Pops a value from the stack and
sets it as the new value of global <code>name</code>.





<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
Does the equivalent to <code>t[n] = v</code>,
where <code>t</code> is the value at the given index
and <code>v</code> is the value at the top of the stack.


<p>
This function pops the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
Pops a table from the stack and
sets it as the new metatable for the value at the given index.





<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
Does the equivalent to <code>t[k] = v</code>,
where <code>t</code> is the value at the given index,
<code>v</code> is the value at the top of the stack,
and <code>k</code> is the value just below the top.


<p>
This function pops both the key and the value from the stack.
As in Lua, this function may trigger a metamethod
for the "newindex" event (see <a href="#2.4">&sect;2.4</a>).





<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
Accepts any index, or&nbsp;0,
and sets the stack top to this index.
If the new top is larger than the old one,
then the new elements are filled with <b>nil</b>.
If <code>index</code> is&nbsp;0, then all stack elements are removed.





<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
Pops a value from the stack and sets it as
the new value associated to the full userdata at the given index.





<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
An opaque structure that points to a thread and indirectly
(through the thread) to the whole state of a Lua interpreter.
The Lua library is fully reentrant:
it has no global variables.
All information about a state is accessible through this structure.


<p>
A pointer to this structure must be passed as the first argument to
every function in the library, except to <a href="#lua_newstate"><code>lua_newstate</code></a>,
which creates a Lua state from scratch.





<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
Returns the status of the thread <code>L</code>.


<p>
The status can be 0 (<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>) for a normal thread,
an error code if the thread finished the execution
of a <a href="#lua_resume"><code>lua_resume</code></a> with an error,
or <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> if the thread is suspended.


<p>
You can only call functions in threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>.
You can resume threads with status <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
(to start a new coroutine) or <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>
(to resume a coroutine).





<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
Converts the zero-terminated string <code>s</code> to a number,
pushes that number into the stack,
and returns the total size of the string,
that is, its length plus one.
The conversion can result in an integer or a float,
according to the lexical conventions of Lua (see <a href="#3.1">&sect;3.1</a>).
The string may have leading and trailing spaces and a sign.
If the string is not a valid numeral,
returns 0 and pushes nothing.
(Note that the result can be used as a boolean,
true if the conversion succeeds.)





<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;boolean
value (0&nbsp;or&nbsp;1).
Like all tests in Lua,
<a href="#lua_toboolean"><code>lua_toboolean</code></a> returns true for any Lua value
different from <b>false</b> and <b>nil</b>;
otherwise it returns false.
(If you want to accept only actual boolean values,
use <a href="#lua_isboolean"><code>lua_isboolean</code></a> to test the value's type.)





<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
Converts a value at the given index to a C&nbsp;function.
That value must be a C&nbsp;function;
otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tointegerx"><code>lua_tointegerx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the signed integral type <a href="#lua_Integer"><code>lua_Integer</code></a>.
The Lua value must be an integer,
or a number or string convertible to an integer (see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <code>lua_tointegerx</code> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
Converts the Lua value at the given index to a C&nbsp;string.
If <code>len</code> is not <code>NULL</code>,
it sets <code>*len</code> with the string length.
The Lua value must be a string or a number;
otherwise, the function returns <code>NULL</code>.
If the value is a number,
then <code>lua_tolstring</code> also
<em>changes the actual value in the stack to a string</em>.
(This change confuses <a href="#lua_next"><code>lua_next</code></a>
when <code>lua_tolstring</code> is applied to keys during a table traversal.)


<p>
<code>lua_tolstring</code> returns a pointer
to a string inside the Lua state.
This string always has a zero ('<code>\0</code>')
after its last character (as in&nbsp;C),
but can contain other zeros in its body.


<p>
Because Lua has garbage collection,
there is no guarantee that the pointer returned by <code>lua_tolstring</code>
will be valid after the corresponding Lua value is removed from the stack.





<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> with <code>isnum</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
Converts the Lua value at the given index
to the C&nbsp;type <a href="#lua_Number"><code>lua_Number</code></a> (see <a href="#lua_Number"><code>lua_Number</code></a>).
The Lua value must be a number or a string convertible to a number
(see <a href="#3.4.3">&sect;3.4.3</a>);
otherwise, <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> returns&nbsp;0.


<p>
If <code>isnum</code> is not <code>NULL</code>,
its referent is assigned a boolean value that
indicates whether the operation succeeded.





<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a generic
C&nbsp;pointer (<code>void*</code>).
The value can be a userdata, a table, a thread, or a function;
otherwise, <code>lua_topointer</code> returns <code>NULL</code>.
Different objects will give different pointers.
There is no way to convert the pointer back to its original value.


<p>
Typically this function is used only for hashing and debug information.





<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
Equivalent to <a href="#lua_tolstring"><code>lua_tolstring</code></a> with <code>len</code> equal to <code>NULL</code>.





<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
Converts the value at the given index to a Lua thread
(represented as <code>lua_State*</code>).
This value must be a thread;
otherwise, the function returns <code>NULL</code>.





<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
If the value at the given index is a full userdata,
returns its block address.
If the value is a light userdata,
returns its pointer.
Otherwise, returns <code>NULL</code>.





<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
Returns the type of the value in the given valid index,
or <code>LUA_TNONE</code> for a non-valid (but acceptable) index.
The types returned by <a href="#lua_type"><code>lua_type</code></a> are coded by the following constants
defined in <code>lua.h</code>:
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a> (0),
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>,
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>,
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>,
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>,
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>,
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>,
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>,
and
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>.





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
Returns the name of the type encoded by the value <code>tp</code>,
which must be one the values returned by <a href="#lua_type"><code>lua_type</code></a>.





<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
The unsigned version of <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
Returns the pseudo-index that represents the <code>i</code>-th upvalue of
the running function (see <a href="#4.4">&sect;4.4</a>).





<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
Returns the address of the version number
(a C static variable)
stored in the Lua core.
When called with a valid <a href="#lua_State"><code>lua_State</code></a>,
returns the address of the version used to create that state.
When called with <code>NULL</code>,
returns the address of the version running the call.





<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
The type of the writer function used by <a href="#lua_dump"><code>lua_dump</code></a>.
Every time it produces another piece of chunk,
<a href="#lua_dump"><code>lua_dump</code></a> calls the writer,
passing along the buffer to be written (<code>p</code>),
its size (<code>sz</code>),
and the <code>data</code> parameter supplied to <a href="#lua_dump"><code>lua_dump</code></a>.


<p>
The writer returns an error code:
0&nbsp;means no errors;
any other value means an error and stops <a href="#lua_dump"><code>lua_dump</code></a> from
calling the writer again.





<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
Exchange values between different threads of the same state.


<p>
This function pops <code>n</code> values from the stack <code>from</code>,
and pushes them onto the stack <code>to</code>.





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
This function is equivalent to <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
but it has no continuation (see <a href="#4.7">&sect;4.7</a>).
Therefore, when the thread resumes,
it continues the function that called
the function calling <code>lua_yield</code>.





<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
Yields a coroutine (thread).


<p>
When a C&nbsp;function calls <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
the running coroutine suspends its execution,
and the call to <a href="#lua_resume"><code>lua_resume</code></a> that started this coroutine returns.
The parameter <code>nresults</code> is the number of values from the stack
that will be passed as results to <a href="#lua_resume"><code>lua_resume</code></a>.


<p>
When the coroutine is resumed again,
Lua calls the given continuation function <code>k</code> to continue
the execution of the C&nbsp;function that yielded (see <a href="#4.7">&sect;4.7</a>).
This continuation function receives the same stack
from the previous function,
with the <code>n</code> results removed and
replaced by the arguments passed to <a href="#lua_resume"><code>lua_resume</code></a>.
Moreover,
the continuation function receives the value <code>ctx</code>
that was passed to <a href="#lua_yieldk"><code>lua_yieldk</code></a>.


<p>
Usually, this function does not return;
when the coroutine eventually resumes,
it continues executing the continuation function.
However, there is one special case,
which is when this function is called
from inside a line or a count hook (see <a href="#4.9">&sect;4.9</a>).
In that case, <code>lua_yieldk</code> should be called with no continuation
(probably in the form of <a href="#lua_yield"><code>lua_yield</code></a>) and no results,
and the hook should return immediately after the call.
Lua will yield and,
when the coroutine resumes again,
it will continue the normal execution
of the (Lua) function that triggered the hook.


<p>
This function can raise an error if it is called from a thread
with a pending C call with no continuation function,
or it is called from a thread that is not running inside a resume
(e.g., the main thread).







<h2>4.9 &ndash; <a name="4.9">The Debug Interface</a></h2>

<p>
Lua has no built-in debugging facilities.
Instead, it offers a special interface
by means of functions and <em>hooks</em>.
This interface allows the construction of different
kinds of debuggers, profilers, and other tools
that need "inside information" from the interpreter.



<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) number of upvalues */
  unsigned char nparams;      /* (u) number of parameters */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  <em>other fields</em>
} lua_Debug;</pre>

<p>
A structure used to carry different pieces of
information about a function or an activation record.
<a href="#lua_getstack"><code>lua_getstack</code></a> fills only the private part
of this structure, for later use.
To fill the other fields of <a href="#lua_Debug"><code>lua_Debug</code></a> with useful information,
call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
The fields of <a href="#lua_Debug"><code>lua_Debug</code></a> have the following meaning:

<ul>

<li><b><code>source</code>: </b>
the name of the chunk that created the function.
If <code>source</code> starts with a '<code>@</code>',
it means that the function was defined in a file where
the file name follows the '<code>@</code>'.
If <code>source</code> starts with a '<code>=</code>',
the remainder of its contents describe the source in a user-dependent manner.
Otherwise,
the function was defined in a string where
<code>source</code> is that string.
</li>

<li><b><code>short_src</code>: </b>
a "printable" version of <code>source</code>, to be used in error messages.
</li>

<li><b><code>linedefined</code>: </b>
the line number where the definition of the function starts.
</li>

<li><b><code>lastlinedefined</code>: </b>
the line number where the definition of the function ends.
</li>

<li><b><code>what</code>: </b>
the string <code>"Lua"</code> if the function is a Lua function,
<code>"C"</code> if it is a C&nbsp;function,
<code>"main"</code> if it is the main part of a chunk.
</li>

<li><b><code>currentline</code>: </b>
the current line where the given function is executing.
When no line information is available,
<code>currentline</code> is set to -1.
</li>

<li><b><code>name</code>: </b>
a reasonable name for the given function.
Because functions in Lua are first-class values,
they do not have a fixed name:
some functions can be the value of multiple global variables,
while others can be stored only in a table field.
The <code>lua_getinfo</code> function checks how the function was
called to find a suitable name.
If it cannot find a name,
then <code>name</code> is set to <code>NULL</code>.
</li>

<li><b><code>namewhat</code>: </b>
explains the <code>name</code> field.
The value of <code>namewhat</code> can be
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>,
<code>"field"</code>, <code>"upvalue"</code>, or <code>""</code> (the empty string),
according to how the function was called.
(Lua uses the empty string when no other option seems to apply.)
</li>

<li><b><code>istailcall</code>: </b>
true if this function invocation was called by a tail call.
In this case, the caller of this level is not in the stack.
</li>

<li><b><code>nups</code>: </b>
the number of upvalues of the function.
</li>

<li><b><code>nparams</code>: </b>
the number of fixed parameters of the function
(always 0&nbsp;for C&nbsp;functions).
</li>

<li><b><code>isvararg</code>: </b>
true if the function is a vararg function
(always true for C&nbsp;functions).
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
Returns the current hook function.





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
Returns the current hook count.





<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
Returns the current hook mask.





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
Gets information about a specific function or function invocation.


<p>
To get information about a function invocation,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).


<p>
To get information about a function, you push it onto the stack
and start the <code>what</code> string with the character '<code>&gt;</code>'.
(In that case,
<code>lua_getinfo</code> pops the function from the top of the stack.)
For instance, to know in which line a function <code>f</code> was defined,
you can write the following code:

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* get global 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
Each character in the string <code>what</code>
selects some fields of the structure <code>ar</code> to be filled or
a value to be pushed on the stack:

<ul>

<li><b>'<code>n</code>': </b> fills in the field <code>name</code> and <code>namewhat</code>;
</li>

<li><b>'<code>S</code>': </b>
fills in the fields <code>source</code>, <code>short_src</code>,
<code>linedefined</code>, <code>lastlinedefined</code>, and <code>what</code>;
</li>

<li><b>'<code>l</code>': </b> fills in the field <code>currentline</code>;
</li>

<li><b>'<code>t</code>': </b> fills in the field <code>istailcall</code>;
</li>

<li><b>'<code>u</code>': </b> fills in the fields
<code>nups</code>, <code>nparams</code>, and <code>isvararg</code>;
</li>

<li><b>'<code>f</code>': </b>
pushes onto the stack the function that is
running at the given level;
</li>

<li><b>'<code>L</code>': </b>
pushes onto the stack a table whose indices are the
numbers of the lines that are valid on the function.
(A <em>valid line</em> is a line with some associated code,
that is, a line where you can put a break point.
Non-valid lines include empty lines and comments.)


<p>
If this option is given together with option '<code>f</code>',
its table is pushed after the function.
</li>

</ul>

<p>
This function returns 0 on error
(for instance, an invalid option in <code>what</code>).





<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Gets information about a local variable of
a given activation record or a given function.


<p>
In the first case,
the parameter <code>ar</code> must be a valid activation record that was
filled by a previous call to <a href="#lua_getstack"><code>lua_getstack</code></a> or
given as argument to a hook (see <a href="#lua_Hook"><code>lua_Hook</code></a>).
The index <code>n</code> selects which local variable to inspect;
see <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for details about variable indices
and names.


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> pushes the variable's value onto the stack
and returns its name.


<p>
In the second case, <code>ar</code> must be <code>NULL</code> and the function
to be inspected must be at the top of the stack.
In this case, only parameters of Lua functions are visible
(as there is no information about what variables are active)
and no values are pushed onto the stack.


<p>
Returns <code>NULL</code> (and pushes nothing)
when the index is greater than
the number of active local variables.





<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
Gets information about the interpreter runtime stack.


<p>
This function fills parts of a <a href="#lua_Debug"><code>lua_Debug</code></a> structure with
an identification of the <em>activation record</em>
of the function executing at a given level.
Level&nbsp;0 is the current running function,
whereas level <em>n+1</em> is the function that has called level <em>n</em>
(except for tail calls, which do not count on the stack).
When there are no errors, <a href="#lua_getstack"><code>lua_getstack</code></a> returns 1;
when called with a level greater than the stack depth,
it returns 0.





<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Gets information about the <code>n</code>-th upvalue
of the closure at index <code>funcindex</code>.
It pushes the upvalue's value onto the stack
and returns its name.
Returns <code>NULL</code> (and pushes nothing)
when the index <code>n</code> is greater than the number of upvalues.


<p>
For C&nbsp;functions, this function uses the empty string <code>""</code>
as a name for all upvalues.
(For Lua functions,
upvalues are the external local variables that the function uses,
and that are consequently included in its closure.)


<p>
Upvalues have no particular order,
as they are active through the whole function.
They are numbered in an arbitrary order.





<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
Type for debugging hook functions.


<p>
Whenever a hook is called, its <code>ar</code> argument has its field
<code>event</code> set to the specific event that triggered the hook.
Lua identifies these events with the following constants:
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>, <a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>,
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>, <a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>,
and <a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>.
Moreover, for line events, the field <code>currentline</code> is also set.
To get the value of any other field in <code>ar</code>,
the hook must call <a href="#lua_getinfo"><code>lua_getinfo</code></a>.


<p>
For call events, <code>event</code> can be <code>LUA_HOOKCALL</code>,
the normal value, or <code>LUA_HOOKTAILCALL</code>, for a tail call;
in this case, there will be no corresponding return event.


<p>
While Lua is running a hook, it disables other calls to hooks.
Therefore, if a hook calls back Lua to execute a function or a chunk,
this execution occurs without any calls to hooks.


<p>
Hook functions cannot have continuations,
that is, they cannot call <a href="#lua_yieldk"><code>lua_yieldk</code></a>,
<a href="#lua_pcallk"><code>lua_pcallk</code></a>, or <a href="#lua_callk"><code>lua_callk</code></a> with a non-null <code>k</code>.


<p>
Hook functions can yield under the following conditions:
Only count and line events can yield;
to yield, a hook function must finish its execution
calling <a href="#lua_yield"><code>lua_yield</code></a> with <code>nresults</code> equal to zero
(that is, with no values).





<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
Sets the debugging hook function.


<p>
Argument <code>f</code> is the hook function.
<code>mask</code> specifies on which events the hook will be called:
it is formed by a bitwise OR of the constants
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>,
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>,
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>,
and <a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>.
The <code>count</code> argument is only meaningful when the mask
includes <code>LUA_MASKCOUNT</code>.
For each event, the hook is called as explained below:

<ul>

<li><b>The call hook: </b> is called when the interpreter calls a function.
The hook is called just after Lua enters the new function,
before the function gets its arguments.
</li>

<li><b>The return hook: </b> is called when the interpreter returns from a function.
The hook is called just before Lua leaves the function.
There is no standard way to access the values
to be returned by the function.
</li>

<li><b>The line hook: </b> is called when the interpreter is about to
start the execution of a new line of code,
or when it jumps back in the code (even to the same line).
(This event only happens while Lua is executing a Lua function.)
</li>

<li><b>The count hook: </b> is called after the interpreter executes every
<code>count</code> instructions.
(This event only happens while Lua is executing a Lua function.)
</li>

</ul>

<p>
A hook is disabled by setting <code>mask</code> to zero.





<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
Sets the value of a local variable of a given activation record.
It assigns the value at the top of the stack
to the variable and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index is greater than
the number of active local variables.


<p>
Parameters <code>ar</code> and <code>n</code> are as in function <a href="#lua_getlocal"><code>lua_getlocal</code></a>.





<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
Sets the value of a closure's upvalue.
It assigns the value at the top of the stack
to the upvalue and returns its name.
It also pops the value from the stack.


<p>
Returns <code>NULL</code> (and pops nothing)
when the index <code>n</code> is greater than the number of upvalues.


<p>
Parameters <code>funcindex</code> and <code>n</code> are as in function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>.





<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
Returns a unique identifier for the upvalue numbered <code>n</code>
from the closure at index <code>funcindex</code>.


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.


<p>
Parameters <code>funcindex</code> and <code>n</code> are as in function <a href="#lua_getupvalue"><code>lua_getupvalue</code></a>,
but <code>n</code> cannot be greater than the number of upvalues.





<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
Make the <code>n1</code>-th upvalue of the Lua closure at index <code>funcindex1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure at index <code>funcindex2</code>.







<h1>5 &ndash; <a name="5">The Auxiliary Library</a></h1>

<p>

The <em>auxiliary library</em> provides several convenient functions
to interface C with Lua.
While the basic API provides the primitive functions for all
interactions between C and Lua,
the auxiliary library provides higher-level functions for some
common tasks.


<p>
All functions and types from the auxiliary library
are defined in header file <code>lauxlib.h</code> and
have a prefix <code>luaL_</code>.


<p>
All functions in the auxiliary library are built on
top of the basic API,
and so they provide nothing that cannot be done with that API.
Nevertheless, the use of the auxiliary library ensures
more consistency to your code.


<p>
Several functions in the auxiliary library use internally some
extra stack slots.
When a function in the auxiliary library uses less than five slots,
it does not check the stack size;
it simply assumes that there are enough slots.


<p>
Several functions in the auxiliary library are used to
check C&nbsp;function arguments.
Because the error message is formatted for arguments
(e.g., "<code>bad argument #1</code>"),
you should not use these functions for other stack values.


<p>
Functions called <code>luaL_check*</code>
always raise an error if the check is not satisfied.



<h2>5.1 &ndash; <a name="5.1">Functions and Types</a></h2>

<p>
Here we list all functions and types from the auxiliary library
in alphabetical order.



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
Adds the byte <code>c</code> to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
Adds the string pointed to by <code>s</code> with length <code>l</code> to
the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
The string can contain embedded zeros.





<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
Adds to the buffer <code>B</code> (see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>)
a string of length <code>n</code> previously copied to the
buffer area (see <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>).





<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
Adds the zero-terminated string pointed to by <code>s</code>
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>m</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
Adds the value at the top of the stack
to the buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
Pops the value.


<p>
This is the only function on string buffers that can (and must)
be called with an extra element on the stack,
which is the value to be added to the buffer.





<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
Checks whether <code>cond</code> is true.
If it is not, raises an error with a standard message (see <a href="#luaL_argerror"><code>luaL_argerror</code></a>).





<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
Raises an error reporting a problem with argument <code>arg</code>
of the C&nbsp;function that called it,
using a standard message
that includes <code>extramsg</code> as a comment:

<pre>
     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
This function never returns.





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
Type for a <em>string buffer</em>.


<p>
A string buffer allows C&nbsp;code to build Lua strings piecemeal.
Its pattern of use is as follows:

<ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it with a call <code>luaL_buffinit(L, &amp;b)</code>.</li>

<li>
Then add string pieces to the buffer calling any of
the <code>luaL_add*</code> functions.
</li>

<li>
Finish by calling <code>luaL_pushresult(&amp;b)</code>.
This call leaves the final string on the top of the stack.
</li>

</ul>

<p>
If you know beforehand the total size of the resulting string,
you can use the buffer like this:

<ul>

<li>First declare a variable <code>b</code> of type <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>.</li>

<li>Then initialize it and preallocate a space of
size <code>sz</code> with a call <code>luaL_buffinitsize(L, &amp;b, sz)</code>.</li>

<li>Then copy the string into that space.</li>

<li>
Finish by calling <code>luaL_pushresultsize(&amp;b, sz)</code>,
where <code>sz</code> is the total size of the resulting string
copied into that space.
</li>

</ul>

<p>
During its normal operation,
a string buffer uses a variable number of stack slots.
So, while using a buffer, you cannot assume that you know where
the top of the stack is.
You can use the stack between successive calls to buffer operations
as long as that use is balanced;
that is,
when you call a buffer operation,
the stack is at the same level
it was immediately after the previous buffer operation.
(The only exception to this rule is <a href="#luaL_addvalue"><code>luaL_addvalue</code></a>.)
After calling <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> the stack is back to its
level when the buffer was initialized,
plus the final string on its top.





<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
Initializes a buffer <code>B</code>.
This function does not allocate any space;
the buffer must be declared as a variable
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
Equivalent to the sequence
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>, <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>.





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
Calls a metamethod.


<p>
If the object at index <code>obj</code> has a metatable and this
metatable has a field <code>e</code>,
this function calls this field passing the object as its only argument.
In this case this function returns true and pushes onto the
stack the value returned by the call.
If there is no metatable or no metamethod,
this function returns false (without pushing any value on the stack).





<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
Checks whether the function has an argument
of any type (including <b>nil</b>) at position <code>arg</code>.





<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is an integer
(or can be converted to an integer)
and returns this integer cast to a <a href="#lua_Integer"><code>lua_Integer</code></a>.





<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string;
if <code>l</code> is not <code>NULL</code> fills <code>*l</code>
with the string's length.


<p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a number
and returns this number.





<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string and
searches for this string in the array <code>lst</code>
(which must be NULL-terminated).
Returns the index in the array where the string was found.
Raises an error if the argument is not a string or
if the string cannot be found.


<p>
If <code>def</code> is not <code>NULL</code>,
the function uses <code>def</code> as a default value when
there is no argument <code>arg</code> or when this argument is <b>nil</b>.


<p>
This is a useful function for mapping strings to C&nbsp;enums.
(The usual convention in Lua libraries is
to use strings instead of numbers to select options.)





<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
Grows the stack size to <code>top + sz</code> elements,
raising an error if the stack cannot grow to that size.
<code>msg</code> is an additional text to go into the error message
(or <code>NULL</code> for no additional text).





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
Checks whether the function argument <code>arg</code> is a string
and returns this string.


<p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
Checks whether the function argument <code>arg</code> has type <code>t</code>.
See <a href="#lua_type"><code>lua_type</code></a> for the encoding of types for <code>t</code>.





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
Checks whether the function argument <code>arg</code> is a userdata
of the type <code>tname</code> (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>) and
returns the userdata address (see <a href="#lua_touserdata"><code>lua_touserdata</code></a>).





<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
Checks whether the core running the call,
the core that created the Lua state,
and the code making the call are all using the same version of Lua.
Also checks whether the core running the call
and the core that created the Lua state
are using the same address space.





<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
Loads and runs the given file.
It is defined as the following macro:

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns false if there are no errors
or true in case of errors.





<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
Loads and runs the given string.
It is defined as the following macro:

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
It returns false if there are no errors
or true in case of errors.





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
Raises an error.
The error message format is given by <code>fmt</code>
plus any extra arguments,
following the same rules of <a href="#lua_pushfstring"><code>lua_pushfstring</code></a>.
It also adds at the beginning of the message the file name and
the line number where the error occurred,
if this information is available.


<p>
This function never returns,
but it is an idiom to use it in C&nbsp;functions
as <code>return luaL_error(<em>args</em>)</code>.





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>m</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
This function produces the return values for
process-related functions in the standard library
(<a href="#pdf-os.execute"><code>os.execute</code></a> and <a href="#pdf-io.close"><code>io.close</code></a>).





<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>m</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
This function produces the return values for
file-related functions in the standard library
(<a href="#pdf-io.open"><code>io.open</code></a>, <a href="#pdf-os.rename"><code>os.rename</code></a>, <a href="#pdf-file:seek"><code>file:seek</code></a>, etc.).





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>m</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
Pushes onto the stack the field <code>e</code> from the metatable
of the object at index <code>obj</code> and returns the type of the pushed value.
If the object does not have a metatable,
or if the metatable does not have this field,
pushes nothing and returns <code>LUA_TNIL</code>.





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
Pushes onto the stack the metatable associated with name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>)
(<b>nil</b> if there is no metatable associated with that name).
Returns the type of the pushed value.





<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
Ensures that the value <code>t[fname]</code>,
where <code>t</code> is the value at index <code>idx</code>,
is a table,
and pushes that table onto the stack.
Returns true if it finds a previous table there
and false if it creates a new table.





<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
Creates a copy of string <code>s</code> by replacing
any occurrence of the string <code>p</code>
with the string <code>r</code>.
Pushes the resulting string on the stack and returns it.





<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
Returns the "length" of the value at the given index
as a number;
it is equivalent to the '<code>#</code>' operator in Lua (see <a href="#3.4.7">&sect;3.4.7</a>).
Raises an error if the result of the operation is not an integer.
(This case only can happen through metamethods.)





<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
Equivalent to <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a> with <code>mode</code> equal to <code>NULL</code>.





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
Loads a buffer as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the
buffer pointed to by <code>buff</code> with size <code>sz</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.
<code>name</code> is the chunk name,
used for debug information and error messages.
The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
Equivalent to <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a> with <code>mode</code> equal to <code>NULL</code>.





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
Loads a file as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in the file
named <code>filename</code>.
If <code>filename</code> is <code>NULL</code>,
then it loads from the standard input.
The first line in the file is ignored if it starts with a <code>#</code>.


<p>
The string <code>mode</code> works as in function <a href="#lua_load"><code>lua_load</code></a>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>,
but it has an extra error code <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
for file-related errors
(e.g., it cannot open or read the file).


<p>
As <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
Loads a string as a Lua chunk.
This function uses <a href="#lua_load"><code>lua_load</code></a> to load the chunk in
the zero-terminated string <code>s</code>.


<p>
This function returns the same results as <a href="#lua_load"><code>lua_load</code></a>.


<p>
Also as <a href="#lua_load"><code>lua_load</code></a>, this function only loads the chunk;
it does not run it.





<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table and registers there
the functions in list <code>l</code>.


<p>
It is implemented as the following macro:

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
The array <code>l</code> must be the actual array,
not a pointer to it.





<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
Creates a new table with a size optimized
to store all entries in the array <code>l</code>
(but does not actually store them).
It is intended to be used in conjunction with <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
(see <a href="#luaL_newlib"><code>luaL_newlib</code></a>).


<p>
It is implemented as a macro.
The array <code>l</code> must be the actual array,
not a pointer to it.





<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
If the registry already has the key <code>tname</code>,
returns 0.
Otherwise,
creates a new table to be used as a metatable for userdata,
adds to this new table the pair <code>__name = tname</code>,
adds to the registry the pair <code>[tname] = new table</code>,
and returns 1.
(The entry <code>__name</code> is used by some error-reporting functions.)


<p>
In both cases pushes onto the stack the final value associated
with <code>tname</code> in the registry.





<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
Creates a new Lua state.
It calls <a href="#lua_newstate"><code>lua_newstate</code></a> with an
allocator based on the standard&nbsp;C <code>realloc</code> function
and then sets a panic function (see <a href="#4.6">&sect;4.6</a>) that prints
an error message to the standard error output in case of fatal
errors.


<p>
Returns the new state,
or <code>NULL</code> if there is a memory allocation error.





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
Opens all standard Lua libraries into the given state.





<hr><h3><a name="luaL_opt"><code>luaL_opt</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>T luaL_opt (L, func, arg, dflt);</pre>

<p>
This macro is defined as follows:

<pre>
     (lua_isnoneornil(L,(arg)) ? (dflt) : func(L,(arg)))
</pre><p>
In words, if the argument <code>arg</code> is nil or absent,
the macro results in the default <code>dflt</code>.
Otherwise, it results in the result of calling <code>func</code>
with the state <code>L</code> and the argument index <code>arg</code> as
arguments.
Note that it evaluates the expression <code>dflt</code> only if needed.





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
If the function argument <code>arg</code> is an integer
(or convertible to an integer),
returns this integer.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.


<p>
If <code>l</code> is not <code>NULL</code>,
fills the position <code>*l</code> with the result's length.
If the result is <code>NULL</code>
(only possible when returning <code>d</code> and <code>d == NULL</code>),
its length is considered zero.


<p>
This function uses <a href="#lua_tolstring"><code>lua_tolstring</code></a> to get its result,
so all conversions and caveats of that function apply here.





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
If the function argument <code>arg</code> is a number,
returns this number.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
If the function argument <code>arg</code> is a string,
returns this string.
If this argument is absent or is <b>nil</b>,
returns <code>d</code>.
Otherwise, raises an error.





<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
Equivalent to <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>
with the predefined size <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>.





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>m</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Returns an address to a space of size <code>sz</code>
where you can copy a string to be added to buffer <code>B</code>
(see <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>).
After copying the string into this space you must call
<a href="#luaL_addsize"><code>luaL_addsize</code></a> with the size of the string to actually add
it to the buffer.





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
Finishes the use of buffer <code>B</code> leaving the final string on
the top of the stack.





<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>m</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
Equivalent to the sequence <a href="#luaL_addsize"><code>luaL_addsize</code></a>, <a href="#luaL_pushresult"><code>luaL_pushresult</code></a>.





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>m</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
Creates and returns a <em>reference</em>,
in the table at index <code>t</code>,
for the object at the top of the stack (and pops the object).


<p>
A reference is a unique integer key.
As long as you do not manually add integer keys into table <code>t</code>,
<a href="#luaL_ref"><code>luaL_ref</code></a> ensures the uniqueness of the key it returns.
You can retrieve an object referred by reference <code>r</code>
by calling <code>lua_rawgeti(L, t, r)</code>.
Function <a href="#luaL_unref"><code>luaL_unref</code></a> frees a reference and its associated object.


<p>
If the object at the top of the stack is <b>nil</b>,
<a href="#luaL_ref"><code>luaL_ref</code></a> returns the constant <a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>.
The constant <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> is guaranteed to be different
from any reference returned by <a href="#luaL_ref"><code>luaL_ref</code></a>.





<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
Type for arrays of functions to be registered by
<a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>.
<code>name</code> is the function name and <code>func</code> is a pointer to
the function.
Any array of <a href="#luaL_Reg"><code>luaL_Reg</code></a> must end with a sentinel entry
in which both <code>name</code> and <code>func</code> are <code>NULL</code>.





<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
If <code>modname</code> is not already present in <a href="#pdf-package.loaded"><code>package.loaded</code></a>,
calls function <code>openf</code> with string <code>modname</code> as an argument
and sets the call result in <code>package.loaded[modname]</code>,
as if that function has been called through <a href="#pdf-require"><code>require</code></a>.


<p>
If <code>glb</code> is true,
also stores the module into global <code>modname</code>.


<p>
Leaves a copy of the module on the stack.





<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>m</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
Registers all functions in the array <code>l</code>
(see <a href="#luaL_Reg"><code>luaL_Reg</code></a>) into the table on the top of the stack
(below optional upvalues, see next).


<p>
When <code>nup</code> is not zero,
all functions are created sharing <code>nup</code> upvalues,
which must be previously pushed on the stack
on top of the library table.
These values are popped from the stack after the registration.





<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
Sets the metatable of the object at the top of the stack
as the metatable associated with name <code>tname</code>
in the registry (see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).





<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
The standard representation for file handles,
which is used by the standard I/O library.


<p>
A file handle is implemented as a full userdata,
with a metatable called <code>LUA_FILEHANDLE</code>
(where <code>LUA_FILEHANDLE</code> is a macro with the actual metatable's name).
The metatable is created by the I/O library
(see <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>).


<p>
This userdata must start with the structure <code>luaL_Stream</code>;
it can contain other data after this initial structure.
Field <code>f</code> points to the corresponding C stream
(or it can be <code>NULL</code> to indicate an incompletely created handle).
Field <code>closef</code> points to a Lua function
that will be called to close the stream
when the handle is closed or collected;
this function receives the file handle as its sole argument and
must return either <b>true</b> (in case of success)
or <b>nil</b> plus an error message (in case of error).
Once Lua calls this field,
it changes the field value to <code>NULL</code>
to signal that the handle is closed.





<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>m</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
This function works like <a href="#luaL_checkudata"><code>luaL_checkudata</code></a>,
except that, when the test fails,
it returns <code>NULL</code> instead of raising an error.





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
Converts any Lua value at the given index to a C&nbsp;string
in a reasonable format.
The resulting string is pushed onto the stack and also
returned by the function.
If <code>len</code> is not <code>NULL</code>,
the function also sets <code>*len</code> with the string length.


<p>
If the value has a metatable with a <code>__tostring</code> field,
then <code>luaL_tolstring</code> calls the corresponding metamethod
with the value as argument,
and uses the result of the call as its result.





<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
Creates and pushes a traceback of the stack <code>L1</code>.
If <code>msg</code> is not <code>NULL</code> it is appended
at the beginning of the traceback.
The <code>level</code> parameter tells at which level
to start the traceback.





<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
Returns the name of the type of the value at the given index.





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
Releases reference <code>ref</code> from the table at index <code>t</code>
(see <a href="#luaL_ref"><code>luaL_ref</code></a>).
The entry is removed from the table,
so that the referred object can be collected.
The reference <code>ref</code> is also freed to be used again.


<p>
If <code>ref</code> is <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> or <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>,
<a href="#luaL_unref"><code>luaL_unref</code></a> does nothing.





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>m</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
Pushes onto the stack a string identifying the current position
of the control at level <code>lvl</code> in the call stack.
Typically this string has the following format:

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
Level&nbsp;0 is the running function,
level&nbsp;1 is the function that called the running function,
etc.


<p>
This function is used to build a prefix for error messages.







<h1>6 &ndash; <a name="6">Standard Libraries</a></h1>

<p>
The standard Lua libraries provide useful functions
that are implemented directly through the C&nbsp;API.
Some of these functions provide essential services to the language
(e.g., <a href="#pdf-type"><code>type</code></a> and <a href="#pdf-getmetatable"><code>getmetatable</code></a>);
others provide access to "outside" services (e.g., I/O);
and others could be implemented in Lua itself,
but are quite useful or have critical performance requirements that
deserve an implementation in C (e.g., <a href="#pdf-table.sort"><code>table.sort</code></a>).


<p>
All libraries are implemented through the official C&nbsp;API
and are provided as separate C&nbsp;modules.
Currently, Lua has the following standard libraries:

<ul>

<li>basic library (<a href="#6.1">&sect;6.1</a>);</li>

<li>coroutine library (<a href="#6.2">&sect;6.2</a>);</li>

<li>package library (<a href="#6.3">&sect;6.3</a>);</li>

<li>string manipulation (<a href="#6.4">&sect;6.4</a>);</li>

<li>basic UTF-8 support (<a href="#6.5">&sect;6.5</a>);</li>

<li>table manipulation (<a href="#6.6">&sect;6.6</a>);</li>

<li>mathematical functions (<a href="#6.7">&sect;6.7</a>) (sin, log, etc.);</li>

<li>input and output (<a href="#6.8">&sect;6.8</a>);</li>

<li>operating system facilities (<a href="#6.9">&sect;6.9</a>);</li>

<li>debug facilities (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
Except for the basic and the package libraries,
each library provides all its functions as fields of a global table
or as methods of its objects.


<p>
To have access to these libraries,
the C&nbsp;host program should call the <a href="#luaL_openlibs"><code>luaL_openlibs</code></a> function,
which opens all standard libraries.
Alternatively,
the host program can open them individually by using
<a href="#luaL_requiref"><code>luaL_requiref</code></a> to call
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> (for the basic library),
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> (for the package library),
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> (for the coroutine library),
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> (for the string library),
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> (for the UTF8 library),
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> (for the table library),
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> (for the mathematical library),
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> (for the I/O library),
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> (for the operating system library),
and <a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> (for the debug library).
These functions are declared in <a name="pdf-lualib.h"><code>lualib.h</code></a>.



<h2>6.1 &ndash; <a name="6.1">Basic Functions</a></h2>

<p>
The basic library provides core functions to Lua.
If you do not include this library in your application,
you should check carefully whether you need to provide
implementations for some of its facilities.


<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
Calls <a href="#pdf-error"><code>error</code></a> if
the value of its argument <code>v</code> is false (i.e., <b>nil</b> or <b>false</b>);
otherwise, returns all its arguments.
In case of error,
<code>message</code> is the error object;
when absent, it defaults to "<code>assertion failed!</code>"




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
This function is a generic interface to the garbage collector.
It performs different functions according to its first argument, <code>opt</code>:

<ul>

<li><b>"<code>collect</code>": </b>
performs a full garbage-collection cycle.
This is the default option.
</li>

<li><b>"<code>stop</code>": </b>
stops automatic execution of the garbage collector.
The collector will run only when explicitly invoked,
until a call to restart it.
</li>

<li><b>"<code>restart</code>": </b>
restarts automatic execution of the garbage collector.
</li>

<li><b>"<code>count</code>": </b>
returns the total memory in use by Lua in Kbytes.
The value has a fractional part,
so that it multiplied by 1024
gives the exact number of bytes in use by Lua
(except for overflows).
</li>

<li><b>"<code>step</code>": </b>
performs a garbage-collection step.
The step "size" is controlled by <code>arg</code>.
With a zero value,
the collector will perform one basic (indivisible) step.
For non-zero values,
the collector will perform as if that amount of memory
(in KBytes) had been allocated by Lua.
Returns <b>true</b> if the step finished a collection cycle.
</li>

<li><b>"<code>setpause</code>": </b>
sets <code>arg</code> as the new value for the <em>pause</em> of
the collector (see <a href="#2.5">&sect;2.5</a>).
Returns the previous value for <em>pause</em>.
</li>

<li><b>"<code>setstepmul</code>": </b>
sets <code>arg</code> as the new value for the <em>step multiplier</em> of
the collector (see <a href="#2.5">&sect;2.5</a>).
Returns the previous value for <em>step</em>.
</li>

<li><b>"<code>isrunning</code>": </b>
returns a boolean that tells whether the collector is running
(i.e., not stopped).
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
Opens the named file and executes its contents as a Lua chunk.
When called without arguments,
<code>dofile</code> executes the contents of the standard input (<code>stdin</code>).
Returns all values returned by the chunk.
In case of errors, <code>dofile</code> propagates the error
to its caller (that is, <code>dofile</code> does not run in protected mode).




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
Terminates the last protected function called
and returns <code>message</code> as the error object.
Function <code>error</code> never returns.


<p>
Usually, <code>error</code> adds some information about the error position
at the beginning of the message, if the message is a string.
The <code>level</code> argument specifies how to get the error position.
With level&nbsp;1 (the default), the error position is where the
<code>error</code> function was called.
Level&nbsp;2 points the error to where the function
that called <code>error</code> was called; and so on.
Passing a level&nbsp;0 avoids the addition of error position information
to the message.




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
A global variable (not a function) that
holds the global environment (see <a href="#2.2">&sect;2.2</a>).
Lua itself does not use this variable;
changing its value does not affect any environment,
nor vice versa.




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
If <code>object</code> does not have a metatable, returns <b>nil</b>.
Otherwise,
if the object's metatable has a <code>__metatable</code> field,
returns the associated value.
Otherwise, returns the metatable of the given object.




<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
Returns three values (an iterator function, the table <code>t</code>, and 0)
so that the construction

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
will iterate over the key&ndash;value pairs
(<code>1,t[1]</code>), (<code>2,t[2]</code>), ...,
up to the first nil value.




<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
Loads a chunk.


<p>
If <code>chunk</code> is a string, the chunk is this string.
If <code>chunk</code> is a function,
<code>load</code> calls it repeatedly to get the chunk pieces.
Each call to <code>chunk</code> must return a string that concatenates
with previous results.
A return of an empty string, <b>nil</b>, or no value signals the end of the chunk.


<p>
If there are no syntactic errors,
returns the compiled chunk as a function;
otherwise, returns <b>nil</b> plus the error message.


<p>
If the resulting function has upvalues,
the first upvalue is set to the value of <code>env</code>,
if that parameter is given,
or to the value of the global environment.
Other upvalues are initialized with <b>nil</b>.
(When you load a main chunk,
the resulting function will always have exactly one upvalue,
the <code>_ENV</code> variable (see <a href="#2.2">&sect;2.2</a>).
However,
when you load a binary chunk created from a function (see <a href="#pdf-string.dump"><code>string.dump</code></a>),
the resulting function can have an arbitrary number of upvalues.)
All upvalues are fresh, that is,
they are not shared with any other function.


<p>
<code>chunkname</code> is used as the name of the chunk for error messages
and debug information (see <a href="#4.9">&sect;4.9</a>).
When absent,
it defaults to <code>chunk</code>, if <code>chunk</code> is a string,
or to "<code>=(load)</code>" otherwise.


<p>
The string <code>mode</code> controls whether the chunk can be text or binary
(that is, a precompiled chunk).
It may be the string "<code>b</code>" (only binary chunks),
"<code>t</code>" (only text chunks),
or "<code>bt</code>" (both binary and text).
The default is "<code>bt</code>".


<p>
Lua does not check the consistency of binary chunks.
Maliciously crafted binary chunks can crash
the interpreter.




<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
Similar to <a href="#pdf-load"><code>load</code></a>,
but gets the chunk from file <code>filename</code>
or from the standard input,
if no file name is given.




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
Allows a program to traverse all fields of a table.
Its first argument is a table and its second argument
is an index in this table.
<code>next</code> returns the next index of the table
and its associated value.
When called with <b>nil</b> as its second argument,
<code>next</code> returns an initial index
and its associated value.
When called with the last index,
or with <b>nil</b> in an empty table,
<code>next</code> returns <b>nil</b>.
If the second argument is absent, then it is interpreted as <b>nil</b>.
In particular,
you can use <code>next(t)</code> to check whether a table is empty.


<p>
The order in which the indices are enumerated is not specified,
<em>even for numeric indices</em>.
(To traverse a table in numerical order,
use a numerical <b>for</b>.)


<p>
The behavior of <code>next</code> is undefined if,
during the traversal,
you assign any value to a non-existent field in the table.
You may however modify existing fields.
In particular, you may clear existing fields.




<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
If <code>t</code> has a metamethod <code>__pairs</code>,
calls it with <code>t</code> as argument and returns the first three
results from the call.


<p>
Otherwise,
returns three values: the <a href="#pdf-next"><code>next</code></a> function, the table <code>t</code>, and <b>nil</b>,
so that the construction

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
will iterate over all key&ndash;value pairs of table <code>t</code>.


<p>
See function <a href="#pdf-next"><code>next</code></a> for the caveats of modifying
the table during its traversal.




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
Calls function <code>f</code> with
the given arguments in <em>protected mode</em>.
This means that any error inside&nbsp;<code>f</code> is not propagated;
instead, <code>pcall</code> catches the error
and returns a status code.
Its first result is the status code (a boolean),
which is true if the call succeeds without errors.
In such case, <code>pcall</code> also returns all results from the call,
after this first result.
In case of any error, <code>pcall</code> returns <b>false</b> plus the error message.




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
Receives any number of arguments
and prints their values to <code>stdout</code>,
using the <a href="#pdf-tostring"><code>tostring</code></a> function to convert each argument to a string.
<code>print</code> is not intended for formatted output,
but only as a quick way to show a value,
for instance for debugging.
For complete control over the output,
use <a href="#pdf-string.format"><code>string.format</code></a> and <a href="#pdf-io.write"><code>io.write</code></a>.




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
Checks whether <code>v1</code> is equal to <code>v2</code>,
without invoking the <code>__eq</code> metamethod.
Returns a boolean.




<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
Gets the real value of <code>table[index]</code>,
without invoking the <code>__index</code> metamethod.
<code>table</code> must be a table;
<code>index</code> may be any value.




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
Returns the length of the object <code>v</code>,
which must be a table or a string,
without invoking the <code>__len</code> metamethod.
Returns an integer.




<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
Sets the real value of <code>table[index]</code> to <code>value</code>,
without invoking the <code>__newindex</code> metamethod.
<code>table</code> must be a table,
<code>index</code> any value different from <b>nil</b> and NaN,
and <code>value</code> any Lua value.


<p>
This function returns <code>table</code>.




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
If <code>index</code> is a number,
returns all arguments after argument number <code>index</code>;
a negative number indexes from the end (-1 is the last argument).
Otherwise, <code>index</code> must be the string <code>"#"</code>,
and <code>select</code> returns the total number of extra arguments it received.




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
Sets the metatable for the given table.
(To change the metatable of other types from Lua code,
you must use the debug library (<a href="#6.10">&sect;6.10</a>).)
If <code>metatable</code> is <b>nil</b>,
removes the metatable of the given table.
If the original metatable has a <code>__metatable</code> field,
raises an error.


<p>
This function returns <code>table</code>.




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
When called with no <code>base</code>,
<code>tonumber</code> tries to convert its argument to a number.
If the argument is already a number or
a string convertible to a number,
then <code>tonumber</code> returns this number;
otherwise, it returns <b>nil</b>.


<p>
The conversion of strings can result in integers or floats,
according to the lexical conventions of Lua (see <a href="#3.1">&sect;3.1</a>).
(The string may have leading and trailing spaces and a sign.)


<p>
When called with <code>base</code>,
then <code>e</code> must be a string to be interpreted as
an integer numeral in that base.
The base may be any integer between 2 and 36, inclusive.
In bases above&nbsp;10, the letter '<code>A</code>' (in either upper or lower case)
represents&nbsp;10, '<code>B</code>' represents&nbsp;11, and so forth,
with '<code>Z</code>' representing 35.
If the string <code>e</code> is not a valid numeral in the given base,
the function returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
Receives a value of any type and
converts it to a string in a human-readable format.
(For complete control of how numbers are converted,
use <a href="#pdf-string.format"><code>string.format</code></a>.)


<p>
If the metatable of <code>v</code> has a <code>__tostring</code> field,
then <code>tostring</code> calls the corresponding value
with <code>v</code> as argument,
and uses the result of the call as its result.




<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
Returns the type of its only argument, coded as a string.
The possible results of this function are
"<code>nil</code>" (a string, not the value <b>nil</b>),
"<code>number</code>",
"<code>string</code>",
"<code>boolean</code>",
"<code>table</code>",
"<code>function</code>",
"<code>thread</code>",
and "<code>userdata</code>".




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>


<p>
A global variable (not a function) that
holds a string containing the running Lua version.
The current value of this variable is "<code>Lua 5.3</code>".




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
This function is similar to <a href="#pdf-pcall"><code>pcall</code></a>,
except that it sets a new message handler <code>msgh</code>.







<h2>6.2 &ndash; <a name="6.2">Coroutine Manipulation</a></h2>

<p>
This library comprises the operations to manipulate coroutines,
which come inside the table <a name="pdf-coroutine"><code>coroutine</code></a>.
See <a href="#2.6">&sect;2.6</a> for a general description of coroutines.


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
Creates a new coroutine, with body <code>f</code>.
<code>f</code> must be a function.
Returns this new coroutine,
an object with type <code>"thread"</code>.




<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>


<p>
Returns true when the running coroutine can yield.


<p>
A running coroutine is yieldable if it is not the main thread and
it is not inside a non-yieldable C&nbsp;function.




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
Starts or continues the execution of coroutine <code>co</code>.
The first time you resume a coroutine,
it starts running its body.
The values <code>val1</code>, ... are passed
as the arguments to the body function.
If the coroutine has yielded,
<code>resume</code> restarts it;
the values <code>val1</code>, ... are passed
as the results from the yield.


<p>
If the coroutine runs without any errors,
<code>resume</code> returns <b>true</b> plus any values passed to <code>yield</code>
(when the coroutine yields) or any values returned by the body function
(when the coroutine terminates).
If there is any error,
<code>resume</code> returns <b>false</b> plus the error message.




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
Returns the running coroutine plus a boolean,
true when the running coroutine is the main one.




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
Returns the status of coroutine <code>co</code>, as a string:
<code>"running"</code>,
if the coroutine is running (that is, it called <code>status</code>);
<code>"suspended"</code>, if the coroutine is suspended in a call to <code>yield</code>,
or if it has not started running yet;
<code>"normal"</code> if the coroutine is active but not running
(that is, it has resumed another coroutine);
and <code>"dead"</code> if the coroutine has finished its body function,
or if it has stopped with an error.




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
Creates a new coroutine, with body <code>f</code>.
<code>f</code> must be a function.
Returns a function that resumes the coroutine each time it is called.
Any arguments passed to the function behave as the
extra arguments to <code>resume</code>.
Returns the same values returned by <code>resume</code>,
except the first boolean.
In case of error, propagates the error.




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
Suspends the execution of the calling coroutine.
Any arguments to <code>yield</code> are passed as extra results to <code>resume</code>.







<h2>6.3 &ndash; <a name="6.3">Modules</a></h2>

<p>
The package library provides basic
facilities for loading modules in Lua.
It exports one function directly in the global environment:
<a href="#pdf-require"><code>require</code></a>.
Everything else is exported in a table <a name="pdf-package"><code>package</code></a>.


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
Loads the given module.
The function starts by looking into the <a href="#pdf-package.loaded"><code>package.loaded</code></a> table
to determine whether <code>modname</code> is already loaded.
If it is, then <code>require</code> returns the value stored
at <code>package.loaded[modname]</code>.
Otherwise, it tries to find a <em>loader</em> for the module.


<p>
To find a loader,
<code>require</code> is guided by the <a href="#pdf-package.searchers"><code>package.searchers</code></a> sequence.
By changing this sequence,
we can change how <code>require</code> looks for a module.
The following explanation is based on the default configuration
for <a href="#pdf-package.searchers"><code>package.searchers</code></a>.


<p>
First <code>require</code> queries <code>package.preload[modname]</code>.
If it has a value,
this value (which must be a function) is the loader.
Otherwise <code>require</code> searches for a Lua loader using the
path stored in <a href="#pdf-package.path"><code>package.path</code></a>.
If that also fails, it searches for a C&nbsp;loader using the
path stored in <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
If that also fails,
it tries an <em>all-in-one</em> loader (see <a href="#pdf-package.searchers"><code>package.searchers</code></a>).


<p>
Once a loader is found,
<code>require</code> calls the loader with two arguments:
<code>modname</code> and an extra value dependent on how it got the loader.
(If the loader came from a file,
this extra value is the file name.)
If the loader returns any non-nil value,
<code>require</code> assigns the returned value to <code>package.loaded[modname]</code>.
If the loader does not return a non-nil value and
has not assigned any value to <code>package.loaded[modname]</code>,
then <code>require</code> assigns <b>true</b> to this entry.
In any case, <code>require</code> returns the
final value of <code>package.loaded[modname]</code>.


<p>
If there is any error loading or running the module,
or if it cannot find any loader for the module,
then <code>require</code> raises an error.




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
A string describing some compile-time configurations for packages.
This string is a sequence of lines:

<ul>

<li>The first line is the directory separator string.
Default is '<code>\</code>' for Windows and '<code>/</code>' for all other systems.</li>

<li>The second line is the character that separates templates in a path.
Default is '<code>;</code>'.</li>

<li>The third line is the string that marks the
substitution points in a template.
Default is '<code>?</code>'.</li>

<li>The fourth line is a string that, in a path in Windows,
is replaced by the executable's directory.
Default is '<code>!</code>'.</li>

<li>The fifth line is a mark to ignore all text after it
when building the <code>luaopen_</code> function name.
Default is '<code>-</code>'.</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
The path used by <a href="#pdf-require"><code>require</code></a> to search for a C&nbsp;loader.


<p>
Lua initializes the C&nbsp;path <a href="#pdf-package.cpath"><code>package.cpath</code></a> in the same way
it initializes the Lua path <a href="#pdf-package.path"><code>package.path</code></a>,
using the environment variable <a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a>,
or the environment variable <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a>,
or a default path defined in <code>luaconf.h</code>.




<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
A table used by <a href="#pdf-require"><code>require</code></a> to control which
modules are already loaded.
When you require a module <code>modname</code> and
<code>package.loaded[modname]</code> is not false,
<a href="#pdf-require"><code>require</code></a> simply returns the value stored there.


<p>
This variable is only a reference to the real table;
assignments to this variable do not change the
table used by <a href="#pdf-require"><code>require</code></a>.




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
Dynamically links the host program with the C&nbsp;library <code>libname</code>.


<p>
If <code>funcname</code> is "<code>*</code>",
then it only links with the library,
making the symbols exported by the library
available to other dynamically linked libraries.
Otherwise,
it looks for a function <code>funcname</code> inside the library
and returns this function as a C&nbsp;function.
So, <code>funcname</code> must follow the <a href="#lua_CFunction"><code>lua_CFunction</code></a> prototype
(see <a href="#lua_CFunction"><code>lua_CFunction</code></a>).


<p>
This is a low-level function.
It completely bypasses the package and module system.
Unlike <a href="#pdf-require"><code>require</code></a>,
it does not perform any path searching and
does not automatically adds extensions.
<code>libname</code> must be the complete file name of the C&nbsp;library,
including if necessary a path and an extension.
<code>funcname</code> must be the exact name exported by the C&nbsp;library
(which may depend on the C&nbsp;compiler and linker used).


<p>
This function is not supported by Standard&nbsp;C.
As such, it is only available on some platforms
(Windows, Linux, Mac OS X, Solaris, BSD,
plus other Unix systems that support the <code>dlfcn</code> standard).




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
The path used by <a href="#pdf-require"><code>require</code></a> to search for a Lua loader.


<p>
At start-up, Lua initializes this variable with
the value of the environment variable <a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a> or
the environment variable <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> or
with a default path defined in <code>luaconf.h</code>,
if those environment variables are not defined.
Any "<code>;;</code>" in the value of the environment variable
is replaced by the default path.




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
A table to store loaders for specific modules
(see <a href="#pdf-require"><code>require</code></a>).


<p>
This variable is only a reference to the real table;
assignments to this variable do not change the
table used by <a href="#pdf-require"><code>require</code></a>.




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
A table used by <a href="#pdf-require"><code>require</code></a> to control how to load modules.


<p>
Each entry in this table is a <em>searcher function</em>.
When looking for a module,
<a href="#pdf-require"><code>require</code></a> calls each of these searchers in ascending order,
with the module name (the argument given to <a href="#pdf-require"><code>require</code></a>) as its
sole parameter.
The function can return another function (the module <em>loader</em>)
plus an extra value that will be passed to that loader,
or a string explaining why it did not find that module
(or <b>nil</b> if it has nothing to say).


<p>
Lua initializes this table with four searcher functions.


<p>
The first searcher simply looks for a loader in the
<a href="#pdf-package.preload"><code>package.preload</code></a> table.


<p>
The second searcher looks for a loader as a Lua library,
using the path stored at <a href="#pdf-package.path"><code>package.path</code></a>.
The search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.


<p>
The third searcher looks for a loader as a C&nbsp;library,
using the path given by the variable <a href="#pdf-package.cpath"><code>package.cpath</code></a>.
Again,
the search is done as described in function <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
For instance,
if the C&nbsp;path is the string

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
the searcher for module <code>foo</code>
will try to open the files <code>./foo.so</code>, <code>./foo.dll</code>,
and <code>/usr/local/foo/init.so</code>, in that order.
Once it finds a C&nbsp;library,
this searcher first uses a dynamic link facility to link the
application with the library.
Then it tries to find a C&nbsp;function inside the library to
be used as the loader.
The name of this C&nbsp;function is the string "<code>luaopen_</code>"
concatenated with a copy of the module name where each dot
is replaced by an underscore.
Moreover, if the module name has a hyphen,
its suffix after (and including) the first hyphen is removed.
For instance, if the module name is <code>a.b.c-v2.1</code>,
the function name will be <code>luaopen_a_b_c</code>.


<p>
The fourth searcher tries an <em>all-in-one loader</em>.
It searches the C&nbsp;path for a library for
the root name of the given module.
For instance, when requiring <code>a.b.c</code>,
it will search for a C&nbsp;library for <code>a</code>.
If found, it looks into it for an open function for
the submodule;
in our example, that would be <code>luaopen_a_b_c</code>.
With this facility, a package can pack several C&nbsp;submodules
into one single library,
with each submodule keeping its original open function.


<p>
All searchers except the first one (preload) return as the extra value
the file name where the module was found,
as returned by <a href="#pdf-package.searchpath"><code>package.searchpath</code></a>.
The first searcher returns no extra value.




<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
Searches for the given <code>name</code> in the given <code>path</code>.


<p>
A path is a string containing a sequence of
<em>templates</em> separated by semicolons.
For each template,
the function replaces each interrogation mark (if any)
in the template with a copy of <code>name</code>
wherein all occurrences of <code>sep</code>
(a dot, by default)
were replaced by <code>rep</code>
(the system's directory separator, by default),
and then tries to open the resulting file name.


<p>
For instance, if the path is the string

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
the search for the name <code>foo.a</code>
will try to open the files
<code>./foo/a.lua</code>, <code>./foo/a.lc</code>, and
<code>/usr/local/foo/a/init.lua</code>, in that order.


<p>
Returns the resulting name of the first file that it can
open in read mode (after closing the file),
or <b>nil</b> plus an error message if none succeeds.
(This error message lists all file names it tried to open.)







<h2>6.4 &ndash; <a name="6.4">String Manipulation</a></h2>

<p>
This library provides generic functions for string manipulation,
such as finding and extracting substrings, and pattern matching.
When indexing a string in Lua, the first character is at position&nbsp;1
(not at&nbsp;0, as in C).
Indices are allowed to be negative and are interpreted as indexing backwards,
from the end of the string.
Thus, the last character is at position -1, and so on.


<p>
The string library provides all its functions inside the table
<a name="pdf-string"><code>string</code></a>.
It also sets a metatable for strings
where the <code>__index</code> field points to the <code>string</code> table.
Therefore, you can use the string functions in object-oriented style.
For instance, <code>string.byte(s,i)</code>
can be written as <code>s:byte(i)</code>.


<p>
The string library assumes one-byte character encodings.


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
Returns the internal numeric codes of the characters <code>s[i]</code>,
<code>s[i+1]</code>, ..., <code>s[j]</code>.
The default value for <code>i</code> is&nbsp;1;
the default value for <code>j</code> is&nbsp;<code>i</code>.
These indices are corrected
following the same rules of function <a href="#pdf-string.sub"><code>string.sub</code></a>.


<p>
Numeric codes are not necessarily portable across platforms.




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
Receives zero or more integers.
Returns a string with length equal to the number of arguments,
in which each character has the internal numeric code equal
to its corresponding argument.


<p>
Numeric codes are not necessarily portable across platforms.




<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
Returns a string containing a binary representation
(a <em>binary chunk</em>)
of the given function,
so that a later <a href="#pdf-load"><code>load</code></a> on this string returns
a copy of the function (but with new upvalues).
If <code>strip</code> is a true value,
the binary representation may not include all debug information
about the function,
to save space.


<p>
Functions with upvalues have only their number of upvalues saved.
When (re)loaded,
those upvalues receive fresh instances containing <b>nil</b>.
(You can use the debug library to serialize
and reload the upvalues of a function
in a way adequate to your needs.)




<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
Looks for the first match of
<code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) in the string <code>s</code>.
If it finds a match, then <code>find</code> returns the indices of&nbsp;<code>s</code>
where this occurrence starts and ends;
otherwise, it returns <b>nil</b>.
A third, optional numeric argument <code>init</code> specifies
where to start the search;
its default value is&nbsp;1 and can be negative.
A value of <b>true</b> as a fourth, optional argument <code>plain</code>
turns off the pattern matching facilities,
so the function does a plain "find substring" operation,
with no characters in <code>pattern</code> being considered magic.
Note that if <code>plain</code> is given, then <code>init</code> must be given as well.


<p>
If the pattern has captures,
then in a successful match
the captured values are also returned,
after the two indices.




<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns a formatted version of its variable number of arguments
following the description given in its first argument (which must be a string).
The format string follows the same rules as the ISO&nbsp;C function <code>sprintf</code>.
The only differences are that the options/modifiers
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,
and <code>p</code> are not supported
and that there is an extra option, <code>q</code>.


<p>
The <code>q</code> option formats a string between double quotes,
using escape sequences when necessary to ensure that
it can safely be read back by the Lua interpreter.
For instance, the call

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
may produce the string:

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
Options
<code>A</code>, <code>a</code>, <code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code>, and <code>g</code> all expect a number as argument.
Options <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
expect an integer.
When Lua is compiled with a C89 compiler,
options <code>A</code> and <code>a</code> (hexadecimal floats)
do not support any modifier (flags, width, length).


<p>
Option <code>s</code> expects a string;
if its argument is not a string,
it is converted to one following the same rules of <a href="#pdf-tostring"><code>tostring</code></a>.
If the option has any modifier (flags, width, length),
the string argument should not contain embedded zeros.




<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
Returns an iterator function that,
each time it is called,
returns the next captures from <code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>)
over the string <code>s</code>.
If <code>pattern</code> specifies no captures,
then the whole match is produced in each call.


<p>
As an example, the following loop
will iterate over all the words from string <code>s</code>,
printing one per line:

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
The next example collects all pairs <code>key=value</code> from the
given string into a table:

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
For this function, a caret '<code>^</code>' at the start of a pattern does not
work as an anchor, as this would prevent the iteration.




<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
Returns a copy of <code>s</code>
in which all (or the first <code>n</code>, if given)
occurrences of the <code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) have been
replaced by a replacement string specified by <code>repl</code>,
which can be a string, a table, or a function.
<code>gsub</code> also returns, as its second value,
the total number of matches that occurred.
The name <code>gsub</code> comes from <em>Global SUBstitution</em>.


<p>
If <code>repl</code> is a string, then its value is used for replacement.
The character&nbsp;<code>%</code> works as an escape character:
any sequence in <code>repl</code> of the form <code>%<em>d</em></code>,
with <em>d</em> between 1 and 9,
stands for the value of the <em>d</em>-th captured substring.
The sequence <code>%0</code> stands for the whole match.
The sequence <code>%%</code> stands for a single&nbsp;<code>%</code>.


<p>
If <code>repl</code> is a table, then the table is queried for every match,
using the first capture as the key.


<p>
If <code>repl</code> is a function, then this function is called every time a
match occurs, with all captured substrings passed as arguments,
in order.


<p>
In any case,
if the pattern specifies no captures,
then it behaves as if the whole pattern was inside a capture.


<p>
If the value returned by the table query or by the function call
is a string or a number,
then it is used as the replacement string;
otherwise, if it is <b>false</b> or <b>nil</b>,
then there is no replacement
(that is, the original match is kept in the string).


<p>
Here are some examples:

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
Receives a string and returns its length.
The empty string <code>""</code> has length 0.
Embedded zeros are counted,
so <code>"a\000bc\000"</code> has length 5.




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
Receives a string and returns a copy of this string with all
uppercase letters changed to lowercase.
All other characters are left unchanged.
The definition of what an uppercase letter is depends on the current locale.




<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
Looks for the first <em>match</em> of
<code>pattern</code> (see <a href="#6.4.1">&sect;6.4.1</a>) in the string <code>s</code>.
If it finds one, then <code>match</code> returns
the captures from the pattern;
otherwise it returns <b>nil</b>.
If <code>pattern</code> specifies no captures,
then the whole match is returned.
A third, optional numeric argument <code>init</code> specifies
where to start the search;
its default value is&nbsp;1 and can be negative.




<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns a binary string containing the values <code>v1</code>, <code>v2</code>, etc.
packed (that is, serialized in binary form)
according to the format string <code>fmt</code> (see <a href="#6.4.2">&sect;6.4.2</a>).




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
Returns the size of a string resulting from <a href="#pdf-string.pack"><code>string.pack</code></a>
with the given format.
The format string cannot have the variable-length options
'<code>s</code>' or '<code>z</code>' (see <a href="#6.4.2">&sect;6.4.2</a>).




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
Returns a string that is the concatenation of <code>n</code> copies of
the string <code>s</code> separated by the string <code>sep</code>.
The default value for <code>sep</code> is the empty string
(that is, no separator).
Returns the empty string if <code>n</code> is not positive.


<p>
(Note that it is very easy to exhaust the memory of your machine
with a single call to this function.)




<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
Returns a string that is the string <code>s</code> reversed.




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
Returns the substring of <code>s</code> that
starts at <code>i</code>  and continues until <code>j</code>;
<code>i</code> and <code>j</code> can be negative.
If <code>j</code> is absent, then it is assumed to be equal to -1
(which is the same as the string length).
In particular,
the call <code>string.sub(s,1,j)</code> returns a prefix of <code>s</code>
with length <code>j</code>,
and <code>string.sub(s, -i)</code> (for a positive <code>i</code>)
returns a suffix of <code>s</code>
with length <code>i</code>.


<p>
If, after the translation of negative indices,
<code>i</code> is less than 1,
it is corrected to 1.
If <code>j</code> is greater than the string length,
it is corrected to that length.
If, after these corrections,
<code>i</code> is greater than <code>j</code>,
the function returns the empty string.




<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
Returns the values packed in string <code>s</code> (see <a href="#pdf-string.pack"><code>string.pack</code></a>)
according to the format string <code>fmt</code> (see <a href="#6.4.2">&sect;6.4.2</a>).
An optional <code>pos</code> marks where
to start reading in <code>s</code> (default is 1).
After the read values,
this function also returns the index of the first unread byte in <code>s</code>.




<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
Receives a string and returns a copy of this string with all
lowercase letters changed to uppercase.
All other characters are left unchanged.
The definition of what a lowercase letter is depends on the current locale.





<h3>6.4.1 &ndash; <a name="6.4.1">Patterns</a></h3>

<p>
Patterns in Lua are described by regular strings,
which are interpreted as patterns by the pattern-matching functions
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>,
and <a href="#pdf-string.match"><code>string.match</code></a>.
This section describes the syntax and the meaning
(that is, what they match) of these strings.



<h4>Character Class:</h4><p>
A <em>character class</em> is used to represent a set of characters.
The following combinations are allowed in describing a character class:

<ul>

<li><b><em>x</em>: </b>
(where <em>x</em> is not one of the <em>magic characters</em>
<code>^$()%.[]*+-?</code>)
represents the character <em>x</em> itself.
</li>

<li><b><code>.</code>: </b> (a dot) represents all characters.</li>

<li><b><code>%a</code>: </b> represents all letters.</li>

<li><b><code>%c</code>: </b> represents all control characters.</li>

<li><b><code>%d</code>: </b> represents all digits.</li>

<li><b><code>%g</code>: </b> represents all printable characters except space.</li>

<li><b><code>%l</code>: </b> represents all lowercase letters.</li>

<li><b><code>%p</code>: </b> represents all punctuation characters.</li>

<li><b><code>%s</code>: </b> represents all space characters.</li>

<li><b><code>%u</code>: </b> represents all uppercase letters.</li>

<li><b><code>%w</code>: </b> represents all alphanumeric characters.</li>

<li><b><code>%x</code>: </b> represents all hexadecimal digits.</li>

<li><b><code>%<em>x</em></code>: </b> (where <em>x</em> is any non-alphanumeric character)
represents the character <em>x</em>.
This is the standard way to escape the magic characters.
Any non-alphanumeric character
(including all punctuation characters, even the non-magical)
can be preceded by a '<code>%</code>'
when used to represent itself in a pattern.
</li>

<li><b><code>[<em>set</em>]</code>: </b>
represents the class which is the union of all
characters in <em>set</em>.
A range of characters can be specified by
separating the end characters of the range,
in ascending order, with a '<code>-</code>'.
All classes <code>%</code><em>x</em> described above can also be used as
components in <em>set</em>.
All other characters in <em>set</em> represent themselves.
For example, <code>[%w_]</code> (or <code>[_%w]</code>)
represents all alphanumeric characters plus the underscore,
<code>[0-7]</code> represents the octal digits,
and <code>[0-7%l%-]</code> represents the octal digits plus
the lowercase letters plus the '<code>-</code>' character.


<p>
You can put a closing square bracket in a set
by positioning it as the first character in the set.
You can put a hyphen in a set
by positioning it as the first or the last character in the set.
(You can also use an escape for both cases.)


<p>
The interaction between ranges and classes is not defined.
Therefore, patterns like <code>[%a-z]</code> or <code>[a-%%]</code>
have no meaning.
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
represents the complement of <em>set</em>,
where <em>set</em> is interpreted as above.
</li>

</ul><p>
For all classes represented by single letters (<code>%a</code>, <code>%c</code>, etc.),
the corresponding uppercase letter represents the complement of the class.
For instance, <code>%S</code> represents all non-space characters.


<p>
The definitions of letter, space, and other character groups
depend on the current locale.
In particular, the class <code>[a-z]</code> may not be equivalent to <code>%l</code>.





<h4>Pattern Item:</h4><p>
A <em>pattern item</em> can be

<ul>

<li>
a single character class,
which matches any single character in the class;
</li>

<li>
a single character class followed by '<code>*</code>',
which matches zero or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
</li>

<li>
a single character class followed by '<code>+</code>',
which matches one or more repetitions of characters in the class.
These repetition items will always match the longest possible sequence;
</li>

<li>
a single character class followed by '<code>-</code>',
which also matches zero or more repetitions of characters in the class.
Unlike '<code>*</code>',
these repetition items will always match the shortest possible sequence;
</li>

<li>
a single character class followed by '<code>?</code>',
which matches zero or one occurrence of a character in the class.
It always matches one occurrence if possible;
</li>

<li>
<code>%<em>n</em></code>, for <em>n</em> between 1 and 9;
such item matches a substring equal to the <em>n</em>-th captured string
(see below);
</li>

<li>
<code>%b<em>xy</em></code>, where <em>x</em> and <em>y</em> are two distinct characters;
such item matches strings that start with&nbsp;<em>x</em>, end with&nbsp;<em>y</em>,
and where the <em>x</em> and <em>y</em> are <em>balanced</em>.
This means that, if one reads the string from left to right,
counting <em>+1</em> for an <em>x</em> and <em>-1</em> for a <em>y</em>,
the ending <em>y</em> is the first <em>y</em> where the count reaches 0.
For instance, the item <code>%b()</code> matches expressions with
balanced parentheses.
</li>

<li>
<code>%f[<em>set</em>]</code>, a <em>frontier pattern</em>;
such item matches an empty string at any position such that
the next character belongs to <em>set</em>
and the previous character does not belong to <em>set</em>.
The set <em>set</em> is interpreted as previously described.
The beginning and the end of the subject are handled as if
they were the character '<code>\0</code>'.
</li>

</ul>




<h4>Pattern:</h4><p>
A <em>pattern</em> is a sequence of pattern items.
A caret '<code>^</code>' at the beginning of a pattern anchors the match at the
beginning of the subject string.
A '<code>$</code>' at the end of a pattern anchors the match at the
end of the subject string.
At other positions,
'<code>^</code>' and '<code>$</code>' have no special meaning and represent themselves.





<h4>Captures:</h4><p>
A pattern can contain sub-patterns enclosed in parentheses;
they describe <em>captures</em>.
When a match succeeds, the substrings of the subject string
that match captures are stored (<em>captured</em>) for future use.
Captures are numbered according to their left parentheses.
For instance, in the pattern <code>"(a*(.)%w(%s*))"</code>,
the part of the string matching <code>"a*(.)%w(%s*)"</code> is
stored as the first capture (and therefore has number&nbsp;1);
the character matching "<code>.</code>" is captured with number&nbsp;2,
and the part matching "<code>%s*</code>" has number&nbsp;3.


<p>
As a special case, the empty capture <code>()</code> captures
the current string position (a number).
For instance, if we apply the pattern <code>"()aa()"</code> on the
string <code>"flaaap"</code>, there will be two captures: 3&nbsp;and&nbsp;5.







<h3>6.4.2 &ndash; <a name="6.4.2">Format Strings for Pack and Unpack</a></h3>

<p>
The first argument to <a href="#pdf-string.pack"><code>string.pack</code></a>,
<a href="#pdf-string.packsize"><code>string.packsize</code></a>, and <a href="#pdf-string.unpack"><code>string.unpack</code></a>
is a format string,
which describes the layout of the structure being created or read.


<p>
A format string is a sequence of conversion options.
The conversion options are as follows:

<ul>
<li><b><code>&lt;</code>: </b>sets little endian</li>
<li><b><code>&gt;</code>: </b>sets big endian</li>
<li><b><code>=</code>: </b>sets native endian</li>
<li><b><code>![<em>n</em>]</code>: </b>sets maximum alignment to <code>n</code>
(default is native alignment)</li>
<li><b><code>b</code>: </b>a signed byte (<code>char</code>)</li>
<li><b><code>B</code>: </b>an unsigned byte (<code>char</code>)</li>
<li><b><code>h</code>: </b>a signed <code>short</code> (native size)</li>
<li><b><code>H</code>: </b>an unsigned <code>short</code> (native size)</li>
<li><b><code>l</code>: </b>a signed <code>long</code> (native size)</li>
<li><b><code>L</code>: </b>an unsigned <code>long</code> (native size)</li>
<li><b><code>j</code>: </b>a <code>lua_Integer</code></li>
<li><b><code>J</code>: </b>a <code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b>a <code>size_t</code> (native size)</li>
<li><b><code>i[<em>n</em>]</code>: </b>a signed <code>int</code> with <code>n</code> bytes
(default is native size)</li>
<li><b><code>I[<em>n</em>]</code>: </b>an unsigned <code>int</code> with <code>n</code> bytes
(default is native size)</li>
<li><b><code>f</code>: </b>a <code>float</code> (native size)</li>
<li><b><code>d</code>: </b>a <code>double</code> (native size)</li>
<li><b><code>n</code>: </b>a <code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b>a fixed-sized string with <code>n</code> bytes</li>
<li><b><code>z</code>: </b>a zero-terminated string</li>
<li><b><code>s[<em>n</em>]</code>: </b>a string preceded by its length
coded as an unsigned integer with <code>n</code> bytes
(default is a <code>size_t</code>)</li>
<li><b><code>x</code>: </b>one byte of padding</li>
<li><b><code>X<em>op</em></code>: </b>an empty item that aligns
according to option <code>op</code>
(which is otherwise ignored)</li>
<li><b>'<code> </code>': </b>(empty space) ignored</li>
</ul><p>
(A "<code>[<em>n</em>]</code>" means an optional integral numeral.)
Except for padding, spaces, and configurations
(options "<code>xX &lt;=&gt;!</code>"),
each option corresponds to an argument (in <a href="#pdf-string.pack"><code>string.pack</code></a>)
or a result (in <a href="#pdf-string.unpack"><code>string.unpack</code></a>).


<p>
For options "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", and "<code>I<em>n</em></code>",
<code>n</code> can be any integer between 1 and 16.
All integral options check overflows;
<a href="#pdf-string.pack"><code>string.pack</code></a> checks whether the given value fits in the given size;
<a href="#pdf-string.unpack"><code>string.unpack</code></a> checks whether the read value fits in a Lua integer.


<p>
Any format string starts as if prefixed by "<code>!1=</code>",
that is,
with maximum alignment of 1 (no alignment)
and native endianness.


<p>
Alignment works as follows:
For each option,
the format gets extra padding until the data starts
at an offset that is a multiple of the minimum between the
option size and the maximum alignment;
this minimum must be a power of 2.
Options "<code>c</code>" and "<code>z</code>" are not aligned;
option "<code>s</code>" follows the alignment of its starting integer.


<p>
All padding is filled with zeros by <a href="#pdf-string.pack"><code>string.pack</code></a>
(and ignored by <a href="#pdf-string.unpack"><code>string.unpack</code></a>).







<h2>6.5 &ndash; <a name="6.5">UTF-8 Support</a></h2>

<p>
This library provides basic support for UTF-8 encoding.
It provides all its functions inside the table <a name="pdf-utf8"><code>utf8</code></a>.
This library does not provide any support for Unicode other
than the handling of the encoding.
Any operation that needs the meaning of a character,
such as character classification, is outside its scope.


<p>
Unless stated otherwise,
all functions that expect a byte position as a parameter
assume that the given position is either the start of a byte sequence
or one plus the length of the subject string.
As in the string library,
negative indices count from the end of the string.


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
Receives zero or more integers,
converts each one to its corresponding UTF-8 byte sequence
and returns a string with the concatenation of all these sequences.




<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
The pattern (a string, not a function) "<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
(see <a href="#6.4.1">&sect;6.4.1</a>),
which matches exactly one UTF-8 byte sequence,
assuming that the subject is a valid UTF-8 string.




<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
Returns values so that the construction

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
will iterate over all characters in string <code>s</code>,
with <code>p</code> being the position (in bytes) and <code>c</code> the code point
of each character.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
Returns the codepoints (as integers) from all characters in <code>s</code>
that start between byte position <code>i</code> and <code>j</code> (both included).
The default for <code>i</code> is 1 and for <code>j</code> is <code>i</code>.
It raises an error if it meets any invalid byte sequence.




<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
Returns the number of UTF-8 characters in string <code>s</code>
that start between positions <code>i</code> and <code>j</code> (both inclusive).
The default for <code>i</code> is 1 and for <code>j</code> is -1.
If it finds any invalid byte sequence,
returns a false value plus the position of the first invalid byte.




<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
Returns the position (in bytes) where the encoding of the
<code>n</code>-th character of <code>s</code>
(counting from position <code>i</code>) starts.
A negative <code>n</code> gets characters before position <code>i</code>.
The default for <code>i</code> is 1 when <code>n</code> is non-negative
and <code>#s + 1</code> otherwise,
so that <code>utf8.offset(s, -n)</code> gets the offset of the
<code>n</code>-th character from the end of the string.
If the specified character is neither in the subject
nor right after its end,
the function returns <b>nil</b>.


<p>
As a special case,
when <code>n</code> is 0 the function returns the start of the encoding
of the character that contains the <code>i</code>-th byte of <code>s</code>.


<p>
This function assumes that <code>s</code> is a valid UTF-8 string.







<h2>6.6 &ndash; <a name="6.6">Table Manipulation</a></h2>

<p>
This library provides generic functions for table manipulation.
It provides all its functions inside the table <a name="pdf-table"><code>table</code></a>.


<p>
Remember that, whenever an operation needs the length of a table,
all caveats about the length operator apply (see <a href="#3.4.7">&sect;3.4.7</a>).
All functions ignore non-numeric keys
in the tables given as arguments.


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
Given a list where all elements are strings or numbers,
returns the string <code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>.
The default value for <code>sep</code> is the empty string,
the default for <code>i</code> is 1,
and the default for <code>j</code> is <code>#list</code>.
If <code>i</code> is greater than <code>j</code>, returns the empty string.




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
Inserts element <code>value</code> at position <code>pos</code> in <code>list</code>,
shifting up the elements
<code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code>.
The default value for <code>pos</code> is <code>#list+1</code>,
so that a call <code>table.insert(t,x)</code> inserts <code>x</code> at the end
of list <code>t</code>.




<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
Moves elements from table <code>a1</code> to table <code>a2</code>,
performing the equivalent to the following
multiple assignment:
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>.
The default for <code>a2</code> is <code>a1</code>.
The destination range can overlap with the source range.
The number of elements to be moved must fit in a Lua integer.


<p>
Returns the destination table <code>a2</code>.




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns a new table with all arguments stored into keys 1, 2, etc.
and with a field "<code>n</code>" with the total number of arguments.
Note that the resulting table may not be a sequence.




<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
Removes from <code>list</code> the element at position <code>pos</code>,
returning the value of the removed element.
When <code>pos</code> is an integer between 1 and <code>#list</code>,
it shifts down the elements
<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
and erases element <code>list[#list]</code>;
The index <code>pos</code> can also be 0 when <code>#list</code> is 0,
or <code>#list + 1</code>;
in those cases, the function erases the element <code>list[pos]</code>.


<p>
The default value for <code>pos</code> is <code>#list</code>,
so that a call <code>table.remove(l)</code> removes the last element
of list <code>l</code>.




<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
Sorts list elements in a given order, <em>in-place</em>,
from <code>list[1]</code> to <code>list[#list]</code>.
If <code>comp</code> is given,
then it must be a function that receives two list elements
and returns true when the first element must come
before the second in the final order
(so that, after the sort,
<code>i &lt; j</code> implies <code>not comp(list[j],list[i])</code>).
If <code>comp</code> is not given,
then the standard Lua operator <code>&lt;</code> is used instead.


<p>
Note that the <code>comp</code> function must define
a strict partial order over the elements in the list;
that is, it must be asymmetric and transitive.
Otherwise, no valid sort may be possible.


<p>
The sort algorithm is not stable:
elements considered equal by the given order
may have their relative positions changed by the sort.




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
Returns the elements from the given list.
This function is equivalent to

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
By default, <code>i</code> is&nbsp;1 and <code>j</code> is <code>#list</code>.







<h2>6.7 &ndash; <a name="6.7">Mathematical Functions</a></h2>

<p>
This library provides basic mathematical functions.
It provides all its functions and constants inside the table <a name="pdf-math"><code>math</code></a>.
Functions with the annotation "<code>integer/float</code>" give
integer results for integer arguments
and float results for float (or mixed) arguments.
Rounding functions
(<a href="#pdf-math.ceil"><code>math.ceil</code></a>, <a href="#pdf-math.floor"><code>math.floor</code></a>, and <a href="#pdf-math.modf"><code>math.modf</code></a>)
return an integer when the result fits in the range of an integer,
or a float otherwise.


<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
Returns the absolute value of <code>x</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
Returns the arc cosine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
Returns the arc sine of <code>x</code> (in radians).




<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>

Returns the arc tangent of <code>y/x</code> (in radians),
but uses the signs of both arguments to find the
quadrant of the result.
(It also handles correctly the case of <code>x</code> being zero.)


<p>
The default value for <code>x</code> is 1,
so that the call <code>math.atan(y)</code>
returns the arc tangent of <code>y</code>.




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
Returns the smallest integral value larger than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
Returns the cosine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from radians to degrees.




<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
Returns the value <em>e<sup>x</sup></em>
(where <code>e</code> is the base of natural logarithms).




<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
Returns the largest integral value smaller than or equal to <code>x</code>.




<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
Returns the remainder of the division of <code>x</code> by <code>y</code>
that rounds the quotient towards zero. (integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
The float value <code>HUGE_VAL</code>,
a value larger than any other numeric value.




<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
Returns the logarithm of <code>x</code> in the given base.
The default for <code>base</code> is <em>e</em>
(so that the function returns the natural logarithm of <code>x</code>).




<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the maximum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
An integer with the maximum value for an integer.




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
Returns the argument with the minimum value,
according to the Lua operator <code>&lt;</code>. (integer/float)




<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
An integer with the minimum value for an integer.




<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
Returns the integral part of <code>x</code> and the fractional part of <code>x</code>.
Its second result is always a float.




<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
The value of <em>&pi;</em>.




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
Converts the angle <code>x</code> from degrees to radians.




<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
When called without arguments,
returns a pseudo-random float with uniform distribution
in the range  <em>[0,1)</em>.  
When called with two integers <code>m</code> and <code>n</code>,
<code>math.random</code> returns a pseudo-random integer
with uniform distribution in the range <em>[m, n]</em>.
(The value <em>n-m</em> cannot be negative and must fit in a Lua integer.)
The call <code>math.random(n)</code> is equivalent to <code>math.random(1,n)</code>.


<p>
This function is an interface to the underling
pseudo-random generator function provided by C.




<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
Sets <code>x</code> as the "seed"
for the pseudo-random generator:
equal seeds produce equal sequences of numbers.




<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
Returns the sine of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
Returns the square root of <code>x</code>.
(You can also use the expression <code>x^0.5</code> to compute this value.)




<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
Returns the tangent of <code>x</code> (assumed to be in radians).




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
If the value <code>x</code> is convertible to an integer,
returns that integer.
Otherwise, returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
Returns "<code>integer</code>" if <code>x</code> is an integer,
"<code>float</code>" if it is a float,
or <b>nil</b> if <code>x</code> is not a number.




<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
Returns a boolean,
true if and only if integer <code>m</code> is below integer <code>n</code> when
they are compared as unsigned integers.







<h2>6.8 &ndash; <a name="6.8">Input and Output Facilities</a></h2>

<p>
The I/O library provides two different styles for file manipulation.
The first one uses implicit file handles;
that is, there are operations to set a default input file and a
default output file,
and all input/output operations are over these default files.
The second style uses explicit file handles.


<p>
When using implicit file handles,
all operations are supplied by table <a name="pdf-io"><code>io</code></a>.
When using explicit file handles,
the operation <a href="#pdf-io.open"><code>io.open</code></a> returns a file handle
and then all operations are supplied as methods of the file handle.


<p>
The table <code>io</code> also provides
three predefined file handles with their usual meanings from C:
<a name="pdf-io.stdin"><code>io.stdin</code></a>, <a name="pdf-io.stdout"><code>io.stdout</code></a>, and <a name="pdf-io.stderr"><code>io.stderr</code></a>.
The I/O library never closes these files.


<p>
Unless otherwise stated,
all I/O functions return <b>nil</b> on failure
(plus an error message as a second result and
a system-dependent error code as a third result)
and some value different from <b>nil</b> on success.
In non-POSIX systems,
the computation of the error message and error code
in case of errors
may be not thread safe,
because they rely on the global C variable <code>errno</code>.


<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
Equivalent to <code>file:close()</code>.
Without a <code>file</code>, closes the default output file.




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
Equivalent to <code>io.output():flush()</code>.




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
When called with a file name, it opens the named file (in text mode),
and sets its handle as the default input file.
When called with a file handle,
it simply sets this file handle as the default input file.
When called without arguments,
it returns the current default input file.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename, &middot;&middot;&middot;])</code></a></h3>


<p>
Opens the given file name in read mode
and returns an iterator function that
works like <code>file:lines(&middot;&middot;&middot;)</code> over the opened file.
When the iterator function detects the end of file,
it returns no values (to finish the loop) and automatically closes the file.


<p>
The call <code>io.lines()</code> (with no file name) is equivalent
to <code>io.input():lines("*l")</code>;
that is, it iterates over the lines of the default input file.
In this case, the iterator does not close the file when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
This function opens a file,
in the mode specified in the string <code>mode</code>.
In case of success,
it returns a new file handle.


<p>
The <code>mode</code> string can be any of the following:

<ul>
<li><b>"<code>r</code>": </b> read mode (the default);</li>
<li><b>"<code>w</code>": </b> write mode;</li>
<li><b>"<code>a</code>": </b> append mode;</li>
<li><b>"<code>r+</code>": </b> update mode, all previous data is preserved;</li>
<li><b>"<code>w+</code>": </b> update mode, all previous data is erased;</li>
<li><b>"<code>a+</code>": </b> append update mode, previous data is preserved,
  writing is only allowed at the end of file.</li>
</ul><p>
The <code>mode</code> string can also have a '<code>b</code>' at the end,
which is needed in some systems to open the file in binary mode.




<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
Similar to <a href="#pdf-io.input"><code>io.input</code></a>, but operates over the default output file.




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
This function is system dependent and is not available
on all platforms.


<p>
Starts program <code>prog</code> in a separated process and returns
a file handle that you can use to read data from this program
(if <code>mode</code> is <code>"r"</code>, the default)
or to write data to this program
(if <code>mode</code> is <code>"w"</code>).




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.input():read(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
In case of success,
returns a handle for a temporary file.
This file is opened in update mode
and it is automatically removed when the program ends.




<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
Checks whether <code>obj</code> is a valid file handle.
Returns the string <code>"file"</code> if <code>obj</code> is an open file handle,
<code>"closed file"</code> if <code>obj</code> is a closed file handle,
or <b>nil</b> if <code>obj</code> is not a file handle.




<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
Equivalent to <code>io.output():write(&middot;&middot;&middot;)</code>.




<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
Closes <code>file</code>.
Note that files are automatically closed when
their handles are garbage collected,
but that takes an unpredictable amount of time to happen.


<p>
When closing a file handle created with <a href="#pdf-io.popen"><code>io.popen</code></a>,
<a href="#pdf-file:close"><code>file:close</code></a> returns the same values
returned by <a href="#pdf-os.execute"><code>os.execute</code></a>.




<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
Saves any written data to <code>file</code>.




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
Returns an iterator function that,
each time it is called,
reads the file according to the given formats.
When no format is given,
uses "<code>l</code>" as a default.
As an example, the construction

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
will iterate over all characters of the file,
starting at the current position.
Unlike <a href="#pdf-io.lines"><code>io.lines</code></a>, this function does not close the file
when the loop ends.


<p>
In case of errors this function raises the error,
instead of returning an error code.




<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
Reads the file <code>file</code>,
according to the given formats, which specify what to read.
For each format,
the function returns a string or a number with the characters read,
or <b>nil</b> if it cannot read data with the specified format.
(In this latter case,
the function does not read subsequent formats.)
When called without formats,
it uses a default format that reads the next line
(see below).


<p>
The available formats are

<ul>

<li><b>"<code>n</code>": </b>
reads a numeral and returns it as a float or an integer,
following the lexical conventions of Lua.
(The numeral may have leading spaces and a sign.)
This format always reads the longest input sequence that
is a valid prefix for a numeral;
if that prefix does not form a valid numeral
(e.g., an empty string, "<code>0x</code>", or "<code>3.4e-</code>"),
it is discarded and the function returns <b>nil</b>.
</li>

<li><b>"<code>a</code>": </b>
reads the whole file, starting at the current position.
On end of file, it returns the empty string.
</li>

<li><b>"<code>l</code>": </b>
reads the next line skipping the end of line,
returning <b>nil</b> on end of file.
This is the default format.
</li>

<li><b>"<code>L</code>": </b>
reads the next line keeping the end-of-line character (if present),
returning <b>nil</b> on end of file.
</li>

<li><b><em>number</em>: </b>
reads a string with up to this number of bytes,
returning <b>nil</b> on end of file.
If <code>number</code> is zero,
it reads nothing and returns an empty string,
or <b>nil</b> on end of file.
</li>

</ul><p>
The formats "<code>l</code>" and "<code>L</code>" should be used only for text files.




<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
Sets and gets the file position,
measured from the beginning of the file,
to the position given by <code>offset</code> plus a base
specified by the string <code>whence</code>, as follows:

<ul>
<li><b>"<code>set</code>": </b> base is position 0 (beginning of the file);</li>
<li><b>"<code>cur</code>": </b> base is current position;</li>
<li><b>"<code>end</code>": </b> base is end of file;</li>
</ul><p>
In case of success, <code>seek</code> returns the final file position,
measured in bytes from the beginning of the file.
If <code>seek</code> fails, it returns <b>nil</b>,
plus a string describing the error.


<p>
The default value for <code>whence</code> is <code>"cur"</code>,
and for <code>offset</code> is 0.
Therefore, the call <code>file:seek()</code> returns the current
file position, without changing it;
the call <code>file:seek("set")</code> sets the position to the
beginning of the file (and returns 0);
and the call <code>file:seek("end")</code> sets the position to the
end of the file, and returns its size.




<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
Sets the buffering mode for an output file.
There are three available modes:

<ul>

<li><b>"<code>no</code>": </b>
no buffering; the result of any output operation appears immediately.
</li>

<li><b>"<code>full</code>": </b>
full buffering; output operation is performed only
when the buffer is full or when
you explicitly <code>flush</code> the file (see <a href="#pdf-io.flush"><code>io.flush</code></a>).
</li>

<li><b>"<code>line</code>": </b>
line buffering; output is buffered until a newline is output
or there is any input from some special files
(such as a terminal device).
</li>

</ul><p>
For the last two cases, <code>size</code>
specifies the size of the buffer, in bytes.
The default is an appropriate size.




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
Writes the value of each of its arguments to <code>file</code>.
The arguments must be strings or numbers.


<p>
In case of success, this function returns <code>file</code>.
Otherwise it returns <b>nil</b> plus a string describing the error.







<h2>6.9 &ndash; <a name="6.9">Operating System Facilities</a></h2>

<p>
This library is implemented through table <a name="pdf-os"><code>os</code></a>.


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
Returns an approximation of the amount in seconds of CPU time
used by the program.




<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
Returns a string or a table containing date and time,
formatted according to the given string <code>format</code>.


<p>
If the <code>time</code> argument is present,
this is the time to be formatted
(see the <a href="#pdf-os.time"><code>os.time</code></a> function for a description of this value).
Otherwise, <code>date</code> formats the current time.


<p>
If <code>format</code> starts with '<code>!</code>',
then the date is formatted in Coordinated Universal Time.
After this optional character,
if <code>format</code> is the string "<code>*t</code>",
then <code>date</code> returns a table with the following fields:
<code>year</code>, <code>month</code> (1&ndash;12), <code>day</code> (1&ndash;31),
<code>hour</code> (0&ndash;23), <code>min</code> (0&ndash;59), <code>sec</code> (0&ndash;61),
<code>wday</code> (weekday, 1&ndash;7, Sunday is&nbsp;1),
<code>yday</code> (day of the year, 1&ndash;366),
and <code>isdst</code> (daylight saving flag, a boolean).
This last field may be absent
if the information is not available.


<p>
If <code>format</code> is not "<code>*t</code>",
then <code>date</code> returns the date as a string,
formatted according to the same rules as the ISO&nbsp;C function <code>strftime</code>.


<p>
When called without arguments,
<code>date</code> returns a reasonable date and time representation that depends on
the host system and on the current locale.
(More specifically, <code>os.date()</code> is equivalent to <code>os.date("%c")</code>.)


<p>
In non-POSIX systems,
this function may be not thread safe
because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.




<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
Returns the difference, in seconds,
from time <code>t1</code> to time <code>t2</code>
(where the times are values returned by <a href="#pdf-os.time"><code>os.time</code></a>).
In POSIX, Windows, and some other systems,
this value is exactly <code>t2</code><em>-</em><code>t1</code>.




<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
This function is equivalent to the ISO&nbsp;C function <code>system</code>.
It passes <code>command</code> to be executed by an operating system shell.
Its first result is <b>true</b>
if the command terminated successfully,
or <b>nil</b> otherwise.
After this first result
the function returns a string plus a number,
as follows:

<ul>

<li><b>"<code>exit</code>": </b>
the command terminated normally;
the following number is the exit status of the command.
</li>

<li><b>"<code>signal</code>": </b>
the command was terminated by a signal;
the following number is the signal that terminated the command.
</li>

</ul>

<p>
When called without a <code>command</code>,
<code>os.execute</code> returns a boolean that is true if a shell is available.




<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
Calls the ISO&nbsp;C function <code>exit</code> to terminate the host program.
If <code>code</code> is <b>true</b>,
the returned status is <code>EXIT_SUCCESS</code>;
if <code>code</code> is <b>false</b>,
the returned status is <code>EXIT_FAILURE</code>;
if <code>code</code> is a number,
the returned status is this number.
The default value for <code>code</code> is <b>true</b>.


<p>
If the optional second argument <code>close</code> is true,
closes the Lua state before exiting.




<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
Returns the value of the process environment variable <code>varname</code>,
or <b>nil</b> if the variable is not defined.




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
Deletes the file (or empty directory, on POSIX systems)
with the given name.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.
Otherwise, it returns true.




<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
Renames the file or directory named <code>oldname</code> to <code>newname</code>.
If this function fails, it returns <b>nil</b>,
plus a string describing the error and the error code.
Otherwise, it returns true.




<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
Sets the current locale of the program.
<code>locale</code> is a system-dependent string specifying a locale;
<code>category</code> is an optional string describing which category to change:
<code>"all"</code>, <code>"collate"</code>, <code>"ctype"</code>,
<code>"monetary"</code>, <code>"numeric"</code>, or <code>"time"</code>;
the default category is <code>"all"</code>.
The function returns the name of the new locale,
or <b>nil</b> if the request cannot be honored.


<p>
If <code>locale</code> is the empty string,
the current locale is set to an implementation-defined native locale.
If <code>locale</code> is the string "<code>C</code>",
the current locale is set to the standard C locale.


<p>
When called with <b>nil</b> as the first argument,
this function only returns the name of the current locale
for the given category.


<p>
This function may be not thread safe
because of its reliance on C&nbsp;function <code>setlocale</code>.




<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
Returns the current time when called without arguments,
or a time representing the local date and time specified by the given table.
This table must have fields <code>year</code>, <code>month</code>, and <code>day</code>,
and may have fields
<code>hour</code> (default is 12),
<code>min</code> (default is 0),
<code>sec</code> (default is 0),
and <code>isdst</code> (default is <b>nil</b>).
Other fields are ignored.
For a description of these fields, see the <a href="#pdf-os.date"><code>os.date</code></a> function.


<p>
The values in these fields do not need to be inside their valid ranges.
For instance, if <code>sec</code> is -10,
it means -10 seconds from the time specified by the other fields;
if <code>hour</code> is 1000,
it means +1000 hours from the time specified by the other fields.


<p>
The returned value is a number, whose meaning depends on your system.
In POSIX, Windows, and some other systems,
this number counts the number
of seconds since some given start time (the "epoch").
In other systems, the meaning is not specified,
and the number returned by <code>time</code> can be used only as an argument to
<a href="#pdf-os.date"><code>os.date</code></a> and <a href="#pdf-os.difftime"><code>os.difftime</code></a>.




<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
Returns a string with a file name that can
be used for a temporary file.
The file must be explicitly opened before its use
and explicitly removed when no longer needed.


<p>
In POSIX systems,
this function also creates a file with that name,
to avoid security risks.
(Someone else might create the file with wrong permissions
in the time between getting the name and creating the file.)
You still have to open the file to use it
and to remove it (even if you do not use it).


<p>
When possible,
you may prefer to use <a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>,
which automatically removes the file when the program ends.







<h2>6.10 &ndash; <a name="6.10">The Debug Library</a></h2>

<p>
This library provides
the functionality of the debug interface (<a href="#4.9">&sect;4.9</a>) to Lua programs.
You should exert care when using this library.
Several of its functions
violate basic assumptions about Lua code
(e.g., that variables local to a function
cannot be accessed from outside;
that userdata metatables cannot be changed by Lua code;
that Lua programs do not crash)
and therefore can compromise otherwise secure code.
Moreover, some functions in this library may be slow.


<p>
All functions in this library are provided
inside the <a name="pdf-debug"><code>debug</code></a> table.
All functions that operate over a thread
have an optional first argument which is the
thread to operate over.
The default is always the current thread.


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
Enters an interactive mode with the user,
running each string that the user enters.
Using simple commands and other debug facilities,
the user can inspect global and local variables,
change their values, evaluate expressions, and so on.
A line containing only the word <code>cont</code> finishes this function,
so that the caller continues its execution.


<p>
Note that commands for <code>debug.debug</code> are not lexically nested
within any function and so have no direct access to local variables.




<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
Returns the current hook settings of the thread, as three values:
the current hook function, the current hook mask,
and the current hook count
(as set by the <a href="#pdf-debug.sethook"><code>debug.sethook</code></a> function).




<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
Returns a table with information about a function.
You can give the function directly
or you can give a number as the value of <code>f</code>,
which means the function running at level <code>f</code> of the call stack
of the given thread:
level&nbsp;0 is the current function (<code>getinfo</code> itself);
level&nbsp;1 is the function that called <code>getinfo</code>
(except for tail calls, which do not count on the stack);
and so on.
If <code>f</code> is a number larger than the number of active functions,
then <code>getinfo</code> returns <b>nil</b>.


<p>
The returned table can contain all the fields returned by <a href="#lua_getinfo"><code>lua_getinfo</code></a>,
with the string <code>what</code> describing which fields to fill in.
The default for <code>what</code> is to get all information available,
except the table of valid lines.
If present,
the option '<code>f</code>'
adds a field named <code>func</code> with the function itself.
If present,
the option '<code>L</code>'
adds a field named <code>activelines</code> with the table of
valid lines.


<p>
For instance, the expression <code>debug.getinfo(1,"n").name</code> returns
a name for the current function,
if a reasonable name can be found,
and the expression <code>debug.getinfo(print)</code>
returns a table with all available information
about the <a href="#pdf-print"><code>print</code></a> function.




<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
This function returns the name and the value of the local variable
with index <code>local</code> of the function at level <code>f</code> of the stack.
This function accesses not only explicit local variables,
but also parameters, temporaries, etc.


<p>
The first parameter or local variable has index&nbsp;1, and so on,
following the order that they are declared in the code,
counting only the variables that are active
in the current scope of the function.
Negative indices refer to vararg arguments;
-1 is the first vararg argument.
The function returns <b>nil</b> if there is no variable with the given index,
and raises an error when called with a level out of range.
(You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(internal variables such as loop control variables,
and variables from chunks saved without debug information).


<p>
The parameter <code>f</code> may also be a function.
In that case, <code>getlocal</code> returns only the name of function parameters.




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
Returns the metatable of the given <code>value</code>
or <b>nil</b> if it does not have a metatable.




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
Returns the registry table (see <a href="#4.5">&sect;4.5</a>).




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
This function returns the name and the value of the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue with the given index.


<p>
Variable names starting with '<code>(</code>' (open parenthesis) 
represent variables with no known names
(variables from chunks saved without debug information).




<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
Returns the Lua value associated to <code>u</code>.
If <code>u</code> is not a full userdata,
returns <b>nil</b>.




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
Sets the given function as a hook.
The string <code>mask</code> and the number <code>count</code> describe
when the hook will be called.
The string mask may have any combination of the following characters,
with the given meaning:

<ul>
<li><b>'<code>c</code>': </b> the hook is called every time Lua calls a function;</li>
<li><b>'<code>r</code>': </b> the hook is called every time Lua returns from a function;</li>
<li><b>'<code>l</code>': </b> the hook is called every time Lua enters a new line of code.</li>
</ul><p>
Moreover,
with a <code>count</code> different from zero,
the hook is called also after every <code>count</code> instructions.


<p>
When called without arguments,
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> turns off the hook.


<p>
When the hook is called, its first argument is a string
describing the event that has triggered its call:
<code>"call"</code> (or <code>"tail call"</code>),
<code>"return"</code>,
<code>"line"</code>, and <code>"count"</code>.
For line events,
the hook also gets the new line number as its second parameter.
Inside a hook,
you can call <code>getinfo</code> with level&nbsp;2 to get more information about
the running function
(level&nbsp;0 is the <code>getinfo</code> function,
and level&nbsp;1 is the hook function).




<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the local variable
with index <code>local</code> of the function at level <code>level</code> of the stack.
The function returns <b>nil</b> if there is no local
variable with the given index,
and raises an error when called with a <code>level</code> out of range.
(You can call <code>getinfo</code> to check whether the level is valid.)
Otherwise, it returns the name of the local variable.


<p>
See <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> for more information about
variable indices and names.




<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
Sets the metatable for the given <code>value</code> to the given <code>table</code>
(which can be <b>nil</b>).
Returns <code>value</code>.




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
This function assigns the value <code>value</code> to the upvalue
with index <code>up</code> of the function <code>f</code>.
The function returns <b>nil</b> if there is no upvalue
with the given index.
Otherwise, it returns the name of the upvalue.




<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
Sets the given <code>value</code> as
the Lua value associated to the given <code>udata</code>.
<code>udata</code> must be a full userdata.


<p>
Returns <code>udata</code>.




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
If <code>message</code> is present but is neither a string nor <b>nil</b>,
this function returns <code>message</code> without further processing.
Otherwise,
it returns a string with a traceback of the call stack.
The optional <code>message</code> string is appended
at the beginning of the traceback.
An optional <code>level</code> number tells at which level
to start the traceback
(default is 1, the function calling <code>traceback</code>).




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
Returns a unique identifier (as a light userdata)
for the upvalue numbered <code>n</code>
from the given function.


<p>
These unique identifiers allow a program to check whether different
closures share upvalues.
Lua closures that share an upvalue
(that is, that access a same external local variable)
will return identical ids for those upvalue indices.




<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
Make the <code>n1</code>-th upvalue of the Lua closure <code>f1</code>
refer to the <code>n2</code>-th upvalue of the Lua closure <code>f2</code>.







<h1>7 &ndash; <a name="7">Lua Standalone</a></h1>

<p>
Although Lua has been designed as an extension language,
to be embedded in a host C&nbsp;program,
it is also frequently used as a standalone language.
An interpreter for Lua as a standalone language,
called simply <code>lua</code>,
is provided with the standard distribution.
The standalone interpreter includes
all standard libraries, including the debug library.
Its usage is:

<pre>
     lua [options] [script [args]]
</pre><p>
The options are:

<ul>
<li><b><code>-e <em>stat</em></code>: </b> executes string <em>stat</em>;</li>
<li><b><code>-l <em>mod</em></code>: </b> "requires" <em>mod</em> and assigns the
  result to global @<em>mod</em>;</li>
<li><b><code>-i</code>: </b> enters interactive mode after running <em>script</em>;</li>
<li><b><code>-v</code>: </b> prints version information;</li>
<li><b><code>-E</code>: </b> ignores environment variables;</li>
<li><b><code>--</code>: </b> stops handling options;</li>
<li><b><code>-</code>: </b> executes <code>stdin</code> as a file and stops handling options.</li>
</ul><p>
After handling its options, <code>lua</code> runs the given <em>script</em>.
When called without arguments,
<code>lua</code> behaves as <code>lua -v -i</code>
when the standard input (<code>stdin</code>) is a terminal,
and as <code>lua -</code> otherwise.


<p>
When called without option <code>-E</code>,
the interpreter checks for an environment variable <a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>
(or <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a> if the versioned name is not defined)
before running any argument.
If the variable content has the format <code>@<em>filename</em></code>,
then <code>lua</code> executes the file.
Otherwise, <code>lua</code> executes the string itself.


<p>
When called with option <code>-E</code>,
besides ignoring <code>LUA_INIT</code>,
Lua also ignores
the values of <code>LUA_PATH</code> and <code>LUA_CPATH</code>,
setting the values of
<a href="#pdf-package.path"><code>package.path</code></a> and <a href="#pdf-package.cpath"><code>package.cpath</code></a>
with the default paths defined in <code>luaconf.h</code>.


<p>
All options are handled in order, except <code>-i</code> and <code>-E</code>.
For instance, an invocation like

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
will first set <code>a</code> to 1, then print the value of <code>a</code>,
and finally run the file <code>script.lua</code> with no arguments.
(Here <code>$</code> is the shell prompt. Your prompt may be different.)


<p>
Before running any code,
<code>lua</code> collects all command-line arguments
in a global table called <code>arg</code>.
The script name goes to index 0,
the first argument after the script name goes to index 1,
and so on.
Any arguments before the script name
(that is, the interpreter name plus its options)
go to negative indices.
For instance, in the call

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
the table is like this:

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
If there is no script in the call,
the interpreter name goes to index 0,
followed by the other arguments.
For instance, the call

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
will print "<code>-e</code>".
If there is a script,
the script is called with arguments
<code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>.
(Like all chunks in Lua,
the script is compiled as a vararg function.)


<p>
In interactive mode,
Lua repeatedly prompts and waits for a line.
After reading a line,
Lua first try to interpret the line as an expression.
If it succeeds, it prints its value.
Otherwise, it interprets the line as a statement.
If you write an incomplete statement,
the interpreter waits for its completion
by issuing a different prompt.


<p>
If the global variable <a name="pdf-_PROMPT"><code>_PROMPT</code></a> contains a string,
then its value is used as the prompt.
Similarly, if the global variable <a name="pdf-_PROMPT2"><code>_PROMPT2</code></a> contains a string,
its value is used as the secondary prompt
(issued during incomplete statements).


<p>
In case of unprotected errors in the script,
the interpreter reports the error to the standard error stream.
If the error object is not a string but
has a metamethod <code>__tostring</code>,
the interpreter calls this metamethod to produce the final message.
Otherwise, the interpreter converts the error object to a string
and adds a stack traceback to it.


<p>
When finishing normally,
the interpreter closes its main Lua state
(see <a href="#lua_close"><code>lua_close</code></a>).
The script can avoid this step by
calling <a href="#pdf-os.exit"><code>os.exit</code></a> to terminate.


<p>
To allow the use of Lua as a
script interpreter in Unix systems,
the standalone interpreter skips
the first line of a chunk if it starts with <code>#</code>.
Therefore, Lua scripts can be made into executable programs
by using <code>chmod +x</code> and the&nbsp;<code>#!</code> form,
as in

<pre>
     #!/usr/local/bin/lua
</pre><p>
(Of course,
the location of the Lua interpreter may be different in your machine.
If <code>lua</code> is in your <code>PATH</code>,
then

<pre>
     #!/usr/bin/env lua
</pre><p>
is a more portable solution.)



<h1>8 &ndash; <a name="8">Incompatibilities with the Previous Version</a></h1>

<p>
Here we list the incompatibilities that you may find when moving a program
from Lua&nbsp;5.2 to Lua&nbsp;5.3.
You can avoid some incompatibilities by compiling Lua with
appropriate options (see file <code>luaconf.h</code>).
However,
all these compatibility options will be removed in the future.


<p>
Lua versions can always change the C API in ways that
do not imply source-code changes in a program,
such as the numeric values for constants
or the implementation of functions as macros.
Therefore,
you should not assume that binaries are compatible between
different Lua versions.
Always recompile clients of the Lua API when
using a new version.


<p>
Similarly, Lua versions can always change the internal representation
of precompiled chunks;
precompiled chunks are not compatible between different Lua versions.


<p>
The standard paths in the official distribution may
change between versions.



<h2>8.1 &ndash; <a name="8.1">Changes in the Language</a></h2>
<ul>

<li>
The main difference between Lua&nbsp;5.2 and Lua&nbsp;5.3 is the
introduction of an integer subtype for numbers.
Although this change should not affect "normal" computations,
some computations
(mainly those that involve some kind of overflow)
can give different results.


<p>
You can fix these differences by forcing a number to be a float
(in Lua&nbsp;5.2 all numbers were float),
in particular writing constants with an ending <code>.0</code>
or using <code>x = x + 0.0</code> to convert a variable.
(This recommendation is only for a quick fix
for an occasional incompatibility;
it is not a general guideline for good programming.
For good programming,
use floats where you need floats
and integers where you need integers.)
</li>

<li>
The conversion of a float to a string now adds a <code>.0</code> suffix
to the result if it looks like an integer.
(For instance, the float 2.0 will be printed as <code>2.0</code>,
not as <code>2</code>.)
You should always use an explicit format
when you need a specific format for numbers.


<p>
(Formally this is not an incompatibility,
because Lua does not specify how numbers are formatted as strings,
but some programs assumed a specific format.)
</li>

<li>
The generational mode for the garbage collector was removed.
(It was an experimental feature in Lua&nbsp;5.2.)
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">Changes in the Libraries</a></h2>
<ul>

<li>
The <code>bit32</code> library has been deprecated.
It is easy to require a compatible external library or,
better yet, to replace its functions with appropriate bitwise operations.
(Keep in mind that <code>bit32</code> operates on 32-bit integers,
while the bitwise operators in Lua&nbsp;5.3 operate on Lua integers,
which by default have 64&nbsp;bits.)
</li>

<li>
The Table library now respects metamethods
for setting and getting elements.
</li>

<li>
The <a href="#pdf-ipairs"><code>ipairs</code></a> iterator now respects metamethods and
its <code>__ipairs</code> metamethod has been deprecated.
</li>

<li>
Option names in <a href="#pdf-io.read"><code>io.read</code></a> do not have a starting '<code>*</code>' anymore.
For compatibility, Lua will continue to accept (and ignore) this character.
</li>

<li>
The following functions were deprecated in the mathematical library:
<code>atan2</code>, <code>cosh</code>, <code>sinh</code>, <code>tanh</code>, <code>pow</code>,
<code>frexp</code>, and <code>ldexp</code>.
You can replace <code>math.pow(x,y)</code> with <code>x^y</code>;
you can replace <code>math.atan2</code> with <code>math.atan</code>,
which now accepts one or two arguments;
you can replace <code>math.ldexp(x,exp)</code> with <code>x * 2.0^exp</code>.
For the other operations,
you can either use an external library or
implement them in Lua.
</li>

<li>
The searcher for C loaders used by <a href="#pdf-require"><code>require</code></a>
changed the way it handles versioned names.
Now, the version should come after the module name
(as is usual in most other tools).
For compatibility, that searcher still tries the old format
if it cannot find an open function according to the new style.
(Lua&nbsp;5.2 already worked that way,
but it did not document the change.)
</li>

<li>
The call <code>collectgarbage("count")</code> now returns only one result.
(You can compute that second result from the fractional part
of the first result.)
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">Changes in the API</a></h2>


<ul>

<li>
Continuation functions now receive as arguments what they needed
to get through <code>lua_getctx</code>,
so <code>lua_getctx</code> has been removed.
Adapt your code accordingly.
</li>

<li>
Function <a href="#lua_dump"><code>lua_dump</code></a> has an extra parameter, <code>strip</code>.
Use 0 as the value of this parameter to get the old behavior.
</li>

<li>
Functions to inject/project unsigned integers
(<code>lua_pushunsigned</code>, <code>lua_tounsigned</code>, <code>lua_tounsignedx</code>,
<code>luaL_checkunsigned</code>, <code>luaL_optunsigned</code>)
were deprecated.
Use their signed equivalents with a type cast.
</li>

<li>
Macros to project non-default integer types
(<code>luaL_checkint</code>, <code>luaL_optint</code>, <code>luaL_checklong</code>, <code>luaL_optlong</code>)
were deprecated.
Use their equivalent over <a href="#lua_Integer"><code>lua_Integer</code></a> with a type cast
(or, when possible, use <a href="#lua_Integer"><code>lua_Integer</code></a> in your code).
</li>

</ul>




<h1>9 &ndash; <a name="9">The Complete Syntax of Lua</a></h1>

<p>
Here is the complete syntax of Lua in extended BNF.
As usual in extended BNF,
{A} means 0 or more As,
and [A] means an optional A.
(For operator precedences, see <a href="#3.4.8">&sect;3.4.8</a>;
for a description of the terminals
Name, Numeral,
and LiteralString, see <a href="#3.1">&sect;3.1</a>.)




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; | 
		 varlist &lsquo;<b>=</b>&rsquo; explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist] 

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name 

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args 

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | 
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; | 
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; | 
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

<p>








<P CLASS="footer">
Last update:
Tue Jul 14 10:32:39 UTC 2020
</P>
<!--
Last change: revised for Lua 5.3.6
-->

</body></html>




================================================
File: lua/doc/readme.html
================================================
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<TITLE>Lua 5.3 readme</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="lua.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=iso-8859-1">
<STYLE TYPE="text/css">
blockquote, .display {
	border: solid #a0a0a0 2px ;
	border-radius: 8px ;
	padding: 1em ;
	margin: 0px ;
}

.display {
	word-spacing: 0.25em ;
}

dl.display dd {
	padding-bottom: 0.2em ;
}

tt, kbd, code {
	font-size: 12pt ;
}
</STYLE>
</HEAD>

<BODY>

<H1>
<A HREF="http://www.lua.org/"><IMG SRC="logo.gif" ALT="Lua"></A>
Welcome to Lua 5.3
</H1>

<DIV CLASS="menubar">
<A HREF="#about">about</A>
&middot;
<A HREF="#install">installation</A>
&middot;
<A HREF="#changes">changes</A>
&middot;
<A HREF="#license">license</A>
&middot;
<A HREF="contents.html">reference manual</A>
</DIV>

<H2><A NAME="about">About Lua</A></H2>
<P>
Lua is a powerful, fast, lightweight, embeddable scripting language
developed by a
<A HREF="http://www.lua.org/authors.html">team</A>
at
<A HREF="http://www.puc-rio.br/">PUC-Rio</A>,
the Pontifical Catholic University of Rio de Janeiro in Brazil.
Lua is
<A HREF="#license">free software</A>
used in many products and projects around the world.

<P>
Lua's
<A HREF="http://www.lua.org/">official web site</A>
provides complete information
about Lua,
including
an
<A HREF="http://www.lua.org/about.html">executive summary</A>
and
updated
<A HREF="http://www.lua.org/docs.html">documentation</A>,
especially the
<A HREF="http://www.lua.org/manual/5.3/">reference manual</A>,
which may differ slightly from the
<A HREF="contents.html">local copy</A>
distributed in this package.

<H2><A NAME="install">Installing Lua</A></H2>
<P>
Lua is distributed in
<A HREF="http://www.lua.org/ftp/">source</A>
form.
You need to build it before using it.
Building Lua should be straightforward
because
Lua is implemented in pure ANSI C and compiles unmodified in all known
platforms that have an ANSI C compiler.
Lua also compiles unmodified as C++.
The instructions given below for building Lua are for Unix-like platforms.
See also
<A HREF="#other">instructions for other systems</A>
and
<A HREF="#customization">customization options</A>.

<P>
If you don't have the time or the inclination to compile Lua yourself,
get a binary from
<A HREF="http://lua-users.org/wiki/LuaBinaries">LuaBinaries</A>.
Try also
<A HREF="http://luadist.org/">LuaDist</A>,
a multi-platform distribution of Lua that includes batteries.

<H3>Building Lua</H3>
<P>
In most Unix-like platforms, simply do "<KBD>make</KBD>" with a suitable target.
Here are the details.

<OL>
<LI>
Open a terminal window and move to
the top-level directory, which is named <TT>lua-5.3.6</TT>.
The <TT>Makefile</TT> there controls both the build process and the installation process.
<P>
<LI>
  Do "<KBD>make</KBD>" and see if your platform is listed.
  The platforms currently supported are:
<P>
<P CLASS="display">
   aix bsd c89 freebsd generic linux macosx mingw posix solaris
</P>
<P>
  If your platform is listed, just do "<KBD>make xxx</KBD>", where xxx
  is your platform name.
<P>
  If your platform is not listed, try the closest one or posix, generic,
  c89, in this order.
<P>
<LI>
The compilation takes only a few moments
and produces three files in the <TT>src</TT> directory:
lua (the interpreter),
luac (the compiler),
and liblua.a (the library).
<P>
<LI>
  To check that Lua has been built correctly, do "<KBD>make test</KBD>"
  after building Lua. This will run the interpreter and print its version.
</OL>
<P>
If you're running Linux and get compilation errors,
make sure you have installed the <TT>readline</TT> development package
(which is probably named <TT>libreadline-dev</TT> or <TT>readline-devel</TT>).
If you get link errors after that,
then try "<KBD>make linux MYLIBS=-ltermcap</KBD>".

<H3>Installing Lua</H3>
<P>
  Once you have built Lua, you may want to install it in an official
  place in your system. In this case, do "<KBD>make install</KBD>". The official
  place and the way to install files are defined in the <TT>Makefile</TT>. You'll
  probably need the right permissions to install files.

<P>
  To build and install Lua in one step, do "<KBD>make xxx install</KBD>",
  where xxx is your platform name.

<P>
  To install Lua locally, do "<KBD>make local</KBD>".
  This will create a directory <TT>install</TT> with subdirectories
  <TT>bin</TT>, <TT>include</TT>, <TT>lib</TT>, <TT>man</TT>, <TT>share</TT>,
  and install Lua as listed below.

  To install Lua locally, but in some other directory, do
  "<KBD>make install INSTALL_TOP=xxx</KBD>", where xxx is your chosen directory.
  The installation starts in the <TT>src</TT> and <TT>doc</TT> directories,
  so take care if <TT>INSTALL_TOP</TT> is not an absolute path.

<DL CLASS="display">
<DT>
    bin:
<DD>
    lua luac
<DT>
    include:
<DD>
    lua.h luaconf.h lualib.h lauxlib.h lua.hpp
<DT>
    lib:
<DD>
    liblua.a
<DT>
    man/man1:
<DD>
    lua.1 luac.1
</DL>

<P>
  These are the only directories you need for development.
  If you only want to run Lua programs,
  you only need the files in <TT>bin</TT> and <TT>man</TT>.
  The files in <TT>include</TT> and <TT>lib</TT> are needed for
  embedding Lua in C or C++ programs.

<H3><A NAME="customization">Customization</A></H3>
<P>
  Three kinds of things can be customized by editing a file:
<UL>
    <LI> Where and how to install Lua &mdash; edit <TT>Makefile</TT>.
    <LI> How to build Lua &mdash; edit <TT>src/Makefile</TT>.
    <LI> Lua features &mdash; edit <TT>src/luaconf.h</TT>.
</UL>

<P>
  You don't actually need to edit the Makefiles because you may set the
  relevant variables in the command line when invoking make.
  Nevertheless, it's probably best to edit and save the Makefiles to
  record the changes you've made.

<P>
  On the other hand, if you need to customize some Lua features, you'll need
  to edit <TT>src/luaconf.h</TT> before building and installing Lua.
  The edited file will be the one installed, and
  it will be used by any Lua clients that you build, to ensure consistency.
  Further customization is available to experts by editing the Lua sources.

<H3><A NAME="other">Building Lua on other systems</A></H3>
<P>
  If you're not using the usual Unix tools, then the instructions for
  building Lua depend on the compiler you use. You'll need to create
  projects (or whatever your compiler uses) for building the library,
  the interpreter, and the compiler, as follows:

<DL CLASS="display">
<DT>
library:
<DD>
lapi.c lcode.c lctype.c ldebug.c ldo.c ldump.c lfunc.c lgc.c llex.c
lmem.c lobject.c lopcodes.c lparser.c lstate.c lstring.c ltable.c
ltm.c lundump.c lvm.c lzio.c
lauxlib.c lbaselib.c lbitlib.c lcorolib.c ldblib.c liolib.c
lmathlib.c loslib.c lstrlib.c ltablib.c lutf8lib.c loadlib.c linit.c
<DT>
interpreter:
<DD>
  library, lua.c
<DT>
compiler:
<DD>
  library, luac.c
</DL>

<P>
  To use Lua as a library in your own programs you'll need to know how to
  create and use libraries with your compiler. Moreover, to dynamically load
  C libraries for Lua you'll need to know how to create dynamic libraries
  and you'll need to make sure that the Lua API functions are accessible to
  those dynamic libraries &mdash; but <EM>don't</EM> link the Lua library
  into each dynamic library. For Unix, we recommend that the Lua library
  be linked statically into the host program and its symbols exported for
  dynamic linking; <TT>src/Makefile</TT> does this for the Lua interpreter.
  For Windows, we recommend that the Lua library be a DLL.
  In all cases, the compiler luac should be linked statically.

<P>
  As mentioned above, you may edit <TT>src/luaconf.h</TT> to customize
  some features before building Lua.

<H2><A NAME="changes">Changes since Lua 5.2</A></H2>
<P>
Here are the main changes introduced in Lua 5.3.
The
<A HREF="contents.html">reference manual</A>
lists the
<A HREF="manual.html#8">incompatibilities</A> that had to be introduced.

<H3>Main changes</H3>
<UL>
<LI> integers (64-bit by default)
<LI> official support for 32-bit numbers
<LI> bitwise operators
<LI> basic utf-8 support
<LI> functions for packing and unpacking values

</UL>

Here are the other changes introduced in Lua 5.3:
<H3>Language</H3>
<UL>
<LI> userdata can have any Lua value as uservalue
<LI> floor division
<LI> more flexible rules for some metamethods
</UL>

<H3>Libraries</H3>
<UL>
<LI> <CODE>ipairs</CODE> and the table library respect metamethods
<LI> strip option in <CODE>string.dump</CODE>
<LI> table library respects metamethods
<LI> new function <CODE>table.move</CODE>
<LI> new function <CODE>string.pack</CODE>
<LI> new function <CODE>string.unpack</CODE>
<LI> new function <CODE>string.packsize</CODE>
</UL>

<H3>C API</H3>
<UL>
<LI> simpler API for continuation functions in C
<LI> <CODE>lua_gettable</CODE> and similar functions return type of resulted value
<LI> strip option in <CODE>lua_dump</CODE>
<LI> new function: <CODE>lua_geti</CODE>
<LI> new function: <CODE>lua_seti</CODE>
<LI> new function: <CODE>lua_isyieldable</CODE>
<LI> new function: <CODE>lua_numbertointeger</CODE>
<LI> new function: <CODE>lua_rotate</CODE>
<LI> new function: <CODE>lua_stringtonumber</CODE>
</UL>

<H3>Lua standalone interpreter</H3>
<UL>
<LI> can be used as calculator; no need to prefix with '='
<LI> <CODE>arg</CODE> table available to all code
</UL>

<H2><A NAME="license">License</A></H2>
<P>
<A HREF="http://www.opensource.org/docs/definition.php">
<IMG SRC="osi-certified-72x60.png" ALIGN="right" ALT="[osi certified]" STYLE="padding-left: 30px ;">
</A>
Lua is free software distributed under the terms of the
<A HREF="http://www.opensource.org/licenses/mit-license.html">MIT license</A>
reproduced below;
it may be used for any purpose, including commercial purposes,
at absolutely no cost without having to ask us.

The only requirement is that if you do use Lua,
then you should give us credit by including the appropriate copyright notice somewhere in your product or its documentation.

For details, see
<A HREF="http://www.lua.org/license.html">this</A>.

<BLOCKQUOTE STYLE="padding-bottom: 0em">
Copyright &copy; 1994&ndash;2020 Lua.org, PUC-Rio.

<P>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

<P>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

<P>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
</BLOCKQUOTE>
<P>

<P CLASS="footer">
Last update:
Tue Jul 14 10:33:01 UTC 2020
</P>
<!--
Last change: revised for Lua 5.3.6
-->

</BODY>
</HTML>



================================================
File: lua/src/Makefile
================================================
# Makefile for building Lua
# See ../doc/readme.html for installation and customization instructions.

# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================

# Your platform. See PLATS for possible values.
PLAT= none

CC= gcc -std=gnu99
CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)
LDFLAGS= $(SYSLDFLAGS) $(MYLDFLAGS)
LIBS= -lm $(SYSLIBS) $(MYLIBS)

AR= ar rcu
RANLIB= ranlib
RM= rm -f

SYSCFLAGS=
SYSLDFLAGS=
SYSLIBS=

MYCFLAGS=
MYLDFLAGS=
MYLIBS=
MYOBJS=

# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======

PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris

LUA_A=	liblua.a
CORE_O=	lapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
	lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \
	ltm.o lundump.o lvm.o lzio.o
LIB_O=	lauxlib.o lbaselib.o lbitlib.o lcorolib.o ldblib.o liolib.o \
	lmathlib.o loslib.o lstrlib.o ltablib.o lutf8lib.o loadlib.o linit.o
BASE_O= $(CORE_O) $(LIB_O) $(MYOBJS)

LUA_T=	lua
LUA_O=	lua.o

LUAC_T=	luac
LUAC_O=	luac.o

ALL_O= $(BASE_O) $(LUA_O) $(LUAC_O)
ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)
ALL_A= $(LUA_A)

# Targets start here.
default: $(PLAT)

all:	$(ALL_T)

o:	$(ALL_O)

a:	$(ALL_A)

$(LUA_A): $(BASE_O)
	$(AR) $@ $(BASE_O)
	$(RANLIB) $@

$(LUA_T): $(LUA_O) $(LUA_A)
	$(CC) -o $@ $(LDFLAGS) $(LUA_O) $(LUA_A) $(LIBS)

$(LUAC_T): $(LUAC_O) $(LUA_A)
	$(CC) -o $@ $(LDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)

clean:
	$(RM) $(ALL_T) $(ALL_O)

depend:
	@$(CC) $(CFLAGS) -MM l*.c

echo:
	@echo "PLAT= $(PLAT)"
	@echo "CC= $(CC)"
	@echo "CFLAGS= $(CFLAGS)"
	@echo "LDFLAGS= $(SYSLDFLAGS)"
	@echo "LIBS= $(LIBS)"
	@echo "AR= $(AR)"
	@echo "RANLIB= $(RANLIB)"
	@echo "RM= $(RM)"

# Convenience targets for popular platforms
ALL= all

none:
	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
	@echo "   $(PLATS)"

aix:
	$(MAKE) $(ALL) CC="xlc" CFLAGS="-O2 -DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-ldl" SYSLDFLAGS="-brtl -bexpall"

bsd:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-Wl,-E"

c89:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_C89" CC="gcc -std=c89"
	@echo ''
	@echo '*** C89 does not guarantee 64-bit integers for Lua.'
	@echo ''


freebsd:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX -I/usr/include/edit" SYSLIBS="-Wl,-E -ledit" CC="cc"

generic: $(ALL)

linux:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -ldl -lreadline"

macosx:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_MACOSX" SYSLIBS="-lreadline"

mingw:
	$(MAKE) "LUA_A=lua53.dll" "LUA_T=lua.exe" \
	"AR=$(CC) -shared -o" "RANLIB=strip --strip-unneeded" \
	"SYSCFLAGS=-DLUA_BUILD_AS_DLL" "SYSLIBS=" "SYSLDFLAGS=-s" lua.exe
	$(MAKE) "LUAC_T=luac.exe" luac.exe

posix:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX"

solaris:
	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN -D_REENTRANT" SYSLIBS="-ldl"

# list targets that do not create files (but not all makes understand .PHONY)
.PHONY: all $(PLATS) default o a clean depend echo none

# DO NOT DELETE

lapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
 lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \
 ltable.h lundump.h lvm.h
lauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h
lbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lbitlib.o: lbitlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
 llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
 ldo.h lgc.h lstring.h ltable.h lvm.h
lcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h
ldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
ldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
 lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \
 ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h
ldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
 lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \
 lparser.h lstring.h ltable.h lundump.h lvm.h
ldump.o: ldump.c lprefix.h lua.h luaconf.h lobject.h llimits.h lstate.h \
 ltm.h lzio.h lmem.h lundump.h
lfunc.o: lfunc.c lprefix.h lua.h luaconf.h lfunc.h lobject.h llimits.h \
 lgc.h lstate.h ltm.h lzio.h lmem.h
lgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
 llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
linit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h
liolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
llex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \
 lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \
 lstring.h ltable.h
lmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
 llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h
loadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \
 ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \
 lvm.h
lopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h
loslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
 llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
 ldo.h lfunc.h lstring.h lgc.h ltable.h
lstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
 lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \
 lstring.h ltable.h
lstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
 lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h
lstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
ltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
 llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h
ltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
ltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
 llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h ltable.h lvm.h
lua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
luac.o: luac.c lprefix.h lua.h luaconf.h lauxlib.h lobject.h llimits.h \
 lstate.h ltm.h lzio.h lmem.h lundump.h ldebug.h lopcodes.h
lundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
 lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \
 lundump.h
lutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
lvm.o: lvm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
 llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h \
 ltable.h lvm.h
lzio.o: lzio.c lprefix.h lua.h luaconf.h llimits.h lmem.h lstate.h \
 lobject.h ltm.h lzio.h

# (end of Makefile)



================================================
File: lua/src/lua.hpp
================================================
// lua.hpp
// Lua header files for C++
// <<extern "C">> not supplied automatically because Lua also compiles as C++

#include <AP_Filesystem/AP_Filesystem.h>
#include <AP_Filesystem/posix_compat.h>

extern "C" {
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
}



================================================
File: modules/NMEA_2000.lua
================================================
--[[
   NMEA 2000 parser as lua module
   with thanks to https://canboat.github.io/canboat/canboat.html

   caller must setup a PGN expected size table with set_PGN_table()
--]]

local M = {}

M.PGN_table = {}

-- multi-frame pending data
M.pending = { pgn = nil, data = "", count = 0, expected_size = 0 }

-- Extract the PGN (Parameter Group Number) from the message ID
local function extract_pgn(message_id)
   local PF = (message_id >> 16) & 0xFF
   local RDP = (message_id >> 24) & 0x3
   if PF < 0xF0 then
      return (RDP << 16) | (PF << 8)
   else
      local PS = (message_id >> 8) & 0xFF
      return (RDP << 16) | (PF << 8) | PS
   end
end

--[[
   extract data from a CAN frame as a lua binary string
--]]
local function extract_data(frame, max_len)
   local ret = ""
   local dlc = frame:dlc()
   local len = math.min(dlc, max_len)
   for ofs = 1, len do
      ret = ret .. string.char(frame:data(ofs-1))
   end
   return ret
end

--[[
   set table of PGNs that we are interested in along with the expected packet size

   The table should be indexed by the PGN and give the expected size
   of that PGN any frames with PGNs not in this table will be
   discarded
--]]
function M.set_PGN_table(t)
   M.PGN_table = t
end

-- Parse CAN frame and reassemble messages
function M.parse(can_frame)
   if not can_frame:isExtended() then
      -- NMEA 2000 frame are always extended (29 bit address)
      return nil
   end
   local message_id = can_frame:id_signed()

   local pgn = extract_pgn(message_id)
   local dlc = can_frame:dlc()

   local exp_size = M.PGN_table[pgn]
   if not exp_size then
      -- discard unwated frame and reset pending
      M.pending.pgn = nil
      return nil
   end

   if exp_size <= 8 and exp_size > dlc then
      -- discard short frame
      M.pending.pgn = nil
      return nil
   end

   if exp_size <= 8 then
      -- single frame
      local data = extract_data(can_frame, exp_size)
      M.pending.pgn = nil
      return pgn, data
   end

   -- multi-frame
   local data = extract_data(can_frame, dlc)
   local subframe = string.byte(data, 1) & 0x1F
   if M.pending.pgn ~= pgn or subframe ~= M.pending.count then
      -- reset
      M.pending.pgn = nil
      M.pending.data = ""
      M.pending.count = 0

      if subframe ~= 0 then
         -- discard, lost first frame or out of order
         return nil
      end
   end

   if subframe == 0 then
      M.pending.expected_size = string.byte(data, 2)
      if M.pending.expected_size < exp_size then
         M.pending.pgn = nil
         return nil
      end
      M.pending.data = M.pending.data .. string.sub(data, 3, #data)
   else
      M.pending.data = M.pending.data .. string.sub(data, 2, #data)
   end
   M.pending.pgn = pgn
   M.pending.count = M.pending.count + 1

   -- do we have a complete frame
   if #M.pending.data >= M.pending.expected_size then
      M.pending.pgn = nil
      return pgn, M.pending.data
   end

   return nil
end

return M



================================================
File: modules/mavport.lua
================================================
-- class to cast mavlink SERIAL_CONTROL message functionality as a serial port.
-- currently always uses the "dev shell" device (which is ignored by Ardupilot).
-- designed for use with the Lua REPL applet.
-- note that flush() must be called to empty internal transmit buffers.

local mavport = {}

local mavlink_msgs = require("MAVLink/mavlink_msgs")

local SERIAL_CONTROL_DATA_LEN = 70
local SERIAL_CONTROL = require("MAVLink/mavlink_msg_SERIAL_CONTROL")
local msg_map = {
    [SERIAL_CONTROL.id] = "SERIAL_CONTROL",
}

function mavport:begin(_)
    local data = {}
    for i = 1, SERIAL_CONTROL_DATA_LEN do
        data[i] = 0
    end
    self._tx_template = {
        baudrate = 0,
        timeout = 0,
        device = 10, -- dev shell
        flags = 1, -- is reply
        count = 0,
        data = data,
    }

    self._tx_buf = data
    self._tx_count = 0
    self._tx_msg = nil

    self._chan = 0 -- send to channel 0 by default

    self._rx_buf = nil
    self._rx_pos = 1

    mavlink.init(4, 1) -- only one message we care about, don't need huge queue
    mavlink.register_rx_msgid(SERIAL_CONTROL.id) -- register it
end

function mavport:write(value)
    return self:writestring(string.char(value))
end

function mavport:writestring(str)
    if self._tx_msg then -- message already queued?
        self:flush()
        if self._tx_msg then return 0 end -- reject if flush failed
    end

    local count = self._tx_count
    local buf = self._tx_buf
    for ci = 1, #str do
        if count == SERIAL_CONTROL_DATA_LEN then break end
        count = count + 1
        buf[count] = str:byte(ci)
    end
    local sent = count - self._tx_count
    self._tx_count = count

    if count == SERIAL_CONTROL_DATA_LEN then
        self:flush()
    end

    return sent
end

function mavport:flush() -- send queued data if possible
    if not self._tx_msg and self._tx_count > 0 then
        -- encode the message and store it for transmission
        local msg = self._tx_template
        msg.count = self._tx_count
        _, self._tx_msg = mavlink_msgs.encode("SERIAL_CONTROL", msg)
        self._tx_count = 0
    end

    if self._tx_msg then -- message to send?
        if mavlink.send_chan(self._chan, SERIAL_CONTROL.id, self._tx_msg) then
            self._tx_msg = nil -- successfully sent
        end
    end
end

function mavport:read()
    if not self._rx_buf then
        self:_receive()
        if not self._rx_buf then return -1 end
    end

    local b = self._rx_buf
    local pos = self._rx_pos
    local c = b[pos]

    self._rx_pos = pos + 1
    if pos == #b then
        self._rx_buf = nil
    end

    return c 
end

function mavport:readstring(count)
    local avail = self:available() -- also fills rx buf
    if avail == 0 then return "" end
    if count > avail then count = avail end

    local b = self._rx_buf
    local pos = self._rx_pos
    local s = string.char(table.unpack(b, pos, pos+count-1))

    pos = pos + count
    if pos > #b then
        self._rx_buf = nil
    end
    self._rx_pos = pos

    return s
end

function mavport:_receive()
    local msg, chan
    while true do
        msg, chan = mavlink.receive_chan()
        if not msg then return end -- no new messages

        -- decode message and handle if it's for us
        msg = mavlink_msgs.decode(msg, msg_map)
        if msg.device == 10 then -- for the dev shell?
            self._chan = chan -- reply on the same channel
            break
        end
    end

    local data = msg.data
    local count = msg.count
    -- remove trailing nulls, they shouldn't happen but they do
    while data[count] == 0 do
        count = count - 1
    end

    -- store received bytes
    if count > 0 then
        if count < SERIAL_CONTROL_DATA_LEN then -- remove trailing junk
            data = table.move(data, 1, count, 1, {})
        end
        self._rx_buf = data
        self._rx_pos = 1
    end
end

function mavport:available()
    if not self._rx_buf then
        self:_receive()
        if not self._rx_buf then return 0 end
    end

    return #self._rx_buf - self._rx_pos + 1
end

-- for completeness
function mavport.set_flow_control(_, _)
end

return mavport



================================================
File: modules/vehicle_control.lua
================================================
--[[
  vehicle_control.lua: A library for advanced vehicle control in ArduPilot Lua scripting.

  This library provides high-level functions for executing complex flight patterns
  and aerobatic maneuvers. Functions are designed to be re-entrant and are managed
  by a state machine from a parent script's update() loop.
]]

local vehicle_control = {}

-- Define status constants for state machine management
vehicle_control.RUNNING = 0
vehicle_control.SUCCESS = 1

-- Define a constant for the special throttle-cut value to improve readability
vehicle_control.THROTTLE_CUT = -1

-- Enum for flip axis
vehicle_control.axis = {
  ROLL = 1,
  PITCH = 2,
}

-- Enum for vehicle modes
vehicle_control.mode = {
  LOITER = 5,
  GUIDED = 4,
  RTL = 6,
}

-- Enum for MAV_SEVERITY levels, as required by the playbook
vehicle_control.MAV_SEVERITY = {
  EMERGENCY = 0,
  ALERT = 1,
  CRITICAL = 2,
  ERROR = 3,
  WARNING = 4,
  NOTICE = 5,
  INFO = 6,
  DEBUG = 7,
}

--================================================================
-- Pattern Control
--================================================================
vehicle_control.pattern = {}

--[[
  Initializes a flight pattern by performing pre-flight checks and calculating geometry.
  @param radius_m The radius for the pattern's circular elements.
  @return A table containing start_location, center_1, and center_2, or nil and an error message.
]]
function vehicle_control.pattern.start(radius_m)
  -- Precondition checks
  if not arming:is_armed() or not vehicle:get_likely_flying() then
    return nil, "Vehicle must be armed and flying"
  end
  local current_mode = vehicle:get_mode()
  if not (current_mode == vehicle_control.mode.LOITER or current_mode == vehicle_control.mode.GUIDED) then
    return nil, "Vehicle must be in Loiter or Guided mode"
  end
  local current_loc = ahrs:get_location()
  if not current_loc then
    return nil, "Vehicle position not available"
  end

  -- Set vehicle to Guided mode for pattern execution
  if not vehicle:set_mode(vehicle_control.mode.GUIDED) then
    return nil, "Failed to set mode to Guided"
  end

  -- Calculate pattern geometry
  local start_location = current_loc:copy()
  local heading_rad = ahrs:get_yaw_rad()

  local center_1 = start_location:copy()
  center_1:offset_bearing(math.deg(heading_rad) + 90, radius_m)

  local center_2 = start_location:copy()
  center_2:offset_bearing(math.deg(heading_rad) - 90, radius_m)

  return {
    start_location = start_location,
    center_1 = center_1,
    center_2 = center_2,
  }
end

--[[
  Starts flying a circular arc.
  @return A state table for the fly_arc_update function.
]]
function vehicle_control.pattern.fly_arc_start(center_loc, start_bearing_deg, end_bearing_deg, radius_m, speed_ms, direction)
  vehicle:set_desired_speed(speed_ms)
  local total_angle_deg = (end_bearing_deg - start_bearing_deg)
  if direction > 0 and total_angle_deg < 0 then
    total_angle_deg = total_angle_deg + 360
  elseif direction < 0 and total_angle_deg > 0 then
    total_angle_deg = total_angle_deg - 360
  end

  local arc_length = math.abs(math.rad(total_angle_deg)) * radius_m
  local duration_s = arc_length / speed_ms

  return {
    start_time = millis():tofloat(),
    duration_s = duration_s,
    center_loc = center_loc,
    start_bearing_deg = start_bearing_deg,
    total_angle_deg = total_angle_deg,
    radius_m = radius_m,
  }
end

--[[
  Updates the vehicle's position along a circular arc.
  @param state The state table from fly_arc_start.
  @return RUNNING or SUCCESS.
]]
function vehicle_control.pattern.fly_arc_update(state)
  local elapsed_time = (millis():tofloat() - state.start_time) / 1000.0
  if elapsed_time >= state.duration_s then
    return vehicle_control.SUCCESS
  end

  local progress = elapsed_time / state.duration_s
  local current_bearing_deg = state.start_bearing_deg + (state.total_angle_deg * progress)
  local target_loc = state.center_loc:copy()
  target_loc:offset_bearing(current_bearing_deg, state.radius_m)

  vehicle:set_target_location(target_loc)
  return vehicle_control.RUNNING
end


--================================================================
-- Advanced Maneuvers
--================================================================
vehicle_control.maneuver = {}

-- Enum for flip maneuver stages
vehicle_control.maneuver.stage = {
  WAITING_BALLISTIC_ENTRY = 1,
  FLIPPING = 2,
  RESTORING = 3,
  DONE = 4,
}

--[[
  Starts a flip maneuver.
  @param axis The axis of rotation (vehicle_control.axis.ROLL or vehicle_control.axis.PITCH).
  @param rate_degs The initial rotation rate in degrees/second.
  @param throttle_level The throttle level (0-1), or vehicle_control.THROTTLE_CUT to cut throttle.
  @param flip_duration_s (optional) The desired total duration of the maneuver.
  @param num_flips (optional) The number of flips to perform (default 1).
  @param slew_gain (optional) The proportional gain for rate slewing (default 0.5).
  @param climb_multiplier (optional) A factor to scale the initial climb rate to counteract drag (default 1.5).
  @return A state table for the perform_flip_update function, or nil and an error message.
]]
function vehicle_control.maneuver.flip_start(axis, rate_degs, throttle_level, flip_duration_s, num_flips, slew_gain, climb_multiplier)
  -- 1. Save State & Prepare
  if not vehicle:get_mode() == vehicle_control.mode.GUIDED then
    gcs:send_text(vehicle_control.MAV_SEVERITY.WARNING, "Flip requires Guided mode")
    return nil, "Flip requires Guided mode"
  end

  -- Check for required parameters
  if type(rate_degs) ~= "number" or rate_degs == 0 then
    gcs:send_text(vehicle_control.MAV_SEVERITY.ERROR, "Flip requires a non-zero number for rate_degs")
    return nil, "Invalid rate_degs"
  end

  -- Default throttle_level to zero if not provided
  if throttle_level == nil then
    throttle_level = 0.0
  end

  num_flips = num_flips or 1
  climb_multiplier = climb_multiplier or 1.5
  local total_angle_deg = 360 * num_flips
  local t_flip = flip_duration_s or (total_angle_deg / math.abs(rate_degs))
  if t_flip <= 0 then
    gcs:send_text(vehicle_control.MAV_SEVERITY.WARNING, "Flip duration must be positive")
    return nil, "Flip duration must be positive"
  end

  -- 2. Calculate required climb rate and initiate climb
  local climb_rate_ms = 0.5 * 9.81 * t_flip
  local initial_velocity_ned = ahrs:get_velocity_NED()
  
  local vel_ned = Vector3f()
  vel_ned:x(initial_velocity_ned:x())
  vel_ned:y(initial_velocity_ned:y())
  vel_ned:z(-climb_rate_ms * climb_multiplier)
  
  if not vehicle:set_target_velocity_NED(vel_ned) then
    gcs:send_text(vehicle_control.MAV_SEVERITY.WARNING, "Failed to set target velocity for climb")
    return nil, "Failed to set climb velocity"
  end

  -- 3. Prepare for Flip
  local initial_attitude_euler = Vector3f()
  initial_attitude_euler:x(ahrs:get_roll_rad())
  initial_attitude_euler:y(ahrs:get_pitch_rad())
  initial_attitude_euler:z(ahrs:get_yaw_rad())
  
  local initial_location = ahrs:get_location()
  local initial_state = { attitude = initial_attitude_euler, velocity = initial_velocity_ned, location = initial_location }

  local throttle_cmd = (throttle_level == vehicle_control.THROTTLE_CUT) and 0.0 or throttle_level
  local initial_angle = (axis == vehicle_control.axis.ROLL) and math.deg(initial_state.attitude:x()) or math.deg(initial_state.attitude:y())

  return {
    stage = vehicle_control.maneuver.stage.WAITING_BALLISTIC_ENTRY,
    initial_state = initial_state,
    t_flip = t_flip,
    total_angle_deg = total_angle_deg,
    rate_degs = rate_degs,
    axis = axis,
    throttle_cmd = throttle_cmd,
    last_angle = initial_angle,
    accumulated_angle = 0,
    Kp = slew_gain or 0.5,
  }
end

--[[
  Updates the flip maneuver state machine.
  @param state The state table from flip_start.
  @return RUNNING or SUCCESS.
]]
function vehicle_control.maneuver.flip_update(state)
  if state.stage == vehicle_control.maneuver.stage.WAITING_BALLISTIC_ENTRY then
    local current_vel_ned = ahrs:get_velocity_NED()
    local current_loc = ahrs:get_location()
    if not (current_vel_ned and current_loc) then return vehicle_control.RUNNING end

    local vz = -current_vel_ned:z() -- upward velocity is positive
    if vz <= 0 then return vehicle_control.RUNNING end -- only proceed if we are climbing

    local alt_diff = (current_loc:alt() - state.initial_state.location:alt()) / 100.0
    
    local t_to_apex = vz / 9.81
    local h_gain = vz * t_to_apex - 0.5 * 9.81 * t_to_apex^2
    local h_apex = alt_diff + h_gain
    if h_apex < 0 then h_apex = 0 end -- prevent sqrt of negative number
    local t_fall = math.sqrt(2 * h_apex / 9.81)
    local t_hang = t_to_apex + t_fall

    if t_hang <= state.t_flip then
      state.stage = vehicle_control.maneuver.stage.FLIPPING
      state.start_time = millis():tofloat()
      
      -- Start the flip with the specified throttle
      local roll_rate_dps, pitch_rate_dps = 0, 0
      if state.axis == vehicle_control.axis.ROLL then
        roll_rate_dps = state.rate_degs
      else -- pitch
        pitch_rate_dps = state.rate_degs
      end
      vehicle:set_target_rate_and_throttle(roll_rate_dps, pitch_rate_dps, 0, state.throttle_cmd)
    end
    return vehicle_control.RUNNING

  elseif state.stage == vehicle_control.maneuver.stage.FLIPPING then
    local elapsed_time = (millis():tofloat() - state.start_time) / 1000.0
    if elapsed_time >= state.t_flip then
      state.stage = vehicle_control.maneuver.stage.RESTORING
      return vehicle_control.RUNNING
    end

    -- Unwrap angle to track total rotation
    local current_angle = (state.axis == vehicle_control.axis.ROLL) and math.deg(ahrs:get_roll_rad()) or math.deg(ahrs:get_pitch_rad())
    local delta_angle = current_angle - state.last_angle
    if delta_angle > 180 then
      delta_angle = delta_angle - 360
    elseif delta_angle < -180 then
      delta_angle = delta_angle + 360
    end
    state.accumulated_angle = state.accumulated_angle + delta_angle
    state.last_angle = current_angle

    -- Slew rate to match desired duration
    local expected_angle = (elapsed_time / state.t_flip) * state.total_angle_deg * (state.rate_degs > 0 and 1 or -1)
    local error = expected_angle - state.accumulated_angle
    local new_rate_degs = state.rate_degs + state.Kp * error

    -- Set target rates
    local roll_rate_dps, pitch_rate_dps = 0, 0
    if state.axis == vehicle_control.axis.ROLL then
      roll_rate_dps = new_rate_degs
    else -- pitch
      pitch_rate_dps = new_rate_degs
    end
    vehicle:set_target_rate_and_throttle(roll_rate_dps, pitch_rate_dps, 0, state.throttle_cmd)

    return vehicle_control.RUNNING

  elseif state.stage == vehicle_control.maneuver.stage.RESTORING then
    -- Restore the original FULL 3D velocity vector. The autopilot's controller
    -- will handle the attitude and throttle to achieve this trajectory,
    -- correcting for any accumulated position or altitude errors.
    vehicle:set_target_velocity_NED(state.initial_state.velocity)
    
    gcs:send_text(vehicle_control.MAV_SEVERITY.INFO, "Flip complete, resuming trajectory.")
    state.stage = vehicle_control.maneuver.stage.DONE
    return vehicle_control.SUCCESS
  end

  return vehicle_control.SUCCESS
end


--================================================================
-- Utility Functions
--================================================================
vehicle_control.utils = {}

--[[
  Checks if the vehicle has arrived at a target location.
  @param target_location The destination Location object.
  @param tolerance_m The arrival radius in meters.
  @return true if arrived, false otherwise.
]]
function vehicle_control.utils.has_arrived(target_location, tolerance_m)
  local current_loc = ahrs:get_location()
  if current_loc and current_loc:get_distance(target_location) < tolerance_m then
    return true
  end
  return false
end

return vehicle_control



================================================
File: modules/MAVLink/Readme.md
================================================
These .lua definition for messages can be generated using pymavlink with the following command:
(change the last path accordingly to place the files where you need them)
```
cd ardupilot/modules/mavlink
python ./pymavlink/tools/mavgen.py --lang Lua ./message_definitions/v1.0/all.xml --out ./modules/MAVLink
```

Add `--wire-protocol 2.0` to include extension fields in the generated code



================================================
File: modules/MAVLink/mavlink_msg_COMMAND_ACK.lua
================================================
local COMMAND_ACK = {}
COMMAND_ACK.id = 77
COMMAND_ACK.fields = {
             { "command", "<I2" },
             { "result", "<B" },
             { "progress", "<B" },
             { "result_param2", "<i4" },
             { "target_system", "<B" },
             { "target_component", "<B" },
             }
return COMMAND_ACK



================================================
File: modules/MAVLink/mavlink_msg_COMMAND_LONG.lua
================================================
local COMMAND_LONG = {}
COMMAND_LONG.id = 76
COMMAND_LONG.crc_extra = 152
COMMAND_LONG.fields = {
             { "param1", "<f" },
             { "param2", "<f" },
             { "param3", "<f" },
             { "param4", "<f" },
             { "param5", "<f" },
             { "param6", "<f" },
             { "param7", "<f" },
             { "command", "<I2" },
             { "target_system", "<B" },
             { "target_component", "<B" },
             { "confirmation", "<B" },
             }
return COMMAND_LONG



================================================
File: modules/MAVLink/mavlink_msg_FOLLOW_TARGET.lua
================================================
local FOLLOW_TARGET = {}
FOLLOW_TARGET.id = 144
FOLLOW_TARGET.fields = {
             { "timestamp", "<I8" },
             { "custom_state", "<I8" },
             { "lat", "<i4" },
             { "lon", "<i4" },
             { "alt", "<f" },
             { "vel", "<f", 3 },
             { "acc", "<f", 3 },
             { "attitude_q", "<f", 4 },
             { "rates", "<f", 3 },
             { "position_cov", "<f", 3 },
             { "est_capabilities", "<B" },
             }
return FOLLOW_TARGET



================================================
File: modules/MAVLink/mavlink_msg_GLOBAL_POSITION_INT.lua
================================================
local GLOBAL_POSITION_INT = {}
GLOBAL_POSITION_INT.id = 33
GLOBAL_POSITION_INT.fields = {
             { "time_boot_ms", "<I4" },
             { "lat", "<i4" },
             { "lon", "<i4" },
             { "alt", "<i4" },
             { "relative_alt", "<i4" },
             { "vx", "<i2" },
             { "vy", "<i2" },
             { "vz", "<i2" },
             { "hdg", "<I2" },
             }
return GLOBAL_POSITION_INT



================================================
File: modules/MAVLink/mavlink_msg_HEARTBEAT.lua
================================================
local HEARTBEAT = {}
HEARTBEAT.id = 0
HEARTBEAT.fields = {
             { "custom_mode", "<I4" },
             { "type", "<B" },
             { "autopilot", "<B" },
             { "base_mode", "<B" },
             { "system_status", "<B" },
             { "mavlink_version", "<B" },
             }
return HEARTBEAT



================================================
File: modules/MAVLink/mavlink_msg_SERIAL_CONTROL.lua
================================================
local SERIAL_CONTROL = {}
SERIAL_CONTROL.id = 126
SERIAL_CONTROL.fields = {
             { "baudrate", "<I4" },
             { "timeout", "<I2" },
             { "device", "<B" },
             { "flags", "<B" },
             { "count", "<B" },
             { "data", "<B", 70 },
             }
return SERIAL_CONTROL



================================================
File: modules/MAVLink/mavlink_msgs.lua
================================================
-- Auto generated MAVLink parsing script
local mavlink_msgs = {}

---Lookup the message id for a given message name
---@param msgname string
---@return integer -- message id
function mavlink_msgs.get_msgid(msgname)
  local message_map = require("MAVLink/mavlink_msg_" .. msgname)
  if not message_map then
    error("Unknown MAVLink message " .. msgname)
  end
  return message_map.id
end

---Return a object containing everything that is not the payload
---@param message any -- encoded message
---@return table
function mavlink_msgs.decode_header(message)
  -- build up a map of the result
  local result = {}

  result.checksum = string.unpack("<H", message, 1)

  -- id the MAVLink version
  local magic = string.unpack("<B", message, 3)
  if (magic == 0xFE) then -- mavlink 1
    result.protocol_version = 1
  elseif (magic == 0XFD) then --mavlink 2
    result.protocol_version = 2
  else
    error("Invalid magic byte")
  end

  -- fetch payload length
  result.payload_length = string.unpack("<B", message, 4)

  -- fetch the incompat/compat flags
  result.incompat_flags, result.compat_flags = string.unpack("<BB", message, 5)

  -- fetch seq/sysid/compid
  result.seq, result.sysid, result.compid = string.unpack("<BBB", message, 7)

  -- fetch the message id
  result.msgid = string.unpack("<I3", message, 10)

  return result
end

-- generate the x25crc for a given buffer
---@param buffer string -- buffer to crc
---@return integer -- resulting crc 0 to 0xFFFF
function mavlink_msgs.generateCRC(buffer)
  -- generate the x25crc for a given buffer.
  local crc = 0xFFFF
  for i = 1, #buffer do
      local tmp = string.byte(buffer, i, i) ~ (crc & 0xFF)
      tmp = (tmp ~ (tmp << 4)) & 0xFF
      crc = (crc >> 8) ~ (tmp << 8) ~ (tmp << 3) ~ (tmp >> 4)
      crc = crc & 0xFFFF
  end
  return crc
end

-- Note that this does not parse the serial data, it parses the MAVLink 2 C structure `mavlink_message_t`
-- This structure is passed in by the ArduPilot bindings as a string
---@param message any -- encoded message
---@param msg_map table -- table containing message objects with keys of the message ID
---@return table|nil -- a table representing the contents of the message, or nill if decode failed
function mavlink_msgs.decode(message, msg_map)
  local result = mavlink_msgs.decode_header(message)
  local message_map = require("MAVLink/mavlink_msg_" .. msg_map[result.msgid])
  if not message_map then
    -- we don't know how to decode this message, bail on it
    return nil
  end

  -- If we have a crc extra for this message then check it
  -- This ensures compatibility with message definitions generated before the crc check was added
  if message_map.crc_extra then
    -- crc of payload and header values
    local crc_buffer
    if result.protocol_version == 2 then
      crc_buffer = string.sub(message, 4, 12 + result.payload_length)

    else
      -- V1 does not include all fields on the wire
      crc_buffer = string.char(result.payload_length)
      crc_buffer = crc_buffer .. string.char(result.seq)
      crc_buffer = crc_buffer .. string.char(result.sysid)
      crc_buffer = crc_buffer .. string.char(result.compid)
      crc_buffer = crc_buffer .. string.char(result.msgid)
      if result.payload_length > 0 then
        crc_buffer = crc_buffer .. string.sub(message, 13, 12 + result.payload_length)
      end

    end

    local crc = mavlink_msgs.generateCRC(crc_buffer .. string.char(message_map.crc_extra))

    if crc ~= result.checksum then
      -- crc failed
      return nil
    end
  end

  -- map all the fields out
  local offset = 13
  for _,v in ipairs(message_map.fields) do
    if v[3] then
      result[v[1]] = {}
      for j=1,v[3] do
        result[v[1]][j], offset = string.unpack(v[2], message, offset)
      end
    else
      result[v[1]], offset = string.unpack(v[2], message, offset)
      if string.sub(v[2],2,2) == 'c' then
        -- Got string, unpack includes 0 values to the set length
        -- this is annoying, so remove them
        result[v[1]] = string.gsub(result[v[1]], string.char(0), "")
      end
    end
  end

  return result
end

---Encode the payload section of a given message
---@param msgname string -- name of message to encode
---@param message table -- table containing key value pairs representing the data fields in the message
---@return integer -- message id
---@return string -- encoded payload
function mavlink_msgs.encode(msgname, message)
  local message_map = require("MAVLink/mavlink_msg_" .. msgname)
  if not message_map then
    -- we don't know how to encode this message, bail on it
    error("Unknown MAVLink message " .. msgname)
  end

  local packString = "<"
  local packedTable = {}
  local packedIndex = 1
  for i,v in ipairs(message_map.fields) do
    if v[3] then
      packString = (packString .. string.rep(string.sub(v[2], 2), v[3]))
      for j = 1, v[3] do
        packedTable[packedIndex] = message[message_map.fields[i][1]][j]
        if packedTable[packedIndex] == nil then
          packedTable[packedIndex] = 0
        end
        packedIndex = packedIndex + 1
      end
    else
      packString = (packString .. string.sub(v[2], 2))
      packedTable[packedIndex] = message[message_map.fields[i][1]]
      packedIndex = packedIndex + 1
    end
  end
  return message_map.id, string.pack(packString, table.unpack(packedTable))
end

return mavlink_msgs



================================================
File: tests/check.json
================================================
{ // lua-language-server config for checking
    "$schema": "https://raw.githubusercontent.com/LuaLS/vscode-lua/master/setting/schema.json",
    "runtime.version": "Lua 5.3",
    "runtime.builtin": {
        // Not all of the standard functionality is available
        "coroutine": "disable",
        "os": "disable",
        "debug": "disable",
        "ffi": "disable",
        "jit": "disable",
        "table.clear": "disable",
        "table.new": "disable"
      },
    "workspace": {
      // These lua scripts are not for running on AP
      "ignoreDir": ["Tools/CHDK-Scripts/*", "modules/*", "libraries/AP_Scripting/tests/luacheck.lua", "lua-language-server/*"],
      // Dont use gitignore, it results in skipping checks for in progress scripts running in SITL
      "useGitIgnore": false
    }
}



================================================
File: tests/docs.json
================================================
{ // lua-language-server config for docs generation
    "runtime.version": "Lua 5.3",
    "runtime.builtin": {
        "basic": "disable",
        "bit": "disable",
        "bit32": "disable",
        "builtin": "disable",
        "coroutine": "disable",
        "debug": "disable",
        "ffi": "disable",
        "io": "disable",
        "jit": "disable",
        "math": "disable",
        "os": "disable",
        "package": "disable",
        "string": "disable",
        "table": "disable",
        "table.clear": "disable",
        "table.new": "disable",
        "utf8": "disable"
      }
}



================================================
File: tests/docs_check.py
================================================
#!/usr/bin/env python3

# flake8: noqa
 
'''
Reads two lua docs files and checks for differences

python ./libraries/AP_Scripting/tests/docs_check.py "./libraries/AP_Scripting/docs/docs expected.lua" "./libraries/AP_Scripting/docs/docs.lua"

AP_FLAKE8_CLEAN
'''

import optparse, sys, re

class method(object):
    def __init__(self, global_name, local_name, num_args, full_line, returns, params):
        self.global_name = global_name
        self.local_name = local_name
        self.num_args = num_args
        self.full_line = full_line
        self.returns = returns
        self.params = params
        self.manual = False
        for i in range(len(self.returns)):
            if self.returns[i][0] == 'UNKNOWN':
                self.manual  = True

        for i in range(len(self.params)):
            if self.params[i][0] == 'UNKNOWN':
                self.manual  = True

    def __str__(self):
        ret_str = "%s\n" % (self.full_line)
        if len(self.local_name):
            ret_str += "\tClass: %s\n" % (self.global_name)
            ret_str += "\tFunction: %s\n" % (self.local_name)
        else:
            ret_str += "\tGlobal: %s\n" % (self.global_name)
        ret_str +=  "\tNum Args: %s\n" % (self.num_args)

        ret_str +=  "\tParams:\n"
        for param_type in self.params:
            ret_str += "\t\t%s\n" % param_type

        ret_str +=  "\tReturns:\n"
        for return_type in self.returns:
            ret_str += "\t\t%s\n" % return_type

        ret_str +="\n"
        return ret_str

    def type_compare(self, A, B):
        if (((len(A) == 1) and (A[0] == 'UNKNOWN')) or
            ((len(B) == 1) and (B[0] == 'UNKNOWN'))):
            # UNKNOWN is a special case used for manual bindings
            return True

        if len(A) != len(B):
            return False

        for i in range(len(A)):
            if A[i] != B[i]:
                return False

        return True

    def types_compare(self, A, B):
        if len(A) != len(B):
            return False

        for i in range(len(A)):
            if not self.type_compare(A[i], B[i]):
                return False

        return True
    
    def check_types(self, other):
        if not self.types_compare(self.returns, other.returns):
            return False

        if not self.types_compare(self.params, other.params):
            return False

        return True

    def __eq__(self, other):
        return (self.global_name == other.global_name) and (self.local_name == other.local_name) and (self.num_args == other.num_args)

    def is_overload(self, other):
        # this allows multiple function definitions with different params
        white_list = [
            "Parameter" 
        ]
        allow_override = other.manual or (self.global_name in white_list)
        return allow_override and (self.global_name == other.global_name) and (self.local_name == other.local_name) and (self.num_args != other.num_args)

def get_return_type(line):
    try:
        match = re.findall(r"^---@return (\w+(\|(\w+))*)", line)
        all_types = match[0][0]
        return all_types.split("|")

    except:
        raise Exception("Could not get return type in: %s" % line)

def get_param_type(line):
    try:
        match = re.findall(r"^---@param (?:\w+\??|...) (\w+(\|(\w+))*)", line)
        all_types = match[0][0]
        return all_types.split("|")

    except:
        raise Exception("Could not get param type in: %s" % line)

def parse_file(file_name):
    methods = []
    returns = []
    params = []
    with open(file_name) as fp:
        while True:
            line = fp.readline()
            if not line:
                break

            # Acuminate return and params to associate with next function
            if line.startswith("---@return"):
                returns.append(get_return_type(line))

            if line.startswith("---@param"):
                params.append(get_param_type(line))

            # only consider functions
            if not line.startswith("function"):
                continue

            # remove any comment
            line = line.split('--', 1)[0]

            # remove any trailing whitespace
            line = line.strip()

            # remove "function"
            function_line = line.split(' ', 1)[1]

            # remove "end"
            function_line = function_line.rsplit(' ', 1)[0]

            # remove spaces
            function_line = function_line.replace(" ", "")

            # get arguments
            function_name, args = function_line.split("(",1)
            args = args[0:args.find(")")]

            if len(args) == 0:
                num_args = 0
            else:
                num_args = args.count(",") + 1

            if num_args != len(params):
                raise Exception("Missing \"---@param\" for function: %s", line)

            # get global/class name and function name
            local_name = ""
            if function_name.count(":") == 1:
                global_name, local_name = function_name.split(":",1)
            else:
                global_name = function_name

            methods.append(method(global_name, local_name, num_args, line, returns, params))
            returns = []
            params = []

    return methods

def compare(expected_file_name, got_file_name):

    # parse in methods
    expected_methods = parse_file(expected_file_name)
    got_methods = parse_file(got_file_name)

    pass_check = True

    # make sure each expected method is included once
    for meth in expected_methods:
        found = False
        for got in got_methods:
            if got == meth:
                if found:
                    print("Multiple definitions of:")
                    print(meth)
                    pass_check = False

                elif not meth.check_types(got):
                    print("Type error:")
                    print("Want:")
                    print(meth)
                    print("Got:")
                    print(got)
                    pass_check = False

                found = True

        if not found:
            print("Missing definition of:")
            print(meth)
            pass_check = False


    # White list of classes that are allowed unexpected definitions
    white_list = [
        # "virtual" class to bypass need for nil check when getting a parameter value, Parameter_ud is used internally, Parameter_ud_const exists only in the docs.
        "Parameter_ud_const"
    ]

    # make sure no unexpected methods are included
    for got in got_methods:
        if got.global_name in white_list:
            # Dont check if in the white list
            continue

        found = False
        for meth in expected_methods:
            if (got == meth) or got.is_overload(meth):
                found = True
                break
        if not found:
            print("Unexpected definition of:")
            print(got)
            pass_check = False

    if not pass_check:
        raise Exception("Docs do not match")
    else:
        print("Docs check passed")

if __name__ == '__main__':

    parser = optparse.OptionParser(__file__)

    opts, args = parser.parse_args()

    if len(args) != 2:
        print('Usage: %s "expected docs path" "current docs path"' % parser.usage)
        sys.exit(0)

    compare(args[0], args[1])





================================================
File: tests/luacheck.lua
================================================

-- https://luacheck.readthedocs.io/en/stable/warnings.html
ignore = {"111", -- Setting an undefined global variable.
          "113", -- Accessing an undefined global variable.
          "631", -- Line is too long.
          "611", -- A line consists of nothing but whitespace.
          "612", -- A line contains trailing whitespace.
          "614"} -- Trailing whitespace in a comment.

-- These lua scripts are not for running on AP
exclude_files = {"Tools/CHDK-Scripts/*", "modules/*", "libraries/AP_Scripting/tests/luacheck.lua", "lua-language-server/*"}

-- Grab AP globals from docs file
stds.ArduPilot = {}
stds.ArduPilot.read_globals = {}

local env = setmetatable({}, {__index = _G})
assert(pcall(setfenv(assert(loadfile("libraries/AP_Scripting/docs/docs.lua")), env)))

for key, value in pairs(env) do
    local singleton = { other_fields = false }

    -- add sub-functions
    if type(value) == 'table' then
        singleton['fields'] = {}
        for s_key, _ in pairs(value) do
            singleton['fields'][s_key] = { other_fields = false }
        end
    end

    stds.ArduPilot.read_globals[key] = singleton
end

-- We cannot add enums to the docs without giving a value, we don't know the value until compile time
-- There are only a few, so I have added them manually here.
local function add_enum(singleton, enum)
    stds.ArduPilot.read_globals[singleton].fields[enum] = { other_fields = false }
end

add_enum('mission', 'MISSION_COMPLETE')
add_enum('mission', 'MISSION_RUNNING')
add_enum('mission', 'MISSION_STOPPED')

add_enum('terrain', 'TerrainStatusOK')
add_enum('terrain', 'TerrainStatusUnhealthy')
add_enum('terrain', 'TerrainStatusDisabled')

add_enum('gps', 'GPS_OK_FIX_3D_RTK_FIXED')
add_enum('gps', 'GPS_OK_FIX_3D_RTK_FLOAT')
add_enum('gps', 'GPS_OK_FIX_3D_DGPS')
add_enum('gps', 'GPS_OK_FIX_3D')
add_enum('gps', 'GPS_OK_FIX_2D')
add_enum('gps', 'NO_FIX')
add_enum('gps', 'NO_GPS')

std = "lua53+ArduPilot"




================================================
File: tests/math.lua
================================================
-- $Id: math.lua,v 1.77 2016/06/23 15:17:20 roberto Exp roberto $

--[[
*****************************************************************************
* Copyright (C) 1994-2016 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*****************************************************************************
]]

-- This code is copied from https://github.com/lua/tests and slightly modified to work within ArduPilot

-- luacheck: ignore 211 (Unused local variable)
-- luacheck: ignore 213 (Unused loop variable)
-- luacheck: ignore 411 (Redefining a local variable)
-- luacheck: ignore 421 (Shadowing a local variable)
-- luacheck: ignore 581 (Negation of a relational operator - operator can be flipped)

---@diagnostic disable: cast-local-type
---@diagnostic disable: undefined-global

gcs:send_text(6, "testing numbers and math lib")

local minint = math.mininteger
local maxint = math.maxinteger

local intbits = math.floor(math.log(maxint, 2) + 0.5) + 1
assert((1 << intbits) == 0)

assert(minint == 1 << (intbits - 1))
assert(maxint == minint - 1)

-- number of bits in the mantissa of a floating-point number
local floatbits = 24
do
  local p = 2.0^floatbits
  while p < p + 1.0 do
    p = p * 2.0
    floatbits = floatbits + 1
  end
end

local function isNaN (x)
  return (x ~= x)
end

assert(isNaN(0/0))
assert(not isNaN(1/0))


do
  local x = 2.0^floatbits
  assert(x > x - 1.0 and x == x + 1.0)

  gcs:send_text(6, string.format("%d-bit integers, %d-bit (mantissa) floats",
                       intbits, floatbits))
end

assert(math.type(0) == "integer" and math.type(0.0) == "float"
       and math.type("10") == nil)


local function checkerror (msg, f, ...)
  local s, err = pcall(f, ...)
  assert(not s and string.find(err, msg))
end

local msgf2i = "number.* has no integer representation"

-- float equality
function eq (a,b,limit)
  if not limit then
    if floatbits >= 50 then limit = 1E-11
    else limit = 1E-5
    end
  end
  -- a == b needed for +inf/-inf
  return a == b or math.abs(a-b) <= limit
end


-- equality with types
function eqT (a,b)
  return a == b and math.type(a) == math.type(b)
end


-- basic float notation
assert(0e12 == 0 and .0 == 0 and 0. == 0 and .2e2 == 20 and 2.E-1 == 0.2)

do
  local a,b,c = "2", " 3e0 ", " 10  "
  assert(a+b == 5 and -b == -3 and b+"2" == 5 and "10"-c == 0)
  assert(type(a) == 'string' and type(b) == 'string' and type(c) == 'string')
  assert(a == "2" and b == " 3e0 " and c == " 10  " and -c == -"  10 ")
  assert(c%a == 0 and a^b == 08)
  a = 0
  assert(a == -a and 0 == -0)
end

do
  local x = -1
  local mz = 0/x   -- minus zero
  t = {[0] = 10, 20, 30, 40, 50}
  assert(t[mz] == t[0] and t[-0] == t[0])
end

do   -- tests for 'modf'
  local a,b = math.modf(3.5)
  assert(a == 3.0 and b == 0.5)
  a,b = math.modf(-2.5)
  assert(a == -2.0 and b == -0.5)
  a,b = math.modf(-3e23)
  assert(a == -3e23 and b == 0.0)
  a,b = math.modf(3e35)
  assert(a == 3e35 and b == 0.0)
  a,b = math.modf(-1/0)   -- -inf
  assert(a == -1/0 and b == 0.0)
  a,b = math.modf(1/0)   -- inf
  assert(a == 1/0 and b == 0.0)
  a,b = math.modf(0/0)   -- NaN
  assert(isNaN(a) and isNaN(b))
  a,b = math.modf(3)  -- integer argument
  assert(eqT(a, 3) and eqT(b, 0.0))
  a,b = math.modf(minint)
  assert(eqT(a, minint) and eqT(b, 0.0))
end

assert(math.huge > 10e30)
assert(-math.huge < -10e30)


-- integer arithmetic
assert(minint < minint + 1)
assert(maxint - 1 < maxint)
assert(0 - minint == minint)
assert(minint * minint == 0)
assert(maxint * maxint * maxint == maxint)


-- testing floor division and conversions

for _, i in pairs{-16, -15, -3, -2, -1, 0, 1, 2, 3, 15} do
  for _, j in pairs{-16, -15, -3, -2, -1, 1, 2, 3, 15} do
    for _, ti in pairs{0, 0.0} do     -- try 'i' as integer and as float
      for _, tj in pairs{0, 0.0} do   -- try 'j' as integer and as float
        local x = i + ti
        local y = j + tj
          assert(i//j == math.floor(i/j))
      end
    end
  end
end

assert(1//0.0 == 1/0)
assert(-1 // 0.0 == -1/0)
assert(eqT(3.5 // 1.5, 2.0))
assert(eqT(3.5 // -1.5, -3.0))

assert(maxint // maxint == 1)
assert(maxint // 1 == maxint)
assert((maxint - 1) // maxint == 0)
assert(maxint // (maxint - 1) == 1)
assert(minint // minint == 1)
assert(minint // minint == 1)
assert((minint + 1) // minint == 0)
assert(minint // (minint + 1) == 1)
assert(minint // 1 == minint)

assert(minint // -1 == -minint)
assert(minint // -2 == 2^(intbits - 2))
assert(maxint // -1 == -maxint)


-- negative exponents
do
  assert(2^-3 == 1 / 2^3)
  assert(eq((-3)^-3, 1 / (-3)^3))
  for i = -3, 3 do    -- variables avoid constant folding
      for j = -3, 3 do
        -- domain errors (0^(-n)) are not portable
        if not _port or i ~= 0 or j > 0 then
          assert(eq(i^j, 1 / i^(-j)))
       end
    end
  end
end

-- comparison between floats and integers (border cases)
if floatbits < intbits then
  assert(2.0^floatbits == (1 << floatbits))
  assert(2.0^floatbits - 1.0 == (1 << floatbits) - 1.0)
  assert(2.0^floatbits - 1.0 ~= (1 << floatbits))
  -- float is rounded, int is not
  assert(2.0^floatbits + 1.0 ~= (1 << floatbits) + 1)
else   -- floats can express all integers with full accuracy
  assert(maxint == maxint + 0.0)
  assert(maxint - 1 == maxint - 1.0)
  assert(minint + 1 == minint + 1.0)
  assert(maxint ~= maxint - 1.0)
end
assert(maxint + 0.0 == 2.0^(intbits - 1) - 1.0)
assert(minint + 0.0 == minint)
assert(minint + 0.0 == -2.0^(intbits - 1))


-- order between floats and integers
assert(1 < 1.1); assert(not (1 < 0.9))
assert(1 <= 1.1); assert(not (1 <= 0.9))
assert(-1 < -0.9); assert(not (-1 < -1.1))
assert(1 <= 1.1); assert(not (-1 <= -1.1))
assert(-1 < -0.9); assert(not (-1 < -1.1))
assert(-1 <= -0.9); assert(not (-1 <= -1.1))
assert(minint <= minint + 0.0)
assert(minint + 0.0 <= minint)
assert(not (minint < minint + 0.0))
assert(not (minint + 0.0 < minint))
assert(maxint < minint * -1.0)
assert(maxint <= minint * -1.0)

do
  local fmaxi1 = 2^(intbits - 1)
  assert(maxint < fmaxi1)
  assert(maxint <= fmaxi1)
  assert(not (fmaxi1 <= maxint))
  assert(minint <= -2^(intbits - 1))
  assert(-2^(intbits - 1) <= minint)
end

if floatbits < intbits then
  gcs:send_text(6, "testing order (floats can't represent all int)")
  local fmax = 2^floatbits
  local ifmax = fmax | 0
  assert(fmax < ifmax + 1)
  assert(fmax - 1 < ifmax)
  assert(-(fmax - 1) > -ifmax)
  assert(not (fmax <= ifmax - 1))
  assert(-fmax > -(ifmax + 1))
  assert(not (-fmax >= -(ifmax - 1)))

  assert(fmax/2 - 0.5 < ifmax//2)
  assert(-(fmax/2 - 0.5) > -ifmax//2)

  assert(maxint < 2^intbits)
  assert(minint > -2^intbits)
  assert(maxint <= 2^intbits)
  assert(minint >= -2^intbits)
else
  gcs:send_text(6, "testing order (floats can represent all ints)")
  assert(maxint < maxint + 1.0)
  assert(maxint < maxint + 0.5)
  assert(maxint - 1.0 < maxint)
  assert(maxint - 0.5 < maxint)
  assert(not (maxint + 0.0 < maxint))
  assert(maxint + 0.0 <= maxint)
  assert(not (maxint < maxint + 0.0))
  assert(maxint + 0.0 <= maxint)
  assert(maxint <= maxint + 0.0)
  assert(not (maxint + 1.0 <= maxint))
  assert(not (maxint + 0.5 <= maxint))
  assert(not (maxint <= maxint - 1.0))
  assert(not (maxint <= maxint - 0.5))

  assert(minint < minint + 1.0)
  assert(minint < minint + 0.5)
  assert(minint <= minint + 0.5)
  assert(minint - 1.0 < minint)
  assert(minint - 1.0 <= minint)
  assert(not (minint + 0.0 < minint))
  assert(not (minint + 0.5 < minint))
  assert(not (minint < minint + 0.0))
  assert(minint + 0.0 <= minint)
  assert(minint <= minint + 0.0)
  assert(not (minint + 1.0 <= minint))
  assert(not (minint + 0.5 <= minint))
  assert(not (minint <= minint - 1.0))
end

do
  local NaN = 0/0
  assert(not (NaN < 0))
  assert(not (NaN > minint))
  assert(not (NaN <= -9))
  assert(not (NaN <= maxint))
  assert(not (NaN < maxint))
  assert(not (minint <= NaN))
  assert(not (minint < NaN))
end


-- avoiding errors at compile time
--local function checkcompt (msg, code)
--  checkerror(msg, assert(load(code)))
--end
--checkcompt("divide by zero", "return 2 // 0")
--checkcompt(msgf2i, "return 2.3 >> 0")
--checkcompt(msgf2i, ("return 2.0^%d & 1"):format(intbits - 1))
--checkcompt("field 'huge'", "return math.huge << 1")
--checkcompt(msgf2i, ("return 1 | 2.0^%d"):format(intbits - 1))
--checkcompt(msgf2i, "return 2.3 ~ '0.0'")


-- testing overflow errors when converting from float to integer (runtime)
local function f2i (x) return x | x end
checkerror(msgf2i, f2i, math.huge)     -- +inf
checkerror(msgf2i, f2i, -math.huge)    -- -inf
checkerror(msgf2i, f2i, 0/0)           -- NaN

if floatbits < intbits then
  -- conversion tests when float cannot represent all integers
  assert(maxint + 1.0 == maxint + 0.0)
  assert(minint - 1.0 == minint + 0.0)
  checkerror(msgf2i, f2i, maxint + 0.0)
  assert(f2i(2.0^(intbits - 2)) == 1 << (intbits - 2))
  assert(f2i(-2.0^(intbits - 2)) == -(1 << (intbits - 2)))
  assert((2.0^(floatbits - 1) + 1.0) // 1 == (1 << (floatbits - 1)) + 1)
  -- maximum integer representable as a float
  local mf = maxint - (1 << (floatbits - intbits)) + 1
  assert(f2i(mf + 0.0) == mf)  -- OK up to here
  mf = mf + 1
  assert(f2i(mf + 0.0) ~= mf)   -- no more representable
else
  -- conversion tests when float can represent all integers
  assert(maxint + 1.0 > maxint)
  assert(minint - 1.0 < minint)
  assert(f2i(maxint + 0.0) == maxint)
  checkerror("no integer rep", f2i, maxint + 1.0)
  checkerror("no integer rep", f2i, minint - 1.0)
end

-- 'minint' should be representable as a float no matter the precision
assert(f2i(minint + 0.0) == minint)


-- testing numeric strings

assert("2" + 1 == 3)
assert("2 " + 1 == 3)
assert(" -2 " + 1 == -1)
assert(" -0xa " + 1 == -9)


-- Literal integer Overflows (new behavior in 5.3.3)
do
  -- no overflows
  assert(eqT(tonumber(tostring(maxint)), maxint))
  assert(eqT(tonumber(tostring(minint)), minint))

  -- add 1 to last digit as a string (it cannot be 9...)
  local function incd (n)
    local s = string.format("%d", n)
    s = string.gsub(s, "%d$", function (d)
          assert(d ~= '9')
          return string.char(string.byte(d) + 1)
        end)
    return s
  end

  -- 'tonumber' with overflow by 1
  assert(eqT(tonumber(incd(maxint)), maxint + 1.0))
  assert(eqT(tonumber(incd(minint)), minint - 1.0))

  -- large numbers
  assert(eqT(tonumber("1"..string.rep("0", 30)), 1e30))
  assert(eqT(tonumber("-1"..string.rep("0", 30)), -1e30))

  -- hexa format still wraps around
  assert(eqT(tonumber("0x1"..string.rep("0", 30)), 0))

  -- lexer in the limits
  --assert(minint == load("return " .. minint)())
  --assert(eqT(maxint, load("return " .. maxint)()))

  assert(eqT(10000000000000000000000.0, 10000000000000000000000))
  assert(eqT(-10000000000000000000000.0, -10000000000000000000000))
end


-- testing 'tonumber'

-- 'tonumber' with numbers
assert(tonumber(3.4) == 3.4)
assert(eqT(tonumber(3), 3))
assert(eqT(tonumber(maxint), maxint) and eqT(tonumber(minint), minint))
assert(tonumber(1/0) == 1/0)

-- 'tonumber' with strings
assert(tonumber("0") == 0)
assert(tonumber("") == nil)
assert(tonumber("  ") == nil)
assert(tonumber("-") == nil)
assert(tonumber("  -0x ") == nil)
assert(tonumber{} == nil)
assert(tonumber'+0.01' == 1/100 and tonumber'+.01' == 0.01 and
       tonumber'.01' == 0.01    and tonumber'-1.' == -1 and
       tonumber'+1.' == 1)
assert(tonumber'+ 0.01' == nil and tonumber'+.e1' == nil and
       tonumber'1e' == nil     and tonumber'1.0e+' == nil and
       tonumber'.' == nil)
assert(tonumber('-012') == -010-2)
assert(tonumber('-1.2e2') == - - -120)

assert(tonumber("0xffffffffffff") == (1 << (4*12)) - 1)
assert(tonumber("0x"..string.rep("f", (intbits//4))) == -1)
assert(tonumber("-0x"..string.rep("f", (intbits//4))) == 1)

-- testing 'tonumber' with base
assert(tonumber('  001010  ', 2) == 10)
assert(tonumber('  001010  ', 10) == 001010)
assert(tonumber('  -1010  ', 2) == -10)
assert(tonumber('10', 36) == 36)
assert(tonumber('  -10  ', 36) == -36)
assert(tonumber('  +1Z  ', 36) == 36 + 35)
assert(tonumber('  -1z  ', 36) == -36 + -35)
assert(tonumber('-fFfa', 16) == -(10+(16*(15+(16*(15+(16*15)))))))
assert(tonumber(string.rep('1', (intbits - 2)), 2) + 1 == 2^(intbits - 2))
assert(tonumber('ffffFFFF', 16)+1 == (1 << 32))
assert(tonumber('0ffffFFFF', 16)+1 == (1 << 32))
assert(tonumber('-0ffffffFFFF', 16) - 1 == -(1 << 40))
for i = 2,36 do
  local i2 = i * i
  local i10 = i2 * i2 * i2 * i2 * i2      -- i^10
  assert(tonumber('\t10000000000\t', i) == i10)
end

if not _soft then
  -- tests with very long numerals
  assert(tonumber("0x"..string.rep("f", 13)..".0") == 2.0^(4*13) - 1)
  assert(tonumber("0x"..string.rep("f", 150)..".0") == 2.0^(4*150) - 1)
  assert(tonumber("0x"..string.rep("f", 300)..".0") == 2.0^(4*300) - 1)
  assert(tonumber("0x"..string.rep("f", 500)..".0") == 2.0^(4*500) - 1)
  assert(tonumber('0x3.' .. string.rep('0', 1000)) == 3)
  assert(tonumber('0x' .. string.rep('0', 1000) .. 'a') == 10)
  assert(tonumber('0x0.' .. string.rep('0', 13).."1") == 2.0^(-4*14))
  assert(tonumber('0x0.' .. string.rep('0', 150).."1") == 2.0^(-4*151))
  assert(tonumber('0x0.' .. string.rep('0', 300).."1") == 2.0^(-4*301))
  assert(tonumber('0x0.' .. string.rep('0', 500).."1") == 2.0^(-4*501))

  assert(tonumber('0xe03' .. string.rep('0', 1000) .. 'p-4000') == 3587.0)
  assert(tonumber('0x.' .. string.rep('0', 1000) .. '74p4004') == 0x7.4)
end

-- testing 'tonumber' for invalid formats
--[[
local function f (...)
  if select('#', ...) == 1 then
    return (...)
  else
    return "***"
  end
end

assert(f(tonumber('fFfa', 15)) == nil)
assert(f(tonumber('099', 8)) == nil)
assert(f(tonumber('1\0', 2)) == nil)
assert(f(tonumber('', 8)) == nil)
assert(f(tonumber('  ', 9)) == nil)
assert(f(tonumber('  ', 9)) == nil)
assert(f(tonumber('0xf', 10)) == nil)

assert(f(tonumber('inf')) == nil)
assert(f(tonumber(' INF ')) == nil)
assert(f(tonumber('Nan')) == nil)
assert(f(tonumber('nan')) == nil)

assert(f(tonumber('  ')) == nil)
assert(f(tonumber('')) == nil)
assert(f(tonumber('1  a')) == nil)
assert(f(tonumber('1  a', 2)) == nil)
assert(f(tonumber('1\0')) == nil)
assert(f(tonumber('1 \0')) == nil)
assert(f(tonumber('1\0 ')) == nil)
assert(f(tonumber('e1')) == nil)
assert(f(tonumber('e  1')) == nil)
assert(f(tonumber(' 3.4.5 ')) == nil)
]]

-- testing 'tonumber' for invalid hexadecimal formats

assert(tonumber('0x') == nil)
assert(tonumber('x') == nil)
assert(tonumber('x3') == nil)
assert(tonumber('0x3.3.3') == nil)   -- two decimal points
assert(tonumber('00x2') == nil)
assert(tonumber('0x 2') == nil)
assert(tonumber('0 x2') == nil)
assert(tonumber('23x') == nil)
assert(tonumber('- 0xaa') == nil)
assert(tonumber('-0xaaP ') == nil)   -- no exponent
assert(tonumber('0x0.51p') == nil)
assert(tonumber('0x5p+-2') == nil)


-- testing hexadecimal numerals

assert(0x10 == 16 and 0xfff == 2^12 - 1 and 0XFB == 251)
assert(0x0p12 == 0 and 0x.0p-3 == 0)
assert(0xFFFFFFFF == (1 << 32) - 1)
assert(tonumber('+0x2') == 2)
assert(tonumber('-0xaA') == -170)
assert(tonumber('-0xffFFFfff') == -(1 << 32) + 1)

-- possible confusion with decimal exponent
assert(0E+1 == 0 and 0xE+1 == 15 and 0xe-1 == 13)


-- floating hexas

assert(tonumber('  0x2.5  ') == 0x25/16)
assert(tonumber('  -0x2.5  ') == -0x25/16)
assert(tonumber('  +0x0.51p+8  ') == 0x51)
assert(0x.FfffFFFF == 1 - '0x.00000001')
assert('0xA.a' + 0 == 10 + 10/16)
assert(0xa.aP4 == 0XAA)
assert(0x4P-2 == 1)
assert(0x1.1 == '0x1.' + '+0x.1')
assert(0Xabcdef.0 == 0x.ABCDEFp+24)


assert(1.1 == 1.+.1)
assert(100.0 == 1E2 and .01 == 1e-2)
assert(1111111111 - 1111111110 == 1000.00e-03)
assert(1.1 == '1.'+'.1')
assert(tonumber'1111111111' - tonumber'1111111110' ==
       tonumber"  +0.001e+3 \n\t")

assert(0.1e-30 > 0.9E-31 and 0.9E30 < 0.1e31)

assert(0.123456 > 0.123455)

assert(tonumber('+1.23E18') == 1.23*10.0^18)

-- testing order operators
assert(not(1<1) and (1<2) and not(2<1))
assert(not('a'<'a') and ('a'<'b') and not('b'<'a'))
assert((1<=1) and (1<=2) and not(2<=1))
assert(('a'<='a') and ('a'<='b') and not('b'<='a'))
assert(not(1>1) and not(1>2) and (2>1))
assert(not('a'>'a') and not('a'>'b') and ('b'>'a'))
assert((1>=1) and not(1>=2) and (2>=1))
assert(('a'>='a') and not('a'>='b') and ('b'>='a'))
assert(1.3 < 1.4 and 1.3 <= 1.4 and not (1.3 < 1.3) and 1.3 <= 1.3)

-- testing mod operator
assert(eqT(-4 % 3, 2))
assert(eqT(4 % -3, -2))
assert(eqT(-4.0 % 3, 2.0))
assert(eqT(4 % -3.0, -2.0))
assert(math.pi - math.pi % 1 == 3)
assert(math.pi - math.pi % 0.001 == 3.141)

assert(eqT(minint % minint, 0))
assert(eqT(maxint % maxint, 0))
assert((minint + 1) % minint == minint + 1)
assert((maxint - 1) % maxint == maxint - 1)
assert(minint % maxint == maxint - 1)

assert(minint % -1 == 0)
assert(minint % -2 == 0)
assert(maxint % -2 == -1)

-- testing unsigned comparisons
assert(math.ult(3, 4))
assert(not math.ult(4, 4))
assert(math.ult(-2, -1))
assert(math.ult(2, -1))
assert(not math.ult(-2, -2))
assert(math.ult(maxint, minint))
assert(not math.ult(minint, maxint))


assert(eq(math.sin(-9.8)^2 + math.cos(-9.8)^2, 1))
assert(eq(math.tan(math.pi/4), 1))
assert(eq(math.sin(math.pi/2), 1) and eq(math.cos(math.pi/2), 0))
assert(eq(math.atan(1), math.pi/4) and eq(math.acos(0), math.pi/2) and
       eq(math.asin(1), math.pi/2))
assert(eq(math.deg(math.pi/2), 90) and eq(math.rad(90), math.pi/2))
assert(math.abs(-10.43) == 10.43)
assert(eqT(math.abs(minint), minint))
assert(eqT(math.abs(maxint), maxint))
assert(eqT(math.abs(-maxint), maxint))
assert(eq(math.atan(1,0), math.pi/2))
assert(math.fmod(10,3) == 1)
assert(eq(math.sqrt(10)^2, 10))
assert(eq(math.log(2, 10), math.log(2)/math.log(10)))
assert(eq(math.log(2, 2), 1))
assert(eq(math.log(9, 3), 2))
assert(eq(math.exp(0), 1))
assert(eq(math.sin(10), math.sin(10%(2*math.pi))))


assert(tonumber(' 1.3e-2 ') == 1.3e-2)
assert(tonumber(' -1.00000000000001 ') == -1.00000000000001)

-- testing constant limits
-- 2^23 = 8388608
assert(8388609 + -8388609 == 0)
assert(8388608 + -8388608 == 0)
assert(8388607 + -8388607 == 0)



do   -- testing floor & ceil
  assert(eqT(math.floor(3.4), 3))
  assert(eqT(math.ceil(3.4), 4))
  assert(eqT(math.floor(-3.4), -4))
  assert(eqT(math.ceil(-3.4), -3))
  assert(eqT(math.floor(maxint), maxint))
  assert(eqT(math.ceil(maxint), maxint))
  assert(eqT(math.floor(minint), minint))
  assert(eqT(math.floor(minint + 0.0), minint))
  assert(eqT(math.ceil(minint), minint))
  assert(eqT(math.ceil(minint + 0.0), minint))
  assert(math.floor(1e50) == 1e50)
  assert(math.ceil(1e50) == 1e50)
  assert(math.floor(-1e50) == -1e50)
  assert(math.ceil(-1e50) == -1e50)
  for _, p in pairs{31,32,63,64} do
    assert(math.floor(2^p) == 2^p)
    assert(math.floor(2^p + 0.5) == 2^p)
    assert(math.ceil(2^p) == 2^p)
    assert(math.ceil(2^p - 0.5) == 2^p)
  end
  checkerror("number expected", math.floor, {})
  checkerror("number expected", math.ceil, print)
  assert(eqT(math.tointeger(minint), minint))
  assert(eqT(math.tointeger(minint .. ""), minint))
  assert(eqT(math.tointeger(maxint), maxint))
  assert(eqT(math.tointeger(maxint .. ""), maxint))
  assert(eqT(math.tointeger(minint + 0.0), minint))
  assert(math.tointeger(0.0 - minint) == nil)
  assert(math.tointeger(math.pi) == nil)
  assert(math.tointeger(-math.pi) == nil)
  assert(math.floor(math.huge) == math.huge)
  assert(math.ceil(math.huge) == math.huge)
  assert(math.tointeger(math.huge) == nil)
  assert(math.floor(-math.huge) == -math.huge)
  assert(math.ceil(-math.huge) == -math.huge)
  assert(math.tointeger(-math.huge) == nil)
  assert(math.tointeger("34.0") == 34)
  assert(math.tointeger("34.3") == nil)
  assert(math.tointeger({}) == nil)
  assert(math.tointeger(0/0) == nil)    -- NaN
end


-- testing fmod for integers
for i = -6, 6 do
  for j = -6, 6 do
    if j ~= 0 then
      local mi = math.fmod(i, j)
      local mf = math.fmod(i + 0.0, j)
      assert(mi == mf)
      assert(math.type(mi) == 'integer' and math.type(mf) == 'float')
      if (i >= 0 and j >= 0) or (i <= 0 and j <= 0) or mi == 0 then
        assert(eqT(mi, i % j))
      end
    end
  end
end
assert(eqT(math.fmod(minint, minint), 0))
assert(eqT(math.fmod(maxint, maxint), 0))
assert(eqT(math.fmod(minint + 1, minint), minint + 1))
assert(eqT(math.fmod(maxint - 1, maxint), maxint - 1))

checkerror("zero", math.fmod, 3, 0)


do    -- testing max/min
  checkerror("value expected", math.max)
  checkerror("value expected", math.min)
  assert(eqT(math.max(3), 3))
  assert(eqT(math.max(3, 5, 9, 1), 9))
  assert(math.max(maxint, 10e60) == 10e60)
  assert(eqT(math.max(minint, minint + 1), minint + 1))
  assert(eqT(math.min(3), 3))
  assert(eqT(math.min(3, 5, 9, 1), 1))
  assert(math.min(3.2, 5.9, -9.2, 1.1) == -9.2)
  assert(math.min(1.9, 1.7, 1.72) == 1.7)
  assert(math.min(-10e60, minint) == -10e60)
  assert(eqT(math.min(maxint, maxint - 1), maxint - 1))
  assert(eqT(math.min(maxint - 2, maxint, maxint - 1), maxint - 2))
end
-- testing implicit convertions

local a,b = '10', '20'
assert(a*b == 200 and a+b == 30 and a-b == -10 and a/b == 0.5 and -b == -20)
assert(a == '10' and b == '20')


do
  gcs:send_text(6, "testing -0 and NaN")
  local mz, z = -0.0, 0.0
  assert(mz == z)
  assert(1/mz < 0 and 0 < 1/z)
  local a = {[mz] = 1}
  assert(a[z] == 1 and a[mz] == 1)
  a[z] = 2
  assert(a[z] == 2 and a[mz] == 2)
  local inf = math.huge * 2 + 1
  mz, z = -1/inf, 1/inf
  assert(mz == z)
  assert(1/mz < 0 and 0 < 1/z)
  local NaN = inf - inf
  assert(NaN ~= NaN)
  assert(not (NaN < NaN))
  assert(not (NaN <= NaN))
  assert(not (NaN > NaN))
  assert(not (NaN >= NaN))
  assert(not (0 < NaN) and not (NaN < 0))
  local NaN1 = 0/0
  assert(NaN ~= NaN1 and not (NaN <= NaN1) and not (NaN1 <= NaN))
  local a = {}
  assert(not pcall(rawset, a, NaN, 1))
  assert(a[NaN] == nil)
  a[1] = 1
  assert(not pcall(rawset, a, NaN, 1))
  assert(a[NaN] == nil)
  -- strings with same binary representation as 0.0 (might create problems
  -- for constant manipulation in the pre-compiler)
  local a1, a2, a3, a4, a5 = 0, 0, "\0\0\0\0\0\0\0\0", 0, "\0\0\0\0\0\0\0\0"
  assert(a1 == a2 and a2 == a4 and a1 ~= a3)
  assert(a3 == a5)
end


gcs:send_text(6, "testing 'math.random'")
math.randomseed(0)

do   -- test random for floats
  local max = -math.huge
  local min = math.huge
  for i = 0, 20000 do
    local t = math.random()
    assert(0 <= t and t < 1)
    max = math.max(max, t)
    min = math.min(min, t)
    if eq(max, 1, 0.001) and eq(min, 0, 0.001) then
      goto ok
    end
  end
  -- loop ended without satisfing condition
  assert(false)
 ::ok::
end

do
  local function aux (p, lim)   -- test random for small intervals
    local x1, x2
    if #p == 1 then x1 = 1; x2 = p[1]
    else x1 = p[1]; x2 = p[2]
    end
    local mark = {}; local count = 0   -- to check that all values appeared
    for i = 0, lim or 2000 do
      local t = math.random(table.unpack(p))
      assert(x1 <= t and t <= x2)
      if not mark[t] then  -- new value
        mark[t] = true
        count = count + 1
      end
      if count == x2 - x1 + 1 then   -- all values appeared; OK
        goto ok
      end
    end
    -- loop ended without satisfing condition
    assert(false)
   ::ok::
  end

  aux({-10,0})
  aux({6})
  aux({-10, 10})
  aux({minint, minint})
  aux({maxint, maxint})
  aux({minint, minint + 9})
  aux({maxint - 3, maxint})
end

do
  local function aux(p1, p2)       -- test random for large intervals
    local max = minint
    local min = maxint
    local n = 200
    local mark = {}; local count = 0   -- to count how many different values
    for _ = 1, n do
      local t = math.random(p1, p2)
      max = math.max(max, t)
      min = math.min(min, t)
      if not mark[t] then  -- new value
        mark[t] = true
        count = count + 1
      end
    end
    -- at least 80% of values are different
    assert(count >= n * 0.8)
    -- min and max not too far from formal min and max
    local diff = (p2 - p1) // 8
    assert(min < p1 + diff and max > p2 - diff)
  end
  aux(0, maxint)
  aux(1, maxint)
  aux(minint, -1)
  aux(minint // 2, maxint // 2)
end

for i=1,100 do
  assert(math.random(maxint) > 0)
  assert(math.random(minint, -1) < 0)
end

assert(not pcall(math.random, 1, 2, 3))    -- too many arguments

-- empty interval
assert(not pcall(math.random, minint + 1, minint))
assert(not pcall(math.random, maxint, maxint - 1))
assert(not pcall(math.random, maxint, minint))

-- interval too large
assert(not pcall(math.random, minint, 0))
assert(not pcall(math.random, -1, maxint))
assert(not pcall(math.random, minint // 2, maxint // 2 + 1))

function update()
  gcs:send_text(6, 'Math tests passed')
  return update, 1000
end

return update()



================================================
File: tests/mavlink_test.lua
================================================
---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter

local mavlink_msgs = require("mavlink/mavlink_msgs")

local msg_map = {}

local heartbeat_msgid = mavlink_msgs.get_msgid("HEARTBEAT")

msg_map[heartbeat_msgid] = "HEARTBEAT"
-- initialize MAVLink rx with buffer depth and number of rx message IDs to register
mavlink.init(10, 1)
-- register message id to receive
mavlink.register_rx_msgid(heartbeat_msgid)
local test_named_value = 0.0
function update()
    local msg,chan,timestamp_ms = mavlink.receive_chan()
    if msg then
        gcs:send_text(6, string.format("Received message on channel %d at %s", chan, tostring(timestamp_ms)))
        local parsed_msg = mavlink_msgs.decode(msg, msg_map)
        if parsed_msg.msgid == heartbeat_msgid then
            gcs:send_text(6, string.format("Received heartbeat from %d", parsed_msg.sysid))
        end
    else
        gcs:send_text(6, "No heartbeat received")
    end
    test_named_value = test_named_value + 1.0
    -- send named value float
    mavlink.send_chan(0, mavlink_msgs.encode("NAMED_VALUE_FLOAT", {time_boot_ms = millis():toint(), name = "test", value = test_named_value}))
    return update, 1000
end

return update()



================================================
File: tests/scripting_require_test_2.lua
================================================
-- main require tests are in scripting_test.lua

-- CAREFUL WHEN EDITING!!!! we do some very careful work to check that require
-- works even when the update function's first upvalue is not the script
-- environment _ENV. this fact can be verified by looking at its upvalues using
-- e.g. https://www.luac.nl/

local loop_time = 500 -- number of ms between runs

-- alias global gcs as a local so update uses it as an upvalue
local gcs = gcs -- luacheck: ignore

local passes = 0 -- run both before and after scheduling

-- this time running require, the main function that implicitly wraps the script
-- is the update function and its only upvalue is by definition _ENV; require
-- is expected to work here
local require_global = require("test/nested")

local function update()
  -- reference gcs first so it's update's first upvalue
  gcs:send_text(6, "testing")
  -- require is a global, so referencing it implicitly adds _ENV as update's
  -- second upvalue, thus exercising the problem during the second and third
  -- passes when this is in fact the update function
  local require_local = require("test/nested") -- should not cause an error

  -- validate we got the same object (object contents validated in main test)
  -- no matter when require is called and what set of upvalues are used
  if require_local == require_global then
    passes = passes + 1
  else
    gcs:send_text(0, "Failed: require returned different objects")
  end
  if passes >= 3 then
    gcs:send_text(3, "Require test 2 passed")
  end

  -- now schedule this function as the update function, not the main function
  return update, loop_time
end

-- run immediately before starting to reschedule. the update function doesn't
-- change until the return, so the first time it's run the bug shouldn't trigger
-- as the main function's upvalues are still the ones checked
return update()



================================================
File: tests/scripting_test.lua
================================================
-- this is a script which is primarily intended to test the scripting bindings and be used with autotest
-- however it may be useful to some as a demo of how the API's can be used, this example is much less
-- heavily commented, and may require quite a bit more RAM to run in

local loop_time = 500 -- number of ms between runs
local require_test_global = require('test/nested')

function is_equal(v1, v2, tolerance)
  return math.abs(v1 - v2) < (tolerance or 0.0001)
end

function test_offset(ofs_e, ofs_n)
  local manipulated_pos = Location()
  manipulated_pos:offset(ofs_e, ofs_n)
  local distance_offset = manipulated_pos:get_distance(Location())
  if distance_offset < 0 then
    gcs:send_text(0, "Location:get_distance() returned a negative number")
    return false
  end
  local error_dist = distance_offset - math.sqrt((ofs_e*ofs_e)+(ofs_n*ofs_n))
  if error_dist > 0.1 then
    gcs:send_text(0, string.format("Failed offset %.1f, %.1f with an error of %f", ofs_e, ofs_n, error_dist))
    return false
  end
  local from_origin_NE = Location():get_distance_NE(manipulated_pos)
  if (not is_equal(ofs_e, from_origin_NE:x(), 0.01)) or (not is_equal(ofs_n, from_origin_NE:y(), 0.01)) then
    gcs:send_text(0, string.format("Failed to offset %.1f, %.1f %.1f %.1f", ofs_e, ofs_n, from_origin_NE:x(), from_origin_NE:y()))
    return false
  end
  local from_origin_NED = Location():get_distance_NED(manipulated_pos)
  if (not is_equal(from_origin_NED:x(), from_origin_NE:x())) or (not is_equal(from_origin_NED:y(), from_origin_NE:y())) then 
    gcs:send_text(0, string.format("Distance NED != NE %.1f, %.1f %.1f %.1f", from_origin_NED:x(), from_origin_NED:y(), from_origin_NE:x(), from_origin_NE:y()))
    return false
  end
  return true
end

function test_uint64()
  local pass = true

  local zero = uint64_t()
  local max = uint64_t(-1, -1)

  pass = pass and (zero - 1) == max
  pass = pass and ~max == zero
  pass = pass and max > zero
  pass = pass and (((zero + 1) + 1.1) + uint32_t(1)) == uint64_t(0, 3)
  pass = pass and tostring(zero) == "0"
  pass = pass and (uint64_t(15) & uint64_t(130)) == uint32_t(2)
  pass = pass and (uint64_t(1) | uint64_t(2)) == uint64_t(3)
  pass = pass and (uint64_t(1) << 1) == uint64_t(2)
  pass = pass and (uint64_t(16) >> 1) == uint64_t(8)
  pass = pass and type(zero:tofloat()) == "number"
  pass = pass and zero:tofloat() == 0

  local high, low
  high, low = zero:split()
  pass = pass and high == uint32_t(0) and low == uint32_t(0)

  high, low = max:split()
  pass = pass and high == uint32_t(-1) and low == uint32_t(-1)

  return pass
end

function update()
  local all_tests_passed = true
  local require_test_local = require('test/nested')
  -- test require()ing a script
  if require_test_local.call_fn() ~= 'nested' then
    gcs:send_text(0, "Failed to require() the same script multiple times")
    all_tests_passed = false
  end
  if require_test_global.call_fn() ~= 'nested' then
    gcs:send_text(0, "Failed to require() the script once")
    all_tests_passed = false
  end
  if require_test_global.top.call_fn() ~= 'top' then
    gcs:send_text(0, "Failed to call a function nested in a required script")
    all_tests_passed = false
  end
  -- each test should run then and it's result with the previous ones
  all_tests_passed = test_offset(500, 200) and all_tests_passed
  all_tests_passed = test_uint64() and all_tests_passed

  if all_tests_passed then
    gcs:send_text(3, "Internal tests passed")
  end
  return update, loop_time
end

return update() -- run immediately before starting to reschedule



================================================
File: tests/serial_loopback.lua
================================================
local ser_driver = serial:find_serial(0)
local ser_device = serial:find_simulated_device(28, 0)

if ser_driver == nil or ser_device == nil then
  error("bad config")
end

ser_driver:begin(115200) -- baud rate does not matter

function test_driver_to_device()
  local msg_send = "hello device"
  local num_sent = 0
  for ci = 1,#msg_send do
    num_sent = num_sent + ser_driver:write(msg_send:byte(ci, ci)):toint()
  end
  local msg_recv = ser_device:readstring(#msg_send)
  if msg_send == msg_recv and num_sent == #msg_send then
    gcs:send_text(6, "driver -> device good")
  end
end

function test_device_to_driver()
  local msg_send = "hello driver"
  local num_sent = ser_device:writestring(msg_send)
  local msg_recv = ser_driver:readstring(#msg_send)
  if msg_send == msg_recv and num_sent == #msg_send then
    gcs:send_text(6, "device -> driver good")
  end
end

function update()
  test_driver_to_device()
  test_device_to_driver()
end

return update()



================================================
File: tests/strings.lua
================================================
-- $Id: strings.lua,v 1.86 2016/11/07 13:11:28 roberto Exp roberto $

--[[
*****************************************************************************
* Copyright (C) 1994-2016 Lua.org, PUC-Rio.
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*****************************************************************************
]]

-- This code is copied from https://github.com/lua/tests and slightly modified to work within ArduPilot

-- luacheck: ignore 581 (Negation of a relational operator - operator can be flipped)

---@diagnostic disable: param-type-mismatch
---@diagnostic disable: missing-parameter
---@diagnostic disable: undefined-global


gcs:send_text(6, 'testing strings and string library')

local maxi, mini = math.maxinteger, math.mininteger


local function checkerror (msg, f, ...)
  local s, err = pcall(f, ...)
  assert(not s and string.find(err, msg))
end


-- testing string comparisons
assert('alo' < 'alo1')
assert('' < 'a')
assert('alo\0alo' < 'alo\0b')
assert('alo\0alo\0\0' > 'alo\0alo\0')
assert('alo' < 'alo\0')
assert('alo\0' > 'alo')
assert('\0' < '\1')
assert('\0\0' < '\0\1')
assert('\1\0a\0a' <= '\1\0a\0a')
assert(not ('\1\0a\0b' <= '\1\0a\0a'))
assert('\0\0\0' < '\0\0\0\0')
assert(not('\0\0\0\0' < '\0\0\0'))
assert('\0\0\0' <= '\0\0\0\0')
assert(not('\0\0\0\0' <= '\0\0\0'))
assert('\0\0\0' <= '\0\0\0')
assert('\0\0\0' >= '\0\0\0')
assert(not ('\0\0b' < '\0\0a\0'))

-- testing string.sub
assert(string.sub("123456789",2,4) == "234")
assert(string.sub("123456789",7) == "789")
assert(string.sub("123456789",7,6) == "")
assert(string.sub("123456789",7,7) == "7")
assert(string.sub("123456789",0,0) == "")
assert(string.sub("123456789",-10,10) == "123456789")
assert(string.sub("123456789",1,9) == "123456789")
assert(string.sub("123456789",-10,-20) == "")
assert(string.sub("123456789",-1) == "9")
assert(string.sub("123456789",-4) == "6789")
assert(string.sub("123456789",-6, -4) == "456")
assert(string.sub("123456789", mini, -4) == "123456")
assert(string.sub("123456789", mini, maxi) == "123456789")
assert(string.sub("123456789", mini, mini) == "")
assert(string.sub("\000123456789",3,5) == "234")
assert(("\000123456789"):sub(8) == "789")

-- testing string.find
assert(string.find("123456789", "345") == 3)
a,b = string.find("123456789", "345")
assert(string.sub("123456789", a, b) == "345")
assert(string.find("1234567890123456789", "345", 3) == 3)
assert(string.find("1234567890123456789", "345", 4) == 13)
assert(string.find("1234567890123456789", "346", 4) == nil)
assert(string.find("1234567890123456789", ".45", -9) == 13)
assert(string.find("abcdefg", "\0", 5, 1) == nil)
assert(string.find("", "") == 1)
assert(string.find("", "", 1) == 1)
assert(not string.find("", "", 2))
assert(string.find('', 'aaa', 1) == nil)
assert(('alo(.)alo'):find('(.)', 1, 1) == 4)

assert(string.len("") == 0)
assert(string.len("\0\0\0") == 3)
assert(string.len("1234567890") == 10)

assert(#"" == 0)
assert(#"\0\0\0" == 3)
assert(#"1234567890" == 10)

-- testing string.byte/string.char
assert(string.byte("a") == 97)
assert(string.byte("\xe4") > 127)
assert(string.byte(string.char(255)) == 255)
assert(string.byte(string.char(0)) == 0)
assert(string.byte("\0") == 0)
assert(string.byte("\0\0alo\0x", -1) == string.byte('x'))
assert(string.byte("ba", 2) == 97)
assert(string.byte("\n\n", 2, -1) == 10)
assert(string.byte("\n\n", 2, 2) == 10)
assert(string.byte("") == nil)
assert(string.byte("hi", -3) == nil)
assert(string.byte("hi", 3) == nil)
assert(string.byte("hi", 9, 10) == nil)
assert(string.byte("hi", 2, 1) == nil)
assert(string.char() == "")
assert(string.char(0, 255, 0) == "\0\255\0")
assert(string.char(0, string.byte("\xe4"), 0) == "\0\xe4\0")
assert(string.char(string.byte("\xe4l\0�u", 1, -1)) == "\xe4l\0�u")
assert(string.char(string.byte("\xe4l\0�u", 1, 0)) == "")
assert(string.char(string.byte("\xe4l\0�u", -10, 100)) == "\xe4l\0�u")

assert(string.upper("ab\0c") == "AB\0C")
assert(string.lower("\0ABCc%$") == "\0abcc%$")
assert(string.rep('teste', 0) == '')
assert(string.rep('t�s\00t�', 2) == 't�s\0t�t�s\000t�')
assert(string.rep('', 10) == '')

if string.packsize("i") == 4 then
  -- result length would be 2^31 (int overflow)
  checkerror("too large", string.rep, 'aa', (1 << 30))
  checkerror("too large", string.rep, 'a', (1 << 30), ',')
end

-- repetitions with separator
assert(string.rep('teste', 0, 'xuxu') == '')
assert(string.rep('teste', 1, 'xuxu') == 'teste')
assert(string.rep('\1\0\1', 2, '\0\0') == '\1\0\1\0\0\1\0\1')
assert(string.rep('', 10, '.') == string.rep('.', 9))
assert(not pcall(string.rep, "aa", maxi // 2 + 10))
assert(not pcall(string.rep, "", maxi // 2 + 10, "aa"))

assert(string.reverse"" == "")
assert(string.reverse"\0\1\2\3" == "\3\2\1\0")
assert(string.reverse"\0001234" == "4321\0")

for i=0,30 do assert(string.len(string.rep('a', i)) == i) end

assert(type(tostring(nil)) == 'string')
assert(type(tostring(12)) == 'string')
assert(string.find(tostring{}, 'table:'))
assert(#tostring('\0') == 1)
assert(tostring(true) == "true")
assert(tostring(false) == "false")
assert(tostring(-1203) == "-1203")
assert(tostring(1203.125) == "1203.125")
assert(tostring(-0.5) == "-0.5")
assert(tostring(-32767) == "-32767")
if math.tointeger(2147483647) then   -- no overflow? (32 bits)
  assert(tostring(-2147483647) == "-2147483647")
end
if math.tointeger(4611686018427387904) then   -- no overflow? (64 bits)
  assert(tostring(4611686018427387904) == "4611686018427387904")
  assert(tostring(-4611686018427387904) == "-4611686018427387904")
end

if tostring(0.0) == "0.0" then   -- "standard" coercion float->string
  assert('' .. 12 == '12' and 12.0 .. '' == '12.0')
  assert(tostring(-1203 + 0.0) == "-1203.0")
else   -- compatible coercion
  assert(tostring(0.0) == "0")
  assert('' .. 12 == '12' and 12.0 .. '' == '12')
  assert(tostring(-1203 + 0.0) == "-1203")
end


x = '"�lo"\n\\'
assert(string.format('%q%s', x, x) == '"\\"�lo\\"\\\n\\\\""�lo"\n\\')
assert(string.format('%q', "\0") == [["\0"]])
--assert(load(string.format('return %q', x))() == x)
x = "\0\1\0023\5\0009"
--assert(load(string.format('return %q', x))() == x)
assert(string.format("\0%c\0%c%x\0", string.byte("\xe4"), string.byte("b"), 140) ==
              "\0\xe4\0b8c\0")
assert(string.format('') == "")
assert(string.format("%c",34)..string.format("%c",48)..string.format("%c",90)..string.format("%c",100) ==
       string.format("%c%c%c%c", 34, 48, 90, 100))
assert(string.format("%s\0 is not \0%s", 'not be', 'be') == 'not be\0 is not \0be')
assert(string.format("%%%d %010d", 10, 23) == "%10 0000000023")
assert(tonumber(string.format("%f", 10.3)) == 10.3)
x = string.format('"%-50s"', 'a')
assert(#x == 52)
assert(string.sub(x, 1, 4) == '"a  ')

assert(string.format("-%.20s.20s", string.rep("%", 2000)) ==
                     "-"..string.rep("%", 20)..".20s")
assert(string.format('"-%20s.20s"', string.rep("%", 2000)) ==
       string.format("%q", "-"..string.rep("%", 2000)..".20s"))

--[[
do
  local function checkQ (v)
    local s = string.format("%q", v)
    local nv = load("return " .. s)()
    assert(v == nv and math.type(v) == math.type(nv))
  end
  checkQ("\0\0\1\255\u{234}")
  checkQ(math.maxinteger)
  checkQ(math.mininteger)
  checkQ(math.pi)
  checkQ(0.1)
  checkQ(true)
  checkQ(nil)
  checkQ(false)
  checkerror("no literal", string.format, "%q", {})
end
]]

assert(string.format("\0%s\0", "\0\0\1") == "\0\0\0\1\0")
checkerror("contains zeros", string.format, "%10s", "\0")

-- format x tostring
assert(string.format("%s %s", nil, true) == "nil true")
assert(string.format("%s %.4s", false, true) == "false true")
assert(string.format("%.3s %.3s", false, true) == "fal tru")
--local m = setmetatable({}, {__tostring = function () return "hello" end,
--                            __name = "hi"})
--assert(string.format("%s %.10s", m, m) == "hello hello")
--getmetatable(m).__tostring = nil   -- will use '__name' from now on
--assert(string.format("%.4s", m) == "hi: ")

--getmetatable(m).__tostring = function () return {} end
--checkerror("'__tostring' must return a string", tostring, m)


assert(string.format("%x", 0.0) == "0")
assert(string.format("%02x", 0.0) == "00")
assert(string.format("%08X", 0xFFFFFFFF) == "FFFFFFFF")
assert(string.format("%+08d", 31501) == "+0031501")
assert(string.format("%+08d", -30927) == "-0030927")


do    -- longest number that can be formatted
  local i = 1
  local j = 10000
  while i + 1 < j do   -- binary search for maximum finite float
    local m = (i + j) // 2
    if 10^m < math.huge then i = m else j = m end
  end
  assert(10^i < math.huge and 10^j == math.huge)
  local s = string.format('%.99f', -(10^i))
  assert(string.len(s) >= i + 101)
  assert(tonumber(s) == -(10^i))
end


-- testing large numbers for format
do   -- assume at least 32 bits
  local max, min = 0x7fffffff, -0x80000000    -- "large" for 32 bits
  assert(string.sub(string.format("%8x", -1), -8) == "ffffffff")
  assert(string.format("%x", max) == "7fffffff")
  assert(string.sub(string.format("%x", min), -8) == "80000000")
  assert(string.format("%d", max) ==  "2147483647")
  assert(string.format("%d", min) == "-2147483648")
  assert(string.format("%u", 0xffffffff) == "4294967295")
  assert(string.format("%o", 0xABCD) == "125715")

  max, min = 0x7fffffffffffffff, -0x8000000000000000
  if max > 2.0^53 then  -- only for 64 bits
    assert(string.format("%x", (2^52 | 0) - 1) == "fffffffffffff")
    assert(string.format("0x%8X", 0x8f000003) == "0x8F000003")
    assert(string.format("%d", 2^53) == "9007199254740992")
    assert(string.format("%i", -2^53) == "-9007199254740992")
    assert(string.format("%x", max) == "7fffffffffffffff")
    assert(string.format("%x", min) == "8000000000000000")
    assert(string.format("%d", max) ==  "9223372036854775807")
    assert(string.format("%d", min) == "-9223372036854775808")
    assert(string.format("%u", ~(-1 << 64)) == "18446744073709551615")
    assert(tostring(1234567890123) == '1234567890123')
  end
end


do gcs:send_text(6, "testing 'format %a %A'")
  local function matchhexa (n)
    local s = string.format("%a", n)
    -- result matches ISO C requirements
    assert(string.find(s, "^%-?0x[1-9a-f]%.?[0-9a-f]*p[-+]?%d+$"))
    assert(tonumber(s) == n)  -- and has full precision
    s = string.format("%A", n)
    assert(string.find(s, "^%-?0X[1-9A-F]%.?[0-9A-F]*P[-+]?%d+$"))
    assert(tonumber(s) == n)
  end
  for _, n in ipairs{0.1, -0.1, 1/3, -1/3, 1e30, -1e30,
                     -45/247, 1, -1, 2, -2, 3e-20, -3e-20} do
    matchhexa(n)
  end

  assert(string.find(string.format("%A", 0.0), "^0X0%.?0?P%+?0$"))
  assert(string.find(string.format("%a", -0.0), "^%-0x0%.?0?p%+?0$"))

  if not _port then   -- test inf, -inf, NaN, and -0.0
    assert(string.find(string.format("%a", 1/0), "^inf"))
    assert(string.find(string.format("%A", -1/0), "^%-INF"))
    assert(string.find(string.format("%a", 0/0), "^%-?nan"))
    assert(string.find(string.format("%a", -0.0), "^%-0x0"))
  end
  
  if not pcall(string.format, "%.3a", 0) then
    (Message or print)("\n >>> modifiers for format '%a' not available <<<\n")
  else
    assert(string.find(string.format("%+.2A", 12), "^%+0X%x%.%x0P%+?%d$"))
    assert(string.find(string.format("%.4A", -12), "^%-0X%x%.%x000P%+?%d$"))
  end
end


-- errors in format

local function check (fmt, msg)
  checkerror(msg, string.format, fmt, 10)
end

local aux = string.rep('0', 600)
check("%100.3d", "too long")
check("%1"..aux..".3d", "too long")
check("%1.100d", "too long")
check("%10.1"..aux.."004d", "too long")
check("%t", "invalid option")
check("%"..aux.."d", "repeated flags")
check("%d %d", "no value")


--assert(load("return 1\n--comment without ending EOL")() == 1)


checkerror("table expected", table.concat, 3)
assert(table.concat{} == "")
assert(table.concat({}, 'x') == "")
assert(table.concat({'\0', '\0\1', '\0\1\2'}, '.\0.') == "\0.\0.\0\1.\0.\0\1\2")
local a = {}; for i=1,300 do a[i] = "xuxu" end
assert(table.concat(a, "123").."123" == string.rep("xuxu123", 300))
assert(table.concat(a, "b", 20, 20) == "xuxu")
assert(table.concat(a, "", 20, 21) == "xuxuxuxu")
assert(table.concat(a, "x", 22, 21) == "")
assert(table.concat(a, "3", 299) == "xuxu3xuxu")
assert(table.concat({}, "x", maxi, maxi - 1) == "")
assert(table.concat({}, "x", mini + 1, mini) == "")
assert(table.concat({}, "x", maxi, mini) == "")
assert(table.concat({[maxi] = "alo"}, "x", maxi, maxi) == "alo")
assert(table.concat({[maxi] = "alo", [maxi - 1] = "y"}, "-", maxi - 1, maxi)
       == "y-alo")

assert(not pcall(table.concat, {"a", "b", {}}))

a = {"a","b","c"}
assert(table.concat(a, ",", 1, 0) == "")
assert(table.concat(a, ",", 1, 1) == "a")
assert(table.concat(a, ",", 1, 2) == "a,b")
assert(table.concat(a, ",", 2) == "b,c")
assert(table.concat(a, ",", 3) == "c")
assert(table.concat(a, ",", 4) == "")

function update()
  gcs:send_text(6, 'String tests passed')
  return update, 1000
end

return update()



================================================
File: tests/modules/test/nested.lua
================================================
-- Description: Test require()ing another script
local nested = {}
nested.top = require('test/top')

-- create some test functions to call
function nested.call_fn()
    return "nested"
end

return nested



================================================
File: tests/modules/test/top.lua
================================================
-- Description: Test require()ing another script
local top = {}

-- create some test functions to call
function top.call_fn()
    return "top"
end

return top


