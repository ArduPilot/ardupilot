// ESCVelocityProtocol.h was generated by ProtoGen version 2.18.c

/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 

#ifndef _ESCVELOCITYPROTOCOL_H
#define _ESCVELOCITYPROTOCOL_H

// C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 * \mainpage ESCVelocity protocol stack
 *
 * This is the ICD for the Currawong Engineering Electronic Speed Controller
 * (ESCVelocity). This document details the ESCVelocity command and packet
 * structure for communication with and configuration of the ESC
 *
 * The protocol API enumeration is incremented anytime the protocol is changed
 * in a way that affects compatibility with earlier versions of the protocol.
 * The protocol enumeration for this version is: 23
 *
 * The protocol version is 3.05
 */

#include <stdint.h>
#include <string.h>	// C string manipulation function header

//! \return the protocol API enumeration
#define getESCVelocityApi() 23

//! \return the protocol version string
#define getESCVelocityVersion() "3.05"

/*!
 * ESC_Disable_Sequence
 */
typedef enum
{
    ESC_DISABLE_A = 0xAA,//!< Constant value required for disabling the ESC
    ESC_DISABLE_B = 0xC3 //!< Constant value required for disabling the ESC
} ESCDisableSequence;

/*!
 * ESC_Enable_Sequence
 */
typedef enum
{
    ESC_ENABLE_A = 0xAA, //!< Constant value required for enabling the ESC
    ESC_ENABLE_B = 0x3C  //!< Constant value required for enabling the ESC
} ESCEnableSequence;

/*!
 * ESC Operational Modes
 */
typedef enum
{
    ESC_MODE_STANDBY = 0x00, //!< ESC is in standby mode - the motor is OFF but the ESC is ready to accept motor commands
    ESC_MODE_PWM,            //!< ESC is controlling motor in open-loop mode based on a 'PWM' (Pulse Width) input
    ESC_MODE_RPM,            //!< ESC is controlling motor speed based on an RPM setpoint
    ESC_VALID_MODES          //!< ESC mode counter
} ESCOperatingModes;

//! \return the label of a 'ESCOperatingModes' enum entry, based on its value
const char* ESCOperatingModes_EnumLabel(int value);

/*!
 * ESC Command Sources
 */
typedef enum
{
    ESC_COMMAND_SOURCE_NONE = 0x00,//!< No valid command has been received
    ESC_COMMAND_SOURCE_CAN,      //!< Most recent command from CAN
    ESC_COMMAND_SOURCE_PWM       //!< Most recent command from PWM
} ESCCommandSources;

//! \return the label of a 'ESCCommandSources' enum entry, based on its value
const char* ESCCommandSources_EnumLabel(int value);

/*!
 * ESC motor temperature sensor options
 */
typedef enum
{
    ESC_MOTOR_TEMP_SENSOR_OFF = 0x00,//!< No temperature sensor selected
    ESC_MOTOR_TEMP_SENSOR_KTY84,     //!< KTY84 of equivalent
    ESC_MOTOR_TEMP_SENSOR_KTY83      //!< KTY83 or equivalent
} ESCMotorTemperatureSensor;

//! \return the label of a 'ESCMotorTemperatureSensor' enum entry, based on its value
const char* ESCMotorTemperatureSensor_EnumLabel(int value);

/*!
 * ESC Command Priorities
 */
typedef enum
{
    ESC_COMMAND_PRIORITY_CAN_ONLY = 0x00,//!< Commands only from CAN, PWM hardware input is disabled
    ESC_COMMAND_PRIORITY_CAN_PRIORITY,   //!< Commands from CAN or PWM hardware input, CAN takes priority
    ESC_COMMAND_PRIORITY_PWM_PRIORITY    //!< Commands from CAN or PWM hardware input, PWM takes priority
} ESCCommandPriorities;

//! \return the label of a 'ESCCommandPriorities' enum entry, based on its value
const char* ESCCommandPriorities_EnumLabel(int value);

/*!
 * Motor Direction Enumeration
 */
typedef enum
{
    ESC_MOTOR_DIR_FORWARD = 0x00,//!< Forward motor direction
    ESC_MOTOR_DIR_REVERSE = 0x01 //!< Reverse motor direction
} ESCMotorDirections;

/*!
 * Motor beep modes enumeration
 */
typedef enum
{
    ESC_BEEP_NONE = 0b00,
    ESC_BEEP_STATUS = 0b01,//!< Motor status beeps only
    ESC_BEEP_ERROR = 0b10,//!< Motor error beeps only
    ESC_BEEP_ALL = 0b11  //!< All motor beeps
} ESCBeepModes;

/*!
 * ESC Multi Command Packets
 */
typedef enum
{
    PKT_ESC_SETPOINT_1 = 0,//!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 1 - 4
    PKT_ESC_SETPOINT_2,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 5 - 8
    PKT_ESC_SETPOINT_3,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 9 - 12
    PKT_ESC_SETPOINT_4,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 13 - 16
    PKT_ESC_SETPOINT_5,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 17 - 20
    PKT_ESC_SETPOINT_6,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 21 - 24
    PKT_ESC_SETPOINT_7,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 25 - 28
    PKT_ESC_SETPOINT_8,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 29 - 32
    PKT_ESC_SETPOINT_9,  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 33 - 36
    PKT_ESC_SETPOINT_10, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 37 - 40
    PKT_ESC_SETPOINT_11, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 41 - 44
    PKT_ESC_SETPOINT_12, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 45 - 48
    PKT_ESC_SETPOINT_13, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 49 - 52
    PKT_ESC_SETPOINT_14, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 53 - 56
    PKT_ESC_SETPOINT_15, //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 57 - 60
    PKT_ESC_SETPOINT_16  //!< This packet is used to send commands to multiple ESCs with sequential CAN IDs 61 - 64
} ESCMultiCommandPackets;

//! \return the label of a 'ESCMultiCommandPackets' enum entry, based on its value
const char* ESCMultiCommandPackets_EnumLabel(int value);

/*!
 * ESC Command Packets
 */
typedef enum
{
    PKT_ESC_PWM_CMD = 0x10,//!< Send a PWM (Pulse width) command to a particular ESC
    PKT_ESC_RPM_CMD,     //!< Send an RPM (Speed) command to a particular ESC
    PKT_ESC_DISABLE = 0x20,//!< Send this packet to an ESC to disable the ESC
    PKT_ESC_STANDBY      //!< Send this packet to an ESC to enable the ESC and place it in Standby mode
} ESCCommandPackets;

//! \return the label of a 'ESCCommandPackets' enum entry, based on its value
const char* ESCCommandPackets_EnumLabel(int value);

/*!
 * ESC Status Packets
 */
typedef enum
{
    PKT_ESC_STATUS_A = 0x80,     //!< ESC Status A telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_STATUS_B,            //!< ESC Status B telemetry packet transmitted by the ESC at regular intervals
    PKT_ESC_ACCELEROMETER = 0x88 //!< Raw accelerometer data
} ESCStatusPackets;

//! \return the label of a 'ESCStatusPackets' enum entry, based on its value
const char* ESCStatusPackets_EnumLabel(int value);

/*!
 * ESC Packets Definitions
 */
typedef enum
{
    PKT_ESC_SERIAL_NUMBER = 0x90,//!< ESC Serial Number and User ID information
    PKT_ESC_TITLE,               //!< Human-readable string descriptor (max 8 chars) of the particular ESC
    PKT_ESC_FIRMWARE,            //!< ESC Firmware information
    PKT_ESC_SYSTEM_INFO,         //!< ESC system information packet
    PKT_ESC_TELEMETRY_SETTINGS,  //!< Telemetry packet configuration
    PKT_ESC_EEPROM               //!< ESC non-volatile data information and settings
} ESCPackets;

//! \return the label of a 'ESCPackets' enum entry, based on its value
const char* ESCPackets_EnumLabel(int value);


// The prototypes below provide an interface to the packets.
// They are not auto-generated functions, but must be hand-written

//! \return the packet data pointer from the packet
uint8_t* getESCVelocityPacketData(void* pkt);

//! \return the packet data pointer from the packet, const
const uint8_t* getESCVelocityPacketDataConst(const void* pkt);

//! Complete a packet after the data have been encoded
void finishESCVelocityPacket(void* pkt, int size, uint32_t packetID);

//! \return the size of a packet from the packet header
int getESCVelocityPacketSize(const void* pkt);

//! \return the ID of a packet from the packet header
uint32_t getESCVelocityPacketID(const void* pkt);

#ifdef __cplusplus
}
#endif
#endif
