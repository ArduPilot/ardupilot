// scaledencode.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "scaledencode.h"
#include "fieldencode.h"


/*!
 * Scale a float using floating point scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int float32ScaledToBitfield(float value, float min, float scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Protect from underflow
    if(value < min)
        return 0;

    // Scale the number
    value = (value - min)*scaler;

    // Protect from overflow
    if(value > max)
        return max;

    // Account for fractional truncation
    return (unsigned int)(value + 0.5f);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo4UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 4294967295ul)
        number = 4294967295ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo4SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 2147483647l)
            number = 2147483647l;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-2147483647l - 1))
            number = (-2147483647l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo3UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 16777215ul)
        number = 16777215ul;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint32_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int32_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 8388607)
            number = 8388607;
        else
            number = (int32_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-8388607l - 1))
            number = (-8388607l - 1);
        else
            number = (int32_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int24ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2
 * unsigned bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 65535u)
        number = 65535u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint16_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int16_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 32767)
            number = 32767;
        else
            number = (int16_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-32767 - 1))
            number = (-32767 - 1);
        else
            number = (int16_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1
 * unsigned byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler)
{
    // scale the number
    float scaledvalue = (float)((value - min)*scaler);
    uint8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 255u)
        number = 255u;
    else if(scaledvalue <= 0)
        number = 0;
    else
        number = (uint8_t)(scaledvalue + 0.5f); // account for fractional truncation

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a float on a byte stream by floating point scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler)
{
    // scale the number
    float scaledvalue = (float)(value*scaler);
    int8_t number;

    // Make sure number fits in the range
    if(scaledvalue >= 0)
    {
        if(scaledvalue >= 127)
            number = 127;
        else
            number = (int8_t)(scaledvalue + 0.5f); // account for fractional truncation
    }
    else
    {
        if(scaledvalue <= (-127 - 1))
            number = (-127 - 1);
        else
            number = (int8_t)(scaledvalue - 0.5f); // account for fractional truncation
    }

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a uint32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint32ScaledToBitfield(uint32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo4UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo4SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo3UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo3SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedBeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo2UnsignedLeBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedBeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo2SignedLeBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint32ScaledTo1UnsignedBytes(uint32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint32ScaledTo1SignedBytes(uint32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int32_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int32ScaledToBitfield(int32_t value, int32_t min, uint32_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo4UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
    }

    uint32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 4 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo4SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    int32ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToBeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo3UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 16777215ul)
            number = 16777215ul;
    }

    uint24ToLeBytes((uint32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToBeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 3 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo3SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 8388607l)
        number = 8388607l;
    else if(number < (-8388607l - 1))
        number = (-8388607l - 1);

    int24ToLeBytes((int32_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedBeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToBeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo2UnsignedLeBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 65535u)
            number = 65535u;
    }

    uint16ToLeBytes((uint16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedBeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToBeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo2SignedLeBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 32767)
        number = 32767;
    else if(number < (-32767 - 1))
        number = (-32767 - 1);

    int16ToLeBytes((int16_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int32ScaledTo1UnsignedBytes(int32_t value, uint8_t* bytes, int* index, int32_t min, uint32_t scaler)
{
    // scale the number
    uint32_t number = 0;

    // Make sure number fits in the range
    if(((int32_t)value) > min)
    {
        number = (uint32_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int32_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int32ScaledTo1SignedBytes(int32_t value, uint8_t* bytes, int* index, uint32_t scaler)
{
    // scale the number
    int32_t number = (int32_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint16ScaledToBitfield(uint16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedBeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo2UnsignedLeBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedBeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo2SignedLeBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint16ScaledTo1UnsignedBytes(uint16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a uint16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint16ScaledTo1SignedBytes(uint16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a int16_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int16ScaledToBitfield(int16_t value, int16_t min, uint16_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedBeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 unsigned
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo2UnsignedLeBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
    }

    uint16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in big endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedBeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToBeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 2 signed
 * bytes in little endian order.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo2SignedLeBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    int16ToLeBytes(number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int16ScaledTo1UnsignedBytes(int16_t value, uint8_t* bytes, int* index, int16_t min, uint16_t scaler)
{
    // scale the number
    uint16_t number = 0;

    // Make sure number fits in the range
    if(((int16_t)value) > min)
    {
        number = (uint16_t)((value - min)*scaler);
        if(number > 255u)
            number = 255u;
    }

    uint8ToBytes((uint8_t)number, bytes, index);
}


/*!
 * Encode a int16_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int16ScaledTo1SignedBytes(int16_t value, uint8_t* bytes, int* index, uint16_t scaler)
{
    // scale the number
    int16_t number = (int16_t)(value*scaler);

    // Make sure number fits in the range
    if(number > 127)
        number = 127;
    else if(number < (-127 - 1))
        number = (-127 - 1);

    int8ToBytes((int8_t)number, bytes, index);
}


/*!
 * Scale a uint8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int uint8ScaledToBitfield(uint8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void uint8ScaledTo1UnsignedBytes(uint8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a uint8_t on a byte stream by integer scaling to fit in 1 signed
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void uint8ScaledTo1SignedBytes(uint8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


/*!
 * Scale a int8_t using integer scaling to the base integer type used for
 * bitfields.
 * \param value is the number to scale.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer.
 * \param bits is the number of bits in the bitfield, used to limit the returned value.
 * \return (value-min)*scaler.
 */
unsigned int int8ScaledToBitfield(int8_t value, int8_t min, uint8_t scaler, int bits)
{
    // The largest integer the bitfield can hold
    unsigned int max = (0x1u << bits) - 1;

    // Scale the number
    unsigned int number = (unsigned int)((value - min)*scaler);

    // Protect from underflow
    if(((int32_t)value) < min)
        return 0;

    // Protect from overflow
    if(number > max)
        return max;

    return number;
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 unsigned
 * byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be encoded.
 * \param scaler is multiplied by value to create the encoded integer: encoded = (value-min)*scaler.
 */
void int8ScaledTo1UnsignedBytes(int8_t value, uint8_t* bytes, int* index, int8_t min, uint8_t scaler)
{
    // scale the number
    uint8_t number = 0;

    // Make sure number fits in the range
    if(((int8_t)value) > min)
    {
        number = (uint8_t)((value - min)*scaler);
    }

    uint8ToBytes(number, bytes, index);
}


/*!
 * Encode a int8_t on a byte stream by integer scaling to fit in 1 signed byte.
 * \param value is the number to encode.
 * \param bytes is a pointer to the byte stream which receives the encoded data.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param scaler is multiplied by value to create the encoded integer: encoded = value*scaler.
 */
void int8ScaledTo1SignedBytes(int8_t value, uint8_t* bytes, int* index, uint8_t scaler)
{
    // scale the number
    int8_t number = (int8_t)(value*scaler);

    int8ToBytes(number, bytes, index);
}


// end of scaledencode.c
