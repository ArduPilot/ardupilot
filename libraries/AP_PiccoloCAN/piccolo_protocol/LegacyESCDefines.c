// LegacyESCDefines.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters
 */

#include "LegacyESCDefines.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a ESC_LegacyStatusBits_t into a byte array
 *
 * Status bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeESC_LegacyStatusBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ESC_LegacyStatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // 1 = Hardware inhibit is active (ESC is disabled)
    _pg_data[_pg_byteindex] = (uint8_t)_pg_user->hwInhibit << 7;

    // 1 = Software inhibit is active (ESC is disabled)
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->swInhibit << 6;

    // 0 = Active Freewheeling is not enabled, 1 = Active Freewheeling is enabled
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->afwEnabled << 5;

    // 0 = Motor direction is FORWARDS, 1= Motor direction is REVERSE
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->direction << 4;

    // Set if the ESC command timeout period has elapsed (and the ESC is in STANDBY mode)
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->timeout << 3;

    // 1 = in starting mode (0 = stopped or running)
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->starting << 2;

    // 0 = most recent command from CAN, 1 = most recent command from PWM
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->commandSource << 1;

    // ESC is running
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->running;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeESC_LegacyStatusBits_t

/*!
 * \brief Decode a ESC_LegacyStatusBits_t from a byte array
 *
 * Status bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeESC_LegacyStatusBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ESC_LegacyStatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // 1 = Hardware inhibit is active (ESC is disabled)
    _pg_user->hwInhibit = (_pg_data[_pg_byteindex] >> 7);

    // 1 = Software inhibit is active (ESC is disabled)
    _pg_user->swInhibit = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // 0 = Active Freewheeling is not enabled, 1 = Active Freewheeling is enabled
    _pg_user->afwEnabled = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // 0 = Motor direction is FORWARDS, 1= Motor direction is REVERSE
    _pg_user->direction = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if the ESC command timeout period has elapsed (and the ESC is in STANDBY mode)
    _pg_user->timeout = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // 1 = in starting mode (0 = stopped or running)
    _pg_user->starting = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // 0 = most recent command from CAN, 1 = most recent command from PWM
    _pg_user->commandSource = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // ESC is running
    _pg_user->running = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeESC_LegacyStatusBits_t

/*!
 * \brief Encode a ESC_LegacyWarningBits_t into a byte array
 *
 * Warning bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeESC_LegacyWarningBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ESC_LegacyWarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Set if RPM signal is not detected
    _pg_data[_pg_byteindex] = (uint8_t)_pg_user->noRPMSignal << 7;

    // Set if the ESC motor speed exceeds the configured warning threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->overspeed << 6;

    // Set if the ESC motor current (positive or negative) exceeds the configured warning threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->overcurrent << 5;

    // Set if the internal ESC temperature is above the warning threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->escTemperature << 4;

    // Set if the motor temperature is above the warning threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->motorTemperature << 3;

    // Set if the input voltage is below the minimum threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->undervoltage << 2;

    // Set if the input voltage is above the maximum threshold
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->overvoltage << 1;

    // Set if hardware PWM input is enabled but invalid
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->invalidPWMsignal;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeESC_LegacyWarningBits_t

/*!
 * \brief Decode a ESC_LegacyWarningBits_t from a byte array
 *
 * Warning bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeESC_LegacyWarningBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ESC_LegacyWarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Set if RPM signal is not detected
    _pg_user->noRPMSignal = (_pg_data[_pg_byteindex] >> 7);

    // Set if the ESC motor speed exceeds the configured warning threshold
    _pg_user->overspeed = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if the ESC motor current (positive or negative) exceeds the configured warning threshold
    _pg_user->overcurrent = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if the internal ESC temperature is above the warning threshold
    _pg_user->escTemperature = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Set if the motor temperature is above the warning threshold
    _pg_user->motorTemperature = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Set if the input voltage is below the minimum threshold
    _pg_user->undervoltage = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Set if the input voltage is above the maximum threshold
    _pg_user->overvoltage = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Set if hardware PWM input is enabled but invalid
    _pg_user->invalidPWMsignal = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeESC_LegacyWarningBits_t

/*!
 * \brief Encode a ESC_LegacyErrorBits_t into a byte array
 *
 * Error bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeESC_LegacyErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ESC_LegacyErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Set if communication link to the motor controller is lost
    _pg_data[_pg_byteindex] = (uint8_t)_pg_user->linkError << 7;

    // Set if the ESC has detected an overcurrent event and is actively folding back duty cycle
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->foldback << 6;

    // Set if the settings checksum does not match the programmed values
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->settingsChecksum << 5;

    // Set if the motor settings are invalid
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->motorSettings << 4;

    // Reserved for future use
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->reservedD << 3;

    // Reserved for future use
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->reservedE << 2;

    // Reserved for future use
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->reservedF << 1;

    // Reserved for future use
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_user->reservedG;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeESC_LegacyErrorBits_t

/*!
 * \brief Decode a ESC_LegacyErrorBits_t from a byte array
 *
 * Error bits associated with the legacy (gen-1) ESC
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeESC_LegacyErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ESC_LegacyErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Set if communication link to the motor controller is lost
    _pg_user->linkError = (_pg_data[_pg_byteindex] >> 7);

    // Set if the ESC has detected an overcurrent event and is actively folding back duty cycle
    _pg_user->foldback = ((_pg_data[_pg_byteindex] >> 6) & 0x1);

    // Set if the settings checksum does not match the programmed values
    _pg_user->settingsChecksum = ((_pg_data[_pg_byteindex] >> 5) & 0x1);

    // Set if the motor settings are invalid
    _pg_user->motorSettings = ((_pg_data[_pg_byteindex] >> 4) & 0x1);

    // Reserved for future use
    _pg_user->reservedD = ((_pg_data[_pg_byteindex] >> 3) & 0x1);

    // Reserved for future use
    _pg_user->reservedE = ((_pg_data[_pg_byteindex] >> 2) & 0x1);

    // Reserved for future use
    _pg_user->reservedF = ((_pg_data[_pg_byteindex] >> 1) & 0x1);

    // Reserved for future use
    _pg_user->reservedG = ((_pg_data[_pg_byteindex]) & 0x1);
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeESC_LegacyErrorBits_t

// end of LegacyESCDefines.c
