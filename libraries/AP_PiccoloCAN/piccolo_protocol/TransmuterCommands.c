// TransmuterCommands.c was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "TransmuterCommands.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Lookup label for 'TransmuterSystemCommands' enum entry
 * 
 * \param value is the integer value of the enum entry
 * \return string label of the given entry
 */
const char* TransmuterSystemCommands_EnumLabel(int value)
{
    switch (value)
    {
    default:
        return "";
    case CMD_TRANSMUTER_SET_CURRENT_TARGET_AUTO:
        return "CMD_TRANSMUTER_SET_CURRENT_TARGET_AUTO";
    case CMD_TRANSMUTER_SET_CURRENT_TARGET_MANUAL:
        return "CMD_TRANSMUTER_SET_CURRENT_TARGET_MANUAL";
    case CMD_TRANSMUTER_SET_RPM_TARGET_AUTO:
        return "CMD_TRANSMUTER_SET_RPM_TARGET_AUTO";
    case CMD_TRANSMUTER_SET_RPM_TARGET_MANUAL:
        return "CMD_TRANSMUTER_SET_RPM_TARGET_MANUAL";
    case CMD_TRANSMUTER_REQUEST_HF_DATA:
        return "CMD_TRANSMUTER_REQUEST_HF_DATA";
    }
}

/*!
 * \brief Create the Transmuter_SetCurrentTargetAuto packet
 *
 * Set current target to auto mode
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_SetCurrentTargetAutoPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_TRANSMUTER_SET_CURRENT_TARGET_AUTO), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_SetCurrentTargetAutoPacketID());

}// encodeTransmuter_SetCurrentTargetAutoPacket

/*!
 * \brief Decode the Transmuter_SetCurrentTargetAuto packet
 *
 * Set current target to auto mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_SetCurrentTargetAutoPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_SetCurrentTargetAutoPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_SetCurrentTargetAutoMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_TRANSMUTER_SET_CURRENT_TARGET_AUTO)
        return 0;

    return 1;

}// decodeTransmuter_SetCurrentTargetAutoPacket

/*!
 * \brief Create the Transmuter_SetCurrentTargetManual packet
 *
 * Set current target to auto mode
 * \param _pg_pkt points to the packet which will be created by this function
 * \param current is 
 */
void encodeTransmuter_SetCurrentTargetManualPacket(void* _pg_pkt, float current)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_TRANSMUTER_SET_CURRENT_TARGET_MANUAL), _pg_data, &_pg_byteindex);

    // Range of current is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(current, _pg_data, &_pg_byteindex, 128.498039f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_SetCurrentTargetManualPacketID());

}// encodeTransmuter_SetCurrentTargetManualPacket

/*!
 * \brief Decode the Transmuter_SetCurrentTargetManual packet
 *
 * Set current target to auto mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \param current receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_SetCurrentTargetManualPacket(const void* _pg_pkt, float* current)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_SetCurrentTargetManualPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_SetCurrentTargetManualMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_TRANSMUTER_SET_CURRENT_TARGET_MANUAL)
        return 0;

    // Range of current is -255.0f to 255.0f.
    (*current) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    return 1;

}// decodeTransmuter_SetCurrentTargetManualPacket

/*!
 * \brief Create the Transmuter_SetRpmTargetAuto packet
 *
 * Set RPM target to auto mode
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_SetRpmTargetAutoPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_TRANSMUTER_SET_RPM_TARGET_AUTO), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_SetRpmTargetAutoPacketID());

}// encodeTransmuter_SetRpmTargetAutoPacket

/*!
 * \brief Decode the Transmuter_SetRpmTargetAuto packet
 *
 * Set RPM target to auto mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_SetRpmTargetAutoPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_SetRpmTargetAutoPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_SetRpmTargetAutoMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_TRANSMUTER_SET_RPM_TARGET_AUTO)
        return 0;

    return 1;

}// decodeTransmuter_SetRpmTargetAutoPacket

/*!
 * \brief Create the Transmuter_SetRpmTargetManual packet
 *
 * Set RPM target to auto mode
 * \param _pg_pkt points to the packet which will be created by this function
 * \param rpm is Manual RPM command
 */
void encodeTransmuter_SetRpmTargetManualPacket(void* _pg_pkt, uint16_t rpm)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_TRANSMUTER_SET_RPM_TARGET_MANUAL), _pg_data, &_pg_byteindex);

    // Manual RPM command
    // Range of rpm is 0 to 65535.
    uint16ToBeBytes(rpm, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_SetRpmTargetManualPacketID());

}// encodeTransmuter_SetRpmTargetManualPacket

/*!
 * \brief Decode the Transmuter_SetRpmTargetManual packet
 *
 * Set RPM target to auto mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \param rpm receives Manual RPM command
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_SetRpmTargetManualPacket(const void* _pg_pkt, uint16_t* rpm)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_SetRpmTargetManualPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_SetRpmTargetManualMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_TRANSMUTER_SET_RPM_TARGET_MANUAL)
        return 0;

    // Manual RPM command
    // Range of rpm is 0 to 65535.
    (*rpm) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_SetRpmTargetManualPacket
// end of TransmuterCommands.c
