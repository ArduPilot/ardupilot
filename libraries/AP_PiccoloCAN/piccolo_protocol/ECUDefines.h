// ECUDefines.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */
 

#ifndef _ECUDEFINES_H
#define _ECUDEFINES_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include <stdbool.h>
#include "ECUProtocol.h"

typedef struct
{
    bool     servoLink;      //!< 1 if CAN servo is not connected
    bool     servoPosition;  //!< 1 if CAN servo is reporting a position error
    unsigned reserved_A : 6; //!< Reserved for future use
    unsigned reserved_B : 8; //!< Reserved for future use
    unsigned reserved_C : 8; //!< Reserved for future use
    unsigned reserved_D : 8; //!< Reserved for future use
}ECU_AuxiliaryErrorBits_t;

//! return the minimum encoded length for the ECU_AuxiliaryErrorBits_t structure
#define getMinLengthOfECU_AuxiliaryErrorBits_t() (4)

//! return the maximum encoded length for the ECU_AuxiliaryErrorBits_t structure
#define getMaxLengthOfECU_AuxiliaryErrorBits_t() (4)

//! Encode a ECU_AuxiliaryErrorBits_t into a byte array
void encodeECU_AuxiliaryErrorBits_t(uint8_t* data, int* bytecount, const ECU_AuxiliaryErrorBits_t* user);

//! Decode a ECU_AuxiliaryErrorBits_t from a byte array
int decodeECU_AuxiliaryErrorBits_t(const uint8_t* data, int* bytecount, ECU_AuxiliaryErrorBits_t* user);

typedef struct
{
    unsigned knockControl : 1;              //!< Knock control error
    unsigned afCloseLoop : 1;               //!< AF closed loop error
    unsigned eepromError : 1;               //!< EEPROM error
    unsigned cmosRam : 1;                   //!< CMOS RAM error
    unsigned overVoltage : 1;               //!< Over voltage error
    unsigned powerDown : 1;                 //!< Power down error
    unsigned knockSensor : 1;               //!< Knock sensor error
    unsigned overBoost : 1;                 //!< Over boost error
    unsigned cam2Pos : 1;                   //!< CAM2 position error
    unsigned cam1Pos : 1;                   //!< CAM1 position error
    unsigned highSpeedInput2 : 1;           //!< High speed input 1 error
    unsigned highSpeedInput1 : 1;           //!< High speed input 2 error
    unsigned tooManyCylPulse : 1;           //!< Set if too many cylinder pulses
    unsigned tooFewCylPulse : 1;            //!< Set if too few cylinder pulses
    unsigned syncInputPulseMissing : 1;     //!< Set if sync input pulse missing
    unsigned cylinderInputPulseMissing : 1; //!< Set if cylinder input pulse missing
    unsigned af2Sensor : 1;                 //!< Air fuel sensor 2 error
    unsigned af1Sensor : 1;                 //!< Air fuel sensor 1 error
    unsigned baroSensor : 1;                //!< Barometric pressure sensor error
    unsigned ebpSensor : 1;                 //!< Exhaust back pressure sensor error
    unsigned mapSensor : 1;                 //!< Manifold pressure sensor error
    unsigned tpsSensor : 1;                 //!< Throttle position sensor error
    unsigned chtSensor : 1;                 //!< Cylinder head temperature sensor error
    unsigned matSensor : 1;                 //!< Manifold pressure sensor error
}ECU_AutronicErrorBits_t;

//! return the minimum encoded length for the ECU_AutronicErrorBits_t structure
#define getMinLengthOfECU_AutronicErrorBits_t() (4)

//! return the maximum encoded length for the ECU_AutronicErrorBits_t structure
#define getMaxLengthOfECU_AutronicErrorBits_t() (4)

//! Encode a ECU_AutronicErrorBits_t into a byte array
void encodeECU_AutronicErrorBits_t(uint8_t* data, int* bytecount, const ECU_AutronicErrorBits_t* user);

//! Decode a ECU_AutronicErrorBits_t from a byte array
int decodeECU_AutronicErrorBits_t(const uint8_t* data, int* bytecount, ECU_AutronicErrorBits_t* user);

typedef struct
{
    ECU_AutronicErrorBits_t  autronic;  //!< Error information for autronic processor
    ECU_AuxiliaryErrorBits_t auxiliary; //!< Error information for auxiliary processor
}ECU_ErrorBits_t;

//! return the minimum encoded length for the ECU_ErrorBits_t structure
#define getMinLengthOfECU_ErrorBits_t() (8)

//! return the maximum encoded length for the ECU_ErrorBits_t structure
#define getMaxLengthOfECU_ErrorBits_t() (8)

//! Encode a ECU_ErrorBits_t into a byte array
void encodeECU_ErrorBits_t(uint8_t* data, int* bytecount, const ECU_ErrorBits_t* user);

//! Decode a ECU_ErrorBits_t from a byte array
int decodeECU_ErrorBits_t(const uint8_t* data, int* bytecount, ECU_ErrorBits_t* user);

typedef struct
{
    unsigned reserved : 7; //!< reserved for future use
    bool     delayOnTemp;  //!< Set to base the delay on temperature, else the delay is manually set
}ECU_ThrottleDelayConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleDelayConfigBits_t structure
#define getMinLengthOfECU_ThrottleDelayConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleDelayConfigBits_t structure
#define getMaxLengthOfECU_ThrottleDelayConfigBits_t() (1)

//! Encode a ECU_ThrottleDelayConfigBits_t into a byte array
void encodeECU_ThrottleDelayConfigBits_t(uint8_t* data, int* bytecount, const ECU_ThrottleDelayConfigBits_t* user);

//! Decode a ECU_ThrottleDelayConfigBits_t from a byte array
int decodeECU_ThrottleDelayConfigBits_t(const uint8_t* data, int* bytecount, ECU_ThrottleDelayConfigBits_t* user);

typedef struct
{
    bool servoPassthrough;    //!< Enable pass-through of CAN servo data over serial link
    bool canThrottleDetected; //!< Set if the CAN throttle is detected
    bool canThrottle;         //!< Set if CAN throttle is enabled. This bit is ignored when this packet is sent to the ECU. To enable CAN throttle you must use system commands
}ECU_ThrottleConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleConfigBits_t structure
#define getMinLengthOfECU_ThrottleConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleConfigBits_t structure
#define getMaxLengthOfECU_ThrottleConfigBits_t() (1)

//! Encode a ECU_ThrottleConfigBits_t into a byte array
void encodeECU_ThrottleConfigBits_t(uint8_t* data, int* bytecount, const ECU_ThrottleConfigBits_t* user);

//! Decode a ECU_ThrottleConfigBits_t from a byte array
int decodeECU_ThrottleConfigBits_t(const uint8_t* data, int* bytecount, ECU_ThrottleConfigBits_t* user);

typedef struct
{
    bool curveActive; //!< Throttle curve is active
}ECU_ThrottleCurveConfigBits_t;

//! return the minimum encoded length for the ECU_ThrottleCurveConfigBits_t structure
#define getMinLengthOfECU_ThrottleCurveConfigBits_t() (1)

//! return the maximum encoded length for the ECU_ThrottleCurveConfigBits_t structure
#define getMaxLengthOfECU_ThrottleCurveConfigBits_t() (1)

//! Encode a ECU_ThrottleCurveConfigBits_t into a byte array
void encodeECU_ThrottleCurveConfigBits_t(uint8_t* data, int* bytecount, const ECU_ThrottleCurveConfigBits_t* user);

//! Decode a ECU_ThrottleCurveConfigBits_t from a byte array
int decodeECU_ThrottleCurveConfigBits_t(const uint8_t* data, int* bytecount, ECU_ThrottleCurveConfigBits_t* user);

typedef struct
{
    uint16_t powerCycles;          
    uint16_t customerID_deprecated; //!< Deprecated - DO NOT USE
    uint8_t  versionHardware;      
    uint8_t  reservedA;             //!< reserved for future use
    uint8_t  reservedB;             //!< reserved for future use
}ECU_ECUSettings_t;

//! return the minimum encoded length for the ECU_ECUSettings_t structure
#define getMinLengthOfECU_ECUSettings_t() (7)

//! return the maximum encoded length for the ECU_ECUSettings_t structure
#define getMaxLengthOfECU_ECUSettings_t() (7)

//! Encode a ECU_ECUSettings_t into a byte array
void encodeECU_ECUSettings_t(uint8_t* data, int* bytecount, const ECU_ECUSettings_t* user);

//! Decode a ECU_ECUSettings_t from a byte array
int decodeECU_ECUSettings_t(const uint8_t* data, int* bytecount, ECU_ECUSettings_t* user);

typedef struct
{
    bool servoPassthrough; //!< If set, the ECU will pass servo CAN packet data over the serial link
    bool piccoloUplink;    //!< If set, the ECU will decode CAN messages in the PICCOLO_DATA_UP group
    bool autronicRelay;    //!< If set, the ECU supports Autronic message passthrough
    bool dualPump;         //!< If set, the ECU supports redundant fuel pump control
    bool piPump;           //!< If set, the ECU runs a PI controller for fuel pressure. If not set, it uses bang-bang control
    bool mapCorrection;    //!< If set, the ECU will automatically compensate for degredation of the MAP sensor over time
    bool watchdog;         //!< If set, the ECU watchdog timer is enabled
    bool debug;            //!< If set, the ECU is compiled with extra debug functionality enabled
}ECU_CompileOptions_t;

//! return the minimum encoded length for the ECU_CompileOptions_t structure
#define getMinLengthOfECU_CompileOptions_t() (2)

//! return the maximum encoded length for the ECU_CompileOptions_t structure
#define getMaxLengthOfECU_CompileOptions_t() (2)

//! Encode a ECU_CompileOptions_t into a byte array
void encodeECU_CompileOptions_t(uint8_t* data, int* bytecount, const ECU_CompileOptions_t* user);

//! Decode a ECU_CompileOptions_t from a byte array
int decodeECU_CompileOptions_t(const uint8_t* data, int* bytecount, ECU_CompileOptions_t* user);

#ifdef __cplusplus
}
#endif
#endif // _ECUDEFINES_H
