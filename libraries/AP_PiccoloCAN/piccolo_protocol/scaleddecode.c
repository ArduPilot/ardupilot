// scaleddecode.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "scaleddecode.h"
#include "fielddecode.h"


/*!
 * Compute a float using inverse floating point scaling from the base integer
 * type used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param invscaler is multiplied by the integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the scaling function.
 * \return the correctly scaled decoded value: return = min + value*invscaler.
 */
float float32ScaledFromBitfield(unsigned int value, float min, float invscaler)
{
    return (float)(min + invscaler*value);
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint32FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint32FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int32FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int32FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint24FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint24FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int24FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int24FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint16FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint16FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int16FromBeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int16FromLeBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = encoded*invscaler.
 */
float float32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, float min, float invscaler)
{
    return (float)(min + invscaler*uint8FromBytes(bytes, index));
}


/*!
 * Decode a float from a byte stream by inverse floating point scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param invscaler is multiplied by the decoded integer to create the return value.
 *        invscaler should be the inverse of the scaler given to the encode function.
 * \return the correctly scaled decoded value: return = min + encoded*invscaler.
 */
float float32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, float invscaler)
{
    return (float)(invscaler*int8FromBytes(bytes, index));
}


/*!
 * Compute a uint32_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFromBitfield(unsigned int value, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + value/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 4
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 3
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint32_t uint32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (uint32_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint32_t from a byte stream by inverse integer scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint32_t uint32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (uint32_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int32_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFromBitfield(unsigned int value, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + value/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom4UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom4UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom4SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int32FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 4 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 4 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom4SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int32FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom3UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom3UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom3SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int24FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 3 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 3 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom3SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int24FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int32_t int32ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int32_t min, uint32_t divisor)
{
    return (int32_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int32_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int32_t int32ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint32_t divisor)
{
    return (int32_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a uint16_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFromBitfield(unsigned int value, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + value/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * signed bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 2
 * signed bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint16_t uint16ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (uint16_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint16_t from a byte stream by inverse integer scaling from 1
 * signed byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint16_t uint16ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (uint16_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int16_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFromBitfield(unsigned int value, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + value/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom2UnsignedBeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2
 * unsigned bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom2UnsignedLeBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in big endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom2SignedBeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int16FromBeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 2 signed
 * bytes in little endian order.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 2 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom2SignedLeBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int16FromLeBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int16_t int16ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int16_t min, uint16_t divisor)
{
    return (int16_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int16_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int16_t int16ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint16_t divisor)
{
    return (int16_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a uint8_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint8_t uint8ScaledFromBitfield(unsigned int value, int8_t min, uint8_t divisor)
{
    return (uint8_t)(min + value/divisor);
}


/*!
 * Decode a uint8_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
uint8_t uint8ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int8_t min, uint8_t divisor)
{
    return (uint8_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a uint8_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
uint8_t uint8ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint8_t divisor)
{
    return (uint8_t)(int8FromBytes(bytes, index)/divisor);
}


/*!
 * Compute a int8_t using inverse integer scaling from the base integer type
 * used for bitfields.
 * \param value is the integer bitfield number to inverse scale
 * \param min is the minimum value that can be represented.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int8_t int8ScaledFromBitfield(unsigned int value, int8_t min, uint8_t divisor)
{
    return (int8_t)(min + value/divisor);
}


/*!
 * Decode a int8_t from a byte stream by inverse integer scaling from 1
 * unsigned byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param min is the minimum value that can be decoded.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = min + encoded/divisor.
 */
int8_t int8ScaledFrom1UnsignedBytes(const uint8_t* bytes, int* index, int8_t min, uint8_t divisor)
{
    return (int8_t)(min + uint8FromBytes(bytes, index)/divisor);
}


/*!
 * Decode a int8_t from a byte stream by inverse integer scaling from 1 signed
 * byte.
 * \param bytes is a pointer to the byte stream to decode.
 * \param index gives the location of the first byte in the byte stream, and
 *        will be incremented by 1 when this function is complete.
 * \param divisor is divided into the encoded integer to create the return value.
 * \return the correctly scaled decoded value: return = encoded/divisor.
 */
int8_t int8ScaledFrom1SignedBytes(const uint8_t* bytes, int* index, uint8_t divisor)
{
    return (int8_t)(int8FromBytes(bytes, index)/divisor);
}


// end of scaleddecode.c
