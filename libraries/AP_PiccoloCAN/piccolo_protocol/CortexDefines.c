// CortexDefines.c was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "CortexDefines.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a Cortex_StatusBits_t into a byte array
 *
 * Status bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeCortex_StatusBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Cortex_StatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved bits
    _pg_data[_pg_byteindex] = 0;

    // Cortex operational mode
    // Range of mode is 0 to 15.
    _pg_data[_pg_byteindex] |= (uint8_t)limitMax(_pg_user->mode, 15);

    // Warning flag (refer to 'warning' structure)
    _pg_data[_pg_byteindex + 1] = (uint8_t)((_pg_user->warning == true) ? 1 : 0) << 7;

    // Error flag (refer to 'error' structure)
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->error == true) ? 1 : 0) << 6;

    // Set if generator power limit is currently active
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->powerLimit == true) ? 1 : 0) << 5;

    // Set if CHPS is running from shore power
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->shorePower == true) ? 1 : 0) << 4;

    // Set if the CHPS is ready to run the engine
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->readyToRun == true) ? 1 : 0) << 3;

    // Set if the CHPS is hardware inhibited
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->inhibited == true) ? 1 : 0) << 2;

    // Reserved bits

    // Set if the CHPS is in calibration mode
    _pg_data[_pg_byteindex + 2] = (uint8_t)((_pg_user->calibrationMode == true) ? 1 : 0) << 7;

    // Reserved byte

    // Battery charger enabled status
    // Range of batteryCharger is 0 to 3.
    _pg_data[_pg_byteindex + 3] = (uint8_t)limitMax(_pg_user->batteryCharger, 3) << 6;

    // Avionics output rail enabled status
    // Range of avionicsRail is 0 to 3.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(_pg_user->avionicsRail, 3) << 4;

    // Payload output rail enabled status
    // Range of payloadRail is 0 to 3.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(_pg_user->payloadRail, 3) << 2;

    // Servo output rail enabled status
    // Range of servoRail is 0 to 3.
    _pg_data[_pg_byteindex + 3] |= (uint8_t)limitMax(_pg_user->servoRail, 3);
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeCortex_StatusBits_t

/*!
 * \brief Decode a Cortex_StatusBits_t from a byte array
 *
 * Status bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeCortex_StatusBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Cortex_StatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved bits

    // Cortex operational mode
    // Range of mode is 0 to 15.
    _pg_user->mode = ((_pg_data[_pg_byteindex]) & 0xF);

    // Warning flag (refer to 'warning' structure)
    _pg_user->warning = ((_pg_data[_pg_byteindex + 1] >> 7)) ? true : false;

    // Error flag (refer to 'error' structure)
    _pg_user->error = (((_pg_data[_pg_byteindex + 1] >> 6) & 0x1)) ? true : false;

    // Set if generator power limit is currently active
    _pg_user->powerLimit = (((_pg_data[_pg_byteindex + 1] >> 5) & 0x1)) ? true : false;

    // Set if CHPS is running from shore power
    _pg_user->shorePower = (((_pg_data[_pg_byteindex + 1] >> 4) & 0x1)) ? true : false;

    // Set if the CHPS is ready to run the engine
    _pg_user->readyToRun = (((_pg_data[_pg_byteindex + 1] >> 3) & 0x1)) ? true : false;

    // Set if the CHPS is hardware inhibited
    _pg_user->inhibited = (((_pg_data[_pg_byteindex + 1] >> 2) & 0x1)) ? true : false;

    // Reserved bits

    // Set if the CHPS is in calibration mode
    _pg_user->calibrationMode = ((_pg_data[_pg_byteindex + 2] >> 7)) ? true : false;

    // Reserved byte

    // Battery charger enabled status
    // Range of batteryCharger is 0 to 3.
    _pg_user->batteryCharger = (_pg_data[_pg_byteindex + 3] >> 6);

    // Avionics output rail enabled status
    // Range of avionicsRail is 0 to 3.
    _pg_user->avionicsRail = ((_pg_data[_pg_byteindex + 3] >> 4) & 0x3);

    // Payload output rail enabled status
    // Range of payloadRail is 0 to 3.
    _pg_user->payloadRail = ((_pg_data[_pg_byteindex + 3] >> 2) & 0x3);

    // Servo output rail enabled status
    // Range of servoRail is 0 to 3.
    _pg_user->servoRail = ((_pg_data[_pg_byteindex + 3]) & 0x3);
    _pg_byteindex += 4; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeCortex_StatusBits_t

/*!
 * \brief Encode a Cortex_WarningBits_t into a byte array
 *
 * Warning bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeCortex_WarningBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Cortex_WarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Generator warning - refer to the motor warnings packet
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->generator == true) ? 1 : 0) << 7;

    // Device overtemperature warning
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->temperature == true) ? 1 : 0) << 6;

    // Generator temperature limit warning
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->generatorTempLimit == true) ? 1 : 0) << 5;

    // Generator current limit warning
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->generatorCurrentLimit == true) ? 1 : 0) << 4;

    // Engine power limit warning
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enginePowerLimit == true) ? 1 : 0) << 3;

    // Power loss warning (engine is not developing any power)
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->powerLoss == true) ? 1 : 0) << 2;

    // Low RPM warning (engine speed is below minimum RPM threshold)
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->lowRpm == true) ? 1 : 0) << 1;

    // Battery charge current limit warning
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->batteryChargeCurrentLimit == true) ? 1 : 0);
    _pg_byteindex += 1; // close bit field

    // Reserved byte
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeCortex_WarningBits_t

/*!
 * \brief Decode a Cortex_WarningBits_t from a byte array
 *
 * Warning bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeCortex_WarningBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Cortex_WarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Generator warning - refer to the motor warnings packet
    _pg_user->generator = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Device overtemperature warning
    _pg_user->temperature = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Generator temperature limit warning
    _pg_user->generatorTempLimit = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Generator current limit warning
    _pg_user->generatorCurrentLimit = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Engine power limit warning
    _pg_user->enginePowerLimit = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Power loss warning (engine is not developing any power)
    _pg_user->powerLoss = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;

    // Low RPM warning (engine speed is below minimum RPM threshold)
    _pg_user->lowRpm = (((_pg_data[_pg_byteindex] >> 1) & 0x1)) ? true : false;

    // Battery charge current limit warning
    _pg_user->batteryChargeCurrentLimit = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    // Reserved byte
    _pg_byteindex += 1;

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeCortex_WarningBits_t

/*!
 * \brief Encode a Cortex_ErrorBits_t into a byte array
 *
 * Error bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeCortex_ErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Cortex_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Critical generator fault - refer to the motor errors packet
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->generator == true) ? 1 : 0) << 7;

    // Critical error occurred during engine cranking
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->cranking == true) ? 1 : 0) << 6;

    // Critical error occurred during rail configuration
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->avionicsRail == true) ? 1 : 0) << 5;

    // Critical error occurred during rail configuration
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->payloadRail == true) ? 1 : 0) << 4;

    // Critical error occurred during rail configuration
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->servoRail == true) ? 1 : 0) << 3;

    // Critical error occurred during rail configuration
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->batteryChargerRail == true) ? 1 : 0) << 2;

    // Power map is improperly configured
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->powerMap == true) ? 1 : 0) << 1;

    // Engine was disabled due to low RPM
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->lowRpm == true) ? 1 : 0);

    // Engine was disabled due to loss of power
    _pg_data[_pg_byteindex + 1] = (uint8_t)((_pg_user->powerLoss == true) ? 1 : 0) << 7;

    // Reserved byte
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeCortex_ErrorBits_t

/*!
 * \brief Decode a Cortex_ErrorBits_t from a byte array
 *
 * Error bits for the TelemetryStatus packet
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeCortex_ErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Cortex_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Critical generator fault - refer to the motor errors packet
    _pg_user->generator = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Critical error occurred during engine cranking
    _pg_user->cranking = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Critical error occurred during rail configuration
    _pg_user->avionicsRail = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Critical error occurred during rail configuration
    _pg_user->payloadRail = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Critical error occurred during rail configuration
    _pg_user->servoRail = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Critical error occurred during rail configuration
    _pg_user->batteryChargerRail = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;

    // Power map is improperly configured
    _pg_user->powerMap = (((_pg_data[_pg_byteindex] >> 1) & 0x1)) ? true : false;

    // Engine was disabled due to low RPM
    _pg_user->lowRpm = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;

    // Engine was disabled due to loss of power
    _pg_user->powerLoss = ((_pg_data[_pg_byteindex + 1] >> 7)) ? true : false;

    // Reserved byte
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeCortex_ErrorBits_t

/*!
 * \brief Encode a Cortex_TelemetryPackets_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeCortex_TelemetryPackets_t(uint8_t* _pg_data, int* _pg_bytecount, const Cortex_TelemetryPackets_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable TelemetryStatus packet
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->status == true) ? 1 : 0) << 7;

    // Enable TelemetryGenerator packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->generator == true) ? 1 : 0) << 6;

    // Enable TelemetryBattery packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->battery == true) ? 1 : 0) << 5;

    // Enable TelemetryOutputRail packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->outputRail == true) ? 1 : 0) << 4;

    // Enable TelemetryController packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->controller == true) ? 1 : 0) << 3;

    // Enable TelemetryEngine packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->engine == true) ? 1 : 0) << 2;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeCortex_TelemetryPackets_t

/*!
 * \brief Decode a Cortex_TelemetryPackets_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeCortex_TelemetryPackets_t(const uint8_t* _pg_data, int* _pg_bytecount, Cortex_TelemetryPackets_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable TelemetryStatus packet
    _pg_user->status = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Enable TelemetryGenerator packet
    _pg_user->generator = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Enable TelemetryBattery packet
    _pg_user->battery = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Enable TelemetryOutputRail packet
    _pg_user->outputRail = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Enable TelemetryController packet
    _pg_user->controller = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Enable TelemetryEngine packet
    _pg_user->engine = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeCortex_TelemetryPackets_t

/*!
 * \brief Encode a Cortex_OutputRailSettings_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeCortex_OutputRailSettings_t(uint8_t* _pg_data, int* _pg_bytecount, const Cortex_OutputRailSettings_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Enable output rail at startup
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->enableOnStartup == true) ? 1 : 0) << 7;

    // Reserved bits

    // Rail voltage. Invalid values will be clipped.
    // Range of voltage is 0 to 1023.
    _pg_tempbitfield = (unsigned int)limitMax(_pg_user->voltage, 1023);
    _pg_data[_pg_byteindex + 1] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeCortex_OutputRailSettings_t

/*!
 * \brief Decode a Cortex_OutputRailSettings_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeCortex_OutputRailSettings_t(const uint8_t* _pg_data, int* _pg_bytecount, Cortex_OutputRailSettings_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;
    unsigned int _pg_tempbitfield = 0;

    // Enable output rail at startup
    _pg_user->enableOnStartup = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Reserved bits

    // Rail voltage. Invalid values will be clipped.
    // Range of voltage is 0 to 1023.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 1];

    _pg_user->voltage = _pg_tempbitfield;
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeCortex_OutputRailSettings_t

// end of CortexDefines.c
