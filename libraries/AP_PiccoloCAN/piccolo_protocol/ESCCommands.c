// ESCCommands.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters
 */

#include "ESCCommands.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the ESC_SetNodeID packet
 *
 * Set the CAN Node ID of the target ESC
 * \param _pg_pkt points to the packet which will be created by this function
 * \param serialNumber is The serial number must match that of the target ESC for the command to be accepted
 * \param nodeID is The new Node ID of the ESC
 */
void encodeESC_SetNodeIDPacket(void* _pg_pkt, uint32_t serialNumber, uint8_t nodeID)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_SET_NODE_ID), _pg_data, &_pg_byteindex);

    // The serial number must match that of the target ESC for the command to be accepted
    // Range of serialNumber is 0 to 4294967295.
    uint32ToBeBytes(serialNumber, _pg_data, &_pg_byteindex);

    // The new Node ID of the ESC
    // Range of nodeID is 0 to 255.
    uint8ToBytes(nodeID, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_SetNodeIDPacketID());

}// encodeESC_SetNodeIDPacket

/*!
 * \brief Decode the ESC_SetNodeID packet
 *
 * Set the CAN Node ID of the target ESC
 * \param _pg_pkt points to the packet being decoded by this function
 * \param serialNumber receives The serial number must match that of the target ESC for the command to be accepted
 * \param nodeID receives The new Node ID of the ESC
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_SetNodeIDPacket(const void* _pg_pkt, uint32_t* serialNumber, uint8_t* nodeID)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_SetNodeIDPacketID())
        return 0;

    if(_pg_numbytes < getESC_SetNodeIDMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_SET_NODE_ID)
        return 0;

    // The serial number must match that of the target ESC for the command to be accepted
    // Range of serialNumber is 0 to 4294967295.
    (*serialNumber) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // The new Node ID of the ESC
    // Range of nodeID is 0 to 255.
    (*nodeID) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeESC_SetNodeIDPacket

/*!
 * \brief Create the ESC_SetUserIDA packet
 *
 * Set User ID A
 * \param _pg_pkt points to the packet which will be created by this function
 * \param id is 
 */
void encodeESC_SetUserIDAPacket(void* _pg_pkt, uint16_t id)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_SET_USER_ID_A), _pg_data, &_pg_byteindex);

    // Range of id is 0 to 65535.
    uint16ToBeBytes(id, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_SetUserIDAPacketID());

}// encodeESC_SetUserIDAPacket

/*!
 * \brief Decode the ESC_SetUserIDA packet
 *
 * Set User ID A
 * \param _pg_pkt points to the packet being decoded by this function
 * \param id receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_SetUserIDAPacket(const void* _pg_pkt, uint16_t* id)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_SetUserIDAPacketID())
        return 0;

    if(_pg_numbytes < getESC_SetUserIDAMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_SET_USER_ID_A)
        return 0;

    // Range of id is 0 to 65535.
    (*id) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeESC_SetUserIDAPacket

/*!
 * \brief Create the ESC_SetUserIDB packet
 *
 * Set User ID B
 * \param _pg_pkt points to the packet which will be created by this function
 * \param id is 
 */
void encodeESC_SetUserIDBPacket(void* _pg_pkt, uint16_t id)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_SET_USER_ID_B), _pg_data, &_pg_byteindex);

    // Range of id is 0 to 65535.
    uint16ToBeBytes(id, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_SetUserIDBPacketID());

}// encodeESC_SetUserIDBPacket

/*!
 * \brief Decode the ESC_SetUserIDB packet
 *
 * Set User ID B
 * \param _pg_pkt points to the packet being decoded by this function
 * \param id receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_SetUserIDBPacket(const void* _pg_pkt, uint16_t* id)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_SetUserIDBPacketID())
        return 0;

    if(_pg_numbytes < getESC_SetUserIDBMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_SET_USER_ID_B)
        return 0;

    // Range of id is 0 to 65535.
    (*id) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeESC_SetUserIDBPacket

/*!
 * \brief Create the ESC_UnlockSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeESC_UnlockSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_UNLOCK_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xA0), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xB0), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0xC0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_UnlockSettingsPacketID());

}// encodeESC_UnlockSettingsPacket

/*!
 * \brief Decode the ESC_UnlockSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_UnlockSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_UnlockSettingsPacketID())
        return 0;

    if(_pg_numbytes < getESC_UnlockSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_UNLOCK_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA0)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xB0)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC0)
        return 0;

    return 1;

}// decodeESC_UnlockSettingsPacket

/*!
 * \brief Create the ESC_LockSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeESC_LockSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_LOCK_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0A), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0B), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x0C), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_LockSettingsPacketID());

}// encodeESC_LockSettingsPacket

/*!
 * \brief Decode the ESC_LockSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_LockSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_LockSettingsPacketID())
        return 0;

    if(_pg_numbytes < getESC_LockSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_LOCK_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0A)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0B)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x0C)
        return 0;

    return 1;

}// decodeESC_LockSettingsPacket

/*!
 * \brief Create the ESC_ValidateSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeESC_ValidateSettingsPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_VALIDATE_SETTINGS), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x1A), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x2B), _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(0x3C), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_ValidateSettingsPacketID());

}// encodeESC_ValidateSettingsPacket

/*!
 * \brief Decode the ESC_ValidateSettings packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_ValidateSettingsPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_ValidateSettingsPacketID())
        return 0;

    if(_pg_numbytes < getESC_ValidateSettingsMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_VALIDATE_SETTINGS)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x1A)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x2B)
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x3C)
        return 0;

    return 1;

}// decodeESC_ValidateSettingsPacket

/*!
 * \brief Create the ESC_ResetMotorRunTime packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 * \param serialNumber is Serial number must match ESC
 */
void encodeESC_ResetMotorRunTimePacket(void* _pg_pkt, uint16_t serialNumber)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_RESET_MOTOR_RUN_TIME), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xAB), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xCD), _pg_data, &_pg_byteindex);

    // Serial number must match ESC
    // Range of serialNumber is 0 to 65535.
    uint16ToBeBytes(serialNumber, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_ResetMotorRunTimePacketID());

}// encodeESC_ResetMotorRunTimePacket

/*!
 * \brief Decode the ESC_ResetMotorRunTime packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \param serialNumber receives Serial number must match ESC
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_ResetMotorRunTimePacket(const void* _pg_pkt, uint16_t* serialNumber)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_ResetMotorRunTimePacketID())
        return 0;

    if(_pg_numbytes < getESC_ResetMotorRunTimeMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_RESET_MOTOR_RUN_TIME)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xAB)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xCD)
        return 0;

    // Serial number must match ESC
    // Range of serialNumber is 0 to 65535.
    (*serialNumber) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeESC_ResetMotorRunTimePacket

/*!
 * \brief Create the ESC_EnterBootloader packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeESC_EnterBootloaderPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_ENTER_BOOTLOADER), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xAA), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0x55), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_EnterBootloaderPacketID());

}// encodeESC_EnterBootloaderPacket

/*!
 * \brief Decode the ESC_EnterBootloader packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_EnterBootloaderPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_EnterBootloaderPacketID())
        return 0;

    if(_pg_numbytes < getESC_EnterBootloaderMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_ENTER_BOOTLOADER)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xAA)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x55)
        return 0;

    return 1;

}// decodeESC_EnterBootloaderPacket

/*!
 * \brief Create the ESC_ResetESC packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeESC_ResetESCPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getESCVelocityPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes((uint8_t)(CMD_ESC_RESET), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xAA), _pg_data, &_pg_byteindex);

    // This byte is required for the command to be accepted
    uint8ToBytes((uint8_t)(0xCC), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishESCVelocityPacket(_pg_pkt, _pg_byteindex, getESC_ResetESCPacketID());

}// encodeESC_ResetESCPacket

/*!
 * \brief Decode the ESC_ResetESC packet
 *
 * Send a configuration command to the ESC (followed by optional command data
 * bytes)
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeESC_ResetESCPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getESCVelocityPacketDataConst(_pg_pkt);
    int _pg_numbytes = getESCVelocityPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getESCVelocityPacketID(_pg_pkt) != getESC_ResetESCPacketID())
        return 0;

    if(_pg_numbytes < getESC_ResetESCMinDataLength())
        return 0;

    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) CMD_ESC_RESET)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xAA)
        return 0;

    // This byte is required for the command to be accepted
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xCC)
        return 0;

    return 1;

}// decodeESC_ResetESCPacket
// end of ESCCommands.c
