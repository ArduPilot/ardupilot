// TransmuterPackets.c was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "TransmuterPackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"
#include "TransmuterDefines.h"

/*!
 * \brief Create the Transmuter_EnterStandby packet
 *
 * Put the Transmuter in *STANDBY* mode. If the Transmuter is running it will
 * be disabled.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_EnterStandbyPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xA0), _pg_data, &_pg_byteindex);

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xB0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EnterStandbyPacketID());

}// encodeTransmuter_EnterStandbyPacket

/*!
 * \brief Decode the Transmuter_EnterStandby packet
 *
 * Put the Transmuter in *STANDBY* mode. If the Transmuter is running it will
 * be disabled.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EnterStandbyPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EnterStandbyPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EnterStandbyMinDataLength())
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA0)
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xB0)
        return 0;

    return 1;

}// decodeTransmuter_EnterStandbyPacket

/*!
 * \brief Create the Transmuter_EnterPreflight packet
 *
 * Put the Transmuter in *PREFLIGHT* mode
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_EnterPreflightPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xC0), _pg_data, &_pg_byteindex);

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xD0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EnterPreflightPacketID());

}// encodeTransmuter_EnterPreflightPacket

/*!
 * \brief Decode the Transmuter_EnterPreflight packet
 *
 * Put the Transmuter in *PREFLIGHT* mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EnterPreflightPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EnterPreflightPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EnterPreflightMinDataLength())
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC0)
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xD0)
        return 0;

    return 1;

}// decodeTransmuter_EnterPreflightPacket

/*!
 * \brief Create the Transmuter_EnterWarmup packet
 *
 * Put the Transmuter in *WARMUP* mode. If the engine is not spinning, the
 * Transmuter will enter the engine starting routine.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_EnterWarmupPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for warmup sequence
    uint8ToBytes((uint8_t)(0xC5), _pg_data, &_pg_byteindex);

    // Constant value required for warmup sequence
    uint8ToBytes((uint8_t)(0x5C), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EnterWarmupPacketID());

}// encodeTransmuter_EnterWarmupPacket

/*!
 * \brief Decode the Transmuter_EnterWarmup packet
 *
 * Put the Transmuter in *WARMUP* mode. If the engine is not spinning, the
 * Transmuter will enter the engine starting routine.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EnterWarmupPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EnterWarmupPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EnterWarmupMinDataLength())
        return 0;

    // Constant value required for warmup sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC5)
        return 0;

    // Constant value required for warmup sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x5C)
        return 0;

    return 1;

}// decodeTransmuter_EnterWarmupPacket

/*!
 * \brief Create the Transmuter_EnterRunMode packet
 *
 * Put the Transmuter in *RUN* mode. If the engine is not spinning, the
 * Transmuter will enter the engine starting routine.
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_EnterRunModePacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value requried for run sequence
    uint8ToBytes((uint8_t)(0x5A), _pg_data, &_pg_byteindex);

    // Constant value requried for run sequence
    uint8ToBytes((uint8_t)(0xA5), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EnterRunModePacketID());

}// encodeTransmuter_EnterRunModePacket

/*!
 * \brief Decode the Transmuter_EnterRunMode packet
 *
 * Put the Transmuter in *RUN* mode. If the engine is not spinning, the
 * Transmuter will enter the engine starting routine.
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EnterRunModePacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EnterRunModePacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EnterRunModeMinDataLength())
        return 0;

    // Constant value requried for run sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x5A)
        return 0;

    // Constant value requried for run sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA5)
        return 0;

    return 1;

}// decodeTransmuter_EnterRunModePacket

/*!
 * \brief Create the Transmuter_EnterPWMMode packet
 *
 * Put the Transmtuer in *PWM* mode. The Transmuter will act as a regular ESC
 * and perform ESC PWM commands
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeTransmuter_EnterPWMModePacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value requried for run sequence
    uint8ToBytes((uint8_t)(0x6B), _pg_data, &_pg_byteindex);

    // Constant value requried for run sequence
    uint8ToBytes((uint8_t)(0xB6), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EnterPWMModePacketID());

}// encodeTransmuter_EnterPWMModePacket

/*!
 * \brief Decode the Transmuter_EnterPWMMode packet
 *
 * Put the Transmtuer in *PWM* mode. The Transmuter will act as a regular ESC
 * and perform ESC PWM commands
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EnterPWMModePacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EnterPWMModePacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EnterPWMModeMinDataLength())
        return 0;

    // Constant value requried for run sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x6B)
        return 0;

    // Constant value requried for run sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xB6)
        return 0;

    return 1;

}// decodeTransmuter_EnterPWMModePacket

/*!
 * \brief Create the Transmuter_TelemetryStatus packet
 *
 * The TelemetryStatus packet contains critical operational status information
 * pertaining to the current state of the Transmuter
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryStatusPacketStructure(void* _pg_pkt, const Transmuter_TelemetryStatus_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    encodeTransmuter_StatusBits_t(_pg_data, &_pg_byteindex, &_pg_user->status);

    encodeTransmuter_WarningBits_t(_pg_data, &_pg_byteindex, &_pg_user->warning);

    encodeTransmuter_ErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->errors);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryStatusPacketID());

}// encodeTransmuter_TelemetryStatusPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryStatus packet
 *
 * The TelemetryStatus packet contains critical operational status information
 * pertaining to the current state of the Transmuter
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryStatusPacketStructure(const void* _pg_pkt, Transmuter_TelemetryStatus_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryStatusPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryStatusMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    if(decodeTransmuter_StatusBits_t(_pg_data, &_pg_byteindex, &_pg_user->status) == 0)
        return 0;

    if(decodeTransmuter_WarningBits_t(_pg_data, &_pg_byteindex, &_pg_user->warning) == 0)
        return 0;

    if(decodeTransmuter_ErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->errors) == 0)
        return 0;

    return 1;

}// decodeTransmuter_TelemetryStatusPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryStatus packet
 *
 * The TelemetryStatus packet contains critical operational status information
 * pertaining to the current state of the Transmuter
 * \param _pg_pkt points to the packet which will be created by this function
 * \param status is 
 * \param warning is 
 * \param errors is 
 */
void encodeTransmuter_TelemetryStatusPacket(void* _pg_pkt, const Transmuter_StatusBits_t* status, const Transmuter_WarningBits_t* warning, const Transmuter_ErrorBits_t* errors)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    encodeTransmuter_StatusBits_t(_pg_data, &_pg_byteindex, status);

    encodeTransmuter_WarningBits_t(_pg_data, &_pg_byteindex, warning);

    encodeTransmuter_ErrorBits_t(_pg_data, &_pg_byteindex, errors);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryStatusPacketID());

}// encodeTransmuter_TelemetryStatusPacket

/*!
 * \brief Decode the Transmuter_TelemetryStatus packet
 *
 * The TelemetryStatus packet contains critical operational status information
 * pertaining to the current state of the Transmuter
 * \param _pg_pkt points to the packet being decoded by this function
 * \param status receives 
 * \param warning receives 
 * \param errors receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryStatusPacket(const void* _pg_pkt, Transmuter_StatusBits_t* status, Transmuter_WarningBits_t* warning, Transmuter_ErrorBits_t* errors)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryStatusPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryStatusMinDataLength())
        return 0;

    if(decodeTransmuter_StatusBits_t(_pg_data, &_pg_byteindex, status) == 0)
        return 0;

    if(decodeTransmuter_WarningBits_t(_pg_data, &_pg_byteindex, warning) == 0)
        return 0;

    if(decodeTransmuter_ErrorBits_t(_pg_data, &_pg_byteindex, errors) == 0)
        return 0;

    return 1;

}// decodeTransmuter_TelemetryStatusPacket

/*!
 * \brief Create the Transmuter_TelemetryPower packet
 *
 * The TelemetryPower packet contains information on the current operation
 * point of the engine and generator
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryPowerPacketStructure(void* _pg_pkt, const Transmuter_TelemetryPower_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // System voltage
    // Range of voltage is 0.0f to 128.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->voltage, _pg_data, &_pg_byteindex, 0.0f, 511.992188f);

    // Generator current
    // Range of genCurrent is -500.0f to 500.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->genCurrent, _pg_data, &_pg_byteindex, 65.534f);

    // Battery current
    // Range of batCurrent is -500.0f to 500.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->batCurrent, _pg_data, &_pg_byteindex, 65.534f);

    // Mechanical rotational speed
    // Range of rpm is -32768 to 32767.
    int16ToBeBytes(_pg_user->rpm, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryPowerPacketID());

}// encodeTransmuter_TelemetryPowerPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryPower packet
 *
 * The TelemetryPower packet contains information on the current operation
 * point of the engine and generator
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryPowerPacketStructure(const void* _pg_pkt, Transmuter_TelemetryPower_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryPowerPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryPowerMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // System voltage
    // Range of voltage is 0.0f to 128.0f.
    _pg_user->voltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/511.992188f);

    // Generator current
    // Range of genCurrent is -500.0f to 500.0f.
    _pg_user->genCurrent = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/65.534f);

    // Battery current
    // Range of batCurrent is -500.0f to 500.0f.
    _pg_user->batCurrent = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/65.534f);

    // Mechanical rotational speed
    // Range of rpm is -32768 to 32767.
    _pg_user->rpm = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetryPowerPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryPower packet
 *
 * The TelemetryPower packet contains information on the current operation
 * point of the engine and generator
 * \param _pg_pkt points to the packet which will be created by this function
 * \param voltage is System voltage
 * \param genCurrent is Generator current
 * \param batCurrent is Battery current
 * \param rpm is Mechanical rotational speed
 */
void encodeTransmuter_TelemetryPowerPacket(void* _pg_pkt, float voltage, float genCurrent, float batCurrent, int16_t rpm)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // System voltage
    // Range of voltage is 0.0f to 128.0f.
    float32ScaledTo2UnsignedBeBytes(voltage, _pg_data, &_pg_byteindex, 0.0f, 511.992188f);

    // Generator current
    // Range of genCurrent is -500.0f to 500.0f.
    float32ScaledTo2SignedBeBytes(genCurrent, _pg_data, &_pg_byteindex, 65.534f);

    // Battery current
    // Range of batCurrent is -500.0f to 500.0f.
    float32ScaledTo2SignedBeBytes(batCurrent, _pg_data, &_pg_byteindex, 65.534f);

    // Mechanical rotational speed
    // Range of rpm is -32768 to 32767.
    int16ToBeBytes(rpm, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryPowerPacketID());

}// encodeTransmuter_TelemetryPowerPacket

/*!
 * \brief Decode the Transmuter_TelemetryPower packet
 *
 * The TelemetryPower packet contains information on the current operation
 * point of the engine and generator
 * \param _pg_pkt points to the packet being decoded by this function
 * \param voltage receives System voltage
 * \param genCurrent receives Generator current
 * \param batCurrent receives Battery current
 * \param rpm receives Mechanical rotational speed
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryPowerPacket(const void* _pg_pkt, float* voltage, float* genCurrent, float* batCurrent, int16_t* rpm)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryPowerPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryPowerMinDataLength())
        return 0;

    // System voltage
    // Range of voltage is 0.0f to 128.0f.
    (*voltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/511.992188f);

    // Generator current
    // Range of genCurrent is -500.0f to 500.0f.
    (*genCurrent) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/65.534f);

    // Battery current
    // Range of batCurrent is -500.0f to 500.0f.
    (*batCurrent) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/65.534f);

    // Mechanical rotational speed
    // Range of rpm is -32768 to 32767.
    (*rpm) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetryPowerPacket

/*!
 * \brief Create the Transmuter_TelemetrySetpoint packet
 *
 * The TelemetrySetpoint packet contains system setpoint/target information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetrySetpointPacketStructure(void* _pg_pkt, const Transmuter_TelemetrySetpoint_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Battery current setpoint value
    // Range of currentSetpoint is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->currentSetpoint, _pg_data, &_pg_byteindex, 128.498039f);

    // System RPM target
    // Range of rpmTarget is -32768 to 32767.
    int16ToBeBytes(_pg_user->rpmTarget, _pg_data, &_pg_byteindex);

    // ECU throttle target
    // Range of throttleTarget is 0 to 255.
    uint8ToBytes(_pg_user->throttleTarget, _pg_data, &_pg_byteindex);

    // Generator power target
    // Range of powerTarget is -32768 to 32767.
    int16ToBeBytes(_pg_user->powerTarget, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetrySetpointPacketID());

}// encodeTransmuter_TelemetrySetpointPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetrySetpoint packet
 *
 * The TelemetrySetpoint packet contains system setpoint/target information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetrySetpointPacketStructure(const void* _pg_pkt, Transmuter_TelemetrySetpoint_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetrySetpointPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetrySetpointMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Battery current setpoint value
    // Range of currentSetpoint is -255.0f to 255.0f.
    _pg_user->currentSetpoint = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // System RPM target
    // Range of rpmTarget is -32768 to 32767.
    _pg_user->rpmTarget = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // ECU throttle target
    // Range of throttleTarget is 0 to 255.
    _pg_user->throttleTarget = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator power target
    // Range of powerTarget is -32768 to 32767.
    _pg_user->powerTarget = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetrySetpointPacketStructure

/*!
 * \brief Create the Transmuter_TelemetrySetpoint packet
 *
 * The TelemetrySetpoint packet contains system setpoint/target information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param currentSetpoint is Battery current setpoint value
 * \param rpmTarget is System RPM target
 * \param throttleTarget is ECU throttle target
 * \param powerTarget is Generator power target
 */
void encodeTransmuter_TelemetrySetpointPacket(void* _pg_pkt, float currentSetpoint, int16_t rpmTarget, uint8_t throttleTarget, int16_t powerTarget)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Battery current setpoint value
    // Range of currentSetpoint is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(currentSetpoint, _pg_data, &_pg_byteindex, 128.498039f);

    // System RPM target
    // Range of rpmTarget is -32768 to 32767.
    int16ToBeBytes(rpmTarget, _pg_data, &_pg_byteindex);

    // ECU throttle target
    // Range of throttleTarget is 0 to 255.
    uint8ToBytes(throttleTarget, _pg_data, &_pg_byteindex);

    // Generator power target
    // Range of powerTarget is -32768 to 32767.
    int16ToBeBytes(powerTarget, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetrySetpointPacketID());

}// encodeTransmuter_TelemetrySetpointPacket

/*!
 * \brief Decode the Transmuter_TelemetrySetpoint packet
 *
 * The TelemetrySetpoint packet contains system setpoint/target information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param currentSetpoint receives Battery current setpoint value
 * \param rpmTarget receives System RPM target
 * \param throttleTarget receives ECU throttle target
 * \param powerTarget receives Generator power target
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetrySetpointPacket(const void* _pg_pkt, float* currentSetpoint, int16_t* rpmTarget, uint8_t* throttleTarget, int16_t* powerTarget)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetrySetpointPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetrySetpointMinDataLength())
        return 0;

    // Battery current setpoint value
    // Range of currentSetpoint is -255.0f to 255.0f.
    (*currentSetpoint) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // System RPM target
    // Range of rpmTarget is -32768 to 32767.
    (*rpmTarget) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // ECU throttle target
    // Range of throttleTarget is 0 to 255.
    (*throttleTarget) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator power target
    // Range of powerTarget is -32768 to 32767.
    (*powerTarget) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetrySetpointPacket

/*!
 * \brief Create the Transmuter_TelemetryGenerator packet
 *
 * The TelemetryGenerator packet provides information about the current
 * operational status of the generator and EFI system.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryGeneratorPacketStructure(void* _pg_pkt, const Transmuter_TelemetryGenerator_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Power electronics module temperature
    // Range of fetTemperature is 0 to 255.
    uint8ToBytes(_pg_user->fetTemperature, _pg_data, &_pg_byteindex);

    // Generator motor temperature
    // Range of motTemperature is 0 to 255.
    uint8ToBytes(_pg_user->motTemperature, _pg_data, &_pg_byteindex);

    // Engine cylinder head temperature
    // Range of chtTemperature is 0 to 255.
    uint8ToBytes(_pg_user->chtTemperature, _pg_data, &_pg_byteindex);

    // Fuel pressure
    // Range of fuelPressure is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->fuelPressure, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryGeneratorPacketID());

}// encodeTransmuter_TelemetryGeneratorPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryGenerator packet
 *
 * The TelemetryGenerator packet provides information about the current
 * operational status of the generator and EFI system.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryGeneratorPacketStructure(const void* _pg_pkt, Transmuter_TelemetryGenerator_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryGeneratorPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryGeneratorMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Power electronics module temperature
    // Range of fetTemperature is 0 to 255.
    _pg_user->fetTemperature = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator motor temperature
    // Range of motTemperature is 0 to 255.
    _pg_user->motTemperature = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Engine cylinder head temperature
    // Range of chtTemperature is 0 to 255.
    _pg_user->chtTemperature = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Fuel pressure
    // Range of fuelPressure is 0.0f to 655.35f.
    _pg_user->fuelPressure = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    return 1;

}// decodeTransmuter_TelemetryGeneratorPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryGenerator packet
 *
 * The TelemetryGenerator packet provides information about the current
 * operational status of the generator and EFI system.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param fetTemperature is Power electronics module temperature
 * \param motTemperature is Generator motor temperature
 * \param chtTemperature is Engine cylinder head temperature
 * \param fuelPressure is Fuel pressure
 */
void encodeTransmuter_TelemetryGeneratorPacket(void* _pg_pkt, uint8_t fetTemperature, uint8_t motTemperature, uint8_t chtTemperature, float fuelPressure)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Power electronics module temperature
    // Range of fetTemperature is 0 to 255.
    uint8ToBytes(fetTemperature, _pg_data, &_pg_byteindex);

    // Generator motor temperature
    // Range of motTemperature is 0 to 255.
    uint8ToBytes(motTemperature, _pg_data, &_pg_byteindex);

    // Engine cylinder head temperature
    // Range of chtTemperature is 0 to 255.
    uint8ToBytes(chtTemperature, _pg_data, &_pg_byteindex);

    // Fuel pressure
    // Range of fuelPressure is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(fuelPressure, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryGeneratorPacketID());

}// encodeTransmuter_TelemetryGeneratorPacket

/*!
 * \brief Decode the Transmuter_TelemetryGenerator packet
 *
 * The TelemetryGenerator packet provides information about the current
 * operational status of the generator and EFI system.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param fetTemperature receives Power electronics module temperature
 * \param motTemperature receives Generator motor temperature
 * \param chtTemperature receives Engine cylinder head temperature
 * \param fuelPressure receives Fuel pressure
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryGeneratorPacket(const void* _pg_pkt, uint8_t* fetTemperature, uint8_t* motTemperature, uint8_t* chtTemperature, float* fuelPressure)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryGeneratorPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryGeneratorMinDataLength())
        return 0;

    // Power electronics module temperature
    // Range of fetTemperature is 0 to 255.
    (*fetTemperature) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator motor temperature
    // Range of motTemperature is 0 to 255.
    (*motTemperature) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Engine cylinder head temperature
    // Range of chtTemperature is 0 to 255.
    (*chtTemperature) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Fuel pressure
    // Range of fuelPressure is 0.0f to 655.35f.
    (*fuelPressure) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    return 1;

}// decodeTransmuter_TelemetryGeneratorPacket

/*!
 * \brief Create the Transmuter_TelemetryCapacity packet
 *
 * The TelemetryCapacity packet provides information on the battery and fuel
 * capacity
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryCapacityPacketStructure(void* _pg_pkt, const Transmuter_TelemetryCapacity_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Fuel used estimate
    // Range of fuelUsed is 0 to 4294967295.
    uint32ToBeBytes(_pg_user->fuelUsed, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryCapacityPacketID());

}// encodeTransmuter_TelemetryCapacityPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryCapacity packet
 *
 * The TelemetryCapacity packet provides information on the battery and fuel
 * capacity
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryCapacityPacketStructure(const void* _pg_pkt, Transmuter_TelemetryCapacity_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryCapacityPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryCapacityMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Fuel used estimate
    // Range of fuelUsed is 0 to 4294967295.
    _pg_user->fuelUsed = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetryCapacityPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryCapacity packet
 *
 * The TelemetryCapacity packet provides information on the battery and fuel
 * capacity
 * \param _pg_pkt points to the packet which will be created by this function
 * \param fuelUsed is Fuel used estimate
 */
void encodeTransmuter_TelemetryCapacityPacket(void* _pg_pkt, uint32_t fuelUsed)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Fuel used estimate
    // Range of fuelUsed is 0 to 4294967295.
    uint32ToBeBytes(fuelUsed, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryCapacityPacketID());

}// encodeTransmuter_TelemetryCapacityPacket

/*!
 * \brief Decode the Transmuter_TelemetryCapacity packet
 *
 * The TelemetryCapacity packet provides information on the battery and fuel
 * capacity
 * \param _pg_pkt points to the packet being decoded by this function
 * \param fuelUsed receives Fuel used estimate
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryCapacityPacket(const void* _pg_pkt, uint32_t* fuelUsed)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryCapacityPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryCapacityMinDataLength())
        return 0;

    // Fuel used estimate
    // Range of fuelUsed is 0 to 4294967295.
    (*fuelUsed) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_TelemetryCapacityPacket

/*!
 * \brief Create the Transmuter_TelemetryControlLoop packet
 *
 * Current state of the transmuter current control loop
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryControlLoopPacketStructure(void* _pg_pkt, const Transmuter_TelemetryControlLoop_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of pTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->pTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of iTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->iTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of dTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->dTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of fTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->fTerm, _pg_data, &_pg_byteindex, 327.67f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryControlLoopPacketID());

}// encodeTransmuter_TelemetryControlLoopPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryControlLoop packet
 *
 * Current state of the transmuter current control loop
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryControlLoopPacketStructure(const void* _pg_pkt, Transmuter_TelemetryControlLoop_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryControlLoopPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryControlLoopMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Range of pTerm is -100.0f to 100.0f.
    _pg_user->pTerm = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of iTerm is -100.0f to 100.0f.
    _pg_user->iTerm = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of dTerm is -100.0f to 100.0f.
    _pg_user->dTerm = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of fTerm is -100.0f to 100.0f.
    _pg_user->fTerm = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    return 1;

}// decodeTransmuter_TelemetryControlLoopPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryControlLoop packet
 *
 * Current state of the transmuter current control loop
 * \param _pg_pkt points to the packet which will be created by this function
 * \param pTerm is 
 * \param iTerm is 
 * \param dTerm is 
 * \param fTerm is 
 */
void encodeTransmuter_TelemetryControlLoopPacket(void* _pg_pkt, float pTerm, float iTerm, float dTerm, float fTerm)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of pTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(pTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of iTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(iTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of dTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(dTerm, _pg_data, &_pg_byteindex, 327.67f);

    // Range of fTerm is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(fTerm, _pg_data, &_pg_byteindex, 327.67f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryControlLoopPacketID());

}// encodeTransmuter_TelemetryControlLoopPacket

/*!
 * \brief Decode the Transmuter_TelemetryControlLoop packet
 *
 * Current state of the transmuter current control loop
 * \param _pg_pkt points to the packet being decoded by this function
 * \param pTerm receives 
 * \param iTerm receives 
 * \param dTerm receives 
 * \param fTerm receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryControlLoopPacket(const void* _pg_pkt, float* pTerm, float* iTerm, float* dTerm, float* fTerm)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryControlLoopPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryControlLoopMinDataLength())
        return 0;

    // Range of pTerm is -100.0f to 100.0f.
    (*pTerm) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of iTerm is -100.0f to 100.0f.
    (*iTerm) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of dTerm is -100.0f to 100.0f.
    (*dTerm) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    // Range of fTerm is -100.0f to 100.0f.
    (*fTerm) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    return 1;

}// decodeTransmuter_TelemetryControlLoopPacket

/*!
 * \brief Create the Transmuter_TelemetryAPBPower packet
 *
 * Power information for the Auxilary Power Board
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetryAPBPowerPacketStructure(void* _pg_pkt, const Transmuter_TelemetryAPBPower_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // APB output voltage (V)
    // Range of apbVoltage is 0.0f to 25.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->apbVoltage, _pg_data, &_pg_byteindex, 0.0f, 2621.4f);

    // APB output current (A)
    // Range of apbCurrent is 0.0f to 8.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->apbCurrent, _pg_data, &_pg_byteindex, 0.0f, 8191.875f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryAPBPowerPacketID());

}// encodeTransmuter_TelemetryAPBPowerPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetryAPBPower packet
 *
 * Power information for the Auxilary Power Board
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryAPBPowerPacketStructure(const void* _pg_pkt, Transmuter_TelemetryAPBPower_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryAPBPowerPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetryAPBPowerMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // APB output voltage (V)
    // Range of apbVoltage is 0.0f to 25.0f.
    _pg_user->apbVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2621.4f);

    // APB output current (A)
    // Range of apbCurrent is 0.0f to 8.0f.
    _pg_user->apbCurrent = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/8191.875f);

    return 1;

}// decodeTransmuter_TelemetryAPBPowerPacketStructure

/*!
 * \brief Create the Transmuter_TelemetryAPBPower packet
 *
 * Power information for the Auxilary Power Board
 * \param _pg_pkt points to the packet which will be created by this function
 * \param apbVoltage is APB output voltage (V)
 * \param apbCurrent is APB output current (A)
 */
void encodeTransmuter_TelemetryAPBPowerPacket(void* _pg_pkt, float apbVoltage, float apbCurrent)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // APB output voltage (V)
    // Range of apbVoltage is 0.0f to 25.0f.
    float32ScaledTo2UnsignedBeBytes(apbVoltage, _pg_data, &_pg_byteindex, 0.0f, 2621.4f);

    // APB output current (A)
    // Range of apbCurrent is 0.0f to 8.0f.
    float32ScaledTo2UnsignedBeBytes(apbCurrent, _pg_data, &_pg_byteindex, 0.0f, 8191.875f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetryAPBPowerPacketID());

}// encodeTransmuter_TelemetryAPBPowerPacket

/*!
 * \brief Decode the Transmuter_TelemetryAPBPower packet
 *
 * Power information for the Auxilary Power Board
 * \param _pg_pkt points to the packet being decoded by this function
 * \param apbVoltage receives APB output voltage (V)
 * \param apbCurrent receives APB output current (A)
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetryAPBPowerPacket(const void* _pg_pkt, float* apbVoltage, float* apbCurrent)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetryAPBPowerPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetryAPBPowerMinDataLength())
        return 0;

    // APB output voltage (V)
    // Range of apbVoltage is 0.0f to 25.0f.
    (*apbVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2621.4f);

    // APB output current (A)
    // Range of apbCurrent is 0.0f to 8.0f.
    (*apbCurrent) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/8191.875f);

    return 1;

}// decodeTransmuter_TelemetryAPBPowerPacket

/*!
 * \brief Set a Transmuter_WarningLevels_t to initial values.
 *
 * Set a Transmuter_WarningLevels_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_WarningLevels_t(Transmuter_WarningLevels_t* _pg_user)
{

    // Engine (CHT) temperature warning level
    _pg_user->engineTemp = 140;

}// initTransmuter_WarningLevels_t

/*!
 * \brief Create the Transmuter_WarningLevels packet
 *
 * Warning level configuration values
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_WarningLevelsPacketStructure(void* _pg_pkt, const Transmuter_WarningLevels_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine (CHT) temperature warning level
    // Range of engineTemp is 0 to 255.
    uint8ToBytes(_pg_user->engineTemp, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_WarningLevelsPacketID());

}// encodeTransmuter_WarningLevelsPacketStructure

/*!
 * \brief Decode the Transmuter_WarningLevels packet
 *
 * Warning level configuration values
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_WarningLevelsPacketStructure(const void* _pg_pkt, Transmuter_WarningLevels_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_WarningLevelsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_WarningLevelsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Engine (CHT) temperature warning level
    // Range of engineTemp is 0 to 255.
    _pg_user->engineTemp = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_WarningLevelsPacketStructure

/*!
 * \brief Create the Transmuter_WarningLevels packet
 *
 * Warning level configuration values
 * \param _pg_pkt points to the packet which will be created by this function
 * \param engineTemp is Engine (CHT) temperature warning level
 */
void encodeTransmuter_WarningLevelsPacket(void* _pg_pkt, uint8_t engineTemp)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine (CHT) temperature warning level
    // Range of engineTemp is 0 to 255.
    uint8ToBytes(engineTemp, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_WarningLevelsPacketID());

}// encodeTransmuter_WarningLevelsPacket

/*!
 * \brief Decode the Transmuter_WarningLevels packet
 *
 * Warning level configuration values
 * \param _pg_pkt points to the packet being decoded by this function
 * \param engineTemp receives Engine (CHT) temperature warning level
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_WarningLevelsPacket(const void* _pg_pkt, uint8_t* engineTemp)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_WarningLevelsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_WarningLevelsMinDataLength())
        return 0;

    // Engine (CHT) temperature warning level
    // Range of engineTemp is 0 to 255.
    (*engineTemp) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_WarningLevelsPacket

/*!
 * \brief Verify a Transmuter_WarningLevels_t has acceptable values.
 *
 * Verify a Transmuter_WarningLevels_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_WarningLevels_t(Transmuter_WarningLevels_t* _pg_user)
{
    int _pg_good = 1;

    // Engine (CHT) temperature warning level
    if(_pg_user->engineTemp < 50)
    {
        _pg_user->engineTemp = 50;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_WarningLevels_t

/*!
 * \brief Set a Transmuter_EFISettings_t to initial values.
 *
 * Set a Transmuter_EFISettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_EFISettings_t(Transmuter_EFISettings_t* _pg_user)
{

    // CAN Node ID for the ECU
    _pg_user->ecuAddress = 200;

    // CAN Node ID for the triplex pump
    _pg_user->triplexAddress = 201;

    // Minimum required fuel pressure
    _pg_user->fuelPressureMin = 5.0f;

}// initTransmuter_EFISettings_t

/*!
 * \brief Create the Transmuter_EFISettings packet
 *
 * ECU connection configuration packet
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_EFISettingsPacketStructure(void* _pg_pkt, const Transmuter_EFISettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // CAN Node ID for the ECU
    // Range of ecuAddress is 0 to 255.
    uint8ToBytes(_pg_user->ecuAddress, _pg_data, &_pg_byteindex);

    // ECU firmware checksum
    // Range of ecuFirmwareChecksum is 0 to 65535.
    uint16ToBeBytes(_pg_user->ecuFirmwareChecksum, _pg_data, &_pg_byteindex);

    // ECU settings checksum
    // Range of ecuSettingsChecksum is 0 to 65535.
    uint16ToBeBytes(_pg_user->ecuSettingsChecksum, _pg_data, &_pg_byteindex);

    // CAN Node ID for the triplex pump
    // Range of triplexAddress is 0 to 255.
    uint8ToBytes(_pg_user->triplexAddress, _pg_data, &_pg_byteindex);

    // Triplex pump firmware checksum
    // Range of triplexFirmwareChecksum is 0 to 65535.
    uint16ToBeBytes(_pg_user->triplexFirmwareChecksum, _pg_data, &_pg_byteindex);

    // Minimum required fuel pressure
    // Range of fuelPressureMin is -327.67f to 327.67f.
    float32ScaledTo2SignedBeBytes(_pg_user->fuelPressureMin, _pg_data, &_pg_byteindex, 100.0f);

    // Fuel pressure control method
    // Range of pumpController is 0 to 255.
    uint8ToBytes(_pg_user->pumpController, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EFISettingsPacketID());

}// encodeTransmuter_EFISettingsPacketStructure

/*!
 * \brief Decode the Transmuter_EFISettings packet
 *
 * ECU connection configuration packet
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EFISettingsPacketStructure(const void* _pg_pkt, Transmuter_EFISettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EFISettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_EFISettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->pumpController = TRANSMUTER_PUMP_TRIPLEX;

    // CAN Node ID for the ECU
    // Range of ecuAddress is 0 to 255.
    _pg_user->ecuAddress = uint8FromBytes(_pg_data, &_pg_byteindex);

    // ECU firmware checksum
    // Range of ecuFirmwareChecksum is 0 to 65535.
    _pg_user->ecuFirmwareChecksum = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // ECU settings checksum
    // Range of ecuSettingsChecksum is 0 to 65535.
    _pg_user->ecuSettingsChecksum = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN Node ID for the triplex pump
    // Range of triplexAddress is 0 to 255.
    _pg_user->triplexAddress = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Triplex pump firmware checksum
    // Range of triplexFirmwareChecksum is 0 to 65535.
    _pg_user->triplexFirmwareChecksum = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Minimum required fuel pressure
    // Range of fuelPressureMin is -327.67f to 327.67f.
    _pg_user->fuelPressureMin = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/100.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Fuel pressure control method
    // Range of pumpController is 0 to 255.
    _pg_user->pumpController = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_EFISettingsPacketStructure

/*!
 * \brief Create the Transmuter_EFISettings packet
 *
 * ECU connection configuration packet
 * \param _pg_pkt points to the packet which will be created by this function
 * \param ecuAddress is CAN Node ID for the ECU
 * \param ecuFirmwareChecksum is ECU firmware checksum
 * \param ecuSettingsChecksum is ECU settings checksum
 * \param triplexAddress is CAN Node ID for the triplex pump
 * \param triplexFirmwareChecksum is Triplex pump firmware checksum
 * \param fuelPressureMin is Minimum required fuel pressure
 * \param pumpController is Fuel pressure control method
 */
void encodeTransmuter_EFISettingsPacket(void* _pg_pkt, uint8_t ecuAddress, uint16_t ecuFirmwareChecksum, uint16_t ecuSettingsChecksum, uint8_t triplexAddress, uint16_t triplexFirmwareChecksum, float fuelPressureMin, uint8_t pumpController)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // CAN Node ID for the ECU
    // Range of ecuAddress is 0 to 255.
    uint8ToBytes(ecuAddress, _pg_data, &_pg_byteindex);

    // ECU firmware checksum
    // Range of ecuFirmwareChecksum is 0 to 65535.
    uint16ToBeBytes(ecuFirmwareChecksum, _pg_data, &_pg_byteindex);

    // ECU settings checksum
    // Range of ecuSettingsChecksum is 0 to 65535.
    uint16ToBeBytes(ecuSettingsChecksum, _pg_data, &_pg_byteindex);

    // CAN Node ID for the triplex pump
    // Range of triplexAddress is 0 to 255.
    uint8ToBytes(triplexAddress, _pg_data, &_pg_byteindex);

    // Triplex pump firmware checksum
    // Range of triplexFirmwareChecksum is 0 to 65535.
    uint16ToBeBytes(triplexFirmwareChecksum, _pg_data, &_pg_byteindex);

    // Minimum required fuel pressure
    // Range of fuelPressureMin is -327.67f to 327.67f.
    float32ScaledTo2SignedBeBytes(fuelPressureMin, _pg_data, &_pg_byteindex, 100.0f);

    // Fuel pressure control method
    // Range of pumpController is 0 to 255.
    uint8ToBytes(pumpController, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_EFISettingsPacketID());

}// encodeTransmuter_EFISettingsPacket

/*!
 * \brief Decode the Transmuter_EFISettings packet
 *
 * ECU connection configuration packet
 * \param _pg_pkt points to the packet being decoded by this function
 * \param ecuAddress receives CAN Node ID for the ECU
 * \param ecuFirmwareChecksum receives ECU firmware checksum
 * \param ecuSettingsChecksum receives ECU settings checksum
 * \param triplexAddress receives CAN Node ID for the triplex pump
 * \param triplexFirmwareChecksum receives Triplex pump firmware checksum
 * \param fuelPressureMin receives Minimum required fuel pressure
 * \param pumpController receives Fuel pressure control method
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_EFISettingsPacket(const void* _pg_pkt, uint8_t* ecuAddress, uint16_t* ecuFirmwareChecksum, uint16_t* ecuSettingsChecksum, uint8_t* triplexAddress, uint16_t* triplexFirmwareChecksum, float* fuelPressureMin, uint8_t* pumpController)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_EFISettingsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_EFISettingsMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    (*pumpController) = TRANSMUTER_PUMP_TRIPLEX;

    // CAN Node ID for the ECU
    // Range of ecuAddress is 0 to 255.
    (*ecuAddress) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // ECU firmware checksum
    // Range of ecuFirmwareChecksum is 0 to 65535.
    (*ecuFirmwareChecksum) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // ECU settings checksum
    // Range of ecuSettingsChecksum is 0 to 65535.
    (*ecuSettingsChecksum) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN Node ID for the triplex pump
    // Range of triplexAddress is 0 to 255.
    (*triplexAddress) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Triplex pump firmware checksum
    // Range of triplexFirmwareChecksum is 0 to 65535.
    (*triplexFirmwareChecksum) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Minimum required fuel pressure
    // Range of fuelPressureMin is -327.67f to 327.67f.
    (*fuelPressureMin) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/100.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Fuel pressure control method
    // Range of pumpController is 0 to 255.
    (*pumpController) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_EFISettingsPacket

/*!
 * \brief Verify a Transmuter_EFISettings_t has acceptable values.
 *
 * Verify a Transmuter_EFISettings_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_EFISettings_t(Transmuter_EFISettings_t* _pg_user)
{
    int _pg_good = 1;

    // CAN Node ID for the ECU
    if(_pg_user->ecuAddress > 254)
    {
        _pg_user->ecuAddress = 254;
        _pg_good = 0;
    }

    // CAN Node ID for the triplex pump
    if(_pg_user->triplexAddress > 254)
    {
        _pg_user->triplexAddress = 254;
        _pg_good = 0;
    }

    // Minimum required fuel pressure
    if(_pg_user->fuelPressureMin < 1.0f)
    {
        _pg_user->fuelPressureMin = 1.0f;
        _pg_good = 0;
    }
    else if(_pg_user->fuelPressureMin > 25.0f)
    {
        _pg_user->fuelPressureMin = 25.0f;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_EFISettings_t

/*!
 * \brief Set a Transmuter_GeneratorSettings_t to initial values.
 *
 * Set a Transmuter_GeneratorSettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_GeneratorSettings_t(Transmuter_GeneratorSettings_t* _pg_user)
{

    // Belt ratio between engine and generator motor
    _pg_user->beltRatio = 1.0f;

    // Allowable RPM measurement difference between generator and engine
    _pg_user->rpmThreshold = 350;

    // Timeout before system disables due to engine power loss. Set to zero to disable timeout
    _pg_user->powerLossTimeout = 25;

}// initTransmuter_GeneratorSettings_t

/*!
 * \brief Create the Transmuter_GeneratorSettings packet
 *
 * Generator motor parameters
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_GeneratorSettingsPacketStructure(void* _pg_pkt, const Transmuter_GeneratorSettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Belt ratio between engine and generator motor
    // Range of beltRatio is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->beltRatio, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Allowable RPM measurement difference between generator and engine
    // Range of rpmThreshold is 0 to 65535.
    uint16ToBeBytes(_pg_user->rpmThreshold, _pg_data, &_pg_byteindex);

    // Timeout before system disables due to engine power loss. Set to zero to disable timeout
    // Range of powerLossTimeout is 0 to 255.
    uint8ToBytes(_pg_user->powerLossTimeout, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_GeneratorSettingsPacketID());

}// encodeTransmuter_GeneratorSettingsPacketStructure

/*!
 * \brief Decode the Transmuter_GeneratorSettings packet
 *
 * Generator motor parameters
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_GeneratorSettingsPacketStructure(const void* _pg_pkt, Transmuter_GeneratorSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_GeneratorSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_GeneratorSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Belt ratio between engine and generator motor
    // Range of beltRatio is 0.0f to 65.535f.
    _pg_user->beltRatio = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Allowable RPM measurement difference between generator and engine
    // Range of rpmThreshold is 0 to 65535.
    _pg_user->rpmThreshold = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Timeout before system disables due to engine power loss. Set to zero to disable timeout
    // Range of powerLossTimeout is 0 to 255.
    _pg_user->powerLossTimeout = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_GeneratorSettingsPacketStructure

/*!
 * \brief Create the Transmuter_GeneratorSettings packet
 *
 * Generator motor parameters
 * \param _pg_pkt points to the packet which will be created by this function
 * \param beltRatio is Belt ratio between engine and generator motor
 * \param rpmThreshold is Allowable RPM measurement difference between generator and engine
 * \param powerLossTimeout is Timeout before system disables due to engine power loss. Set to zero to disable timeout
 */
void encodeTransmuter_GeneratorSettingsPacket(void* _pg_pkt, float beltRatio, uint16_t rpmThreshold, uint8_t powerLossTimeout)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Belt ratio between engine and generator motor
    // Range of beltRatio is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(beltRatio, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Allowable RPM measurement difference between generator and engine
    // Range of rpmThreshold is 0 to 65535.
    uint16ToBeBytes(rpmThreshold, _pg_data, &_pg_byteindex);

    // Timeout before system disables due to engine power loss. Set to zero to disable timeout
    // Range of powerLossTimeout is 0 to 255.
    uint8ToBytes(powerLossTimeout, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_GeneratorSettingsPacketID());

}// encodeTransmuter_GeneratorSettingsPacket

/*!
 * \brief Decode the Transmuter_GeneratorSettings packet
 *
 * Generator motor parameters
 * \param _pg_pkt points to the packet being decoded by this function
 * \param beltRatio receives Belt ratio between engine and generator motor
 * \param rpmThreshold receives Allowable RPM measurement difference between generator and engine
 * \param powerLossTimeout receives Timeout before system disables due to engine power loss. Set to zero to disable timeout
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_GeneratorSettingsPacket(const void* _pg_pkt, float* beltRatio, uint16_t* rpmThreshold, uint8_t* powerLossTimeout)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_GeneratorSettingsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_GeneratorSettingsMinDataLength())
        return 0;

    // Belt ratio between engine and generator motor
    // Range of beltRatio is 0.0f to 65.535f.
    (*beltRatio) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Allowable RPM measurement difference between generator and engine
    // Range of rpmThreshold is 0 to 65535.
    (*rpmThreshold) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Timeout before system disables due to engine power loss. Set to zero to disable timeout
    // Range of powerLossTimeout is 0 to 255.
    (*powerLossTimeout) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_GeneratorSettingsPacket

/*!
 * \brief Verify a Transmuter_GeneratorSettings_t has acceptable values.
 *
 * Verify a Transmuter_GeneratorSettings_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_GeneratorSettings_t(Transmuter_GeneratorSettings_t* _pg_user)
{
    int _pg_good = 1;

    // Belt ratio between engine and generator motor
    if(_pg_user->beltRatio < 0.1f)
    {
        _pg_user->beltRatio = 0.1f;
        _pg_good = 0;
    }
    else if(_pg_user->beltRatio > 10.0f)
    {
        _pg_user->beltRatio = 10.0f;
        _pg_good = 0;
    }

    // Allowable RPM measurement difference between generator and engine
    if(_pg_user->rpmThreshold > 5000)
    {
        _pg_user->rpmThreshold = 5000;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_GeneratorSettings_t

/*!
 * \brief Set a Transmuter_StartingSettings_t to initial values.
 *
 * Set a Transmuter_StartingSettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_StartingSettings_t(Transmuter_StartingSettings_t* _pg_user)
{

    // Number of auto-retries allowed for engine starting routine
    _pg_user->retries = 3;

    // Timeout for engine starting routine
    _pg_user->timeout = 50;

    // Starting RPM value
    _pg_user->rpm = 3000;

    // Starting throttle position
    _pg_user->throttle = 25;

    // Settling time after reaching starting RPM
    _pg_user->settlingPeriod = 25;

}// initTransmuter_StartingSettings_t

/*!
 * \brief Create the Transmuter_StartingSettings packet
 *
 * Engine starting settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_StartingSettingsPacketStructure(void* _pg_pkt, const Transmuter_StartingSettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Number of auto-retries allowed for engine starting routine
    // Range of retries is 0 to 255.
    uint8ToBytes(_pg_user->retries, _pg_data, &_pg_byteindex);

    // Timeout for engine starting routine
    // Range of timeout is 0 to 255.
    uint8ToBytes(_pg_user->timeout, _pg_data, &_pg_byteindex);

    // Starting RPM value
    // Range of rpm is 0 to 65535.
    uint16ToBeBytes(_pg_user->rpm, _pg_data, &_pg_byteindex);

    // Starting throttle position
    // Range of throttle is 0 to 255.
    uint8ToBytes(_pg_user->throttle, _pg_data, &_pg_byteindex);

    // Settling time after reaching starting RPM
    // Range of settlingPeriod is 0 to 255.
    uint8ToBytes(_pg_user->settlingPeriod, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_StartingSettingsPacketID());

}// encodeTransmuter_StartingSettingsPacketStructure

/*!
 * \brief Decode the Transmuter_StartingSettings packet
 *
 * Engine starting settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_StartingSettingsPacketStructure(const void* _pg_pkt, Transmuter_StartingSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_StartingSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_StartingSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Number of auto-retries allowed for engine starting routine
    // Range of retries is 0 to 255.
    _pg_user->retries = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Timeout for engine starting routine
    // Range of timeout is 0 to 255.
    _pg_user->timeout = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Starting RPM value
    // Range of rpm is 0 to 65535.
    _pg_user->rpm = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Starting throttle position
    // Range of throttle is 0 to 255.
    _pg_user->throttle = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Settling time after reaching starting RPM
    // Range of settlingPeriod is 0 to 255.
    _pg_user->settlingPeriod = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_StartingSettingsPacketStructure

/*!
 * \brief Create the Transmuter_StartingSettings packet
 *
 * Engine starting settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param retries is Number of auto-retries allowed for engine starting routine
 * \param timeout is Timeout for engine starting routine
 * \param rpm is Starting RPM value
 * \param throttle is Starting throttle position
 * \param settlingPeriod is Settling time after reaching starting RPM
 */
void encodeTransmuter_StartingSettingsPacket(void* _pg_pkt, uint8_t retries, uint8_t timeout, uint16_t rpm, uint8_t throttle, uint8_t settlingPeriod)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Number of auto-retries allowed for engine starting routine
    // Range of retries is 0 to 255.
    uint8ToBytes(retries, _pg_data, &_pg_byteindex);

    // Timeout for engine starting routine
    // Range of timeout is 0 to 255.
    uint8ToBytes(timeout, _pg_data, &_pg_byteindex);

    // Starting RPM value
    // Range of rpm is 0 to 65535.
    uint16ToBeBytes(rpm, _pg_data, &_pg_byteindex);

    // Starting throttle position
    // Range of throttle is 0 to 255.
    uint8ToBytes(throttle, _pg_data, &_pg_byteindex);

    // Settling time after reaching starting RPM
    // Range of settlingPeriod is 0 to 255.
    uint8ToBytes(settlingPeriod, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_StartingSettingsPacketID());

}// encodeTransmuter_StartingSettingsPacket

/*!
 * \brief Decode the Transmuter_StartingSettings packet
 *
 * Engine starting settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param retries receives Number of auto-retries allowed for engine starting routine
 * \param timeout receives Timeout for engine starting routine
 * \param rpm receives Starting RPM value
 * \param throttle receives Starting throttle position
 * \param settlingPeriod receives Settling time after reaching starting RPM
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_StartingSettingsPacket(const void* _pg_pkt, uint8_t* retries, uint8_t* timeout, uint16_t* rpm, uint8_t* throttle, uint8_t* settlingPeriod)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_StartingSettingsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_StartingSettingsMinDataLength())
        return 0;

    // Number of auto-retries allowed for engine starting routine
    // Range of retries is 0 to 255.
    (*retries) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Timeout for engine starting routine
    // Range of timeout is 0 to 255.
    (*timeout) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Starting RPM value
    // Range of rpm is 0 to 65535.
    (*rpm) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Starting throttle position
    // Range of throttle is 0 to 255.
    (*throttle) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Settling time after reaching starting RPM
    // Range of settlingPeriod is 0 to 255.
    (*settlingPeriod) = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeTransmuter_StartingSettingsPacket

/*!
 * \brief Verify a Transmuter_StartingSettings_t has acceptable values.
 *
 * Verify a Transmuter_StartingSettings_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_StartingSettings_t(Transmuter_StartingSettings_t* _pg_user)
{
    int _pg_good = 1;

    // Number of auto-retries allowed for engine starting routine
    if(_pg_user->retries > 50)
    {
        _pg_user->retries = 50;
        _pg_good = 0;
    }

    // Timeout for engine starting routine
    if(_pg_user->timeout < 1)
    {
        _pg_user->timeout = 1;
        _pg_good = 0;
    }

    // Starting RPM value
    if(_pg_user->rpm < 500)
    {
        _pg_user->rpm = 500;
        _pg_good = 0;
    }
    else if(_pg_user->rpm > 25000)
    {
        _pg_user->rpm = 25000;
        _pg_good = 0;
    }

    // Starting throttle position
    if(_pg_user->throttle > 100)
    {
        _pg_user->throttle = 100;
        _pg_good = 0;
    }

    // Settling time after reaching starting RPM
    if(_pg_user->settlingPeriod < 10)
    {
        _pg_user->settlingPeriod = 10;
        _pg_good = 0;
    }
    else if(_pg_user->settlingPeriod > 250)
    {
        _pg_user->settlingPeriod = 250;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_StartingSettings_t

/*!
 * \brief Set a Transmuter_PowerMap_t to initial values.
 *
 * Set a Transmuter_PowerMap_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_PowerMap_t(Transmuter_PowerMap_t* _pg_user)
{

    // Power demand low pass filter corner frequency
    _pg_user->powerFilterHz = 1.0f;

}// initTransmuter_PowerMap_t

/*!
 * \brief Create the Transmuter_PowerMap packet
 *
 * Configuration of transmuter power map lookup table
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_PowerMapPacketStructure(void* _pg_pkt, const Transmuter_PowerMap_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Range of size is 0 to 255.
    uint8ToBytes(_pg_user->size, _pg_data, &_pg_byteindex);

    // Power Input (W)
    // Range of power is -32768 to 32767.
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        int16ToBeBytes(_pg_user->power[_pg_i], _pg_data, &_pg_byteindex);

    // Speed Output (RPM)
    // Range of rpm is -32768 to 32767.
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        int16ToBeBytes(_pg_user->rpm[_pg_i], _pg_data, &_pg_byteindex);

    // Power demand low pass filter corner frequency
    // Range of powerFilterHz is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->powerFilterHz, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_PowerMapPacketID());

}// encodeTransmuter_PowerMapPacketStructure

/*!
 * \brief Decode the Transmuter_PowerMap packet
 *
 * Configuration of transmuter power map lookup table
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_PowerMapPacketStructure(const void* _pg_pkt, Transmuter_PowerMap_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_PowerMapPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_PowerMapMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->powerFilterHz = 1.0f;

    // Range of size is 0 to 255.
    _pg_user->size = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Power Input (W)
    // Range of power is -32768 to 32767.
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        _pg_user->power[_pg_i] = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Speed Output (RPM)
    // Range of rpm is -32768 to 32767.
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        _pg_user->rpm[_pg_i] = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(_pg_numbytes < _pg_byteindex)
        return 0;

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Power demand low pass filter corner frequency
    // Range of powerFilterHz is 0.0f to 65.535f.
    _pg_user->powerFilterHz = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeTransmuter_PowerMapPacketStructure

/*!
 * \brief Verify a Transmuter_PowerMap_t has acceptable values.
 *
 * Verify a Transmuter_PowerMap_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_PowerMap_t(Transmuter_PowerMap_t* _pg_user)
{
    int _pg_good = 1;
    unsigned _pg_i = 0;

    if(_pg_user->size < 2)
    {
        _pg_user->size = 2;
        _pg_good = 0;
    }
    else if(_pg_user->size > 15)
    {
        _pg_user->size = 15;
        _pg_good = 0;
    }

    // Power Input (W)
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        if(_pg_user->power[_pg_i] < 0)
        {
            _pg_user->power[_pg_i] = 0;
            _pg_good = 0;
        }
        else if(_pg_user->power[_pg_i] > 25000)
        {
            _pg_user->power[_pg_i] = 25000;
            _pg_good = 0;
        }

    // Speed Output (RPM)
    for(_pg_i = 0; _pg_i < (unsigned)_pg_user->size && _pg_i < 15; _pg_i++)
        if(_pg_user->rpm[_pg_i] < 0)
        {
            _pg_user->rpm[_pg_i] = 0;
            _pg_good = 0;
        }
        else if(_pg_user->rpm[_pg_i] > 25000)
        {
            _pg_user->rpm[_pg_i] = 25000;
            _pg_good = 0;
        }

    // Power demand low pass filter corner frequency
    if(_pg_user->powerFilterHz < 0.01f)
    {
        _pg_user->powerFilterHz = 0.01f;
        _pg_good = 0;
    }
    else if(_pg_user->powerFilterHz > 50.0f)
    {
        _pg_user->powerFilterHz = 50.0f;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_PowerMap_t

/*!
 * \brief Set a Transmuter_BatterySettings_t to initial values.
 *
 * Set a Transmuter_BatterySettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_BatterySettings_t(Transmuter_BatterySettings_t* _pg_user)
{

    _pg_user->nominalVoltage = 48;

    _pg_user->chargingCurrent = 5;

    // Battery capacity
    _pg_user->capacity = 5000;

    // Battery current measurement scaler value
    _pg_user->currentScaler = 1.0f;

    // Battery current measurement offset value
    _pg_user->currentOffset = 0.0f;

}// initTransmuter_BatterySettings_t

/*!
 * \brief Create the Transmuter_BatterySettings packet
 *
 * Configuration of battery charging parameters
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_BatterySettingsPacketStructure(void* _pg_pkt, const Transmuter_BatterySettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of nominalVoltage is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->nominalVoltage, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // Range of chargingCurrent is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->chargingCurrent, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // Battery capacity
    // Range of capacity is 0 to 65535.
    uint16ToBeBytes(_pg_user->capacity, _pg_data, &_pg_byteindex);

    // Reserved for future use
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Battery current measurement scaler value
    // Range of currentScaler is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->currentScaler, _pg_data, &_pg_byteindex, 327.67f);

    // Battery current measurement offset value
    // Range of currentOffset is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->currentOffset, _pg_data, &_pg_byteindex, 327.67f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_BatterySettingsPacketID());

}// encodeTransmuter_BatterySettingsPacketStructure

/*!
 * \brief Decode the Transmuter_BatterySettings packet
 *
 * Configuration of battery charging parameters
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_BatterySettingsPacketStructure(const void* _pg_pkt, Transmuter_BatterySettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_BatterySettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_BatterySettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->currentScaler = 1.0f;
    _pg_user->currentOffset = 0.0f;

    // Range of nominalVoltage is 0.0f to 100.0f.
    _pg_user->nominalVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // Range of chargingCurrent is 0.0f to 100.0f.
    _pg_user->chargingCurrent = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // Battery capacity
    // Range of capacity is 0 to 65535.
    _pg_user->capacity = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Reserved for future use
    _pg_byteindex += 1;

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Battery current measurement scaler value
    // Range of currentScaler is -100.0f to 100.0f.
    _pg_user->currentScaler = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Battery current measurement offset value
    // Range of currentOffset is -100.0f to 100.0f.
    _pg_user->currentOffset = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    return 1;

}// decodeTransmuter_BatterySettingsPacketStructure

/*!
 * \brief Create the Transmuter_BatterySettings packet
 *
 * Configuration of battery charging parameters
 * \param _pg_pkt points to the packet which will be created by this function
 * \param nominalVoltage is 
 * \param chargingCurrent is 
 * \param capacity is Battery capacity
 * \param currentScaler is Battery current measurement scaler value
 * \param currentOffset is Battery current measurement offset value
 */
void encodeTransmuter_BatterySettingsPacket(void* _pg_pkt, float nominalVoltage, float chargingCurrent, uint16_t capacity, float currentScaler, float currentOffset)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of nominalVoltage is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(nominalVoltage, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // Range of chargingCurrent is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(chargingCurrent, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // Battery capacity
    // Range of capacity is 0 to 65535.
    uint16ToBeBytes(capacity, _pg_data, &_pg_byteindex);

    // Reserved for future use
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    // Battery current measurement scaler value
    // Range of currentScaler is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(currentScaler, _pg_data, &_pg_byteindex, 327.67f);

    // Battery current measurement offset value
    // Range of currentOffset is -100.0f to 100.0f.
    float32ScaledTo2SignedBeBytes(currentOffset, _pg_data, &_pg_byteindex, 327.67f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_BatterySettingsPacketID());

}// encodeTransmuter_BatterySettingsPacket

/*!
 * \brief Decode the Transmuter_BatterySettings packet
 *
 * Configuration of battery charging parameters
 * \param _pg_pkt points to the packet being decoded by this function
 * \param nominalVoltage receives 
 * \param chargingCurrent receives 
 * \param capacity receives Battery capacity
 * \param currentScaler receives Battery current measurement scaler value
 * \param currentOffset receives Battery current measurement offset value
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_BatterySettingsPacket(const void* _pg_pkt, float* nominalVoltage, float* chargingCurrent, uint16_t* capacity, float* currentScaler, float* currentOffset)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_BatterySettingsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_BatterySettingsMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    (*currentScaler) = 1.0f;
    (*currentOffset) = 0.0f;

    // Range of nominalVoltage is 0.0f to 100.0f.
    (*nominalVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // Range of chargingCurrent is 0.0f to 100.0f.
    (*chargingCurrent) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // Battery capacity
    // Range of capacity is 0 to 65535.
    (*capacity) = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Reserved for future use
    _pg_byteindex += 1;

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Battery current measurement scaler value
    // Range of currentScaler is -100.0f to 100.0f.
    (*currentScaler) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Battery current measurement offset value
    // Range of currentOffset is -100.0f to 100.0f.
    (*currentOffset) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/327.67f);

    return 1;

}// decodeTransmuter_BatterySettingsPacket

/*!
 * \brief Verify a Transmuter_BatterySettings_t has acceptable values.
 *
 * Verify a Transmuter_BatterySettings_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_BatterySettings_t(Transmuter_BatterySettings_t* _pg_user)
{
    int _pg_good = 1;

    if(_pg_user->nominalVoltage < 20.0f)
    {
        _pg_user->nominalVoltage = 20.0f;
        _pg_good = 0;
    }
    else if(_pg_user->nominalVoltage > 100.0f)
    {
        _pg_user->nominalVoltage = 100.0f;
        _pg_good = 0;
    }

    // Battery current measurement scaler value
    if(_pg_user->currentScaler < 0.75f)
    {
        _pg_user->currentScaler = 0.75f;
        _pg_good = 0;
    }
    else if(_pg_user->currentScaler > 1.25f)
    {
        _pg_user->currentScaler = 1.25f;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_BatterySettings_t

/*!
 * \brief Set a Transmuter_TelemetrySettings_t to initial values.
 *
 * Set a Transmuter_TelemetrySettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_TelemetrySettings_t(Transmuter_TelemetrySettings_t* _pg_user)
{

    // Telemetry packet selection
    initTransmuter_TelemetryPackets_t(&_pg_user->packets);

}// initTransmuter_TelemetrySettings_t

/*!
 * \brief Create the Transmuter_TelemetrySettings packet
 *
 * Transmuter packet selection. Enable or disable various telemetry packets
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_TelemetrySettingsPacketStructure(void* _pg_pkt, const Transmuter_TelemetrySettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Telemetry packet selection
    encodeTransmuter_TelemetryPackets_t(_pg_data, &_pg_byteindex, &_pg_user->packets);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetrySettingsPacketID());

}// encodeTransmuter_TelemetrySettingsPacketStructure

/*!
 * \brief Decode the Transmuter_TelemetrySettings packet
 *
 * Transmuter packet selection. Enable or disable various telemetry packets
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetrySettingsPacketStructure(const void* _pg_pkt, Transmuter_TelemetrySettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetrySettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_TelemetrySettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // Telemetry packet selection
    if(decodeTransmuter_TelemetryPackets_t(_pg_data, &_pg_byteindex, &_pg_user->packets) == 0)
        return 0;

    return 1;

}// decodeTransmuter_TelemetrySettingsPacketStructure

/*!
 * \brief Create the Transmuter_TelemetrySettings packet
 *
 * Transmuter packet selection. Enable or disable various telemetry packets
 * \param _pg_pkt points to the packet which will be created by this function
 * \param packets is Telemetry packet selection
 */
void encodeTransmuter_TelemetrySettingsPacket(void* _pg_pkt, const Transmuter_TelemetryPackets_t* packets)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Telemetry packet selection
    encodeTransmuter_TelemetryPackets_t(_pg_data, &_pg_byteindex, packets);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_TelemetrySettingsPacketID());

}// encodeTransmuter_TelemetrySettingsPacket

/*!
 * \brief Decode the Transmuter_TelemetrySettings packet
 *
 * Transmuter packet selection. Enable or disable various telemetry packets
 * \param _pg_pkt points to the packet being decoded by this function
 * \param packets receives Telemetry packet selection
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_TelemetrySettingsPacket(const void* _pg_pkt, Transmuter_TelemetryPackets_t* packets)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getTransmuterPacketDataConst(_pg_pkt);
    int _pg_numbytes = getTransmuterPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_TelemetrySettingsPacketID())
        return 0;

    if(_pg_numbytes < getTransmuter_TelemetrySettingsMinDataLength())
        return 0;

    // Telemetry packet selection
    if(decodeTransmuter_TelemetryPackets_t(_pg_data, &_pg_byteindex, packets) == 0)
        return 0;

    return 1;

}// decodeTransmuter_TelemetrySettingsPacket

/*!
 * \brief Set a Transmuter_ThrottleControlLoopSettings_t to initial values.
 *
 * Set a Transmuter_ThrottleControlLoopSettings_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_ThrottleControlLoopSettings_t(Transmuter_ThrottleControlLoopSettings_t* _pg_user)
{

    _pg_user->Kp = 25;

    _pg_user->Ki = (float)2.5;

    _pg_user->Kd = 0;

    _pg_user->Kf = 0;

    // Minimum engine throttle position
    _pg_user->throttleMin = 10;

    // Maximum engine throttle position
    _pg_user->throttleMax = 100;

    // Maximum throttle slew rate
    _pg_user->slewLimit = 100;

    // Throttle command low pass filter corner frequency
    _pg_user->throttleFilterHz = 1.0f;

}// initTransmuter_ThrottleControlLoopSettings_t

/*!
 * \brief Create the Transmuter_ThrottleControlLoopSettings packet
 *
 * Engine throttle control loop settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeTransmuter_ThrottleControlLoopSettingsPacketStructure(void* _pg_pkt, const Transmuter_ThrottleControlLoopSettings_t* _pg_user)
{
    uint8_t* _pg_data = getTransmuterPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of Kp is 0.0f to 50.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kp, _pg_data, &_pg_byteindex, 0.0f, 1310.7f);

    // Range of Ki is 0.0f to 50.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Ki, _pg_data, &_pg_byteindex, 0.0f, 1310.7f);

    // Range of Kd is 0.0f to 50.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kd, _pg_data, &_pg_byteindex, 0.0f, 1310.7f);

    // Range of Kf is 0.0f to 50.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kf, _pg_data, &_pg_byteindex, 0.0f, 1310.7f);

    // Minimum engine throttle position
    // Range of throttleMin is 0 to 255.
    uint8ToBytes(_pg_user->throttleMin, _pg_data, &_pg_byteindex);

    // Maximum engine throttle position
    // Range of throttleMax is 0 to 255.
    uint8ToBytes(_pg_user->throttleMax, _pg_data, &_pg_byteindex);

    // Maximum throttle slew rate
    // Range of slewLimit is 0 to 65535.
    uint16ToBeBytes(_pg_user->slewLimit, _pg_data, &_pg_byteindex);

    // Throttle command low pass filter corner frequency
    // Range of throttleFilterHz is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->throttleFilterHz, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishTransmuterPacket(_pg_pkt, _pg_byteindex, getTransmuter_ThrottleControlLoopSettingsPacketID());

}// encodeTransmuter_ThrottleControlLoopSettingsPacketStructure

/*!
 * \brief Decode the Transmuter_ThrottleControlLoopSettings packet
 *
 * Engine throttle control loop settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeTransmuter_ThrottleControlLoopSettingsPacketStructure(const void* _pg_pkt, Transmuter_ThrottleControlLoopSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getTransmuterPacketID(_pg_pkt) != getTransmuter_ThrottleControlLoopSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getTransmuterPacketSize(_pg_pkt);
    if(_pg_numbytes < getTransmuter_ThrottleControlLoopSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getTransmuterPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->throttleFilterHz = 1.0f;

    // Range of Kp is 0.0f to 50.0f.
    _pg_user->Kp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1310.7f);

    // Range of Ki is 0.0f to 50.0f.
    _pg_user->Ki = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1310.7f);

    // Range of Kd is 0.0f to 50.0f.
    _pg_user->Kd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1310.7f);

    // Range of Kf is 0.0f to 50.0f.
    _pg_user->Kf = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1310.7f);

    // Minimum engine throttle position
    // Range of throttleMin is 0 to 255.
    _pg_user->throttleMin = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Maximum engine throttle position
    // Range of throttleMax is 0 to 255.
    _pg_user->throttleMax = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Maximum throttle slew rate
    // Range of slewLimit is 0 to 65535.
    _pg_user->slewLimit = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Throttle command low pass filter corner frequency
    // Range of throttleFilterHz is 0.0f to 65.535f.
    _pg_user->throttleFilterHz = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeTransmuter_ThrottleControlLoopSettingsPacketStructure

/*!
 * \brief Verify a Transmuter_ThrottleControlLoopSettings_t has acceptable values.
 *
 * Verify a Transmuter_ThrottleControlLoopSettings_t has acceptable values. Not all fields are
 * verified, only those which the protocol specifies. Fields which are outside
 * the allowable range are changed to the maximum or minimum allowable value. 
 * \param _pg_user is the structure whose data are verified
 * \return 1 if all verifiable data where valid, else 0 if data had to be corrected
 */
int verifyTransmuter_ThrottleControlLoopSettings_t(Transmuter_ThrottleControlLoopSettings_t* _pg_user)
{
    int _pg_good = 1;

    if(_pg_user->Kp < 0.0f)
    {
        _pg_user->Kp = 0.0f;
        _pg_good = 0;
    }
    else if(_pg_user->Kp > 50.0f)
    {
        _pg_user->Kp = 50.0f;
        _pg_good = 0;
    }

    if(_pg_user->Ki < 0.0f)
    {
        _pg_user->Ki = 0.0f;
        _pg_good = 0;
    }
    else if(_pg_user->Ki > 50.0f)
    {
        _pg_user->Ki = 50.0f;
        _pg_good = 0;
    }

    if(_pg_user->Kd < 0.0f)
    {
        _pg_user->Kd = 0.0f;
        _pg_good = 0;
    }
    else if(_pg_user->Kd > 50.0f)
    {
        _pg_user->Kd = 50.0f;
        _pg_good = 0;
    }

    if(_pg_user->Kf < 0.0f)
    {
        _pg_user->Kf = 0.0f;
        _pg_good = 0;
    }
    else if(_pg_user->Kf > 50.0f)
    {
        _pg_user->Kf = 50.0f;
        _pg_good = 0;
    }

    // Minimum engine throttle position
    if(_pg_user->throttleMin > 100)
    {
        _pg_user->throttleMin = 100;
        _pg_good = 0;
    }

    // Maximum engine throttle position
    if(_pg_user->throttleMax > 100)
    {
        _pg_user->throttleMax = 100;
        _pg_good = 0;
    }

    // Maximum throttle slew rate
    if(_pg_user->slewLimit < 10)
    {
        _pg_user->slewLimit = 10;
        _pg_good = 0;
    }
    else if(_pg_user->slewLimit > 1000)
    {
        _pg_user->slewLimit = 1000;
        _pg_good = 0;
    }

    // Throttle command low pass filter corner frequency
    if(_pg_user->throttleFilterHz < 0.01f)
    {
        _pg_user->throttleFilterHz = 0.01f;
        _pg_good = 0;
    }
    else if(_pg_user->throttleFilterHz > 50.0f)
    {
        _pg_user->throttleFilterHz = 50.0f;
        _pg_good = 0;
    }

    return _pg_good;

}// verifyTransmuter_ThrottleControlLoopSettings_t

// end of TransmuterPackets.c
