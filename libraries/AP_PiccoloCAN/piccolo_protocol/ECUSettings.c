// ECUSettings.c was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */
 

#include "ECUSettings.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a ECU_PumpOptionBits_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeECU_PumpOptionBits_t(uint8_t* _pg_data, int* _pg_bytecount, const ECU_PumpOptionBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved for future use
    // Range of reserved is 0 to 255.
    _pg_data[_pg_byteindex] = (uint8_t)_pg_user->reserved;
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeECU_PumpOptionBits_t

/*!
 * \brief Decode a ECU_PumpOptionBits_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeECU_PumpOptionBits_t(const uint8_t* _pg_data, int* _pg_bytecount, ECU_PumpOptionBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Reserved for future use
    // Range of reserved is 0 to 255.
    _pg_user->reserved = _pg_data[_pg_byteindex];
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeECU_PumpOptionBits_t

/*!
 * \brief Create the ECU_ThrottleSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_ThrottleSettingsPacketStructure(void* _pg_pkt, const ECU_ThrottleSettings_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // Throttle open PWM value
    // Range of pulseOpen is 0 to 65535.
    uint16ToBeBytes(_pg_user->pulseOpen, _pg_data, &_pg_byteindex);

    // Throttle closed PWM value
    // Range of pulseClosed is 0 to 65535.
    uint16ToBeBytes(_pg_user->pulseClosed, _pg_data, &_pg_byteindex);

    // Throttle input open PWM value
    // Range of pulseInputOpen is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(_pg_user->pulseInputOpen, 4095);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Throttle input closed PWM value
    // Range of pulseInputClosed is 0 to 4095.
    _pg_tempbitfield = (unsigned int)limitMax(_pg_user->pulseInputClosed, 4095);
    _pg_data[_pg_byteindex + 2] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;
    _pg_byteindex += 3; // close bit field


    // Throttle delay, constant value
    // Range of delay is 0 to 255.
    uint8ToBytes(_pg_user->delay, _pg_data, &_pg_byteindex);

    // Throttle delay, minimum value
    // Range of minDelay is 0 to 255.
    uint8ToBytes(_pg_user->minDelay, _pg_data, &_pg_byteindex);

    // Throttle delay, minimum value
    // Range of maxDelay is 0 to 255.
    uint8ToBytes(_pg_user->maxDelay, _pg_data, &_pg_byteindex);

    encodeECU_ThrottleDelayConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->delayConfig);

    // Throttle dashpot soft limit value
    // Range of softLimit is 0 to 255.
    uint8ToBytes(_pg_user->softLimit, _pg_data, &_pg_byteindex);

    // Throttle dashpot hard limit value
    // Range of hardLimit is 0 to 255.
    uint8ToBytes(_pg_user->hardLimit, _pg_data, &_pg_byteindex);

    // Throttle dashpot falloff rate
    // Range of falloffRate is 0 to 255.
    uint8ToBytes(_pg_user->falloffRate, _pg_data, &_pg_byteindex);

    // Throttle curve lookup table elements
    // Range of curve is 0 to 255.
    for(_pg_i = 0; _pg_i < 11; _pg_i++)
        uint8ToBytes(_pg_user->curve[_pg_i], _pg_data, &_pg_byteindex);

    // Throttle curve config bits
    encodeECU_ThrottleCurveConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->curveConfig);

    encodeECU_ThrottleConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->config);

    // Range of analogSpan1 is 0 to 255.
    uint8ToBytes(_pg_user->analogSpan1, _pg_data, &_pg_byteindex);

    // Range of analogSpan2 is 0 to 65535.
    uint16ToBeBytes(_pg_user->analogSpan2, _pg_data, &_pg_byteindex);

    // Range of throttleTarget is 0 to 255.
    uint8ToBytes(_pg_user->throttleTarget, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_ThrottleSettingsPacketID());

}// encodeECU_ThrottleSettingsPacketStructure

/*!
 * \brief Decode the ECU_ThrottleSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_ThrottleSettingsPacketStructure(const void* _pg_pkt, ECU_ThrottleSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_ThrottleSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_ThrottleSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Throttle open PWM value
    // Range of pulseOpen is 0 to 65535.
    _pg_user->pulseOpen = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Throttle closed PWM value
    // Range of pulseClosed is 0 to 65535.
    _pg_user->pulseClosed = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Throttle input open PWM value
    // Range of pulseInputOpen is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 4);

    _pg_user->pulseInputOpen = _pg_tempbitfield;

    // Throttle input closed PWM value
    // Range of pulseInputClosed is 0 to 4095.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0xF);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 2];

    _pg_user->pulseInputClosed = _pg_tempbitfield;
    _pg_byteindex += 3; // close bit field

    // Throttle delay, constant value
    // Range of delay is 0 to 255.
    _pg_user->delay = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle delay, minimum value
    // Range of minDelay is 0 to 255.
    _pg_user->minDelay = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle delay, minimum value
    // Range of maxDelay is 0 to 255.
    _pg_user->maxDelay = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(decodeECU_ThrottleDelayConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->delayConfig) == 0)
        return 0;

    // Throttle dashpot soft limit value
    // Range of softLimit is 0 to 255.
    _pg_user->softLimit = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle dashpot hard limit value
    // Range of hardLimit is 0 to 255.
    _pg_user->hardLimit = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle dashpot falloff rate
    // Range of falloffRate is 0 to 255.
    _pg_user->falloffRate = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle curve lookup table elements
    // Range of curve is 0 to 255.
    for(_pg_i = 0; _pg_i < 11; _pg_i++)
        _pg_user->curve[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle curve config bits
    if(decodeECU_ThrottleCurveConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->curveConfig) == 0)
        return 0;

    if(decodeECU_ThrottleConfigBits_t(_pg_data, &_pg_byteindex, &_pg_user->config) == 0)
        return 0;

    // Range of analogSpan1 is 0 to 255.
    _pg_user->analogSpan1 = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Range of analogSpan2 is 0 to 65535.
    _pg_user->analogSpan2 = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of throttleTarget is 0 to 255.
    _pg_user->throttleTarget = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_ThrottleSettingsPacketStructure

/*!
 * \brief Create the ECU_FuelUsedSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_FuelUsedSettingsPacketStructure(void* _pg_pkt, const ECU_FuelUsedSettings_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of resetOnStartup is 0 to 255.
    uint8ToBytes(_pg_user->resetOnStartup, _pg_data, &_pg_byteindex);

    // Range of divisor is 0 to 65535.
    uint16ToBeBytes(_pg_user->divisor, _pg_data, &_pg_byteindex);

    // Range of offset is 0 to 65535.
    uint16ToBeBytes(_pg_user->offset, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_FuelUsedSettingsPacketID());

}// encodeECU_FuelUsedSettingsPacketStructure

/*!
 * \brief Decode the ECU_FuelUsedSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_FuelUsedSettingsPacketStructure(const void* _pg_pkt, ECU_FuelUsedSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_FuelUsedSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_FuelUsedSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Range of resetOnStartup is 0 to 255.
    _pg_user->resetOnStartup = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Range of divisor is 0 to 65535.
    _pg_user->divisor = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of offset is 0 to 65535.
    _pg_user->offset = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_FuelUsedSettingsPacketStructure

/*!
 * \brief Create the ECU_GovernorSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_GovernorSettingsPacketStructure(void* _pg_pkt, const ECU_GovernorSettings_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Range of pGain is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->pGain, _pg_data, &_pg_byteindex);

    // Range of iGain is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->iGain, _pg_data, &_pg_byteindex);

    // Range of dGain is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->dGain, _pg_data, &_pg_byteindex);

    // Range of scalePower is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->scalePower, _pg_data, &_pg_byteindex);

    // Range of maxRPM is 0.0f to 25500.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->maxRPM, _pg_data, &_pg_byteindex, 0.0f, 0.01f);

    // Range of minRPM is 0.0f to 25500.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->minRPM, _pg_data, &_pg_byteindex, 0.0f, 0.01f);

    // Range of mode is 0 to 255.
    uint8ToBytes(_pg_user->mode, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_GovernorSettingsPacketID());

}// encodeECU_GovernorSettingsPacketStructure

/*!
 * \brief Decode the ECU_GovernorSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_GovernorSettingsPacketStructure(const void* _pg_pkt, ECU_GovernorSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_GovernorSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_GovernorSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Range of pGain is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->pGain = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of iGain is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->iGain = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of dGain is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->dGain = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of scalePower is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->scalePower = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of maxRPM is 0.0f to 25500.0f.
    _pg_user->maxRPM = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.01f);

    // Range of minRPM is 0.0f to 25500.0f.
    _pg_user->minRPM = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.01f);

    // Range of mode is 0 to 255.
    _pg_user->mode = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_GovernorSettingsPacketStructure

/*!
 * \brief Create the ECU_PumpSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_PumpSettingsPacketStructure(void* _pg_pkt, const ECU_PumpSettings_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Pump proportional gain
    // Range of kp is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->kp, _pg_data, &_pg_byteindex);

    // Pump integral gain
    // Range of ki is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->ki, _pg_data, &_pg_byteindex);

    // Pump IMC (internal model) gain
    // Range of km is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->km, _pg_data, &_pg_byteindex);

    // Pump lower pressure limit (PSI)
    // Range of pressureLowerLimit is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->pressureLowerLimit, _pg_data, &_pg_byteindex);

    // Pump upper pressure limit (PSI)
    // Range of pressureUpperLimit is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->pressureUpperLimit, _pg_data, &_pg_byteindex);

    // Fuel pressure setpoint
    // Range of pressureSetpoint is -3.402823466e+38f to 3.402823466e+38f.
    float32ToBeBytes((float)_pg_user->pressureSetpoint, _pg_data, &_pg_byteindex);

    // Range of minimumPWM is 0 to 255.
    uint8ToBytes(_pg_user->minimumPWM, _pg_data, &_pg_byteindex);

    // Range of maximumPWM is 0 to 255.
    uint8ToBytes(_pg_user->maximumPWM, _pg_data, &_pg_byteindex);

    // Pump duty cycle ramp rate
    // Range of rampRate is 0 to 255.
    uint8ToBytes(_pg_user->rampRate, _pg_data, &_pg_byteindex);

    // Pump control system options
    encodeECU_PumpOptionBits_t(_pg_data, &_pg_byteindex, &_pg_user->options);

    // Reserved for future use
    // Range of reservedA is 0 to 255.
    uint8ToBytes(_pg_user->reservedA, _pg_data, &_pg_byteindex);

    // Reserved for future use
    // Range of reservedB is 0 to 255.
    uint8ToBytes(_pg_user->reservedB, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_PumpSettingsPacketID());

}// encodeECU_PumpSettingsPacketStructure

/*!
 * \brief Decode the ECU_PumpSettings packet
 *
 * Throttle settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_PumpSettingsPacketStructure(const void* _pg_pkt, ECU_PumpSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_PumpSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_PumpSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Pump proportional gain
    // Range of kp is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->kp = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Pump integral gain
    // Range of ki is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->ki = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Pump IMC (internal model) gain
    // Range of km is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->km = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Pump lower pressure limit (PSI)
    // Range of pressureLowerLimit is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->pressureLowerLimit = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Pump upper pressure limit (PSI)
    // Range of pressureUpperLimit is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->pressureUpperLimit = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Fuel pressure setpoint
    // Range of pressureSetpoint is -3.402823466e+38f to 3.402823466e+38f.
    _pg_user->pressureSetpoint = float32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of minimumPWM is 0 to 255.
    _pg_user->minimumPWM = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Range of maximumPWM is 0 to 255.
    _pg_user->maximumPWM = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Pump duty cycle ramp rate
    // Range of rampRate is 0 to 255.
    _pg_user->rampRate = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Pump control system options
    if(decodeECU_PumpOptionBits_t(_pg_data, &_pg_byteindex, &_pg_user->options) == 0)
        return 0;

    // Reserved for future use
    // Range of reservedA is 0 to 255.
    _pg_user->reservedA = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Reserved for future use
    // Range of reservedB is 0 to 255.
    _pg_user->reservedB = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_PumpSettingsPacketStructure

/*!
 * \brief Create the ECU_ECUData packet
 *
 * User data
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeECU_ECUDataPacketStructure(void* _pg_pkt, const ECU_ECUData_t* _pg_user)
{
    uint8_t* _pg_data = getECUPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Range of powerCycles is 0 to 65535.
    uint16ToBeBytes(_pg_user->powerCycles, _pg_data, &_pg_byteindex);

    // Range of engineTime is 0 to 4294967295.
    uint32ToBeBytes(_pg_user->engineTime, _pg_data, &_pg_byteindex);

    // Range of engineTimeTotal is 0 to 4294967295.
    uint32ToBeBytes(_pg_user->engineTimeTotal, _pg_data, &_pg_byteindex);

    // Range of fuelUsedOverflows is 0 to 65535.
    uint16ToBeBytes(_pg_user->fuelUsedOverflows, _pg_data, &_pg_byteindex);

    // Range of userValues is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        uint8ToBytes(_pg_user->userValues[_pg_i], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishECUPacket(_pg_pkt, _pg_byteindex, getECU_ECUDataPacketID());

}// encodeECU_ECUDataPacketStructure

/*!
 * \brief Decode the ECU_ECUData packet
 *
 * User data
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeECU_ECUDataPacketStructure(const void* _pg_pkt, ECU_ECUData_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(getECUPacketID(_pg_pkt) != getECU_ECUDataPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getECUPacketSize(_pg_pkt);
    if(_pg_numbytes < getECU_ECUDataMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getECUPacketDataConst(_pg_pkt);

    // Range of powerCycles is 0 to 65535.
    _pg_user->powerCycles = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of engineTime is 0 to 4294967295.
    _pg_user->engineTime = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of engineTimeTotal is 0 to 4294967295.
    _pg_user->engineTimeTotal = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of fuelUsedOverflows is 0 to 65535.
    _pg_user->fuelUsedOverflows = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Range of userValues is 0 to 255.
    for(_pg_i = 0; _pg_i < 8; _pg_i++)
        _pg_user->userValues[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeECU_ECUDataPacketStructure
// end of ECUSettings.c
