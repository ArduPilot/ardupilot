// ServoDefines.h was generated by ProtoGen version 3.2.a

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _SERVODEFINES_H
#define _SERVODEFINES_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include <stdbool.h>
#include "ServoProtocol.h"

/*!
 * Servo status bits
 */
typedef struct
{
    unsigned   enabled : 1;     //!< Servo enabled status
    ServoModes mode;            //!< Servo mode
    unsigned   cmdReceived : 1; //!< Set if the servo has received a valid position command within the configured timeout period
    unsigned   reservedA : 1;   //!< Reserved for future use
    unsigned   reservedB : 1;   //!< Reserved for future use
    unsigned   reservedC : 1;   //!< Reserved for future use
}Servo_StatusBits_t;

//! return the minimum encoded length for the Servo_StatusBits_t structure
#define getMinLengthOfServo_StatusBits_t() (1)

//! return the maximum encoded length for the Servo_StatusBits_t structure
#define getMaxLengthOfServo_StatusBits_t() (1)

//! Encode a Servo_StatusBits_t into a byte array
void encodeServo_StatusBits_t(uint8_t* data, int* bytecount, const Servo_StatusBits_t* user);

//! Decode a Servo_StatusBits_t from a byte array
int decodeServo_StatusBits_t(const uint8_t* data, int* bytecount, Servo_StatusBits_t* user);

/*!
 * Servo warning bits
 */
typedef struct
{
    unsigned overCurrent : 1;      //!< Servo current exceeds warning threshold
    unsigned overTemperature : 1;  //!< Servo temperature exceeds warning threshold
    unsigned overAcceleration : 1; //!< Servo accelerometer reading exceeds warning threshold
    unsigned invalidInput : 1;     //!< Most recent servo position command was outside valid range
    unsigned position : 1;         //!< Servo position is outside calibrated range
    unsigned potCalibration : 1;   //!< Servo potentiometer is not correctly calibrated
    unsigned underVoltage : 1;     //!< Servo voltage is below operational threshold
    unsigned overVoltage : 1;      //!< Servo voltage is above operational threshold
    unsigned reservedB : 8;        //!< Reserved for future use
}Servo_WarningBits_t;

//! return the minimum encoded length for the Servo_WarningBits_t structure
#define getMinLengthOfServo_WarningBits_t() (2)

//! return the maximum encoded length for the Servo_WarningBits_t structure
#define getMaxLengthOfServo_WarningBits_t() (2)

//! Encode a Servo_WarningBits_t into a byte array
void encodeServo_WarningBits_t(uint8_t* data, int* bytecount, const Servo_WarningBits_t* user);

//! Decode a Servo_WarningBits_t from a byte array
int decodeServo_WarningBits_t(const uint8_t* data, int* bytecount, Servo_WarningBits_t* user);

/*!
 * Servo error bits
 */
typedef struct
{
    unsigned position : 1;       //!< Servo position is outside measurement range
    unsigned potError : 1;       //!< Error reading servo position
    unsigned accError : 1;       //!< Error reading servo accelerometer data
    unsigned mapCalibration : 1; //!< Servo input/output map is not correctly calibrated
    unsigned settingsError : 1;  //!< Error reading servo settings from memory
    unsigned healthError : 1;    //!< Error reading servo health tracking information from memory
    unsigned tracking : 1;       //!< Servo position cannot match commanded position
    unsigned reservedB : 1;      //!< Reserved for future use
}Servo_ErrorBits_t;

//! return the minimum encoded length for the Servo_ErrorBits_t structure
#define getMinLengthOfServo_ErrorBits_t() (1)

//! return the maximum encoded length for the Servo_ErrorBits_t structure
#define getMaxLengthOfServo_ErrorBits_t() (1)

//! Encode a Servo_ErrorBits_t into a byte array
void encodeServo_ErrorBits_t(uint8_t* data, int* bytecount, const Servo_ErrorBits_t* user);

//! Decode a Servo_ErrorBits_t from a byte array
int decodeServo_ErrorBits_t(const uint8_t* data, int* bytecount, Servo_ErrorBits_t* user);

/*!
 * Servo packet selection
 */
typedef struct
{
    unsigned statusA : 1;       //!< Select the *STATUS_A* packet
    unsigned statusB : 1;       //!< Select the *STATUS_B* packet
    unsigned statusC : 1;       //!< Select the *STATUS_C* packet
    unsigned statusD : 1;       //!< Select the *STATUS_D* packet
    unsigned accelerometer : 1; //!< Select the *ACCELEROMETER* packet
    unsigned dbgA : 1;          //!< Reserved field (set to zero)
    unsigned dbgB : 1;          //!< Reserved field (set to zero)
    unsigned dbgC : 1;          //!< Reserved field (set to zero)
}Servo_TelemetryPackets_t;

//! return the minimum encoded length for the Servo_TelemetryPackets_t structure
#define getMinLengthOfServo_TelemetryPackets_t() (1)

//! return the maximum encoded length for the Servo_TelemetryPackets_t structure
#define getMaxLengthOfServo_TelemetryPackets_t() (1)

//! Encode a Servo_TelemetryPackets_t into a byte array
void encodeServo_TelemetryPackets_t(uint8_t* data, int* bytecount, const Servo_TelemetryPackets_t* user);

//! Decode a Servo_TelemetryPackets_t from a byte array
int decodeServo_TelemetryPackets_t(const uint8_t* data, int* bytecount, Servo_TelemetryPackets_t* user);

/*!
 * Servo telemetry configuration
 */
typedef struct
{
    uint8_t                  period;          //!< Servo telemetry period
    uint8_t                  silence;         //!< Servo silence period (after boot)
    Servo_TelemetryPackets_t packets;         //!< Telemetry packet selection
    Servo_TelemetryPackets_t responsePackets; //!< Command response packet selection
}Servo_TelemetrySettings_t;

//! return the minimum encoded length for the Servo_TelemetrySettings_t structure
#define getMinLengthOfServo_TelemetrySettings_t() (4)

//! return the maximum encoded length for the Servo_TelemetrySettings_t structure
#define getMaxLengthOfServo_TelemetrySettings_t() (4)

//! Encode a Servo_TelemetrySettings_t into a byte array
void encodeServo_TelemetrySettings_t(uint8_t* data, int* bytecount, const Servo_TelemetrySettings_t* user);

//! Decode a Servo_TelemetrySettings_t from a byte array
int decodeServo_TelemetrySettings_t(const uint8_t* data, int* bytecount, Servo_TelemetrySettings_t* user);

typedef struct
{
    unsigned mapEnabled : 1;             //!< 1 = I/O map is enabled
    unsigned piccoloCmd : 1;             //!< 1 = The servo will listen for Piccolo autopilot CAN messages
    unsigned neutralPositionEnabled : 1; //!< 1 = Servo neutral position is enabled, 0 = Neutral position disabled
    unsigned piccoloChannel : 5;         //!< Channel the servo will use to listen for Piccolo messages.
    unsigned timeoutAction : 2;          //!< Servo action at powerup
    unsigned reservedB : 2;              //!< reserved for future use
    unsigned reservedC : 4;              //!< reserved for future use
}Servo_ConfigBits_t;

//! return the minimum encoded length for the Servo_ConfigBits_t structure
#define getMinLengthOfServo_ConfigBits_t() (2)

//! return the maximum encoded length for the Servo_ConfigBits_t structure
#define getMaxLengthOfServo_ConfigBits_t() (2)

//! Encode a Servo_ConfigBits_t into a byte array
void encodeServo_ConfigBits_t(uint8_t* data, int* bytecount, const Servo_ConfigBits_t* user);

//! Decode a Servo_ConfigBits_t from a byte array
int decodeServo_ConfigBits_t(const uint8_t* data, int* bytecount, Servo_ConfigBits_t* user);

#ifdef __cplusplus
}
#endif
#endif // _SERVODEFINES_H
