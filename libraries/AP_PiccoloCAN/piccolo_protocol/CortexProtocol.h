// CortexProtocol.h was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#ifndef _CORTEXPROTOCOL_H
#define _CORTEXPROTOCOL_H

// Language target is C, C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 * \mainpage Cortex protocol stack
 * 
 * Cortex Hybrid Controller Protocol
 * 
 * The protocol API enumeration is incremented anytime the protocol is changed
 * in a way that affects compatibility with earlier versions of the protocol.
 * The protocol enumeration for this version is: 8
 * 
 * The protocol version is 1.2
 */

#include <stdint.h>
#include <stdbool.h>

//! \return the protocol API enumeration
#define getCortexApi() 8

//! \return the protocol version string
#define getCortexVersion() "1.2"

/*!
 * Cortex packet ID values
 */
typedef enum
{
    PKT_CORTEX_STANDBY = 0x10,                  //!< Command the cortex unit into standby mode
    PKT_CORTEX_PREFLIGHT = 0x11,                //!< Command the cortex unit to enter preflight mode (if supported)
    PKT_CORTEX_CRANK = 0x15,                    //!< Command the cortex unit to start cranking the engine
    PKT_CORTEX_TELEMETRY_STATUS = 0x80,         //!< System status information
    PKT_CORTEX_TELEMETRY_GENERATOR = 0x81,      //!< Generator status information
    PKT_CORTEX_TELEMETRY_BATTERY = 0x82,        //!< Battery status information
    PKT_CORTEX_TELEMETRY_CONTROLLER = 0x83,     //!< Controller status information
    PKT_CORTEX_TELEMETRY_ENGINE = 0x84,         //!< Engine control status information
    PKT_CORTEX_TELEMETRY_OUTPUT_RAIL = 0x85,    //!< Output rail voltage and current information
    PKT_CORTEX_CONFIG_TELEMETRY = 0x90,         //!< Telemetry settings
    PKT_CORTEX_CONFIG_GENERATOR = 0x91,         //!< Generator settings
    PKT_CORTEX_CONFIG_STARTING = 0x92,          //!< System starting settings
    PKT_CORTEX_CONFIG_POWER_LIMIT = 0x93,       //!< Power limit settings
    PKT_CORTEX_CONFIG_POWER_MAP = 0x94,         //!< Engine power map
    PKT_CORTEX_CONFIG_ENGINE = 0x95,            //!< Engine control loop settings
    PKT_CORTEX_CONFIG_THROTTLE = 0x96,          //!< Engine throttle control settings
    PKT_CORTEX_CONFIG_BATTERY = 0x9A,           //!< Battery settings
    PKT_CORTEX_CONFIG_OUTPUT_RAIL = 0x9B,       //!< Output rail settings
    PKT_CORTEX_EXTRA_TELLTALES = 0xA0,          //!< Cortex telltales
    PKT_CORTEX_CMD_SET_OUTPUT_ENABLE = 0xC0,    //!< Set the output enable state for a rail
    PKT_CORTEX_CMD_SET_CALIBRATION_MODE = 0xCC, //!< Enter calibration mode
    PKT_CORTEX_DEBUG_ACCUM = 0xD0,              //!< Debug packet for internal accumulated values
    PKT_CORTEX_DEBUG_CTRL = 0xD1,               //!< Debug packet for internal control values
    PKT_CORTEX_RAIL_CALIBRATION = 0xE0,         //!< Output rail voltage and current calibration packet
    PKT_CORTEX_GET_RAIL_CALIBRATION = 0xE1      //!< Request output rail calibration data
} CortexPackets;

//! \return the label of a 'CortexPackets' enum entry, based on its value
const char* CortexPackets_EnumLabel(int value);

/*!
 * Cortex operational modes enumeration
 */
typedef enum
{
    CORTEX_MODE_BOOTUP = 0x00,    //!< Initial powerup state
    CORTEX_MODE_STANDBY = 0x01,   //!< Standby mode
    CORTEX_MODE_PREFLIGHT = 0x02, //!< Preflight mode
    CORTEX_MODE_CRANKING = 0x03,  //!< Engine cranking mode
    CORTEX_MODE_RESERVED = 0x04,  //!< Reserved value
    CORTEX_MODE_RUNNING = 0x05,   //!< Auto-running mode
} CortexOperationModes;

//! \return the label of a 'CortexOperationModes' enum entry, based on its value
const char* CortexOperationModes_EnumLabel(int value);

/*!
 * Enumeration for output voltage rails
 */
typedef enum
{
    CORTEX_RAIL_SERVO = 0x00,    //!< Servo output rail
    CORTEX_RAIL_BATTERY = 0x01,  //!< Battery charger output rail
    CORTEX_RAIL_PAYLOAD = 0x02,  //!< Payload output rail
    CORTEX_RAIL_AVIONICS = 0x03  //!< Avionics output rail
} CortexOutputRails;

//! \return the label of a 'CortexOutputRails' enum entry, based on its value
const char* CortexOutputRails_EnumLabel(int value);

/*!
 * Cortex rail enable status
 */
typedef enum
{
    CORTEX_RAIL_DISABLE = 0x0, //!< Rail is disabled
    CORTEX_RAIL_STANDBY = 0x1, //!< Rail is temporarily off, and will be automatically enabled once the fault condition clears
    CORTEX_RAIL_ENABLE = 0x2   //!< Rail is enabled
} CortexRailStatus;

//! \return the label of a 'CortexRailStatus' enum entry, based on its value
const char* CortexRailStatus_EnumLabel(int value);


// The prototypes below provide an interface to the packets.
// They are not auto-generated functions, but must be hand-written

//! \return the packet data pointer from the packet
uint8_t* getCortexPacketData(void* pkt);

//! \return the packet data pointer from the packet, const
const uint8_t* getCortexPacketDataConst(const void* pkt);

//! Complete a packet after the data have been encoded
void finishCortexPacket(void* pkt, int size, uint32_t packetID);

//! \return the size of a packet from the packet header
int getCortexPacketSize(const void* pkt);

//! \return the ID of a packet from the packet header
uint32_t getCortexPacketID(const void* pkt);

#ifdef __cplusplus
}
#endif
#endif // _CORTEXPROTOCOL_H
