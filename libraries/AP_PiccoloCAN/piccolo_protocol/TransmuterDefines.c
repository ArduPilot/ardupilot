// TransmuterDefines.c was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "TransmuterDefines.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a Transmuter_StatusBits_t into a byte array
 *
 * Transmuter operational status information
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeTransmuter_StatusBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Transmuter_StatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Transmuter operational mode
    // Range of mode is 0 to 15.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(_pg_user->mode, 15) << 4;

    // Hardware enable is active
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->hwEnable == true) ? 1 : 0) << 3;

    // Software enable is active
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->swEnable == true) ? 1 : 0) << 2;

    // Critical error flag set (refer to error status packet)
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->anyErrors == true) ? 1 : 0) << 1;

    // Warning flag set (refer to error status packet)
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->anyWarnings == true) ? 1 : 0);

    // 0 = Auto current, 1 = Manual current
    _pg_data[_pg_byteindex + 1] = (uint8_t)((_pg_user->manualCurrent == true) ? 1 : 0) << 7;

    // 0 = Auto RPM, 1 = Manual RPM
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->manualSpeed == true) ? 1 : 0) << 6;

    // Reserved for future use

    // EFI system enabled status
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->efiEnabled == true) ? 1 : 0) << 1;

    // Transmuter is ready to run
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->readyToRun == true) ? 1 : 0);
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeTransmuter_StatusBits_t

/*!
 * \brief Decode a Transmuter_StatusBits_t from a byte array
 *
 * Transmuter operational status information
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeTransmuter_StatusBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Transmuter_StatusBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Transmuter operational mode
    // Range of mode is 0 to 15.
    _pg_user->mode = (_pg_data[_pg_byteindex] >> 4);

    // Hardware enable is active
    _pg_user->hwEnable = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Software enable is active
    _pg_user->swEnable = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;

    // Critical error flag set (refer to error status packet)
    _pg_user->anyErrors = (((_pg_data[_pg_byteindex] >> 1) & 0x1)) ? true : false;

    // Warning flag set (refer to error status packet)
    _pg_user->anyWarnings = (((_pg_data[_pg_byteindex]) & 0x1)) ? true : false;

    // 0 = Auto current, 1 = Manual current
    _pg_user->manualCurrent = ((_pg_data[_pg_byteindex + 1] >> 7)) ? true : false;

    // 0 = Auto RPM, 1 = Manual RPM
    _pg_user->manualSpeed = (((_pg_data[_pg_byteindex + 1] >> 6) & 0x1)) ? true : false;

    // Reserved for future use

    // EFI system enabled status
    _pg_user->efiEnabled = (((_pg_data[_pg_byteindex + 1] >> 1) & 0x1)) ? true : false;

    // Transmuter is ready to run
    _pg_user->readyToRun = (((_pg_data[_pg_byteindex + 1]) & 0x1)) ? true : false;
    _pg_byteindex += 2; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeTransmuter_StatusBits_t

/*!
 * \brief Encode a Transmuter_WarningBits_t into a byte array
 *
 * Transmuter operational status warning bits
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeTransmuter_WarningBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Transmuter_WarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // General motor control warning (refer to the motor warnings packet)
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->motor == true) ? 1 : 0) << 7;

    // Battery voltage is outside configured range
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->batVoltage == true) ? 1 : 0) << 6;

    // Battery current is outside configured range
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->batCurrent == true) ? 1 : 0) << 5;

    // Generator current is outside configured range
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->genCurrent == true) ? 1 : 0) << 4;

    // Generator motor temperature exceeds warning limit
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->genTemp == true) ? 1 : 0) << 3;

    // ESC MOSFET temperature exceeds warning limit
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->escTemp == true) ? 1 : 0) << 2;

    // Reserved for future use

    // General ECU warning
    _pg_data[_pg_byteindex + 1] = (uint8_t)((_pg_user->ecu == true) ? 1 : 0) << 7;

    // General fuel pump warning
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->pump == true) ? 1 : 0) << 6;

    // Mismatch between engine and generator RPM
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->rpmMismatch == true) ? 1 : 0) << 5;

    // Engine is not generating expected power
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->powerLoss == true) ? 1 : 0) << 4;

    // Engine is performing at maximum power limit
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->engineLimit == true) ? 1 : 0) << 3;

    // Fuel pressure warning
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->fuelPressure == true) ? 1 : 0) << 2;

    // Engine temperature exceeds warning threshold
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->chtTemp == true) ? 1 : 0) << 1;

    // Reserved for future use
    _pg_byteindex += 2; // close bit field

    // Reserved for future use
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeTransmuter_WarningBits_t

/*!
 * \brief Decode a Transmuter_WarningBits_t from a byte array
 *
 * Transmuter operational status warning bits
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeTransmuter_WarningBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Transmuter_WarningBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // General motor control warning (refer to the motor warnings packet)
    _pg_user->motor = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Battery voltage is outside configured range
    _pg_user->batVoltage = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Battery current is outside configured range
    _pg_user->batCurrent = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Generator current is outside configured range
    _pg_user->genCurrent = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Generator motor temperature exceeds warning limit
    _pg_user->genTemp = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // ESC MOSFET temperature exceeds warning limit
    _pg_user->escTemp = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;

    // Reserved for future use

    // General ECU warning
    _pg_user->ecu = ((_pg_data[_pg_byteindex + 1] >> 7)) ? true : false;

    // General fuel pump warning
    _pg_user->pump = (((_pg_data[_pg_byteindex + 1] >> 6) & 0x1)) ? true : false;

    // Mismatch between engine and generator RPM
    _pg_user->rpmMismatch = (((_pg_data[_pg_byteindex + 1] >> 5) & 0x1)) ? true : false;

    // Engine is not generating expected power
    _pg_user->powerLoss = (((_pg_data[_pg_byteindex + 1] >> 4) & 0x1)) ? true : false;

    // Engine is performing at maximum power limit
    _pg_user->engineLimit = (((_pg_data[_pg_byteindex + 1] >> 3) & 0x1)) ? true : false;

    // Fuel pressure warning
    _pg_user->fuelPressure = (((_pg_data[_pg_byteindex + 1] >> 2) & 0x1)) ? true : false;

    // Engine temperature exceeds warning threshold
    _pg_user->chtTemp = (((_pg_data[_pg_byteindex + 1] >> 1) & 0x1)) ? true : false;

    // Reserved for future use
    _pg_byteindex += 2; // close bit field

    // Reserved for future use
    _pg_byteindex += 1;

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeTransmuter_WarningBits_t

/*!
 * \brief Encode a Transmuter_ErrorBits_t into a byte array
 *
 * Transmuter operational status error bits
 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeTransmuter_ErrorBits_t(uint8_t* _pg_data, int* _pg_bytecount, const Transmuter_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // General motor control error (refer to the motor errors packet)
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->motor == true) ? 1 : 0) << 7;

    // Reserved for future use

    // System power map is improperly configured
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->powerMap == true) ? 1 : 0) << 5;

    // Error during starting routine
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->starting == true) ? 1 : 0) << 4;

    // Reserved for future use

    // ECU connection lost
    _pg_data[_pg_byteindex + 1] = (uint8_t)((_pg_user->ecuConnection == true) ? 1 : 0) << 7;

    // Fuel pump connection lost
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->pumpConnection == true) ? 1 : 0) << 6;

    // Engine stopped due to between engine and generator RPM
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->rpmMismatch == true) ? 1 : 0) << 5;

    // Engine stopped due to not generating power
    _pg_data[_pg_byteindex + 1] |= (uint8_t)((_pg_user->powerLoss == true) ? 1 : 0) << 4;

    // Reserved for future use
    _pg_byteindex += 2; // close bit field

    // Reserved for future use
    uint8ToBytes((uint8_t)(0), _pg_data, &_pg_byteindex);

    *_pg_bytecount = _pg_byteindex;

}// encodeTransmuter_ErrorBits_t

/*!
 * \brief Decode a Transmuter_ErrorBits_t from a byte array
 *
 * Transmuter operational status error bits
 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeTransmuter_ErrorBits_t(const uint8_t* _pg_data, int* _pg_bytecount, Transmuter_ErrorBits_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // General motor control error (refer to the motor errors packet)
    _pg_user->motor = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Reserved for future use

    // System power map is improperly configured
    _pg_user->powerMap = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Error during starting routine
    _pg_user->starting = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Reserved for future use

    // ECU connection lost
    _pg_user->ecuConnection = ((_pg_data[_pg_byteindex + 1] >> 7)) ? true : false;

    // Fuel pump connection lost
    _pg_user->pumpConnection = (((_pg_data[_pg_byteindex + 1] >> 6) & 0x1)) ? true : false;

    // Engine stopped due to between engine and generator RPM
    _pg_user->rpmMismatch = (((_pg_data[_pg_byteindex + 1] >> 5) & 0x1)) ? true : false;

    // Engine stopped due to not generating power
    _pg_user->powerLoss = (((_pg_data[_pg_byteindex + 1] >> 4) & 0x1)) ? true : false;

    // Reserved for future use
    _pg_byteindex += 2; // close bit field

    // Reserved for future use
    _pg_byteindex += 1;

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeTransmuter_ErrorBits_t

/*!
 * \brief Set a Transmuter_TelemetryPackets_t to initial values.
 *
 * Set a Transmuter_TelemetryPackets_t to initial values. Not all fields are set,
 * only those which the protocol specifies.
 * \param _pg_user is the structure whose data are set to initial values
 */
void initTransmuter_TelemetryPackets_t(Transmuter_TelemetryPackets_t* _pg_user)
{

    // Enable TelemetryStatus packet
    _pg_user->status = 1;

    // Enable TelemetryPower packet
    _pg_user->power = 1;

    // Enable TelemetrySetpoint packet
    _pg_user->setpoint = 1;

    // Enable TelemetryGenerator packet
    _pg_user->generator = 1;

    // Enable TelemetryCapacity packet
    _pg_user->capacity = 1;

    // Enable ControlLoop packet
    _pg_user->ctrlLoop = 0;

    // Enable TelemetryAPB packet
    _pg_user->apb = 0;

}// initTransmuter_TelemetryPackets_t

/*!
 * \brief Encode a Transmuter_TelemetryPackets_t into a byte array
 *

 * \param _pg_data points to the byte array to add encoded data to
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param _pg_user is the data to encode in the byte array
 */
void encodeTransmuter_TelemetryPackets_t(uint8_t* _pg_data, int* _pg_bytecount, const Transmuter_TelemetryPackets_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable TelemetryStatus packet
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->status == true) ? 1 : 0) << 7;

    // Enable TelemetryPower packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->power == true) ? 1 : 0) << 6;

    // Enable TelemetrySetpoint packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->setpoint == true) ? 1 : 0) << 5;

    // Enable TelemetryGenerator packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->generator == true) ? 1 : 0) << 4;

    // Enable TelemetryCapacity packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->capacity == true) ? 1 : 0) << 3;

    // Enable ControlLoop packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->ctrlLoop == true) ? 1 : 0) << 2;

    // Enable TelemetryAPB packet
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->apb == true) ? 1 : 0) << 1;

    // Reserved for future use
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

}// encodeTransmuter_TelemetryPackets_t

/*!
 * \brief Decode a Transmuter_TelemetryPackets_t from a byte array
 *

 * \param _pg_data points to the byte array to decoded data from
 * \param _pg_bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param _pg_user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0.
 */
int decodeTransmuter_TelemetryPackets_t(const uint8_t* _pg_data, int* _pg_bytecount, Transmuter_TelemetryPackets_t* _pg_user)
{
    int _pg_byteindex = *_pg_bytecount;

    // Enable TelemetryStatus packet
    _pg_user->status = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Enable TelemetryPower packet
    _pg_user->power = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Enable TelemetrySetpoint packet
    _pg_user->setpoint = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Enable TelemetryGenerator packet
    _pg_user->generator = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Enable TelemetryCapacity packet
    _pg_user->capacity = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Enable ControlLoop packet
    _pg_user->ctrlLoop = (((_pg_data[_pg_byteindex] >> 2) & 0x1)) ? true : false;

    // Enable TelemetryAPB packet
    _pg_user->apb = (((_pg_data[_pg_byteindex] >> 1) & 0x1)) ? true : false;

    // Reserved for future use
    _pg_byteindex += 1; // close bit field

    *_pg_bytecount = _pg_byteindex;

    return 1;

}// decodeTransmuter_TelemetryPackets_t

// end of TransmuterDefines.c
