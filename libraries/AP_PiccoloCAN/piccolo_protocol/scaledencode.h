// scaledencode.h was generated by ProtoGen version 2.18.c

#ifndef _SCALEDENCODE_H
#define _SCALEDENCODE_H

// C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 * scaledencode routines place scaled numbers into a byte stream.
 *
 * scaledencode routines place scaled values into a big or little endian byte
 * stream. The values can be any legitimate type (double, float, uint32_t,
 * uint16_t, uint8_t, int32_t, int16_t, int8_t), and are encoded as either a
 * unsigned or signed integer from 1 to 8 bytes in length. Unsigned encodings
 * allow the caller to specify a minimum and a maximum value, with the only
 * limitation that the maximum value must be more than the minimum. Signed
 * encodings only allow the caller to specify a maximum value which gives
 * maximum absolute value that can be encoded.
 *
 * An example encoding would be: take a float that represents speed in meters
 * per second and encode it in two bytes from -200 to 200 meters per second.
 * In that example the encoding function would be:
 *
 * floatScaledTo2SignedBeBytes(speed, bytestream, &index, 200);
 *
 * This would scale the speed according to (32767/200), and copy the resulting
 * two bytes to bytestream[index] as a signed 16 bit number in big endian
 * order. This would result in a velocity resolution of 0.006 m/s.
 *
 * Another example encoding is: take a double that represents altitude in
 * meters and encode it in three bytes from -1000 to 49000 meters:
 *
 * doubleScaledTo3UnsignedLeBytes(alt, bytestream, &index, -1000, 49000);
 *
 * This would transform the altitude according to (alt *(16777215/50000) + 1000)
 * and copy the resulting three bytes to bytestream[index] as an unsigned 24
 * bit number in little endian order. This would result in an altitude
 * resolution of 0.003 meters.
 * 
 * scaledencode does not include routines that increase the resolution of the
 * source value. For example the function floatScaledTo5UnsignedBeBytes() does
 * not exist, because expanding a float to 5 bytes does not make any resolution
 * improvement over encoding it in 4 bytes. In general the encoded format
 * must be equal to or less than the number of bytes of the raw data.
 */

#define __STDC_CONSTANT_MACROS
#include <stdint.h>

//! Scale a float32 to the base integer type used for bitfield
unsigned int float32ScaledToBitfield(float value, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 4 unsigned bytes in big endian order.
void float32ScaledTo4UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 4 unsigned bytes in little endian order.
void float32ScaledTo4UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 4 signed bytes in big endian order.
void float32ScaledTo4SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 4 signed bytes in little endian order.
void float32ScaledTo4SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 3 unsigned bytes in big endian order.
void float32ScaledTo3UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 3 unsigned bytes in little endian order.
void float32ScaledTo3UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 3 signed bytes in big endian order.
void float32ScaledTo3SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 3 signed bytes in little endian order.
void float32ScaledTo3SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 2 unsigned bytes in big endian order.
void float32ScaledTo2UnsignedBeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 2 unsigned bytes in little endian order.
void float32ScaledTo2UnsignedLeBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 2 signed bytes in big endian order.
void float32ScaledTo2SignedBeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 2 signed bytes in little endian order.
void float32ScaledTo2SignedLeBytes(float value, uint8_t* bytes, int* index, float scaler);

//! Encode a float on a byte stream by scaling to fit in 1 unsigned byte.
void float32ScaledTo1UnsignedBytes(float value, uint8_t* bytes, int* index, float min, float scaler);

//! Encode a float on a byte stream by scaling to fit in 1 signed byte.
void float32ScaledTo1SignedBytes(float value, uint8_t* bytes, int* index, float scaler);

#ifdef __cplusplus
}
#endif
#endif
