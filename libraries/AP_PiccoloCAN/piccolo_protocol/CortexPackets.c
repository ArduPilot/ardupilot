// CortexPackets.c was generated by ProtoGen version 3.5.c

/*
 * This file is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Author: Oliver Walters / Currawong Engineering Pty Ltd
 */

#include "CortexPackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"
#include "CortexDefines.h"

/*!
 * \brief Create the Cortex_Standby packet
 *
 * Command the Cortex into standby mode
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeCortex_StandbyPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xA0), _pg_data, &_pg_byteindex);

    // Constant value required for standby sequence
    uint8ToBytes((uint8_t)(0xB0), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_StandbyPacketID());

}// encodeCortex_StandbyPacket

/*!
 * \brief Decode the Cortex_Standby packet
 *
 * Command the Cortex into standby mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_StandbyPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_StandbyPacketID())
        return 0;

    if(_pg_numbytes < getCortex_StandbyMinDataLength())
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA0)
        return 0;

    // Constant value required for standby sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xB0)
        return 0;

    return 1;

}// decodeCortex_StandbyPacket

/*!
 * \brief Create the Cortex_Preflight packet
 *
 * Command the Cortex to enter preflight mode
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeCortex_PreflightPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for preflight sequence
    uint8ToBytes((uint8_t)(0x3C), _pg_data, &_pg_byteindex);

    // Constant value required for preflight sequence
    uint8ToBytes((uint8_t)(0xC3), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_PreflightPacketID());

}// encodeCortex_PreflightPacket

/*!
 * \brief Decode the Cortex_Preflight packet
 *
 * Command the Cortex to enter preflight mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_PreflightPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_PreflightPacketID())
        return 0;

    if(_pg_numbytes < getCortex_PreflightMinDataLength())
        return 0;

    // Constant value required for preflight sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x3C)
        return 0;

    // Constant value required for preflight sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC3)
        return 0;

    return 1;

}// decodeCortex_PreflightPacket

/*!
 * \brief Create the Cortex_StartCranking packet
 *
 * Command the Cortex to start cranking the engine
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeCortex_StartCrankingPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for cranking sequence
    uint8ToBytes((uint8_t)(0x5A), _pg_data, &_pg_byteindex);

    // Constant value required for cranking sequence
    uint8ToBytes((uint8_t)(0xA5), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_StartCrankingPacketID());

}// encodeCortex_StartCrankingPacket

/*!
 * \brief Decode the Cortex_StartCranking packet
 *
 * Command the Cortex to start cranking the engine
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_StartCrankingPacket(const void* _pg_pkt)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_StartCrankingPacketID())
        return 0;

    if(_pg_numbytes < getCortex_StartCrankingMinDataLength())
        return 0;

    // Constant value required for cranking sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0x5A)
        return 0;

    // Constant value required for cranking sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xA5)
        return 0;

    return 1;

}// decodeCortex_StartCrankingPacket

/*!
 * \brief Create the Cortex_TelemetryStatus packet
 *
 * Overall system status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryStatusPacketStructure(void* _pg_pkt, const Cortex_TelemetryStatus_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // System status bits
    encodeCortex_StatusBits_t(_pg_data, &_pg_byteindex, &_pg_user->status);

    // System warning bits
    encodeCortex_WarningBits_t(_pg_data, &_pg_byteindex, &_pg_user->warning);

    // System error bits
    encodeCortex_ErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->error);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryStatusPacketID());

}// encodeCortex_TelemetryStatusPacketStructure

/*!
 * \brief Decode the Cortex_TelemetryStatus packet
 *
 * Overall system status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryStatusPacketStructure(const void* _pg_pkt, Cortex_TelemetryStatus_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryStatusPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryStatusMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // System status bits
    if(decodeCortex_StatusBits_t(_pg_data, &_pg_byteindex, &_pg_user->status) == 0)
        return 0;

    // System warning bits
    if(decodeCortex_WarningBits_t(_pg_data, &_pg_byteindex, &_pg_user->warning) == 0)
        return 0;

    // System error bits
    if(decodeCortex_ErrorBits_t(_pg_data, &_pg_byteindex, &_pg_user->error) == 0)
        return 0;

    return 1;

}// decodeCortex_TelemetryStatusPacketStructure

/*!
 * \brief Create the Cortex_TelemetryStatus packet
 *
 * Overall system status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param status is System status bits
 * \param warning is System warning bits
 * \param error is System error bits
 */
void encodeCortex_TelemetryStatusPacket(void* _pg_pkt, const Cortex_StatusBits_t* status, const Cortex_WarningBits_t* warning, const Cortex_ErrorBits_t* error)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // System status bits
    encodeCortex_StatusBits_t(_pg_data, &_pg_byteindex, status);

    // System warning bits
    encodeCortex_WarningBits_t(_pg_data, &_pg_byteindex, warning);

    // System error bits
    encodeCortex_ErrorBits_t(_pg_data, &_pg_byteindex, error);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryStatusPacketID());

}// encodeCortex_TelemetryStatusPacket

/*!
 * \brief Decode the Cortex_TelemetryStatus packet
 *
 * Overall system status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param status receives System status bits
 * \param warning receives System warning bits
 * \param error receives System error bits
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryStatusPacket(const void* _pg_pkt, Cortex_StatusBits_t* status, Cortex_WarningBits_t* warning, Cortex_ErrorBits_t* error)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryStatusPacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryStatusMinDataLength())
        return 0;

    // System status bits
    if(decodeCortex_StatusBits_t(_pg_data, &_pg_byteindex, status) == 0)
        return 0;

    // System warning bits
    if(decodeCortex_WarningBits_t(_pg_data, &_pg_byteindex, warning) == 0)
        return 0;

    // System error bits
    if(decodeCortex_ErrorBits_t(_pg_data, &_pg_byteindex, error) == 0)
        return 0;

    return 1;

}// decodeCortex_TelemetryStatusPacket

/*!
 * \brief Create the Cortex_TelemetryGenerator packet
 *
 * Generator status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryGeneratorPacketStructure(void* _pg_pkt, const Cortex_TelemetryGenerator_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Generator speed
    // Range of rpm is -32768 to 32767.
    int16ToBeBytes(_pg_user->rpm, _pg_data, &_pg_byteindex);

    // Generator duty cycle
    // Range of dutyCycle is 0 to 255.
    uint8ToBytes(_pg_user->dutyCycle, _pg_data, &_pg_byteindex);

    // Generator voltage
    // Range of voltage is 0.0f to 255.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->voltage, _pg_data, &_pg_byteindex, 0.0f, 257.0f);

    // Generator current
    // Range of current is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->current, _pg_data, &_pg_byteindex, 128.498039f);

    // Generator temperature
    // Range of temperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->temperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryGeneratorPacketID());

}// encodeCortex_TelemetryGeneratorPacketStructure

/*!
 * \brief Decode the Cortex_TelemetryGenerator packet
 *
 * Generator status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryGeneratorPacketStructure(const void* _pg_pkt, Cortex_TelemetryGenerator_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryGeneratorPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryGeneratorMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Generator speed
    // Range of rpm is -32768 to 32767.
    _pg_user->rpm = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Generator duty cycle
    // Range of dutyCycle is 0 to 255.
    _pg_user->dutyCycle = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator voltage
    // Range of voltage is 0.0f to 255.0f.
    _pg_user->voltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/257.0f);

    // Generator current
    // Range of current is -255.0f to 255.0f.
    _pg_user->current = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // Generator temperature
    // Range of temperature is -55.0f to 200.0f.
    _pg_user->temperature = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryGeneratorPacketStructure

/*!
 * \brief Create the Cortex_TelemetryGenerator packet
 *
 * Generator status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param rpm is Generator speed
 * \param dutyCycle is Generator duty cycle
 * \param voltage is Generator voltage
 * \param current is Generator current
 * \param temperature is Generator temperature
 */
void encodeCortex_TelemetryGeneratorPacket(void* _pg_pkt, int16_t rpm, uint8_t dutyCycle, float voltage, float current, float temperature)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Generator speed
    // Range of rpm is -32768 to 32767.
    int16ToBeBytes(rpm, _pg_data, &_pg_byteindex);

    // Generator duty cycle
    // Range of dutyCycle is 0 to 255.
    uint8ToBytes(dutyCycle, _pg_data, &_pg_byteindex);

    // Generator voltage
    // Range of voltage is 0.0f to 255.0f.
    float32ScaledTo2UnsignedBeBytes(voltage, _pg_data, &_pg_byteindex, 0.0f, 257.0f);

    // Generator current
    // Range of current is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(current, _pg_data, &_pg_byteindex, 128.498039f);

    // Generator temperature
    // Range of temperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(temperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryGeneratorPacketID());

}// encodeCortex_TelemetryGeneratorPacket

/*!
 * \brief Decode the Cortex_TelemetryGenerator packet
 *
 * Generator status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param rpm receives Generator speed
 * \param dutyCycle receives Generator duty cycle
 * \param voltage receives Generator voltage
 * \param current receives Generator current
 * \param temperature receives Generator temperature
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryGeneratorPacket(const void* _pg_pkt, int16_t* rpm, uint8_t* dutyCycle, float* voltage, float* current, float* temperature)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryGeneratorPacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryGeneratorMinDataLength())
        return 0;

    // Generator speed
    // Range of rpm is -32768 to 32767.
    (*rpm) = int16FromBeBytes(_pg_data, &_pg_byteindex);

    // Generator duty cycle
    // Range of dutyCycle is 0 to 255.
    (*dutyCycle) = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Generator voltage
    // Range of voltage is 0.0f to 255.0f.
    (*voltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/257.0f);

    // Generator current
    // Range of current is -255.0f to 255.0f.
    (*current) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // Generator temperature
    // Range of temperature is -55.0f to 200.0f.
    (*temperature) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryGeneratorPacket

/*!
 * \brief Create the Cortex_TelemetryBattery packet
 *
 * Battery status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryBatteryPacketStructure(void* _pg_pkt, const Cortex_TelemetryBattery_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Battery voltage
    // Range of voltage is 0.0f to 255.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->voltage, _pg_data, &_pg_byteindex, 0.0f, 257.0f);

    // Battery current
    // Range of current is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->current, _pg_data, &_pg_byteindex, 128.498039f);

    // Battery temperature
    // Range of temperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->temperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryBatteryPacketID());

}// encodeCortex_TelemetryBatteryPacketStructure

/*!
 * \brief Decode the Cortex_TelemetryBattery packet
 *
 * Battery status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryBatteryPacketStructure(const void* _pg_pkt, Cortex_TelemetryBattery_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryBatteryPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryBatteryMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Battery voltage
    // Range of voltage is 0.0f to 255.0f.
    _pg_user->voltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/257.0f);

    // Battery current
    // Range of current is -255.0f to 255.0f.
    _pg_user->current = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // Battery temperature
    // Range of temperature is -55.0f to 200.0f.
    _pg_user->temperature = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryBatteryPacketStructure

/*!
 * \brief Create the Cortex_TelemetryBattery packet
 *
 * Battery status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param voltage is Battery voltage
 * \param current is Battery current
 * \param temperature is Battery temperature
 */
void encodeCortex_TelemetryBatteryPacket(void* _pg_pkt, float voltage, float current, float temperature)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Battery voltage
    // Range of voltage is 0.0f to 255.0f.
    float32ScaledTo2UnsignedBeBytes(voltage, _pg_data, &_pg_byteindex, 0.0f, 257.0f);

    // Battery current
    // Range of current is -255.0f to 255.0f.
    float32ScaledTo2SignedBeBytes(current, _pg_data, &_pg_byteindex, 128.498039f);

    // Battery temperature
    // Range of temperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(temperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryBatteryPacketID());

}// encodeCortex_TelemetryBatteryPacket

/*!
 * \brief Decode the Cortex_TelemetryBattery packet
 *
 * Battery status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param voltage receives Battery voltage
 * \param current receives Battery current
 * \param temperature receives Battery temperature
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryBatteryPacket(const void* _pg_pkt, float* voltage, float* current, float* temperature)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryBatteryPacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryBatteryMinDataLength())
        return 0;

    // Battery voltage
    // Range of voltage is 0.0f to 255.0f.
    (*voltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/257.0f);

    // Battery current
    // Range of current is -255.0f to 255.0f.
    (*current) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/128.498039f);

    // Battery temperature
    // Range of temperature is -55.0f to 200.0f.
    (*temperature) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryBatteryPacket

/*!
 * \brief Create the Cortex_TelemetryController packet
 *
 * Controller status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryControllerPacketStructure(void* _pg_pkt, const Cortex_TelemetryController_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Generator rectifier temperature
    // Range of rectifierTemperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->rectifierTemperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // Voltage regulator temperature
    // Range of regulatorTemperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->regulatorTemperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // Generator run time
    // Range of runTime is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(_pg_user->runTime, 16777215)), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryControllerPacketID());

}// encodeCortex_TelemetryControllerPacketStructure

/*!
 * \brief Decode the Cortex_TelemetryController packet
 *
 * Controller status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryControllerPacketStructure(const void* _pg_pkt, Cortex_TelemetryController_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryControllerPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryControllerMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Generator rectifier temperature
    // Range of rectifierTemperature is -55.0f to 200.0f.
    _pg_user->rectifierTemperature = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    // Voltage regulator temperature
    // Range of regulatorTemperature is -55.0f to 200.0f.
    _pg_user->regulatorTemperature = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    // Generator run time
    // Range of runTime is 0 to 16777215.
    _pg_user->runTime = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeCortex_TelemetryControllerPacketStructure

/*!
 * \brief Create the Cortex_TelemetryController packet
 *
 * Controller status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param rectifierTemperature is Generator rectifier temperature
 * \param regulatorTemperature is Voltage regulator temperature
 * \param runTime is Generator run time
 */
void encodeCortex_TelemetryControllerPacket(void* _pg_pkt, float rectifierTemperature, float regulatorTemperature, uint32_t runTime)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Generator rectifier temperature
    // Range of rectifierTemperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(rectifierTemperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // Voltage regulator temperature
    // Range of regulatorTemperature is -55.0f to 200.0f.
    float32ScaledTo1UnsignedBytes(regulatorTemperature, _pg_data, &_pg_byteindex, -55.0f, 1.0f);

    // Generator run time
    // Range of runTime is 0 to 16777215.
    uint24ToBeBytes((uint32_t)(limitMax(runTime, 16777215)), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryControllerPacketID());

}// encodeCortex_TelemetryControllerPacket

/*!
 * \brief Decode the Cortex_TelemetryController packet
 *
 * Controller status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param rectifierTemperature receives Generator rectifier temperature
 * \param regulatorTemperature receives Voltage regulator temperature
 * \param runTime receives Generator run time
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryControllerPacket(const void* _pg_pkt, float* rectifierTemperature, float* regulatorTemperature, uint32_t* runTime)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryControllerPacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryControllerMinDataLength())
        return 0;

    // Generator rectifier temperature
    // Range of rectifierTemperature is -55.0f to 200.0f.
    (*rectifierTemperature) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    // Voltage regulator temperature
    // Range of regulatorTemperature is -55.0f to 200.0f.
    (*regulatorTemperature) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, -55.0f, 1.0f/1.0f);

    // Generator run time
    // Range of runTime is 0 to 16777215.
    (*runTime) = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeCortex_TelemetryControllerPacket

/*!
 * \brief Create the Cortex_TelemetryEngine packet
 *
 * Engine control status information. Note that this packet is only available
 * for Cortex devices which support external engine control.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryEnginePacketStructure(void* _pg_pkt, const Cortex_TelemetryEngine_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Throttle voltage target
    // Range of voltageTarget is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->voltageTarget, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Current throttle target
    // Range of throttleTarget is 0.0f to 100.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->throttleTarget, _pg_data, &_pg_byteindex, 0.0f, 2.55f);

    // Engine power demand
    // Range of powerTarget is -32767.0f to 32767.0f.
    float32ScaledTo2SignedBeBytes(_pg_user->powerTarget, _pg_data, &_pg_byteindex, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryEnginePacketID());

}// encodeCortex_TelemetryEnginePacketStructure

/*!
 * \brief Decode the Cortex_TelemetryEngine packet
 *
 * Engine control status information. Note that this packet is only available
 * for Cortex devices which support external engine control.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryEnginePacketStructure(const void* _pg_pkt, Cortex_TelemetryEngine_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryEnginePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryEngineMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Throttle voltage target
    // Range of voltageTarget is 0.0f to 655.35f.
    _pg_user->voltageTarget = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Current throttle target
    // Range of throttleTarget is 0.0f to 100.0f.
    _pg_user->throttleTarget = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.55f);

    // Engine power demand
    // Range of powerTarget is -32767.0f to 32767.0f.
    _pg_user->powerTarget = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryEnginePacketStructure

/*!
 * \brief Create the Cortex_TelemetryEngine packet
 *
 * Engine control status information. Note that this packet is only available
 * for Cortex devices which support external engine control.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param voltageTarget is Throttle voltage target
 * \param throttleTarget is Current throttle target
 * \param powerTarget is Engine power demand
 */
void encodeCortex_TelemetryEnginePacket(void* _pg_pkt, float voltageTarget, float throttleTarget, float powerTarget)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Throttle voltage target
    // Range of voltageTarget is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(voltageTarget, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Current throttle target
    // Range of throttleTarget is 0.0f to 100.0f.
    float32ScaledTo1UnsignedBytes(throttleTarget, _pg_data, &_pg_byteindex, 0.0f, 2.55f);

    // Engine power demand
    // Range of powerTarget is -32767.0f to 32767.0f.
    float32ScaledTo2SignedBeBytes(powerTarget, _pg_data, &_pg_byteindex, 1.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryEnginePacketID());

}// encodeCortex_TelemetryEnginePacket

/*!
 * \brief Decode the Cortex_TelemetryEngine packet
 *
 * Engine control status information. Note that this packet is only available
 * for Cortex devices which support external engine control.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param voltageTarget receives Throttle voltage target
 * \param throttleTarget receives Current throttle target
 * \param powerTarget receives Engine power demand
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryEnginePacket(const void* _pg_pkt, float* voltageTarget, float* throttleTarget, float* powerTarget)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryEnginePacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryEngineMinDataLength())
        return 0;

    // Throttle voltage target
    // Range of voltageTarget is 0.0f to 655.35f.
    (*voltageTarget) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Current throttle target
    // Range of throttleTarget is 0.0f to 100.0f.
    (*throttleTarget) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/2.55f);

    // Engine power demand
    // Range of powerTarget is -32767.0f to 32767.0f.
    (*powerTarget) = float32ScaledFrom2SignedBeBytes(_pg_data, &_pg_byteindex, 1.0f/1.0f);

    return 1;

}// decodeCortex_TelemetryEnginePacket

/*!
 * \brief Create the Cortex_TelemetryOutputRail packet
 *
 * Output rail status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetryOutputRailPacketStructure(void* _pg_pkt, const Cortex_TelemetryOutputRail_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Avionics rail voltage
    // Range of avionicsVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->avionicsVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;


    // Avionics rail current
    // Range of avionicsCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->avionicsCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Payload rail voltage
    // Range of payloadVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->payloadVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // Payload rail current
    // Range of payloadCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->payloadCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;

    // Servo rail voltage
    // Range of servoVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->servoVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 6] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;


    // Servo rail current
    // Range of servoCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)_pg_user->servoCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 7] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 6] |= (uint8_t)_pg_tempbitfield;

    // Reserved for future use
    _pg_byteindex += 8; // close bit field

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryOutputRailPacketID());

}// encodeCortex_TelemetryOutputRailPacketStructure

/*!
 * \brief Decode the Cortex_TelemetryOutputRail packet
 *
 * Output rail status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryOutputRailPacketStructure(const void* _pg_pkt, Cortex_TelemetryOutputRail_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned int _pg_tempbitfield = 0;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryOutputRailPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetryOutputRailMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Avionics rail voltage
    // Range of avionicsVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    _pg_user->avionicsVoltage = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Avionics rail current
    // Range of avionicsCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    _pg_user->avionicsCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Payload rail voltage
    // Range of payloadVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    _pg_user->payloadVoltage = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Payload rail current
    // Range of payloadCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    _pg_user->payloadCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Servo rail voltage
    // Range of servoVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 5] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 6] >> 6);

    _pg_user->servoVoltage = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Servo rail current
    // Range of servoCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 6] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 7] >> 4);

    _pg_user->servoCurrent = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Reserved for future use
    _pg_byteindex += 8; // close bit field

    return 1;

}// decodeCortex_TelemetryOutputRailPacketStructure

/*!
 * \brief Create the Cortex_TelemetryOutputRail packet
 *
 * Output rail status information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param avionicsVoltage is Avionics rail voltage
 * \param avionicsCurrent is Avionics rail current
 * \param payloadVoltage is Payload rail voltage
 * \param payloadCurrent is Payload rail current
 * \param servoVoltage is Servo rail voltage
 * \param servoCurrent is Servo rail current
 */
void encodeCortex_TelemetryOutputRailPacket(void* _pg_pkt, float avionicsVoltage, float avionicsCurrent, float payloadVoltage, float payloadCurrent, float servoVoltage, float servoCurrent)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned int _pg_tempbitfield = 0;

    // Avionics rail voltage
    // Range of avionicsVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)avionicsVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 1] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex] = (uint8_t)_pg_tempbitfield;

    // Avionics rail current
    // Range of avionicsCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)avionicsCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 2] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 1] |= (uint8_t)_pg_tempbitfield;

    // Payload rail voltage
    // Range of payloadVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)payloadVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 3] = (uint8_t)(_pg_tempbitfield << 2);

    _pg_tempbitfield >>= 6;
    _pg_data[_pg_byteindex + 2] |= (uint8_t)_pg_tempbitfield;

    // Payload rail current
    // Range of payloadCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)payloadCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 4] = (uint8_t)_pg_tempbitfield;

    _pg_tempbitfield >>= 8;
    _pg_data[_pg_byteindex + 3] |= (uint8_t)_pg_tempbitfield;

    // Servo rail voltage
    // Range of servoVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)servoVoltage, 0.0f, 10.0f, 10);
    _pg_data[_pg_byteindex + 6] = (uint8_t)(_pg_tempbitfield << 6);

    _pg_tempbitfield >>= 2;
    _pg_data[_pg_byteindex + 5] = (uint8_t)_pg_tempbitfield;

    // Servo rail current
    // Range of servoCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (unsigned int)float32ScaledToBitfield((float)servoCurrent, 0.0f, 50.0f, 10);
    _pg_data[_pg_byteindex + 7] = (uint8_t)(_pg_tempbitfield << 4);

    _pg_tempbitfield >>= 4;
    _pg_data[_pg_byteindex + 6] |= (uint8_t)_pg_tempbitfield;

    // Reserved for future use
    _pg_byteindex += 8; // close bit field

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetryOutputRailPacketID());

}// encodeCortex_TelemetryOutputRailPacket

/*!
 * \brief Decode the Cortex_TelemetryOutputRail packet
 *
 * Output rail status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param avionicsVoltage receives Avionics rail voltage
 * \param avionicsCurrent receives Avionics rail current
 * \param payloadVoltage receives Payload rail voltage
 * \param payloadCurrent receives Payload rail current
 * \param servoVoltage receives Servo rail voltage
 * \param servoCurrent receives Servo rail current
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetryOutputRailPacket(const void* _pg_pkt, float* avionicsVoltage, float* avionicsCurrent, float* payloadVoltage, float* payloadCurrent, float* servoVoltage, float* servoCurrent)
{
    unsigned int _pg_tempbitfield = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetryOutputRailPacketID())
        return 0;

    if(_pg_numbytes < getCortex_TelemetryOutputRailMinDataLength())
        return 0;

    // Avionics rail voltage
    // Range of avionicsVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 1] >> 6);

    (*avionicsVoltage) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Avionics rail current
    // Range of avionicsCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 1] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 2] >> 4);

    (*avionicsCurrent) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Payload rail voltage
    // Range of payloadVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 2] & 0xF);

    _pg_tempbitfield <<= 6;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 3] >> 2);

    (*payloadVoltage) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Payload rail current
    // Range of payloadCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 3] & 0x3);

    _pg_tempbitfield <<= 8;
    _pg_tempbitfield |= _pg_data[_pg_byteindex + 4];

    (*payloadCurrent) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Servo rail voltage
    // Range of servoVoltage is 0.0f to 102.3f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 5] & 0xFF);

    _pg_tempbitfield <<= 2;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 6] >> 6);

    (*servoVoltage) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/10.0f);

    // Servo rail current
    // Range of servoCurrent is 0.0f to 20.46f.
    _pg_tempbitfield = (_pg_data[_pg_byteindex + 6] & 0x3F);

    _pg_tempbitfield <<= 4;
    _pg_tempbitfield |= (_pg_data[_pg_byteindex + 7] >> 4);

    (*servoCurrent) = float32ScaledFromBitfield(_pg_tempbitfield, 0.0f, 1.0f/50.0f);

    // Reserved for future use
    _pg_byteindex += 8; // close bit field

    return 1;

}// decodeCortex_TelemetryOutputRailPacket

/*!
 * \brief Create the Cortex_TelemetrySettings packet
 *
 * Telemetry settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_TelemetrySettingsPacketStructure(void* _pg_pkt, const Cortex_TelemetrySettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Telemetry packet selection
    encodeCortex_TelemetryPackets_t(_pg_data, &_pg_byteindex, &_pg_user->packets);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_TelemetrySettingsPacketID());

}// encodeCortex_TelemetrySettingsPacketStructure

/*!
 * \brief Decode the Cortex_TelemetrySettings packet
 *
 * Telemetry settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_TelemetrySettingsPacketStructure(const void* _pg_pkt, Cortex_TelemetrySettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_TelemetrySettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_TelemetrySettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Telemetry packet selection
    if(decodeCortex_TelemetryPackets_t(_pg_data, &_pg_byteindex, &_pg_user->packets) == 0)
        return 0;

    return 1;

}// decodeCortex_TelemetrySettingsPacketStructure

/*!
 * \brief Create the Cortex_GeneratorSettings packet
 *
 * Generator settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_GeneratorSettingsPacketStructure(void* _pg_pkt, const Cortex_GeneratorSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Timeout for power loss detection
    // Range of powerLossTimeout is 0 to 255.
    uint8ToBytes(_pg_user->powerLossTimeout, _pg_data, &_pg_byteindex);

    // Minimum engine speed for running.
    // Range of minRunningRpm is 0 to 65535.
    uint16ToBeBytes(_pg_user->minRunningRpm, _pg_data, &_pg_byteindex);

    // Generator drive belt ratio
    // Range of beltRatio is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->beltRatio, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_GeneratorSettingsPacketID());

}// encodeCortex_GeneratorSettingsPacketStructure

/*!
 * \brief Decode the Cortex_GeneratorSettings packet
 *
 * Generator settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_GeneratorSettingsPacketStructure(const void* _pg_pkt, Cortex_GeneratorSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_GeneratorSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_GeneratorSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Timeout for power loss detection
    // Range of powerLossTimeout is 0 to 255.
    _pg_user->powerLossTimeout = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Minimum engine speed for running.
    // Range of minRunningRpm is 0 to 65535.
    _pg_user->minRunningRpm = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Generator drive belt ratio
    // Range of beltRatio is 0.0f to 65.535f.
    _pg_user->beltRatio = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeCortex_GeneratorSettingsPacketStructure

/*!
 * \brief Create the Cortex_StartingSettings packet
 *
 * System starting settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_StartingSettingsPacketStructure(void* _pg_pkt, const Cortex_StartingSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine pre-compression duration
    // Range of compressionTime is 0 to 255.
    uint8ToBytes(_pg_user->compressionTime, _pg_data, &_pg_byteindex);

    // Motor pre-compression duty cycle
    // Range of compressionDuty is 0 to 255.
    uint8ToBytes(_pg_user->compressionDuty, _pg_data, &_pg_byteindex);

    // Set this bit to disable manual engine cranking
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->disableManualCranking == true) ? 1 : 0) << 7;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_StartingSettingsPacketID());

}// encodeCortex_StartingSettingsPacketStructure

/*!
 * \brief Decode the Cortex_StartingSettings packet
 *
 * System starting settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_StartingSettingsPacketStructure(const void* _pg_pkt, Cortex_StartingSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_StartingSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_StartingSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->disableManualCranking = 0;
    _pg_user->reservedBits = 0;

    // Engine pre-compression duration
    // Range of compressionTime is 0 to 255.
    _pg_user->compressionTime = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Motor pre-compression duty cycle
    // Range of compressionDuty is 0 to 255.
    _pg_user->compressionDuty = uint8FromBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Set this bit to disable manual engine cranking
    _pg_user->disableManualCranking = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Reserved bits
    // Range of reservedBits is 0 to 127.
    _pg_user->reservedBits = ((_pg_data[_pg_byteindex]) & 0x7F);
    _pg_byteindex += 1; // close bit field

    return 1;

}// decodeCortex_StartingSettingsPacketStructure

/*!
 * \brief Create the Cortex_PowerLimitSettings packet
 *
 * System power limit settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_PowerLimitSettingsPacketStructure(void* _pg_pkt, const Cortex_PowerLimitSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Enable over-temperature power limit
    _pg_data[_pg_byteindex] = (uint8_t)((_pg_user->enableTempLimit == true) ? 1 : 0) << 7;

    // Enable motor current power limit
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enableCurrentLimit == true) ? 1 : 0) << 6;

    // Enable power map power limit
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enablePowerLimit == true) ? 1 : 0) << 5;

    // Enable battery charging current limit
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enableBatteryLimit == true) ? 1 : 0) << 4;

    // Reserved bits
    _pg_byteindex += 1; // close bit field


    // Generator winding current limit
    // Range of generatorCurrentLimit is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->generatorCurrentLimit, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Generator temperature limit value
    // Range of generatorTempLimit is 0 to 255.
    uint8ToBytes(_pg_user->generatorTempLimit, _pg_data, &_pg_byteindex);

    // Power limit filter frequency
    // Range of filter is 0.0f to 10.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->filter, _pg_data, &_pg_byteindex, 0.0f, 25.5f);

    // Power limit controller proportional gain
    // Range of Kp is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kp, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // Power limit controller integral gain
    // Range of Ki is 0.0f to 100.0f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Ki, _pg_data, &_pg_byteindex, 0.0f, 655.35f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_PowerLimitSettingsPacketID());

}// encodeCortex_PowerLimitSettingsPacketStructure

/*!
 * \brief Decode the Cortex_PowerLimitSettings packet
 *
 * System power limit settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_PowerLimitSettingsPacketStructure(const void* _pg_pkt, Cortex_PowerLimitSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_PowerLimitSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_PowerLimitSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Enable over-temperature power limit
    _pg_user->enableTempLimit = ((_pg_data[_pg_byteindex] >> 7)) ? true : false;

    // Enable motor current power limit
    _pg_user->enableCurrentLimit = (((_pg_data[_pg_byteindex] >> 6) & 0x1)) ? true : false;

    // Enable power map power limit
    _pg_user->enablePowerLimit = (((_pg_data[_pg_byteindex] >> 5) & 0x1)) ? true : false;

    // Enable battery charging current limit
    _pg_user->enableBatteryLimit = (((_pg_data[_pg_byteindex] >> 4) & 0x1)) ? true : false;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    // Generator winding current limit
    // Range of generatorCurrentLimit is 0.0f to 655.35f.
    _pg_user->generatorCurrentLimit = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    // Generator temperature limit value
    // Range of generatorTempLimit is 0 to 255.
    _pg_user->generatorTempLimit = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Power limit filter frequency
    // Range of filter is 0.0f to 10.0f.
    _pg_user->filter = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/25.5f);

    // Power limit controller proportional gain
    // Range of Kp is 0.0f to 100.0f.
    _pg_user->Kp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    // Power limit controller integral gain
    // Range of Ki is 0.0f to 100.0f.
    _pg_user->Ki = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/655.35f);

    return 1;

}// decodeCortex_PowerLimitSettingsPacketStructure

/*!
 * \brief Create the Cortex_PowerMap packet
 *
 * Engine power map settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_PowerMapPacketStructure(void* _pg_pkt, const Cortex_PowerMap_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    // Engine RPM values for power map.
    // Range of rpm is 0.0f to 25500.0f.
    for(_pg_i = 0; _pg_i < 5; _pg_i++)
        float32ScaledTo1UnsignedBytes(_pg_user->rpm[_pg_i], _pg_data, &_pg_byteindex, 0.0f, 0.01f);

    // Engine power values for power map
    // Range of power is 0.0f to 2550.0f.
    for(_pg_i = 0; _pg_i < 5; _pg_i++)
        float32ScaledTo1UnsignedBytes(_pg_user->power[_pg_i], _pg_data, &_pg_byteindex, 0.0f, 0.1f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_PowerMapPacketID());

}// encodeCortex_PowerMapPacketStructure

/*!
 * \brief Decode the Cortex_PowerMap packet
 *
 * Engine power map settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_PowerMapPacketStructure(const void* _pg_pkt, Cortex_PowerMap_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;
    unsigned _pg_i = 0;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_PowerMapPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_PowerMapMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Engine RPM values for power map.
    // Range of rpm is 0.0f to 25500.0f.
    for(_pg_i = 0; _pg_i < 5; _pg_i++)
        _pg_user->rpm[_pg_i] = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.01f);

    // Engine power values for power map
    // Range of power is 0.0f to 2550.0f.
    for(_pg_i = 0; _pg_i < 5; _pg_i++)
        _pg_user->power[_pg_i] = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/0.1f);

    return 1;

}// decodeCortex_PowerMapPacketStructure

/*!
 * \brief Create the Cortex_EngineControlSettings packet
 *
 * Engine control settings. This packet only has effect when Cortex device
 * regulates engine RPM.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_EngineControlSettingsPacketStructure(void* _pg_pkt, const Cortex_EngineControlSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Engine ID / address
    // Range of address is 0 to 255.
    uint8ToBytes(_pg_user->address, _pg_data, &_pg_byteindex);

    // Engine speed input filter
    // Range of rpmFilter is 0.0f to 10.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->rpmFilter, _pg_data, &_pg_byteindex, 0.0f, 25.5f);

    // Maximum engine speed limit
    // Range of rpmLimit is 0 to 65535.
    uint16ToBeBytes(_pg_user->rpmLimit, _pg_data, &_pg_byteindex);

    // Engine RPM setpoint controller proportional gain
    // Range of Kp is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kp, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Engine RPM setpoint controller integral gain
    // Range of Ki is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Ki, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Engine RPM setpoint controller derivative gain
    // Range of Kd is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kd, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Engine RPM setpoint controller feedforward gain
    // Range of Kf is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kf, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_EngineControlSettingsPacketID());

}// encodeCortex_EngineControlSettingsPacketStructure

/*!
 * \brief Decode the Cortex_EngineControlSettings packet
 *
 * Engine control settings. This packet only has effect when Cortex device
 * regulates engine RPM.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_EngineControlSettingsPacketStructure(const void* _pg_pkt, Cortex_EngineControlSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_EngineControlSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_EngineControlSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Engine ID / address
    // Range of address is 0 to 255.
    _pg_user->address = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Engine speed input filter
    // Range of rpmFilter is 0.0f to 10.0f.
    _pg_user->rpmFilter = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/25.5f);

    // Maximum engine speed limit
    // Range of rpmLimit is 0 to 65535.
    _pg_user->rpmLimit = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Engine RPM setpoint controller proportional gain
    // Range of Kp is 0.0f to 65.535f.
    _pg_user->Kp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Engine RPM setpoint controller integral gain
    // Range of Ki is 0.0f to 65.535f.
    _pg_user->Ki = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Engine RPM setpoint controller derivative gain
    // Range of Kd is 0.0f to 65.535f.
    _pg_user->Kd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Engine RPM setpoint controller feedforward gain
    // Range of Kf is 0.0f to 65.535f.
    _pg_user->Kf = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeCortex_EngineControlSettingsPacketStructure

/*!
 * \brief Create the Cortex_ThrottleControlSettings packet
 *
 * Throttle control loop settings. This packet only has effect when Cortex
 * device regulates engine throttle.
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_ThrottleControlSettingsPacketStructure(void* _pg_pkt, const Cortex_ThrottleControlSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Throttle control loop input filter
    // Range of filter is 0.0f to 10.0f.
    float32ScaledTo1UnsignedBytes(_pg_user->filter, _pg_data, &_pg_byteindex, 0.0f, 25.5f);

    // Initial throttle setting during engine start/cranking
    // Range of startingThrottle is 0 to 255.
    uint8ToBytes(_pg_user->startingThrottle, _pg_data, &_pg_byteindex);

    // Minimum throttle setting
    // Range of minThrottle is 0 to 255.
    uint8ToBytes(_pg_user->minThrottle, _pg_data, &_pg_byteindex);

    // Maximum throttle setting
    // Range of maxThrottle is 0 to 255.
    uint8ToBytes(_pg_user->maxThrottle, _pg_data, &_pg_byteindex);

    // Throttle controller proportional gain
    // Range of Kp is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kp, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Throttle controller integral gain
    // Range of Ki is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Ki, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Throttle controller derivative gain
    // Range of Kd is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kd, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // Throttle controller feedforward gain
    // Range of Kf is 0.0f to 65.535f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->Kf, _pg_data, &_pg_byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_ThrottleControlSettingsPacketID());

}// encodeCortex_ThrottleControlSettingsPacketStructure

/*!
 * \brief Decode the Cortex_ThrottleControlSettings packet
 *
 * Throttle control loop settings. This packet only has effect when Cortex
 * device regulates engine throttle.
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_ThrottleControlSettingsPacketStructure(const void* _pg_pkt, Cortex_ThrottleControlSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_ThrottleControlSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_ThrottleControlSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Throttle control loop input filter
    // Range of filter is 0.0f to 10.0f.
    _pg_user->filter = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/25.5f);

    // Initial throttle setting during engine start/cranking
    // Range of startingThrottle is 0 to 255.
    _pg_user->startingThrottle = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Minimum throttle setting
    // Range of minThrottle is 0 to 255.
    _pg_user->minThrottle = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Maximum throttle setting
    // Range of maxThrottle is 0 to 255.
    _pg_user->maxThrottle = uint8FromBytes(_pg_data, &_pg_byteindex);

    // Throttle controller proportional gain
    // Range of Kp is 0.0f to 65.535f.
    _pg_user->Kp = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Throttle controller integral gain
    // Range of Ki is 0.0f to 65.535f.
    _pg_user->Ki = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Throttle controller derivative gain
    // Range of Kd is 0.0f to 65.535f.
    _pg_user->Kd = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    // Throttle controller feedforward gain
    // Range of Kf is 0.0f to 65.535f.
    _pg_user->Kf = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/1000.0f);

    return 1;

}// decodeCortex_ThrottleControlSettingsPacketStructure

/*!
 * \brief Create the Cortex_BatterySettings packet
 *
 * Battery settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_BatterySettingsPacketStructure(void* _pg_pkt, const Cortex_BatterySettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Unused, reserved for future use
    uint16ToBeBytes((uint16_t)(0), _pg_data, &_pg_byteindex);

    // Minimum engine speed required for battery charging
    // Range of minChargingRpm is 0 to 65535.
    uint16ToBeBytes(_pg_user->minChargingRpm, _pg_data, &_pg_byteindex);

    // Nominal battery voltage
    // Range of nominalVoltage is 0.0f to 655.35f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->nominalVoltage, _pg_data, &_pg_byteindex, 0.0f, 100.0f);

    // Maximum battery charging current limit
    // Range of chargeCurrentLimit is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->chargeCurrentLimit, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Filter frequency for battery current measurement
    // Range of currentFilter is 0.0f to 5.1f.
    float32ScaledTo1UnsignedBytes(_pg_user->currentFilter, _pg_data, &_pg_byteindex, 0.0f, 50.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_BatterySettingsPacketID());

}// encodeCortex_BatterySettingsPacketStructure

/*!
 * \brief Decode the Cortex_BatterySettings packet
 *
 * Battery settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_BatterySettingsPacketStructure(const void* _pg_pkt, Cortex_BatterySettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_BatterySettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_BatterySettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // this packet has default fields, make sure they are set
    _pg_user->nominalVoltage = 48;
    _pg_user->chargeCurrentLimit = 5;
    _pg_user->currentFilter = 1;

    // Unused, reserved for future use
    _pg_byteindex += 2;

    // Minimum engine speed required for battery charging
    // Range of minChargingRpm is 0 to 65535.
    _pg_user->minChargingRpm = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    if(_pg_byteindex + 2 > _pg_numbytes)
        return 1;

    // Nominal battery voltage
    // Range of nominalVoltage is 0.0f to 655.35f.
    _pg_user->nominalVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/100.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Maximum battery charging current limit
    // Range of chargeCurrentLimit is 0.0f to 25.5f.
    _pg_user->chargeCurrentLimit = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    if(_pg_byteindex + 1 > _pg_numbytes)
        return 1;

    // Filter frequency for battery current measurement
    // Range of currentFilter is 0.0f to 5.1f.
    _pg_user->currentFilter = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/50.0f);

    return 1;

}// decodeCortex_BatterySettingsPacketStructure

/*!
 * \brief Create the Cortex_RailSettings packet
 *
 * Output rail settings
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_RailSettingsPacketStructure(void* _pg_pkt, const Cortex_RailSettings_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Settings for avionics output rail
    encodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->AvionicsRail);

    // Settings for payload output rail
    encodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->PayloadRail);

    // Settings for servo output rail
    encodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->ServoRail);

    // Settings for battery charger output rail
    encodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->BatteryCharger);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_RailSettingsPacketID());

}// encodeCortex_RailSettingsPacketStructure

/*!
 * \brief Decode the Cortex_RailSettings packet
 *
 * Output rail settings
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_RailSettingsPacketStructure(const void* _pg_pkt, Cortex_RailSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_RailSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_RailSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Settings for avionics output rail
    if(decodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->AvionicsRail) == 0)
        return 0;

    // Settings for payload output rail
    if(decodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->PayloadRail) == 0)
        return 0;

    // Settings for servo output rail
    if(decodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->ServoRail) == 0)
        return 0;

    // Settings for battery charger output rail
    if(decodeCortex_OutputRailSettings_t(_pg_data, &_pg_byteindex, &_pg_user->BatteryCharger) == 0)
        return 0;

    return 1;

}// decodeCortex_RailSettingsPacketStructure

/*!
 * \brief Create the Cortex_ExtraTelltaleValues packet
 *
 * Cortex telltale values
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_ExtraTelltaleValuesPacketStructure(void* _pg_pkt, const Cortex_ExtraTelltaleValues_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
    // Range of maxBatteryCurrent is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->maxBatteryCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
    // Range of maxBatteryVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->maxBatteryVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded avionics rail voltage
    // Range of maxAvionicsVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->maxAvionicsVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded payload rail voltage
    // Range of maxPayloadVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->maxPayloadVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded servo rail voltage
    // Range of maxServoVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(_pg_user->maxServoVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded battery charging current
    // Range of maxChargeCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->maxChargeCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded avionics rail current
    // Range of maxAvionicsCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->maxAvionicsCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded payload rail current
    // Range of maxPayloadCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->maxPayloadCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded servo rail current
    // Range of maxServoCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(_pg_user->maxServoCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_ExtraTelltaleValuesPacketID());

}// encodeCortex_ExtraTelltaleValuesPacketStructure

/*!
 * \brief Decode the Cortex_ExtraTelltaleValues packet
 *
 * Cortex telltale values
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_ExtraTelltaleValuesPacketStructure(const void* _pg_pkt, Cortex_ExtraTelltaleValues_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_ExtraTelltaleValuesPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_ExtraTelltaleValuesMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
    // Range of maxBatteryCurrent is 0.0f to 6553.5f.
    _pg_user->maxBatteryCurrent = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
    // Range of maxBatteryVoltage is 0.0f to 6553.5f.
    _pg_user->maxBatteryVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded avionics rail voltage
    // Range of maxAvionicsVoltage is 0.0f to 6553.5f.
    _pg_user->maxAvionicsVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded payload rail voltage
    // Range of maxPayloadVoltage is 0.0f to 6553.5f.
    _pg_user->maxPayloadVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded servo rail voltage
    // Range of maxServoVoltage is 0.0f to 6553.5f.
    _pg_user->maxServoVoltage = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded battery charging current
    // Range of maxChargeCurrent is 0.0f to 25.5f.
    _pg_user->maxChargeCurrent = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded avionics rail current
    // Range of maxAvionicsCurrent is 0.0f to 25.5f.
    _pg_user->maxAvionicsCurrent = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded payload rail current
    // Range of maxPayloadCurrent is 0.0f to 25.5f.
    _pg_user->maxPayloadCurrent = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded servo rail current
    // Range of maxServoCurrent is 0.0f to 25.5f.
    _pg_user->maxServoCurrent = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    return 1;

}// decodeCortex_ExtraTelltaleValuesPacketStructure

/*!
 * \brief Create the Cortex_ExtraTelltaleValues packet
 *
 * Cortex telltale values
 * \param _pg_pkt points to the packet which will be created by this function
 * \param maxBatteryCurrent is Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
 * \param maxBatteryVoltage is Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
 * \param maxAvionicsVoltage is Maximum recorded avionics rail voltage
 * \param maxPayloadVoltage is Maximum recorded payload rail voltage
 * \param maxServoVoltage is Maximum recorded servo rail voltage
 * \param maxChargeCurrent is Maximum recorded battery charging current
 * \param maxAvionicsCurrent is Maximum recorded avionics rail current
 * \param maxPayloadCurrent is Maximum recorded payload rail current
 * \param maxServoCurrent is Maximum recorded servo rail current
 */
void encodeCortex_ExtraTelltaleValuesPacket(void* _pg_pkt, float maxBatteryCurrent, float maxBatteryVoltage, float maxAvionicsVoltage, float maxPayloadVoltage, float maxServoVoltage, float maxChargeCurrent, float maxAvionicsCurrent, float maxPayloadCurrent, float maxServoCurrent)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
    // Range of maxBatteryCurrent is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(maxBatteryCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
    // Range of maxBatteryVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(maxBatteryVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded avionics rail voltage
    // Range of maxAvionicsVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(maxAvionicsVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded payload rail voltage
    // Range of maxPayloadVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(maxPayloadVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded servo rail voltage
    // Range of maxServoVoltage is 0.0f to 6553.5f.
    float32ScaledTo2UnsignedBeBytes(maxServoVoltage, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded battery charging current
    // Range of maxChargeCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(maxChargeCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded avionics rail current
    // Range of maxAvionicsCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(maxAvionicsCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded payload rail current
    // Range of maxPayloadCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(maxPayloadCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // Maximum recorded servo rail current
    // Range of maxServoCurrent is 0.0f to 25.5f.
    float32ScaledTo1UnsignedBytes(maxServoCurrent, _pg_data, &_pg_byteindex, 0.0f, 10.0f);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_ExtraTelltaleValuesPacketID());

}// encodeCortex_ExtraTelltaleValuesPacket

/*!
 * \brief Decode the Cortex_ExtraTelltaleValues packet
 *
 * Cortex telltale values
 * \param _pg_pkt points to the packet being decoded by this function
 * \param maxBatteryCurrent receives Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
 * \param maxBatteryVoltage receives Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
 * \param maxAvionicsVoltage receives Maximum recorded avionics rail voltage
 * \param maxPayloadVoltage receives Maximum recorded payload rail voltage
 * \param maxServoVoltage receives Maximum recorded servo rail voltage
 * \param maxChargeCurrent receives Maximum recorded battery charging current
 * \param maxAvionicsCurrent receives Maximum recorded avionics rail current
 * \param maxPayloadCurrent receives Maximum recorded payload rail current
 * \param maxServoCurrent receives Maximum recorded servo rail current
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_ExtraTelltaleValuesPacket(const void* _pg_pkt, float* maxBatteryCurrent, float* maxBatteryVoltage, float* maxAvionicsVoltage, float* maxPayloadVoltage, float* maxServoVoltage, float* maxChargeCurrent, float* maxAvionicsCurrent, float* maxPayloadCurrent, float* maxServoCurrent)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_ExtraTelltaleValuesPacketID())
        return 0;

    if(_pg_numbytes < getCortex_ExtraTelltaleValuesMinDataLength())
        return 0;

    // Maximum recorded battery current. ESC Telltale corresponds to maximum generator current.
    // Range of maxBatteryCurrent is 0.0f to 6553.5f.
    (*maxBatteryCurrent) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded battery voltage. ESC Telltale corresponds to maximum generator voltage.
    // Range of maxBatteryVoltage is 0.0f to 6553.5f.
    (*maxBatteryVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded avionics rail voltage
    // Range of maxAvionicsVoltage is 0.0f to 6553.5f.
    (*maxAvionicsVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded payload rail voltage
    // Range of maxPayloadVoltage is 0.0f to 6553.5f.
    (*maxPayloadVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded servo rail voltage
    // Range of maxServoVoltage is 0.0f to 6553.5f.
    (*maxServoVoltage) = float32ScaledFrom2UnsignedBeBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded battery charging current
    // Range of maxChargeCurrent is 0.0f to 25.5f.
    (*maxChargeCurrent) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded avionics rail current
    // Range of maxAvionicsCurrent is 0.0f to 25.5f.
    (*maxAvionicsCurrent) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded payload rail current
    // Range of maxPayloadCurrent is 0.0f to 25.5f.
    (*maxPayloadCurrent) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    // Maximum recorded servo rail current
    // Range of maxServoCurrent is 0.0f to 25.5f.
    (*maxServoCurrent) = float32ScaledFrom1UnsignedBytes(_pg_data, &_pg_byteindex, 0.0f, 1.0f/10.0f);

    return 1;

}// decodeCortex_ExtraTelltaleValuesPacket

/*!
 * \brief Create the Cortex_EnableRail packet
 *
 * Example output enable for testing
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeCortex_EnableRailPacketStructure(void* _pg_pkt, const Cortex_EnableRail_t* _pg_user)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
    // Range of index is 0 to 15.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(_pg_user->index, 15) << 4;

    // 1 = enabled. 0 = disabled.
    _pg_data[_pg_byteindex] |= (uint8_t)((_pg_user->enable == true) ? 1 : 0) << 3;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_EnableRailPacketID());

}// encodeCortex_EnableRailPacketStructure

/*!
 * \brief Decode the Cortex_EnableRail packet
 *
 * Example output enable for testing
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_EnableRailPacketStructure(const void* _pg_pkt, Cortex_EnableRail_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_EnableRailPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getCortexPacketSize(_pg_pkt);
    if(_pg_numbytes < getCortex_EnableRailMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getCortexPacketDataConst(_pg_pkt);

    // SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
    // Range of index is 0 to 15.
    _pg_user->index = (_pg_data[_pg_byteindex] >> 4);

    // 1 = enabled. 0 = disabled.
    _pg_user->enable = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    return 1;

}// decodeCortex_EnableRailPacketStructure

/*!
 * \brief Create the Cortex_EnableRail packet
 *
 * Example output enable for testing
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
 * \param enable is 1 = enabled. 0 = disabled.
 */
void encodeCortex_EnableRailPacket(void* _pg_pkt, uint8_t index, bool enable)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
    // Range of index is 0 to 15.
    _pg_data[_pg_byteindex] = (uint8_t)limitMax(index, 15) << 4;

    // 1 = enabled. 0 = disabled.
    _pg_data[_pg_byteindex] |= (uint8_t)((enable == true) ? 1 : 0) << 3;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_EnableRailPacketID());

}// encodeCortex_EnableRailPacket

/*!
 * \brief Decode the Cortex_EnableRail packet
 *
 * Example output enable for testing
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
 * \param enable receives 1 = enabled. 0 = disabled.
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_EnableRailPacket(const void* _pg_pkt, uint8_t* index, bool* enable)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_EnableRailPacketID())
        return 0;

    if(_pg_numbytes < getCortex_EnableRailMinDataLength())
        return 0;

    // SERVO = 0, BATTERY_CHARGER = 1, PAYLOAD = 2, AVIONICS = 3
    // Range of index is 0 to 15.
    (*index) = (_pg_data[_pg_byteindex] >> 4);

    // 1 = enabled. 0 = disabled.
    (*enable) = (((_pg_data[_pg_byteindex] >> 3) & 0x1)) ? true : false;

    // Reserved bits
    _pg_byteindex += 1; // close bit field

    return 1;

}// decodeCortex_EnableRailPacket

/*!
 * \brief Create the Cortex_EnterCalibrationMode packet
 *
 * Enter calibration mode
 * \param _pg_pkt points to the packet which will be created by this function
 * \param serialNumber is Serial number of the device
 */
void encodeCortex_EnterCalibrationModePacket(void* _pg_pkt, uint32_t serialNumber)
{
    uint8_t* _pg_data = getCortexPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Constant value required for calibration sequence
    uint8ToBytes((uint8_t)(0xC0), _pg_data, &_pg_byteindex);

    // Constant value required for calibration sequence
    uint8ToBytes((uint8_t)(0xC1), _pg_data, &_pg_byteindex);

    // Serial number of the device
    // Range of serialNumber is 0 to 4294967295.
    uint32ToBeBytes(serialNumber, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishCortexPacket(_pg_pkt, _pg_byteindex, getCortex_EnterCalibrationModePacketID());

}// encodeCortex_EnterCalibrationModePacket

/*!
 * \brief Decode the Cortex_EnterCalibrationMode packet
 *
 * Enter calibration mode
 * \param _pg_pkt points to the packet being decoded by this function
 * \param serialNumber receives Serial number of the device
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeCortex_EnterCalibrationModePacket(const void* _pg_pkt, uint32_t* serialNumber)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getCortexPacketDataConst(_pg_pkt);
    int _pg_numbytes = getCortexPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getCortexPacketID(_pg_pkt) != getCortex_EnterCalibrationModePacketID())
        return 0;

    if(_pg_numbytes < getCortex_EnterCalibrationModeMinDataLength())
        return 0;

    // Constant value required for calibration sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC0)
        return 0;

    // Constant value required for calibration sequence
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) 0xC1)
        return 0;

    // Serial number of the device
    // Range of serialNumber is 0 to 4294967295.
    (*serialNumber) = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;

}// decodeCortex_EnterCalibrationModePacket
// end of CortexPackets.c
