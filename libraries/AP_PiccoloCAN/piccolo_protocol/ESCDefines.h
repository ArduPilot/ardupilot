// ESCDefines.h was generated by ProtoGen version 2.18.c

/*
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
 

#ifndef _ESCDEFINES_H
#define _ESCDEFINES_H

// C++ compilers: don't mangle us
#ifdef __cplusplus
extern "C" {
#endif

/*!
 * \file
 */

#include "ESCVelocityProtocol.h"

/*!
 * The *status* of the ESC is represented using these status bits. ESC system
 * functionality can be quickly determined using these bits
 */
typedef struct
{
    unsigned hwInhibit : 1;     //!< 1 = Hardware inhibit is active (ESC is disabled)
    unsigned swInhibit : 1;     //!< 1 = Software inhibit is active (ESC is disabled)
    unsigned afwEnabled : 1;    //!< 0 = Active Freewheeling is not enabled, 1 = Active Freewheeling is enabled
    unsigned direction : 1;     //!< 0 = Motor direction is FORWARDS, 1= Motor direction is REVERSE
    unsigned timeout : 1;       //!< Set if the ESC command timeout period has elapsed (and the ESC is in STANDBY mode)
    unsigned starting : 1;      //!< 1 = in starting mode (0 = stopped or running)
    unsigned commandSource : 1; //!< 0 = most recent command from CAN, 1 = most recent command from PWM
    unsigned running : 1;       //!< ESC is running
}ESC_StatusBits_t;

//! return the minimum encoded length for the ESC_StatusBits_t structure
#define getMinLengthOfESC_StatusBits_t() (1)

//! Encode a ESC_StatusBits_t structure into a byte array
void encodeESC_StatusBits_t(uint8_t* data, int* bytecount, const ESC_StatusBits_t* user);

//! Decode a ESC_StatusBits_t structure from a byte array
int decodeESC_StatusBits_t(const uint8_t* data, int* bytecount, ESC_StatusBits_t* user);

/*!
 * The *warning* bits enumerate various system warnings/errors of which the user
 * (or user software) should be made aware. These *warning* bits are transmitted
 * in the telemetry packets such that user software is aware of any these
 * *warning* conditions and can poll the ESC for particular packets if any
 * further information is needed. The ESC will continue to function in the case
 * of a *warning* state
 */
typedef struct
{
    unsigned noRPMSignal : 1;      //!< Set if RPM signal is not detected
    unsigned overspeed : 1;        //!< Set if the ESC motor speed exceeds the configured warning threshold
    unsigned overcurrent : 1;      //!< Set if the ESC motor current (positive or negative) exceeds the configured warning threshold
    unsigned escTemperature : 1;   //!< Set if the internal ESC temperature is above the warning threshold
    unsigned motorTemperature : 1; //!< Set if the motor temperature is above the warning threshold
    unsigned undervoltage : 1;     //!< Set if the input voltage is below the minimum threshold
    unsigned overvoltage : 1;      //!< Set if the input voltage is above the maximum threshold
    unsigned invalidPWMsignal : 1; //!< Set if hardware PWM input is enabled but invalid
}ESC_WarningBits_t;

//! return the minimum encoded length for the ESC_WarningBits_t structure
#define getMinLengthOfESC_WarningBits_t() (1)

//! Encode a ESC_WarningBits_t structure into a byte array
void encodeESC_WarningBits_t(uint8_t* data, int* bytecount, const ESC_WarningBits_t* user);

//! Decode a ESC_WarningBits_t structure from a byte array
int decodeESC_WarningBits_t(const uint8_t* data, int* bytecount, ESC_WarningBits_t* user);

/*!
 * The *error* bits enumerate critical system errors that will cause the ESC to
 * stop functioning until the error cases are alleviated
 */
typedef struct
{
    unsigned linkError : 1;        //!< Set if communication link to the motor controller is lost
    unsigned foldback : 1;         //!< Set if the ESC has detected an overcurrent event and is actively folding back duty cycle
    unsigned settingsChecksum : 1; //!< Set if the settings checksum does not match the programmed values
    unsigned motorSettings : 1;    //!< Set if the motor settings are invalid
    unsigned reservedD : 1;        //!< Reserved for future use
    unsigned reservedE : 1;        //!< Reserved for future use
    unsigned reservedF : 1;        //!< Reserved for future use
    unsigned reservedG : 1;        //!< Reserved for future use
}ESC_ErrorBits_t;

//! return the minimum encoded length for the ESC_ErrorBits_t structure
#define getMinLengthOfESC_ErrorBits_t() (1)

//! Encode a ESC_ErrorBits_t structure into a byte array
void encodeESC_ErrorBits_t(uint8_t* data, int* bytecount, const ESC_ErrorBits_t* user);

//! Decode a ESC_ErrorBits_t structure from a byte array
int decodeESC_ErrorBits_t(const uint8_t* data, int* bytecount, ESC_ErrorBits_t* user);

/*!
 * These bits are used to determine which packets are automatically transmitted
 * as telemetry data by the ESC. Only the packets described here can be
 * configured as telemetry packets
 */
typedef struct
{
    unsigned statusA : 1;         //!< If this bit is set, the STATUS_A packet will be transmitted at the configured rate
    unsigned statusB : 1;         //!< If this bit is set, the STATUS_B packet will be transmitted at the configured rate
    unsigned statusC : 1;         //!< If this bit is set, the STATUS_C packet will be transmitted at the configured rate
    unsigned accelerometer : 1;   //!< If this bit is set, the ACCELEROMETER packet will be transmitted at the configured rate
    unsigned statusD : 1;         //!< If this bit is set, the STATUS_D packet will be transmitted at the configured rate
    unsigned reservedB : 1;       //!< Reserved for future use
    unsigned piccoloDownlink : 1; //!< If this bit is set, any STATUS_x packets selected for telemetry will be mirrored on the Piccolo Downlink packet group (0x14)
    unsigned reservedD : 1;       //!< Reserved for future use
}ESC_TelemetryPackets_t;

// Initial and verify values for TelemetryPackets
#define ESCVelocity_TelemetryPackets_statusA_InitValue 1
#define ESCVelocity_TelemetryPackets_statusB_InitValue 1
#define ESCVelocity_TelemetryPackets_statusC_InitValue 1
#define ESCVelocity_TelemetryPackets_accelerometer_InitValue 0

//! return the minimum encoded length for the ESC_TelemetryPackets_t structure
#define getMinLengthOfESC_TelemetryPackets_t() (1)

//! Encode a ESC_TelemetryPackets_t structure into a byte array
void encodeESC_TelemetryPackets_t(uint8_t* data, int* bytecount, const ESC_TelemetryPackets_t* user);

//! Decode a ESC_TelemetryPackets_t structure from a byte array
int decodeESC_TelemetryPackets_t(const uint8_t* data, int* bytecount, ESC_TelemetryPackets_t* user);

//! Set a ESC_TelemetryPackets_t structure to initial values
void initESC_TelemetryPackets_t(ESC_TelemetryPackets_t* user);

#ifdef __cplusplus
}
#endif
#endif
