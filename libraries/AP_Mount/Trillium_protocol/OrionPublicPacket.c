// OrionPublicPacket.c was generated by ProtoGen version 2.12.c

#include "OrionPublicPacket.h"
#include "floatspecial.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a Date_t structure into a byte array
 *
 * Compresssed date format.
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDate_t(uint8_t* data, int* bytecount, const Date_t* user)
{
    int byteindex = *bytecount;
    unsigned int tempbitfield = 0;

    // Years after 2000
    data[byteindex] = (uint8_t)user->year << 1;

    // Month of the year, from 1 to 12
    tempbitfield = (unsigned int)user->month;
    data[byteindex + 1] = (uint8_t)(tempbitfield << 5);

    tempbitfield >>= 3;
    data[byteindex] |= (uint8_t)tempbitfield;

    // Day of the month, from 1 to 31
    data[byteindex + 1] |= (uint8_t)user->day;
    byteindex += 2; // close bit field

    *bytecount = byteindex;

}// encodeDate_t

/*!
 * \brief Decode a Date_t structure from a byte array
 *
 * Compresssed date format.
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDate_t(const uint8_t* data, int* bytecount, Date_t* user)
{
    int byteindex = *bytecount;
    unsigned int tempbitfield = 0;

    // Years after 2000
    user->year = (data[byteindex] >> 1);

    // Month of the year, from 1 to 12
    tempbitfield = (data[byteindex] & 0x1);

    tempbitfield <<= 3;
    tempbitfield |= (data[byteindex + 1] >> 5);

    user->month = tempbitfield;

    // Day of the month, from 1 to 31
    user->day = ((data[byteindex + 1]) & 0x1F);
    byteindex += 2; // close bit field

    *bytecount = byteindex;

    return 1;

}// decodeDate_t

/*!
 * \brief Encode a OrionCmd_t structure into a byte array
 *
 * Structure for holding a gimbal axis command
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeOrionCmd_t(uint8_t* data, int* bytecount, const OrionCmd_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Pan and tilt commands in radians or radians per second. Interpretation depends on Mode.
    // Range of Target is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->Target[i], data, &byteindex, 1000.0f);

    // Operational mode of the gimbal. Note that not all modes can be directly commanded.
    uint8ToBytes(user->Mode, data, &byteindex);

    // Non-zero to enable inertial stabilization. If zero then Target is with respect to the gimbal mount, otherwise Target is with respect to the inertial or image space.
    uint8ToBytes(user->Stabilized, data, &byteindex);

    // Amount of time in seconds for changing the gimbal position
    // Range of ImpulseTime is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(user->ImpulseTime, data, &byteindex, 0.0f, 10.0f);

    *bytecount = byteindex;

}// encodeOrionCmd_t

/*!
 * \brief Decode a OrionCmd_t structure from a byte array
 *
 * Structure for holding a gimbal axis command
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeOrionCmd_t(const uint8_t* data, int* bytecount, OrionCmd_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Pan and tilt commands in radians or radians per second. Interpretation depends on Mode.
    // Range of Target is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->Target[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Operational mode of the gimbal. Note that not all modes can be directly commanded.
    user->Mode = (OrionMode_t)uint8FromBytes(data, &byteindex);

    // Non-zero to enable inertial stabilization. If zero then Target is with respect to the gimbal mount, otherwise Target is with respect to the inertial or image space.
    user->Stabilized = uint8FromBytes(data, &byteindex);

    // Amount of time in seconds for changing the gimbal position
    // Range of ImpulseTime is 0.0 to 25.5.
    user->ImpulseTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/10.0f);

    *bytecount = byteindex;

    return 1;

}// decodeOrionCmd_t

/*!
 * \brief Encode a OrionLaserState_t structure into a byte array
 *
 * Per-laser state information.
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeOrionLaserState_t(uint8_t* data, int* bytecount, const OrionLaserState_t* user)
{
    int byteindex = *bytecount;

    // The type of this laser
    uint8ToBytes(user->Type, data, &byteindex);

    // Set to 1 if the laser is enabled, otherwise 0
    data[byteindex] = (uint8_t)user->Enabled << 7;

    // Set to 1 if the laser is armed, otherwise 0
    data[byteindex] |= (uint8_t)user->Armed << 6;

    // Set to 1 if the laser is active, otherwise 0
    data[byteindex] |= (uint8_t)user->Active << 5;

    // Set to 1 if the laser is locked due to low ground speed, otherwise 0
    data[byteindex] |= (uint8_t)user->GroundSpeedLock << 4;

    // Set to 1 if the laser is locked due to low GPS altitude, otherwise 0
    data[byteindex] |= (uint8_t)user->AltitudeLock << 3;

    // Set to 1 if the laser is locked by password, otherwise 0
    data[byteindex] |= (uint8_t)user->PasswordLock << 2;

    // Set to 1 if the laser is locked due to lost autopilot comms, otherwise 0
    data[byteindex] |= (uint8_t)user->ApCommLock << 1;

    // Set to 1 if the laser is locked because the autopilot is not in a 'flying' state, otherwise 0
    data[byteindex] |= (uint8_t)user->ApFlyingLock;

    // Set to 1 if the current command is bypassing the safety interlocks, otherwise 0
    data[byteindex + 1] = (uint8_t)user->BypassEnabled << 7;

    // Set to 1 if the laser is locked due to a positive pitch angle, otherwise 0
    data[byteindex + 1] |= (uint8_t)user->PitchAngleLock << 6;

    // Reserved for future use
    data[byteindex + 2] = 0;

    byteindex += 3; // close bit field

    // Time remaining, in milliseconds, before the laser will accept another command
    uint16ToBeBytes(user->WaitTimer, data, &byteindex);

    *bytecount = byteindex;

}// encodeOrionLaserState_t

/*!
 * \brief Decode a OrionLaserState_t structure from a byte array
 *
 * Per-laser state information.
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeOrionLaserState_t(const uint8_t* data, int* bytecount, OrionLaserState_t* user)
{
    int byteindex = *bytecount;
    unsigned int tempbitfield = 0;

    // The type of this laser
    user->Type = (OrionLaserType_t)uint8FromBytes(data, &byteindex);

    // Set to 1 if the laser is enabled, otherwise 0
    user->Enabled = (data[byteindex] >> 7);

    // Set to 1 if the laser is armed, otherwise 0
    user->Armed = ((data[byteindex] >> 6) & 0x1);

    // Set to 1 if the laser is active, otherwise 0
    user->Active = ((data[byteindex] >> 5) & 0x1);

    // Set to 1 if the laser is locked due to low ground speed, otherwise 0
    user->GroundSpeedLock = ((data[byteindex] >> 4) & 0x1);

    // Set to 1 if the laser is locked due to low GPS altitude, otherwise 0
    user->AltitudeLock = ((data[byteindex] >> 3) & 0x1);

    // Set to 1 if the laser is locked by password, otherwise 0
    user->PasswordLock = ((data[byteindex] >> 2) & 0x1);

    // Set to 1 if the laser is locked due to lost autopilot comms, otherwise 0
    user->ApCommLock = ((data[byteindex] >> 1) & 0x1);

    // Set to 1 if the laser is locked because the autopilot is not in a 'flying' state, otherwise 0
    user->ApFlyingLock = ((data[byteindex]) & 0x1);

    // Set to 1 if the current command is bypassing the safety interlocks, otherwise 0
    user->BypassEnabled = (data[byteindex + 1] >> 7);

    // Set to 1 if the laser is locked due to a positive pitch angle, otherwise 0
    user->PitchAngleLock = ((data[byteindex + 1] >> 6) & 0x1);

    // Reserved for future use
    tempbitfield = (data[byteindex + 1] & 0x3F);

    tempbitfield <<= 8;
    tempbitfield |= data[byteindex + 2];

    user->Reserved = tempbitfield;
    byteindex += 3; // close bit field

    // Time remaining, in milliseconds, before the laser will accept another command
    user->WaitTimer = uint16FromBeBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeOrionLaserState_t

/*!
 * \brief Create the GeolocateTelemetryCore packet
 *
 * This packet is transmitted at 10 Hz by the gimbal to communicate the
 * information needed to locate the gimbal and its imagery, to determine the
 * gimbal mode of operation, and to determine how the video output stream is
 * being shifted by the gimbal. This is the primary packet that users should
 * monitor to determine the gimbal status and populate user interfaces.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeGeolocateTelemetryCorePacketStructure(void* pkt, const GeolocateTelemetryCore_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Milliseconds since system bootup
    uint32ToBeBytes(user->systemTime, data, &byteindex);

    // GPS time of week in milliseconds
    uint32ToBeBytes(user->gpsITOW, data, &byteindex);

    // GPS week number since Jan 6 1980
    uint16ToBeBytes(user->gpsWeek, data, &byteindex);

    // Height of the geoid with respect to the WGS84 ellipsoid, in meters
    // Range of geoidUndulation is -120.0 to 120.0.
    float64ScaledTo2SignedBeBytes(user->geoidUndulation, data, &byteindex, 273.0583333333333);

    // Geodetic latitude of the gimbal in radians, positive North
    // Range of posLat is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->posLat, data, &byteindex, 572957795.1308233);

    // Longitude of the gimbal in radians, positive East
    // Range of posLon is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->posLon, data, &byteindex, 572957795.1308233);

    // Altitude of the gimbal in meters above the WGS-84 ellipsoid
    // Range of posAlt is -214748.3647 to 214748.3647.
    float64ScaledTo4SignedBeBytes(user->posAlt, data, &byteindex, 10000.0);

    // Velocity of the gimbal in North, East, Down meters per second
    // Range of velNED is -327.67 to 327.67.
    for(i = 0; i < 3; i++)
        float32ScaledTo2SignedBeBytes(user->velNED[i], data, &byteindex, 100.0f);

    // Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    // Range of gimbalQuat is -1.0 to 1.0.
    for(i = 0; i < 4; i++)
        float32ScaledTo2SignedBeBytes(user->gimbalQuat[i], data, &byteindex, 32767.0f);

    // Gimbal pan angle in radians from -pi to pi. This includes the camera alignment offsets.
    // Range of pan is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->pan, data, &byteindex, 10430.06004058427f);

    // Gimbal tilt angle in radians from -pi to pi This includes the camera alignment offsets.
    // Range of tilt is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->tilt, data, &byteindex, 10430.06004058427f);

    // Horizontal field of view of the camera in radians from 0 to 2pi
    // Range of hfov is 0.0 to 6.283185307179586.
    float32ScaledTo2UnsignedBeBytes(user->hfov, data, &byteindex, 0.0f, 10430.21919552736f);

    // Vertical field of view of the camera in radians from 0 to 2pi
    // Range of vfov is 0.0 to 6.283185307179586.
    float32ScaledTo2UnsignedBeBytes(user->vfov, data, &byteindex, 0.0f, 10430.21919552736f);

    // Vector from the gimbal to the image location in ECEF meters. The image location is only computed if ranging data are provided to the gimbal. Otherwise the image location data are 0,0,0
    // Range of losECEF is -32767.0 to 32767.0.
    for(i = 0; i < 3; i++)
        float32ScaledTo2SignedBeBytes(user->losECEF[i], data, &byteindex, 1.0f);

    // Active focal plane width in pixels
    uint16ToBeBytes(user->pixelWidth, data, &byteindex);

    // Active focal plane height in pixels
    uint16ToBeBytes(user->pixelHeight, data, &byteindex);

    // Operational mode of the gimbal.
    uint8ToBytes(user->mode, data, &byteindex);

    // Distance along the path from 0 (the starting point) to 1 (the ending point). This only applies if the mode is ORION_MODE_PATH.
    // Range of pathProgress is 0.0 to 1.0.
    float32ScaledTo1UnsignedBytes(user->pathProgress, data, &byteindex, 0.0f, 255.0f);

    // Seconds remaining in the stare portion of a step stare point, 0 if stare is not in progress. This only applies if the mode is ORION_MODE_PATH.
    // Range of stareTime is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->stareTime, data, &byteindex, 0.0f, 100.0f);

    // Index of the path point gimbal is traveling from. This only applies if the mode is ORION_MODE_PATH.
    uint8ToBytes(user->pathFrom, data, &byteindex);

    // Index of the path point gimbal is traveling to. This only applies if the mode is ORION_MODE_PATH.
    uint8ToBytes(user->pathTo, data, &byteindex);

    // X (horizontal) and Y (vertical) instantaneous image shifts in radians
    // Range of imageShifts is -2147.483647 to 2147.483647.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo4SignedBeBytes(user->imageShifts[i], data, &byteindex, 1000000.0f);

    // The amount of time in seconds over which these shifts apply. If no new shift data has arrived since this packet was last transmitted then this will be 0
    // Range of imageShiftDeltaTime is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->imageShiftDeltaTime, data, &byteindex, 0.0f, 1000.0f);

    // Registration solution confidence, from 0 (no confidence) to 1 (full confidence).
    // Range of imageShiftConfidence is 0.0 to 1.0.
    float32ScaledTo1UnsignedBytes(user->imageShiftConfidence, data, &byteindex, 0.0f, 255.0f);

    // X (horizontal) and Y (vertical) image shifts in radians, as displayed in the video stream
    // Range of outputShifts is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->outputShifts[i], data, &byteindex, 10430.06004058427f);

    // Range data source used in line of sight calculation
    uint8ToBytes(user->rangeSource, data, &byteindex);

    // Leap seconds to subtract from GPS time to compute UTC time
    uint8ToBytes(user->leapSeconds, data, &byteindex);

    // Pan camera alignment offsets in radian. The raw pan angle is given as pan + panAlignment.
    // Range of panAlignment is -0.127 to 0.127.
    float32ScaledTo1SignedBytes(user->panAlignment, data, &byteindex, 1000.0f);

    // Tilt camera alignment offsets in radian. The raw tilt angle is given as tilt + tiltAlignment.
    // Range of tiltAlignment is -0.127 to 0.127.
    float32ScaledTo1SignedBytes(user->tiltAlignment, data, &byteindex, 1000.0f);

    // This flag indicates special INS options. If insSpecialOption is 1 the INS is running in the gimbal crown, but is rotated from the gimbal native axis. If insSpecialOption is 2 the INS is running in the ball of the gimbal.
    uint8ToBytes(user->insRotationOption, data, &byteindex);

    // The rotation of the INS from its native frame to the North, East, Down navigation frame. If insSpecialOption is 0 then this rotation is the same as the gimbalQuat
    if(user->insRotationOption)
    {
        // Range of insQuat is -1.0 to 1.0.
        for(i = 0; i < 4; i++)
            float32ScaledTo2SignedBeBytes(user->insQuat[i], data, &byteindex, 32767.0f);
    }

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getGeolocateTelemetryCorePacketID());
}

/*!
 * \brief Decode the GeolocateTelemetryCore packet
 *
 * This packet is transmitted at 10 Hz by the gimbal to communicate the
 * information needed to locate the gimbal and its imagery, to determine the
 * gimbal mode of operation, and to determine how the video output stream is
 * being shifted by the gimbal. This is the primary packet that users should
 * monitor to determine the gimbal status and populate user interfaces.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeGeolocateTelemetryCorePacketStructure(const void* pkt, GeolocateTelemetryCore_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getGeolocateTelemetryCorePacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getGeolocateTelemetryCoreMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    for(i = 0; i < 3; i++)
        user->losECEF[i] = 0;
    user->pixelWidth = 0;
    user->pixelHeight = 0;
    user->mode = ORION_MODE_UNKNOWN;
    user->pathProgress = 0;
    user->stareTime = 0;
    user->pathFrom = 0;
    user->pathTo = 0;
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->imageShifts[i] = 0;
    user->imageShiftDeltaTime = 0;
    user->imageShiftConfidence = 0;
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->outputShifts[i] = 0;
    user->rangeSource = RANGE_SRC_SKYLINK;
    user->leapSeconds = 18;
    user->panAlignment = 0;
    user->tiltAlignment = 0;
    user->insRotationOption = insInGimbalNative;
    for(i = 0; i < 4; i++)
        user->insQuat[i] = 0;

    // Milliseconds since system bootup
    user->systemTime = uint32FromBeBytes(data, &byteindex);

    // GPS time of week in milliseconds
    user->gpsITOW = uint32FromBeBytes(data, &byteindex);

    // GPS week number since Jan 6 1980
    user->gpsWeek = uint16FromBeBytes(data, &byteindex);

    // Height of the geoid with respect to the WGS84 ellipsoid, in meters
    // Range of geoidUndulation is -120.0 to 120.0.
    user->geoidUndulation = float64ScaledFrom2SignedBeBytes(data, &byteindex, 1.0/273.0583333333333);

    // Geodetic latitude of the gimbal in radians, positive North
    // Range of posLat is -3.748066027288564 to 3.748066027288564.
    user->posLat = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Longitude of the gimbal in radians, positive East
    // Range of posLon is -3.748066027288564 to 3.748066027288564.
    user->posLon = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Altitude of the gimbal in meters above the WGS-84 ellipsoid
    // Range of posAlt is -214748.3647 to 214748.3647.
    user->posAlt = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/10000.0);

    // Velocity of the gimbal in North, East, Down meters per second
    // Range of velNED is -327.67 to 327.67.
    for(i = 0; i < 3; i++)
        user->velNED[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100.0f);

    // Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    // Range of gimbalQuat is -1.0 to 1.0.
    for(i = 0; i < 4; i++)
        user->gimbalQuat[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/32767.0f);

    // Gimbal pan angle in radians from -pi to pi. This includes the camera alignment offsets.
    // Range of pan is -3.141592653589793 to 3.141592653589793.
    user->pan = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Gimbal tilt angle in radians from -pi to pi This includes the camera alignment offsets.
    // Range of tilt is -3.141592653589793 to 3.141592653589793.
    user->tilt = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Horizontal field of view of the camera in radians from 0 to 2pi
    // Range of hfov is 0.0 to 6.283185307179586.
    user->hfov = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10430.21919552736f);

    // Vertical field of view of the camera in radians from 0 to 2pi
    // Range of vfov is 0.0 to 6.283185307179586.
    user->vfov = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10430.21919552736f);

    // Vector from the gimbal to the image location in ECEF meters. The image location is only computed if ranging data are provided to the gimbal. Otherwise the image location data are 0,0,0
    if(byteindex + 2*3 > numBytes)
        return 1;

    // Range of losECEF is -32767.0 to 32767.0.
    for(i = 0; i < 3; i++)
        user->losECEF[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1.0f);

    // Active focal plane width in pixels
    if(byteindex + 2 > numBytes)
        return 1;

    user->pixelWidth = uint16FromBeBytes(data, &byteindex);

    // Active focal plane height in pixels
    if(byteindex + 2 > numBytes)
        return 1;

    user->pixelHeight = uint16FromBeBytes(data, &byteindex);

    // Operational mode of the gimbal.
    if(byteindex + 1 > numBytes)
        return 1;

    user->mode = (OrionMode_t)uint8FromBytes(data, &byteindex);

    // Distance along the path from 0 (the starting point) to 1 (the ending point). This only applies if the mode is ORION_MODE_PATH.
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of pathProgress is 0.0 to 1.0.
    user->pathProgress = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/255.0f);

    // Seconds remaining in the stare portion of a step stare point, 0 if stare is not in progress. This only applies if the mode is ORION_MODE_PATH.
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of stareTime is 0.0 to 2.55.
    user->stareTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Index of the path point gimbal is traveling from. This only applies if the mode is ORION_MODE_PATH.
    if(byteindex + 1 > numBytes)
        return 1;

    user->pathFrom = uint8FromBytes(data, &byteindex);

    // Index of the path point gimbal is traveling to. This only applies if the mode is ORION_MODE_PATH.
    if(byteindex + 1 > numBytes)
        return 1;

    user->pathTo = uint8FromBytes(data, &byteindex);

    // X (horizontal) and Y (vertical) instantaneous image shifts in radians
    if(byteindex + 4*NUM_GIMBAL_AXES > numBytes)
        return 1;

    // Range of imageShifts is -2147.483647 to 2147.483647.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->imageShifts[i] = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/1000000.0f);

    // The amount of time in seconds over which these shifts apply. If no new shift data has arrived since this packet was last transmitted then this will be 0
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of imageShiftDeltaTime is 0.0 to 65.535.
    user->imageShiftDeltaTime = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Registration solution confidence, from 0 (no confidence) to 1 (full confidence).
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of imageShiftConfidence is 0.0 to 1.0.
    user->imageShiftConfidence = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/255.0f);

    // X (horizontal) and Y (vertical) image shifts in radians, as displayed in the video stream
    if(byteindex + 2*NUM_GIMBAL_AXES > numBytes)
        return 1;

    // Range of outputShifts is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->outputShifts[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Range data source used in line of sight calculation
    if(byteindex + 1 > numBytes)
        return 1;

    user->rangeSource = (RangeDataSrc_t)uint8FromBytes(data, &byteindex);

    // Leap seconds to subtract from GPS time to compute UTC time
    if(byteindex + 1 > numBytes)
        return 1;

    user->leapSeconds = uint8FromBytes(data, &byteindex);

    // Pan camera alignment offsets in radian. The raw pan angle is given as pan + panAlignment.
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of panAlignment is -0.127 to 0.127.
    user->panAlignment = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/1000.0f);

    // Tilt camera alignment offsets in radian. The raw tilt angle is given as tilt + tiltAlignment.
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of tiltAlignment is -0.127 to 0.127.
    user->tiltAlignment = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/1000.0f);

    // This flag indicates special INS options. If insSpecialOption is 1 the INS is running in the gimbal crown, but is rotated from the gimbal native axis. If insSpecialOption is 2 the INS is running in the ball of the gimbal.
    if(byteindex + 1 > numBytes)
        return 1;

    user->insRotationOption = (InsRotationOptions)uint8FromBytes(data, &byteindex);

    // The rotation of the INS from its native frame to the North, East, Down navigation frame. If insSpecialOption is 0 then this rotation is the same as the gimbalQuat
    if(user->insRotationOption)
    {
        if(byteindex + 2*4 > numBytes)
            return 1;

        // Range of insQuat is -1.0 to 1.0.
        for(i = 0; i < 4; i++)
            user->insQuat[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/32767.0f);
    }

    return 1;
}

/*!
 * \brief Create the OrionPerformance packet
 *
 * Measurements related to stabilization performance. This packet is sent by the
 * gimbal 4 times per second.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionPerformancePacketStructure(void* pkt, const OrionPerformance_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Quad rms errors
    // Range of RmsQuad is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->RmsQuad[i], data, &byteindex, 0.0f, 1000000.0f);

    // Dir rms errors
    // Range of RmsDir is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->RmsDir[i], data, &byteindex, 0.0f, 1000000.0f);

    // Vel rms errors
    // Range of RmsVel is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->RmsVel[i], data, &byteindex, 0.0f, 1000.0f);

    // Pos rms errors
    // Range of RmsPos is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->RmsPos[i], data, &byteindex, 0.0f, 1000000.0f);

    // Output current
    // Range of Iout is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->Iout[i], data, &byteindex, 0.0f, 1000.0f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionPerformancePacketID());
}

/*!
 * \brief Decode the OrionPerformance packet
 *
 * Measurements related to stabilization performance. This packet is sent by the
 * gimbal 4 times per second.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionPerformancePacketStructure(const void* pkt, OrionPerformance_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionPerformancePacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionPerformanceMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Quad rms errors
    // Range of RmsQuad is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->RmsQuad[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000000.0f);

    // Dir rms errors
    // Range of RmsDir is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->RmsDir[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000000.0f);

    // Vel rms errors
    // Range of RmsVel is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->RmsVel[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Pos rms errors
    // Range of RmsPos is 0.0 to 0.065535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->RmsPos[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000000.0f);

    // Output current
    // Range of Iout is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->Iout[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    return 1;
}

/*!
 * \brief Create the OrionDiagnostics packet
 *
 * Electrical diagnostic data for the Orion gimbal. This packet is sent by the
 * gimbal every 3 seconds.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionDiagnosticsPacketStructure(void* pkt, const OrionDiagnostics_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Voltage of the 24-volt rail
    // Range of Voltage24 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage24, data, &byteindex, 0.0f, 1000.0f);

    // Voltage of the 12-volt rail
    // Range of Voltage12 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage12, data, &byteindex, 0.0f, 1000.0f);

    // Voltage of the 3.3-volt rail
    // Range of Voltage3v3 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage3v3, data, &byteindex, 0.0f, 1000.0f);

    // Current in Amps of the 24-volt rail
    // Range of Current24 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Current24, data, &byteindex, 0.0f, 1000.0f);

    // Current in Amps of the 12-volt rail
    // Range of Current12 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Current12, data, &byteindex, 0.0f, 1000.0f);

    // Current in Amps of the 3.3-volt rail
    // Range of Current3v3 is 0.0 to 65.535.
    float32ScaledTo2UnsignedBeBytes(user->Current3v3, data, &byteindex, 0.0f, 1000.0f);

    // Temperature of the crown board in degrees Celsius
    // Range of CrownTemp is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(user->CrownTemp, data, &byteindex, 1.0f);

    // Temperature of the SLA-1500 board (if applicable) in degrees Celsius
    // Range of SlaTemp is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(user->SlaTemp, data, &byteindex, 1.0f);

    // Stabilization gyro ADC temperature in degrees Celsius
    // Range of GyroTemp is -127.0 to 127.0.
    float32ScaledTo1SignedBytes(user->GyroTemp, data, &byteindex, 1.0f);

    // Reserved space for future expansion
    uint8ToBytes((uint8_t)(0), data, &byteindex);

    // Voltage variance of the 24-volt rail
    // Range of Voltage24Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage24Var, data, &byteindex, 0.0f, 100000.0f);

    // Voltage variance of the 12-volt rail
    // Range of Voltage12Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage12Var, data, &byteindex, 0.0f, 100000.0f);

    // Voltage variance of the 3.3-volt rail
    // Range of Voltage3v3Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Voltage3v3Var, data, &byteindex, 0.0f, 100000.0f);

    // Current variance in Amps of the 24-volt rail
    // Range of Current24Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Current24Var, data, &byteindex, 0.0f, 100000.0f);

    // Current variance in Amps of the 12-volt rail
    // Range of Current12Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Current12Var, data, &byteindex, 0.0f, 100000.0f);

    // Current variance in Amps of the 3.3-volt rail
    // Range of Current3v3Var is 0.0 to 0.65535.
    float32ScaledTo2UnsignedBeBytes(user->Current3v3Var, data, &byteindex, 0.0f, 100000.0f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionDiagnosticsPacketID());
}

/*!
 * \brief Decode the OrionDiagnostics packet
 *
 * Electrical diagnostic data for the Orion gimbal. This packet is sent by the
 * gimbal every 3 seconds.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionDiagnosticsPacketStructure(const void* pkt, OrionDiagnostics_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionDiagnosticsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionDiagnosticsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Voltage of the 24-volt rail
    // Range of Voltage24 is 0.0 to 65.535.
    user->Voltage24 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Voltage of the 12-volt rail
    // Range of Voltage12 is 0.0 to 65.535.
    user->Voltage12 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Voltage of the 3.3-volt rail
    // Range of Voltage3v3 is 0.0 to 65.535.
    user->Voltage3v3 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Current in Amps of the 24-volt rail
    // Range of Current24 is 0.0 to 65.535.
    user->Current24 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Current in Amps of the 12-volt rail
    // Range of Current12 is 0.0 to 65.535.
    user->Current12 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Current in Amps of the 3.3-volt rail
    // Range of Current3v3 is 0.0 to 65.535.
    user->Current3v3 = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Temperature of the crown board in degrees Celsius
    // Range of CrownTemp is -127.0 to 127.0.
    user->CrownTemp = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/1.0f);

    // Temperature of the SLA-1500 board (if applicable) in degrees Celsius
    // Range of SlaTemp is -127.0 to 127.0.
    user->SlaTemp = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/1.0f);

    // Stabilization gyro ADC temperature in degrees Celsius
    // Range of GyroTemp is -127.0 to 127.0.
    user->GyroTemp = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/1.0f);

    // Reserved space for future expansion
    byteindex += 1;

    // Voltage variance of the 24-volt rail
    // Range of Voltage24Var is 0.0 to 0.65535.
    user->Voltage24Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    // Voltage variance of the 12-volt rail
    // Range of Voltage12Var is 0.0 to 0.65535.
    user->Voltage12Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    // Voltage variance of the 3.3-volt rail
    // Range of Voltage3v3Var is 0.0 to 0.65535.
    user->Voltage3v3Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    // Current variance in Amps of the 24-volt rail
    // Range of Current24Var is 0.0 to 0.65535.
    user->Current24Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    // Current variance in Amps of the 12-volt rail
    // Range of Current12Var is 0.0 to 0.65535.
    user->Current12Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    // Current variance in Amps of the 3.3-volt rail
    // Range of Current3v3Var is 0.0 to 0.65535.
    user->Current3v3Var = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);

    return 1;
}

//! Encode a ThreadLoading_t structure into a byte array
void encodeThreadLoading_t(uint8_t* data, int* bytecount, const ThreadLoading_t* user);

//! Encode a CoreLoading_t structure into a byte array
void encodeCoreLoading_t(uint8_t* data, int* bytecount, const CoreLoading_t* user);

/*!
 * \brief Encode a ThreadLoading_t structure into a byte array
 *
 * Per-thread information, in order of priority (highest to lowest)
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeThreadLoading_t(uint8_t* data, int* bytecount, const ThreadLoading_t* user)
{
    int byteindex = *bytecount;

    // CPU utilization of this thread as a percentage
    // Range of cpuLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->cpuLoad, data, &byteindex, 0.0f, 2.55f);

    // Heap memory utilization of this thread as a percentage, 0 if no heap is present
    // Range of heapLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->heapLoad, data, &byteindex, 0.0f, 2.55f);

    // Stack memory utilization of this thread as a percentage, 100 if stack overflow occurs
    // Range of stackLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->stackLoad, data, &byteindex, 0.0f, 2.55f);

    // Worst case amount of watchdog time remaining in this reporting period for this thread, 0 if watchdog has timed out
    // Range of watchdogLeft is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->watchdogLeft, data, &byteindex, 0.0f, 2.55f);

    // Number of times this thread iterated during the reporting period
    // Range of numIterations is 0.0 to 2550.0.
    float32ScaledTo1UnsignedBytes((float)user->numIterations, data, &byteindex, 0.0f, 0.1f);

    // Worst case thread run time as a ratio with the average thread run time during the reporting period
    // Range of worstcase is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(user->worstcase, data, &byteindex, 0.0f, 10.0f);

    *bytecount = byteindex;

}// encodeThreadLoading_t

/*!
 * \brief Encode a CoreLoading_t structure into a byte array
 *
 * Per-Core CPU load information
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeCoreLoading_t(uint8_t* data, int* bytecount, const CoreLoading_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // CPU utilization as a percentage
    // Range of cpuLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->cpuLoad, data, &byteindex, 0.0f, 2.55f);

    // Heap memory utilization as a percentage, 0 if no heap is present
    // Range of heapLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->heapLoad, data, &byteindex, 0.0f, 2.55f);

    // System stack memory utilization as a percentage, 0 if no system stack is present
    // Range of stackLoad is 0.0 to 100.0.
    float32ScaledTo1UnsignedBytes(user->stackLoad, data, &byteindex, 0.0f, 2.55f);

    // Reserved space for future expansion
    uint8ToBytes((uint8_t)(0), data, &byteindex);

    // Number of threads in the system, must be at least 1
    uint8ToBytes(user->numThreads, data, &byteindex);

    // Per-thread information, in order of priority (highest to lowest)
    for(i = 0; i < (int)user->numThreads && i < 10; i++)
        encodeThreadLoading_t(data, &byteindex, &user->ThreadLoading[i]);

    *bytecount = byteindex;

}// encodeCoreLoading_t

//! Decode a ThreadLoading_t structure from a byte array
int decodeThreadLoading_t(const uint8_t* data, int* bytecount, ThreadLoading_t* user);

//! Decode a CoreLoading_t structure from a byte array
int decodeCoreLoading_t(const uint8_t* data, int* bytecount, CoreLoading_t* user);

/*!
 * \brief Decode a ThreadLoading_t structure from a byte array
 *
 * Per-thread information, in order of priority (highest to lowest)
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeThreadLoading_t(const uint8_t* data, int* bytecount, ThreadLoading_t* user)
{
    int byteindex = *bytecount;

    // CPU utilization of this thread as a percentage
    // Range of cpuLoad is 0.0 to 100.0.
    user->cpuLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Heap memory utilization of this thread as a percentage, 0 if no heap is present
    // Range of heapLoad is 0.0 to 100.0.
    user->heapLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Stack memory utilization of this thread as a percentage, 100 if stack overflow occurs
    // Range of stackLoad is 0.0 to 100.0.
    user->stackLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Worst case amount of watchdog time remaining in this reporting period for this thread, 0 if watchdog has timed out
    // Range of watchdogLeft is 0.0 to 100.0.
    user->watchdogLeft = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Number of times this thread iterated during the reporting period
    // Range of numIterations is 0.0 to 2550.0.
    user->numIterations = (uint16_t)float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/0.1f);

    // Worst case thread run time as a ratio with the average thread run time during the reporting period
    // Range of worstcase is 0.0 to 25.5.
    user->worstcase = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/10.0f);

    *bytecount = byteindex;

    return 1;

}// decodeThreadLoading_t

/*!
 * \brief Decode a CoreLoading_t structure from a byte array
 *
 * Per-Core CPU load information
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeCoreLoading_t(const uint8_t* data, int* bytecount, CoreLoading_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // CPU utilization as a percentage
    // Range of cpuLoad is 0.0 to 100.0.
    user->cpuLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Heap memory utilization as a percentage, 0 if no heap is present
    // Range of heapLoad is 0.0 to 100.0.
    user->heapLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // System stack memory utilization as a percentage, 0 if no system stack is present
    // Range of stackLoad is 0.0 to 100.0.
    user->stackLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2.55f);

    // Reserved space for future expansion
    byteindex += 1;

    // Number of threads in the system, must be at least 1
    user->numThreads = uint8FromBytes(data, &byteindex);

    // Per-thread information, in order of priority (highest to lowest)
    for(i = 0; i < (int)user->numThreads && i < 10; i++)
    {
        if(decodeThreadLoading_t(data, &byteindex, &user->ThreadLoading[i]) == 0)
            return 0;
    }

    *bytecount = byteindex;

    return 1;

}// decodeCoreLoading_t

/*!
 * \brief Create the OrionSoftwareDiagnostics packet
 *
 * Diagnostic information related to software performance for a specific board
 * in the Orion Gimbal. This packet is sent by the gimbal once per second.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionSoftwareDiagnosticsPacketStructure(void* pkt, const OrionSoftwareDiagnostics_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Enumeration defining which board in the gimbal generated this message
    uint8ToBytes(user->sourceBoard, data, &byteindex);

    // Number of CPU cores that this packet reports for
    uint8ToBytes(user->numCores, data, &byteindex);

    // Reserved space for future expansion
    uint16ToBeBytes((uint16_t)(0), data, &byteindex);

    // Per-Core CPU load information
    for(i = 0; i < (int)user->numCores && i < 2; i++)
        encodeCoreLoading_t(data, &byteindex, &user->CoreLoading[i]);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionSoftwareDiagnosticsPacketID());
}

/*!
 * \brief Decode the OrionSoftwareDiagnostics packet
 *
 * Diagnostic information related to software performance for a specific board
 * in the Orion Gimbal. This packet is sent by the gimbal once per second.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionSoftwareDiagnosticsPacketStructure(const void* pkt, OrionSoftwareDiagnostics_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionSoftwareDiagnosticsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionSoftwareDiagnosticsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Enumeration defining which board in the gimbal generated this message
    user->sourceBoard = (OrionBoardEnumeration_t)uint8FromBytes(data, &byteindex);

    // Number of CPU cores that this packet reports for
    user->numCores = uint8FromBytes(data, &byteindex);

    // Reserved space for future expansion
    byteindex += 2;

    // Per-Core CPU load information
    for(i = 0; i < (int)user->numCores && i < 2; i++)
    {
        if(decodeCoreLoading_t(data, &byteindex, &user->CoreLoading[i]) == 0)
            return 0;
    }

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

//! Encode a FftData_t structure into a byte array
void encodeFftData_t(uint8_t* data, int* bytecount, const FftData_t* user);

/*!
 * \brief Encode a FftData_t structure into a byte array
 *
 * A series of points containing FFT-derived frequency and magnitude data
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeFftData_t(uint8_t* data, int* bytecount, const FftData_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Frequency, in Hertz, of the data point defined by this element
    // Range of Frequency is 0.0 to 200.0.
    float32ScaledTo2UnsignedBeBytes(user->Frequency, data, &byteindex, 0.0f, 327.675f);

    // Acceleration magnitude, expressed as a percentage of MaxAccel
    // Range of Accel is 0.0 to 1.0.
    for(i = 0; i < NUM_AXES; i++)
        float32ScaledTo1UnsignedBytes(user->Accel[i], data, &byteindex, 0.0f, 255.0f);

    // Angular rate magnitude, expressed as a percentage of MaxGyro
    // Range of Gyro is 0.0 to 1.0.
    for(i = 0; i < NUM_AXES; i++)
        float32ScaledTo1UnsignedBytes(user->Gyro[i], data, &byteindex, 0.0f, 255.0f);

    *bytecount = byteindex;

}// encodeFftData_t

//! Decode a FftData_t structure from a byte array
int decodeFftData_t(const uint8_t* data, int* bytecount, FftData_t* user);

/*!
 * \brief Decode a FftData_t structure from a byte array
 *
 * A series of points containing FFT-derived frequency and magnitude data
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeFftData_t(const uint8_t* data, int* bytecount, FftData_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // Frequency, in Hertz, of the data point defined by this element
    // Range of Frequency is 0.0 to 200.0.
    user->Frequency = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/327.675f);

    // Acceleration magnitude, expressed as a percentage of MaxAccel
    // Range of Accel is 0.0 to 1.0.
    for(i = 0; i < NUM_AXES; i++)
        user->Accel[i] = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/255.0f);

    // Angular rate magnitude, expressed as a percentage of MaxGyro
    // Range of Gyro is 0.0 to 1.0.
    for(i = 0; i < NUM_AXES; i++)
        user->Gyro[i] = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/255.0f);

    *bytecount = byteindex;

    return 1;

}// decodeFftData_t

/*!
 * \brief Create the OrionVibration packet
 *
 * Platform vibration amplitude and frequency information. This packet is sent
 * by the gimbal once every five seconds.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionVibrationPacketStructure(void* pkt, const OrionVibration_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Maximum acceleration values, in m/s/s
    // Range of MaxAccel is -20.0 to 20.0.
    for(i = 0; i < NUM_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->MaxAccel[i], data, &byteindex, 1638.35f);

    // Maximum angular rate values, in rad/s
    // Range of MaxGyro is -0.1 to 0.1.
    for(i = 0; i < NUM_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->MaxGyro[i], data, &byteindex, 327670.0f);

    // A series of points containing FFT-derived frequency and magnitude data
    for(i = 0; i < 16; i++)
        encodeFftData_t(data, &byteindex, &user->FftData[i]);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionVibrationPacketID());
}

/*!
 * \brief Decode the OrionVibration packet
 *
 * Platform vibration amplitude and frequency information. This packet is sent
 * by the gimbal once every five seconds.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionVibrationPacketStructure(const void* pkt, OrionVibration_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionVibrationPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionVibrationMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Maximum acceleration values, in m/s/s
    // Range of MaxAccel is -20.0 to 20.0.
    for(i = 0; i < NUM_AXES; i++)
        user->MaxAccel[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1638.35f);

    // Maximum angular rate values, in rad/s
    // Range of MaxGyro is -0.1 to 0.1.
    for(i = 0; i < NUM_AXES; i++)
        user->MaxGyro[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/327670.0f);

    // A series of points containing FFT-derived frequency and magnitude data
    for(i = 0; i < 16; i++)
    {
        if(decodeFftData_t(data, &byteindex, &user->FftData[i]) == 0)
            return 0;
    }

    return 1;
}

/*!
 * \brief Create the NetworkDiagnostics packet
 *
 * Ethernet network diagnostic information
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeNetworkDiagnosticsPacketStructure(void* pkt, const NetworkDiagnostics_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Ethernet interface configuration flags
    uint16ToBeBytes(user->Flags, data, &byteindex);

    // Ethernet bytes received
    uint32ToBeBytes(user->RxBytes, data, &byteindex);

    // Ethernet bytes transmitted
    uint32ToBeBytes(user->TxBytes, data, &byteindex);

    // Ethernet packets received
    uint32ToBeBytes(user->RxPackets, data, &byteindex);

    // Ethernet packets transmitted
    uint32ToBeBytes(user->TxPackets, data, &byteindex);

    // Number of receive errors
    uint16ToBeBytes(user->RxErrors, data, &byteindex);

    // Number of transmit errors
    uint16ToBeBytes(user->TxErrors, data, &byteindex);

    // Number of receive packets dropped by the Ethernet driver
    uint16ToBeBytes(user->RxDrops, data, &byteindex);

    // Number of transmit packets dropped by the Ethernet driver
    uint16ToBeBytes(user->TxDrops, data, &byteindex);

    // Number of receive FIFO errors
    uint16ToBeBytes(user->RxFifoErrors, data, &byteindex);

    // Number of transmit FIFO errors
    uint16ToBeBytes(user->TxFifoErrors, data, &byteindex);

    // Framing error count
    uint16ToBeBytes(user->FrameErrors, data, &byteindex);

    // Hardware interface collision count
    uint16ToBeBytes(user->Collisions, data, &byteindex);

    // Number of carrier loss events
    uint16ToBeBytes(user->CarrierErrors, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getNetworkDiagnosticsPacketID());
}

/*!
 * \brief Decode the NetworkDiagnostics packet
 *
 * Ethernet network diagnostic information
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeNetworkDiagnosticsPacketStructure(const void* pkt, NetworkDiagnostics_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getNetworkDiagnosticsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getNetworkDiagnosticsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Ethernet interface configuration flags
    user->Flags = uint16FromBeBytes(data, &byteindex);

    // Ethernet bytes received
    user->RxBytes = uint32FromBeBytes(data, &byteindex);

    // Ethernet bytes transmitted
    user->TxBytes = uint32FromBeBytes(data, &byteindex);

    // Ethernet packets received
    user->RxPackets = uint32FromBeBytes(data, &byteindex);

    // Ethernet packets transmitted
    user->TxPackets = uint32FromBeBytes(data, &byteindex);

    // Number of receive errors
    user->RxErrors = uint16FromBeBytes(data, &byteindex);

    // Number of transmit errors
    user->TxErrors = uint16FromBeBytes(data, &byteindex);

    // Number of receive packets dropped by the Ethernet driver
    user->RxDrops = uint16FromBeBytes(data, &byteindex);

    // Number of transmit packets dropped by the Ethernet driver
    user->TxDrops = uint16FromBeBytes(data, &byteindex);

    // Number of receive FIFO errors
    user->RxFifoErrors = uint16FromBeBytes(data, &byteindex);

    // Number of transmit FIFO errors
    user->TxFifoErrors = uint16FromBeBytes(data, &byteindex);

    // Framing error count
    user->FrameErrors = uint16FromBeBytes(data, &byteindex);

    // Hardware interface collision count
    user->Collisions = uint16FromBeBytes(data, &byteindex);

    // Number of carrier loss events
    user->CarrierErrors = uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionRetractStatus packet
 *
 * Current gimbal retraction mechanism status. This is sent by the gimbal
 * regularly only if a retract system is installed.
 * \param pkt points to the packet which will be created by this function
 * \param Cmd is The current command being tracked by the retract mechanism
 * \param State is The retraction mechanism state
 * \param Pos is Current retract position in radians
 * \param Flags is GPIO status information flags
 */
void encodeOrionRetractStatusPacket(void* pkt, OrionRetractCmd_t Cmd, OrionRetractState_t State, float Pos, uint16_t Flags)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // The current command being tracked by the retract mechanism
    uint8ToBytes(Cmd, data, &byteindex);

    // The retraction mechanism state
    uint8ToBytes(State, data, &byteindex);

    // Current retract position in radians
    // Range of Pos is -32.767 to 32.767.
    float32ScaledTo2SignedBeBytes(Pos, data, &byteindex, 1000.0f);

    // GPIO status information flags
    uint16ToBeBytes(Flags, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionRetractStatusPacketID());
}

/*!
 * \brief Decode the OrionRetractStatus packet
 *
 * Current gimbal retraction mechanism status. This is sent by the gimbal
 * regularly only if a retract system is installed.
 * \param pkt points to the packet being decoded by this function
 * \param Cmd receives The current command being tracked by the retract mechanism
 * \param State receives The retraction mechanism state
 * \param Pos receives Current retract position in radians
 * \param Flags receives GPIO status information flags
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionRetractStatusPacket(const void* pkt, OrionRetractCmd_t* Cmd, OrionRetractState_t* State, float* Pos, uint16_t* Flags)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionRetractStatusPacketID())
        return 0;

    if(numBytes < getOrionRetractStatusMinDataLength())
        return 0;

    // The current command being tracked by the retract mechanism
    *Cmd = (OrionRetractCmd_t)uint8FromBytes(data, &byteindex);

    // The retraction mechanism state
    *State = (OrionRetractState_t)uint8FromBytes(data, &byteindex);

    // Current retract position in radians
    // Range of Pos is -32.767 to 32.767.
    *Pos = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // GPIO status information flags
    *Flags = uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the StareStart packet
 *
 * This packet is transmitted by the gimbal during step-stare operations to
 * indicate that the gimbal is staring and a step-stare image should be
 * acquired. The position data mark the *desired* location that the gimbal is
 * trying to stare at. The *actual* position can be computed by using the gimbal
 * position, quaternion, and pan and tilt angles to project the camera line of
 * sight until to the terrain model. Once the image has been acquired send a
 * ORION_PKT_STARE_ACK packet to tell the gimbal it can move to the next stare
 * point.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeStareStartPacketStructure(void* pkt, const StareStart_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Milliseconds since system bootup. This value should be echoed in the ORION_PKT_STARE_ACK respone.
    uint32ToBeBytes(user->systemTime, data, &byteindex);

    // Seconds remaining before the stare is finished. Send ORION_PKT_STARE_ACK to terminate the stare early.
    // Range of maxStareTime is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->maxStareTime, data, &byteindex, 0.0f, 100.0f);

    // If set then this is the start of an along track stare, not a cross track track stare
    data[byteindex] = (uint8_t)user->alongTrackStare << 7;

    // If set then the previous stare operation was terminated by timeout rather than an ORION_PKT_STARE_ACK packet
    data[byteindex] |= (uint8_t)user->prevStareTerminatedByTime << 6;

    // If set then the stare operation was initiated by timeout rather than by achieving the pan and tilt angles necessary to look at the desired location. In this instance it is possible that the actual stare location is significantly different from the desired stare location
    data[byteindex] |= (uint8_t)user->stareStartedByTime << 5;

    // If set then the gimbal position and attitude data are valid. If not set then only the desired stare position is valid
    data[byteindex] |= (uint8_t)user->gimbalDataValid << 4;

    // If set then the stare position had to be reset due to falling behind.
    data[byteindex] |= (uint8_t)user->stareReset << 3;
    byteindex += 1; // close bit field

    // Seconds of time elapsed between the previous stare start and stare end. If this number approaches stareTime the image-acquisition system is in danger of not keeping up.
    // Range of prevStareTime is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->prevStareTime, data, &byteindex, 0.0f, 100.0f);

    // Amount of time spent stepping and staring, as a ratio to the time between stare starts. As the frequency of stare events goes up this number will go towards 1.0, indicating the system has reached maximum utilization.
    // Range of stareLoad is 0.0 to 1.0.
    float32ScaledTo1UnsignedBytes(user->stareLoad, data, &byteindex, 0.0f, 255.0f);

    // Geodetic latitude of the desired stare point in radians, positive North
    // Range of posLat is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->posLat, data, &byteindex, 572957795.1308233);

    // Longitude of the desired stare point in radians, positive East
    // Range of posLon is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->posLon, data, &byteindex, 572957795.1308233);

    // Altitude of the desired stare point in meters above the WGS-84 ellipsoid
    // Range of posAlt is -214748.3647 to 214748.3647.
    float64ScaledTo4SignedBeBytes(user->posAlt, data, &byteindex, 10000.0);

    // Geodetic latitude of the gimbal in radians, positive North
    // Range of gimbalPosLat is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->gimbalPosLat, data, &byteindex, 572957795.1308233);

    // Longitude of the gimbal in radians, positive East
    // Range of gimbalPosLon is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->gimbalPosLon, data, &byteindex, 572957795.1308233);

    // Altitude of the gimbal in meters above the WGS-84 ellipsoid
    // Range of gimbalPosAlt is -214748.3647 to 214748.3647.
    float64ScaledTo4SignedBeBytes(user->gimbalPosAlt, data, &byteindex, 10000.0);

    // Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    // Range of gimbalQuat is -1.0 to 1.0.
    for(i = 0; i < 4; i++)
        float32ScaledTo2SignedBeBytes(user->gimbalQuat[i], data, &byteindex, 32767.0f);

    // Gimbal pan angle in radians from -pi to pi
    // Range of pan is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->pan, data, &byteindex, 10430.06004058427f);

    // Gimbal tilt angle in radians from -pi to pi
    // Range of tilt is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->tilt, data, &byteindex, 10430.06004058427f);

    // Target range data source
    uint8ToBytes(user->rangeSource, data, &byteindex);

    // Slant range to target, if available (see rangeSource)
    // Range of slantRange is 0.0 to 167772.15.
    float32ScaledTo3UnsignedBeBytes(user->slantRange, data, &byteindex, 0.0f, 100.0f);

    // Angle in radians of the view of the path with respect to the perpendicular ideal view. Positive angles indicate looking ahead, negative are looking behind.
    // Range of alongStareAngle is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->alongStareAngle, data, &byteindex, 10430.06004058427f);

    // Cross track angle in radians of the stare location, which will be zero if cross stepping is not being used. Negative if staring left of the path.
    // Range of crossStareAngle is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->crossStareAngle, data, &byteindex, 10430.06004058427f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getStareStartPacketID());
}

/*!
 * \brief Decode the StareStart packet
 *
 * This packet is transmitted by the gimbal during step-stare operations to
 * indicate that the gimbal is staring and a step-stare image should be
 * acquired. The position data mark the *desired* location that the gimbal is
 * trying to stare at. The *actual* position can be computed by using the gimbal
 * position, quaternion, and pan and tilt angles to project the camera line of
 * sight until to the terrain model. Once the image has been acquired send a
 * ORION_PKT_STARE_ACK packet to tell the gimbal it can move to the next stare
 * point.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeStareStartPacketStructure(const void* pkt, StareStart_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getStareStartPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getStareStartMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->gimbalPosLat = 0;
    user->gimbalPosLon = 0;
    user->gimbalPosAlt = 0;
    for(i = 0; i < 4; i++)
        user->gimbalQuat[i] = 0;
    user->pan = 0;
    user->tilt = 0;
    user->rangeSource = RANGE_SRC_NONE;
    user->slantRange = 0;
    user->alongStareAngle = 0;
    user->crossStareAngle = 0;

    // Milliseconds since system bootup. This value should be echoed in the ORION_PKT_STARE_ACK respone.
    user->systemTime = uint32FromBeBytes(data, &byteindex);

    // Seconds remaining before the stare is finished. Send ORION_PKT_STARE_ACK to terminate the stare early.
    // Range of maxStareTime is 0.0 to 2.55.
    user->maxStareTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // If set then this is the start of an along track stare, not a cross track track stare
    user->alongTrackStare = (data[byteindex] >> 7);

    // If set then the previous stare operation was terminated by timeout rather than an ORION_PKT_STARE_ACK packet
    user->prevStareTerminatedByTime = ((data[byteindex] >> 6) & 0x1);

    // If set then the stare operation was initiated by timeout rather than by achieving the pan and tilt angles necessary to look at the desired location. In this instance it is possible that the actual stare location is significantly different from the desired stare location
    user->stareStartedByTime = ((data[byteindex] >> 5) & 0x1);

    // If set then the gimbal position and attitude data are valid. If not set then only the desired stare position is valid
    user->gimbalDataValid = ((data[byteindex] >> 4) & 0x1);

    // If set then the stare position had to be reset due to falling behind.
    user->stareReset = ((data[byteindex] >> 3) & 0x1);
    byteindex += 1; // close bit field

    // Seconds of time elapsed between the previous stare start and stare end. If this number approaches stareTime the image-acquisition system is in danger of not keeping up.
    // Range of prevStareTime is 0.0 to 2.55.
    user->prevStareTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Amount of time spent stepping and staring, as a ratio to the time between stare starts. As the frequency of stare events goes up this number will go towards 1.0, indicating the system has reached maximum utilization.
    // Range of stareLoad is 0.0 to 1.0.
    user->stareLoad = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/255.0f);

    // Geodetic latitude of the desired stare point in radians, positive North
    // Range of posLat is -3.748066027288564 to 3.748066027288564.
    user->posLat = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Longitude of the desired stare point in radians, positive East
    // Range of posLon is -3.748066027288564 to 3.748066027288564.
    user->posLon = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Altitude of the desired stare point in meters above the WGS-84 ellipsoid
    // Range of posAlt is -214748.3647 to 214748.3647.
    user->posAlt = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/10000.0);

    // Geodetic latitude of the gimbal in radians, positive North
    if(byteindex + 4 > numBytes)
        return 1;

    // Range of gimbalPosLat is -3.748066027288564 to 3.748066027288564.
    user->gimbalPosLat = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Longitude of the gimbal in radians, positive East
    if(byteindex + 4 > numBytes)
        return 1;

    // Range of gimbalPosLon is -3.748066027288564 to 3.748066027288564.
    user->gimbalPosLon = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Altitude of the gimbal in meters above the WGS-84 ellipsoid
    if(byteindex + 4 > numBytes)
        return 1;

    // Range of gimbalPosAlt is -214748.3647 to 214748.3647.
    user->gimbalPosAlt = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/10000.0);

    // Gimbal quaternion describing the rotation from the gimbal mount frame to the North, East, Down navigation frame
    if(byteindex + 2*4 > numBytes)
        return 1;

    // Range of gimbalQuat is -1.0 to 1.0.
    for(i = 0; i < 4; i++)
        user->gimbalQuat[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/32767.0f);

    // Gimbal pan angle in radians from -pi to pi
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of pan is -3.141592653589793 to 3.141592653589793.
    user->pan = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Gimbal tilt angle in radians from -pi to pi
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of tilt is -3.141592653589793 to 3.141592653589793.
    user->tilt = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Target range data source
    if(byteindex + 1 > numBytes)
        return 1;

    user->rangeSource = (RangeDataSrc_t)uint8FromBytes(data, &byteindex);

    // Slant range to target, if available (see rangeSource)
    if(byteindex + 3 > numBytes)
        return 1;

    // Range of slantRange is 0.0 to 167772.15.
    user->slantRange = float32ScaledFrom3UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Angle in radians of the view of the path with respect to the perpendicular ideal view. Positive angles indicate looking ahead, negative are looking behind.
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of alongStareAngle is -3.141592653589793 to 3.141592653589793.
    user->alongStareAngle = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Cross track angle in radians of the stare location, which will be zero if cross stepping is not being used. Negative if staring left of the path.
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of crossStareAngle is -3.141592653589793 to 3.141592653589793.
    user->crossStareAngle = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    return 1;
}

/*!
 * \brief Create the OrionResetSource packet
 *
 * Reset information for a processor in the Orion Gimbal. This packet is
 * transmitted by each processor in the gimbal following its bootup
 * \param pkt points to the packet which will be created by this function
 * \param Vector is Interrupt vector for the last reset
 * \param Address is Program counter prior to the reset (not yet used)
 * \param sourceBoard is Enumeration defining which board in the gimbal generated this message
 */
void encodeOrionResetSourcePacket(void* pkt, uint32_t Vector, uint32_t Address, OrionBoardEnumeration_t sourceBoard)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Interrupt vector for the last reset
    uint32ToBeBytes(Vector, data, &byteindex);

    // Program counter prior to the reset (not yet used)
    uint32ToBeBytes(Address, data, &byteindex);

    // Enumeration defining which board in the gimbal generated this message
    uint8ToBytes(sourceBoard, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionResetSourcePacketID());
}

/*!
 * \brief Decode the OrionResetSource packet
 *
 * Reset information for a processor in the Orion Gimbal. This packet is
 * transmitted by each processor in the gimbal following its bootup
 * \param pkt points to the packet being decoded by this function
 * \param Vector receives Interrupt vector for the last reset
 * \param Address receives Program counter prior to the reset (not yet used)
 * \param sourceBoard receives Enumeration defining which board in the gimbal generated this message
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionResetSourcePacket(const void* pkt, uint32_t* Vector, uint32_t* Address, OrionBoardEnumeration_t* sourceBoard)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionResetSourcePacketID())
        return 0;

    if(numBytes < getOrionResetSourceMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    *sourceBoard = BOARD_CLEVIS;

    // Interrupt vector for the last reset
    *Vector = uint32FromBeBytes(data, &byteindex);

    // Program counter prior to the reset (not yet used)
    *Address = uint32FromBeBytes(data, &byteindex);

    // Enumeration defining which board in the gimbal generated this message
    if(byteindex + 1 > numBytes)
        return 1;

    *sourceBoard = (OrionBoardEnumeration_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DebugString packet
 *
 * This packet sends a human readable text string which is typically used for
 * debugging purposes.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDebugStringPacketStructure(void* pkt, const DebugString_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Identifier to determine which board sent the debug packet
    uint8ToBytes(user->source, data, &byteindex);

    // The importance of the debug message
    uint8ToBytes(user->priority, data, &byteindex);

    uint8ToBytes(user->reserved1, data, &byteindex);

    uint8ToBytes(user->reserved2, data, &byteindex);

    // human readable description of the debug problem
    stringToBytes(user->description, data, &byteindex, 128, 0);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getDebugStringPacketID());
}

/*!
 * \brief Decode the DebugString packet
 *
 * This packet sends a human readable text string which is typically used for
 * debugging purposes.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDebugStringPacketStructure(const void* pkt, DebugString_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getDebugStringPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getDebugStringMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Identifier to determine which board sent the debug packet
    user->source = (OrionBoardEnumeration_t)uint8FromBytes(data, &byteindex);

    // The importance of the debug message
    user->priority = (debugPriority)uint8FromBytes(data, &byteindex);

    user->reserved1 = uint8FromBytes(data, &byteindex);

    user->reserved2 = uint8FromBytes(data, &byteindex);

    // human readable description of the debug problem
    stringFromBytes(user->description, data, &byteindex, 128, 0);

    return 1;
}

/*!
 * \brief Create the KlvUserData packet
 *
 * This packet is used to set and query the values of user-configurable KLV tags
 * \param pkt points to the packet which will be created by this function
 * \param Key is UAS Local Set key
 * \param SubKey is UAS Local Set sub-key, if applicable (e.g., security metadata)
 * \param Length is Data length, in bytes
 * \param Value is Variable-length value string
 */
void encodeKlvUserDataPacket(void* pkt, uint8_t Key, uint8_t SubKey, uint8_t Length, const uint8_t Value[127])
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // UAS Local Set key
    uint8ToBytes(Key, data, &byteindex);

    // UAS Local Set sub-key, if applicable (e.g., security metadata)
    uint8ToBytes(SubKey, data, &byteindex);

    // Data length, in bytes
    uint8ToBytes(Length, data, &byteindex);

    // Variable-length value string
    for(i = 0; i < (int)Length && i < 127; i++)
        uint8ToBytes(Value[i], data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getKlvUserDataPacketID());
}

/*!
 * \brief Decode the KlvUserData packet
 *
 * This packet is used to set and query the values of user-configurable KLV tags
 * \param pkt points to the packet being decoded by this function
 * \param Key receives UAS Local Set key
 * \param SubKey receives UAS Local Set sub-key, if applicable (e.g., security metadata)
 * \param Length receives Data length, in bytes
 * \param Value receives Variable-length value string
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeKlvUserDataPacket(const void* pkt, uint8_t* Key, uint8_t* SubKey, uint8_t* Length, uint8_t Value[127])
{
    int i = 0;
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getKlvUserDataPacketID())
        return 0;

    if(numBytes < getKlvUserDataMinDataLength())
        return 0;

    // UAS Local Set key
    *Key = uint8FromBytes(data, &byteindex);

    // UAS Local Set sub-key, if applicable (e.g., security metadata)
    *SubKey = uint8FromBytes(data, &byteindex);

    // Data length, in bytes
    *Length = uint8FromBytes(data, &byteindex);

    // Variable-length value string
    for(i = 0; i < (int)(*Length) && i < 127; i++)
        Value[i] = uint8FromBytes(data, &byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

/*!
 * \brief Create the GpsData packet
 *
 * Raw GPS data. This packet is normally sent by the gimbal once per second,
 * unless the gimbal is in INS debug mode, in which case this packet is sent for
 * every GPS report. This packet can also be sent to the gimbal in order to
 * provide GPS information. Sending this packet to the gimbal will override any
 * internal GPS. The ideal rate to send this packet to the gimbal is 4Hz.
 *
 * Note that the position information of this packet is *not* the definitive
 * position of the gimbal. That information comes from the INS in the gimbal and
 * is visible in the GeolocateTelemetryCore packet.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeGpsDataPacketStructure(void* pkt, const GpsData_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Set if the GPS has a multi antenna heading solution
    data[byteindex] = (uint8_t)user->multiAntHeadingValid << 7;

    // uBlox fix type
    data[byteindex] |= (uint8_t)user->FixType;
    byteindex += 1; // close bit field

    // uBlox fix state
    uint8ToBytes(user->FixState, data, &byteindex);

    // The number of satellites used in the GPS solution
    uint8ToBytes(user->TrackedSats, data, &byteindex);

    // Position dilution of precision
    // Range of PDOP is 0.0 to 25.5.
    float32ScaledTo1UnsignedBytes(user->PDOP, data, &byteindex, 0.0f, 10.0f);

    // Geodetic latitude in radians, positive North
    // Range of Latitude is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->Latitude, data, &byteindex, 572957795.1308233);

    // Longitude in radians, positive East
    // Range of Longitude is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(user->Longitude, data, &byteindex, 572957795.1308233);

    // Altitude in meters above the WGS-84 ellipsoid
    // Range of Altitude is -214748.3647 to 214748.3647.
    float64ScaledTo4SignedBeBytes(user->Altitude, data, &byteindex, 10000.0);

    // Velocity in North, East, Down meters per second
    // Range of VelNED is -2147483.647 to 2147483.647.
    for(i = 0; i < 3; i++)
        float32ScaledTo4SignedBeBytes(user->VelNED[i], data, &byteindex, 1000.0f);

    // Horizontal accuracy in meters
    // Range of Hacc is -2147483.647 to 2147483.647.
    float32ScaledTo4SignedBeBytes(user->Hacc, data, &byteindex, 1000.0f);

    // Vertical accuracy in meters
    // Range of Vacc is -2147483.647 to 2147483.647.
    float32ScaledTo4SignedBeBytes(user->Vacc, data, &byteindex, 1000.0f);

    // Speed accuracy in meters per second
    // Range of SpeedAcc is -2147483.647 to 2147483.647.
    float32ScaledTo4SignedBeBytes(user->SpeedAcc, data, &byteindex, 1000.0f);

    // Course accuracy in radians
    // Range of HeadingAcc is -374.8065995436313 to 374.8065995436313.
    float32ScaledTo4SignedBeBytes(user->HeadingAcc, data, &byteindex, 5729578.0f);

    // GPS time of week in milliseconds
    uint32ToBeBytes(user->ITOW, data, &byteindex);

    // GPS week number since Jan 6 1980
    uint16ToBeBytes(user->Week, data, &byteindex);

    // Height of the mean seal level geoid with respect to the WGS-84 ellipsoid, in meters
    // Range of GeoidUndulation is -327.67 to 327.67.
    float32ScaledTo2SignedBeBytes(user->GeoidUndulation, data, &byteindex, 100.0f);

    // The source of the GPS data
    uint8ToBytes(user->source, data, &byteindex);

    data[byteindex] = 0;

    // Set if detailed accuracy information (posAccuracy and velAccuracy) are included in this packet
    data[byteindex] |= (uint8_t)user->detailedAccuracyValid << 1;

    // 0 if vertical velocity data are not valid
    data[byteindex] |= (uint8_t)user->verticalVelocityValid;
    byteindex += 1; // close bit field

    // Leap seconds to subtract from GPS time to compute UTC time
    uint8ToBytes(user->leapSeconds, data, &byteindex);

    // The heading in radians from the multi antenna solution from -pi to pi
    if(user->multiAntHeadingValid)
    {
        // Range of multiAntHeading is -3.141592653589793 to 3.141592653589793.
        float32ScaledTo2SignedBeBytes(user->multiAntHeading, data, &byteindex, 10430.06004058427f);
    }

    // North, East, Down position accuracy estimate in meters
    if(user->detailedAccuracyValid)
    {
        // Range of posAccuracy is 0.0 to 65.535.
        for(i = 0; i < 3; i++)
            float32ScaledTo2UnsignedBeBytes(user->posAccuracy[i], data, &byteindex, 0.0f, 1000.0f);
    }

    // North, East, Down velocity accuracy estimate in meters per second
    if(user->detailedAccuracyValid)
    {
        // Range of velAccuracy is 0.0 to 65.535.
        for(i = 0; i < 3; i++)
            float32ScaledTo2UnsignedBeBytes(user->velAccuracy[i], data, &byteindex, 0.0f, 1000.0f);
    }

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getGpsDataPacketID());
}

/*!
 * \brief Decode the GpsData packet
 *
 * Raw GPS data. This packet is normally sent by the gimbal once per second,
 * unless the gimbal is in INS debug mode, in which case this packet is sent for
 * every GPS report. This packet can also be sent to the gimbal in order to
 * provide GPS information. Sending this packet to the gimbal will override any
 * internal GPS. The ideal rate to send this packet to the gimbal is 4Hz.
 *
 * Note that the position information of this packet is *not* the definitive
 * position of the gimbal. That information comes from the INS in the gimbal and
 * is visible in the GeolocateTelemetryCore packet.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeGpsDataPacketStructure(const void* pkt, GpsData_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getGpsDataPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getGpsDataMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->leapSeconds = 17;
    user->multiAntHeading = 0;
    for(i = 0; i < 3; i++)
        user->posAccuracy[i] = 0;
    for(i = 0; i < 3; i++)
        user->velAccuracy[i] = 0;

    // Set if the GPS has a multi antenna heading solution
    user->multiAntHeadingValid = (data[byteindex] >> 7);

    // uBlox fix type
    user->FixType = ((data[byteindex]) & 0xF);
    byteindex += 1; // close bit field

    // uBlox fix state
    user->FixState = uint8FromBytes(data, &byteindex);

    // The number of satellites used in the GPS solution
    user->TrackedSats = uint8FromBytes(data, &byteindex);

    // Position dilution of precision
    // Range of PDOP is 0.0 to 25.5.
    user->PDOP = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/10.0f);

    // Geodetic latitude in radians, positive North
    // Range of Latitude is -3.748066027288564 to 3.748066027288564.
    user->Latitude = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Longitude in radians, positive East
    // Range of Longitude is -3.748066027288564 to 3.748066027288564.
    user->Longitude = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Altitude in meters above the WGS-84 ellipsoid
    // Range of Altitude is -214748.3647 to 214748.3647.
    user->Altitude = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/10000.0);

    // Velocity in North, East, Down meters per second
    // Range of VelNED is -2147483.647 to 2147483.647.
    for(i = 0; i < 3; i++)
        user->VelNED[i] = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Horizontal accuracy in meters
    // Range of Hacc is -2147483.647 to 2147483.647.
    user->Hacc = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Vertical accuracy in meters
    // Range of Vacc is -2147483.647 to 2147483.647.
    user->Vacc = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Speed accuracy in meters per second
    // Range of SpeedAcc is -2147483.647 to 2147483.647.
    user->SpeedAcc = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Course accuracy in radians
    // Range of HeadingAcc is -374.8065995436313 to 374.8065995436313.
    user->HeadingAcc = float32ScaledFrom4SignedBeBytes(data, &byteindex, 1.0f/5729578.0f);

    // GPS time of week in milliseconds
    user->ITOW = uint32FromBeBytes(data, &byteindex);

    // GPS week number since Jan 6 1980
    user->Week = uint16FromBeBytes(data, &byteindex);

    // Height of the mean seal level geoid with respect to the WGS-84 ellipsoid, in meters
    // Range of GeoidUndulation is -327.67 to 327.67.
    user->GeoidUndulation = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100.0f);

    // The source of the GPS data
    user->source = (gpsSource_t)uint8FromBytes(data, &byteindex);

    // Set if detailed accuracy information (posAccuracy and velAccuracy) are included in this packet
    user->detailedAccuracyValid = ((data[byteindex] >> 1) & 0x1);

    // 0 if vertical velocity data are not valid
    user->verticalVelocityValid = ((data[byteindex]) & 0x1);
    byteindex += 1; // close bit field

    // Leap seconds to subtract from GPS time to compute UTC time
    if(byteindex + 1 > numBytes)
        return 1;

    user->leapSeconds = uint8FromBytes(data, &byteindex);

    // The heading in radians from the multi antenna solution from -pi to pi
    if(user->multiAntHeadingValid)
    {
        if(byteindex + 2 > numBytes)
            return 1;

        // Range of multiAntHeading is -3.141592653589793 to 3.141592653589793.
        user->multiAntHeading = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);
    }

    // North, East, Down position accuracy estimate in meters
    if(user->detailedAccuracyValid)
    {
        if(byteindex + 2*3 > numBytes)
            return 1;

        // Range of posAccuracy is 0.0 to 65.535.
        for(i = 0; i < 3; i++)
            user->posAccuracy[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);
    }

    // North, East, Down velocity accuracy estimate in meters per second
    if(user->detailedAccuracyValid)
    {
        if(byteindex + 2*3 > numBytes)
            return 1;

        // Range of velAccuracy is 0.0 to 65.535.
        for(i = 0; i < 3; i++)
            user->velAccuracy[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);
    }

    return 1;
}

/*!
 * \brief Create the InsQuality packet
 *
 * This packet is transmitted once per second by the gimbal to communicate the
 * quality of the inertial navigation system (INS) data. The INS is responsible
 * for fusing the crown board IMU and GPS to determine the position, velocity,
 * attitude, and IMU errors. The quality of the INS data directly impacts the
 * quality of the data in the GeolocateTelemetryCore packet. This data are only
 * sent once per second as the quality data changes slowly.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeInsQualityPacketStructure(void* pkt, const InsQuality_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    unsigned int tempbitfield = 0;
    int i = 0;

    // Milliseconds since system bootup
    uint32ToBeBytes(user->systemTime, data, &byteindex);

    // The source of GPS data
    uint8ToBytes(user->gpsSource, data, &byteindex);

    // Reserved packet space
    data[byteindex] = 0;

    // IMU type
    tempbitfield = user->imuType;
    if(tempbitfield > 7)
        tempbitfield = 7;

    data[byteindex] |= (uint8_t)tempbitfield;
    byteindex += 1; // close bit field

    // The operational mode of the INS
    uint8ToBytes(user->insMode, data, &byteindex);

    // 1 if the INS is computing and reporting gyro bias states
    data[byteindex] = (uint8_t)user->hasGyroBias << 7;

    // 1 if the INS is computing and reporting a gravity bias state
    data[byteindex] |= (uint8_t)user->hasGravityBias << 6;

    // 1 if the INS is computing and reporting accelerometer bias states
    data[byteindex] |= (uint8_t)user->hasAccelBias << 5;

    // 1 if the INS is computing and reporting clock bias and drift states
    data[byteindex] |= (uint8_t)user->hasClockBias << 4;

    // 1 if the INS is computing and reporting pan and tilt bias states
    data[byteindex] |= (uint8_t)user->hasPanTiltBias << 3;

    // 1 if the INS rejected the last position update because the chi-square value was too large.
    data[byteindex] |= (uint8_t)user->posRejected << 2;

    // 1 if the INS rejected the last velocity update because the chi-square value was too large.
    data[byteindex] |= (uint8_t)user->velRejected << 1;

    // 1 if the INS rejected the last heading update because the chi-square value was too large.
    data[byteindex] |= (uint8_t)user->hdgRejected;
    byteindex += 1; // close bit field

    // Time in seconds between GPS measurements, 0 if no measurement
    // Range of gpsPeriod is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->gpsPeriod, data, &byteindex, 0.0f, 100.0f);

    // Time in seconds between heading measurements, 0 if no measurement
    // Range of hdgPeriod is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->hdgPeriod, data, &byteindex, 0.0f, 100.0f);

    // Chi-square statistic of the last position observation
    float16ToBeBytes((float)user->posChiSquare, data, &byteindex, 9);

    // Chi-square statistic of the last velocity observation
    float16ToBeBytes((float)user->velChiSquare, data, &byteindex, 9);

    // Chi-square statistic of the last heading observation
    float16ToBeBytes((float)user->hdgChiSquare, data, &byteindex, 9);

    // Attitude confidence in radians as a body Roll, Pitch, Yaw vector
    // Range of attConfidence is 0.0 to 6.5535.
    for(i = 0; i < 3; i++)
        float32ScaledTo2UnsignedBeBytes(user->attConfidence[i], data, &byteindex, 0.0f, 10000.0f);

    // Velocity confidence in meters per second as a North, East, Down vector
    // Range of velConfidence is 0.0 to 655.35.
    for(i = 0; i < 3; i++)
        float32ScaledTo2UnsignedBeBytes(user->velConfidence[i], data, &byteindex, 0.0f, 100.0f);

    // Position confidence in meters as a North, East, Down vector
    // Range of posConfidence is 0.0 to 655.35.
    for(i = 0; i < 3; i++)
        float32ScaledTo2UnsignedBeBytes(user->posConfidence[i], data, &byteindex, 0.0f, 100.0f);

    // Rate gyro bias confidence in radians per second as a body Roll, Pitch, Yaw vector
    if(user->hasGyroBias)
    {
        // Range of gyroConfidence is 0.0 to 0.65535.
        for(i = 0; i < 3; i++)
            float32ScaledTo2UnsignedBeBytes(user->gyroConfidence[i], data, &byteindex, 0.0f, 100000.0f);
    }

    // Accelerometer bias confidence in m/s/s as a body X, Y, Z vector
    if(user->hasAccelBias)
    {
        // Range of accelConfidence is 0.0 to 2.1845.
        for(i = 0; i < 3; i++)
            float32ScaledTo2UnsignedBeBytes(user->accelConfidence[i], data, &byteindex, 0.0f, 30000.0f);
    }

    // Gravity bias confidence in m/s/s
    if(user->hasGravityBias)
    {
        // Range of gravityConfidence is 0.0 to 2.1845.
        float32ScaledTo2UnsignedBeBytes(user->gravityConfidence, data, &byteindex, 0.0f, 30000.0f);
    }

    // Clock bias confidence (for tightly coupled) in meters
    if(user->hasClockBias)
    {
        // Range of clockBiasConfidence is 0.0 to 6.5535.
        float32ScaledTo2UnsignedBeBytes(user->clockBiasConfidence, data, &byteindex, 0.0f, 10000.0f);
    }

    // Clock drift confience (for tightly coupled) in meters per second
    if(user->hasClockBias)
    {
        // Range of clockDriftConfidence is 0.0 to 6.5535.
        float32ScaledTo2UnsignedBeBytes(user->clockDriftConfidence, data, &byteindex, 0.0f, 10000.0f);
    }

    // Rate gyro bias estimate in radians per second as a body Roll, Pitch, Yaw vector
    if(user->hasGyroBias)
    {
        // Range of gyroBias is -0.32767 to 0.32767.
        for(i = 0; i < 3; i++)
            float32ScaledTo2SignedBeBytes(user->gyroBias[i], data, &byteindex, 100000.0f);
    }

    // Accelerometer bias estimate in m/s/s as a body X, Y, Z vector
    if(user->hasAccelBias)
    {
        // Range of accelBias is 0.0 to 2.1845.
        for(i = 0; i < 3; i++)
            float32ScaledTo2UnsignedBeBytes(user->accelBias[i], data, &byteindex, 0.0f, 30000.0f);
    }

    // Gravity bias estimate in m/s/s
    if(user->hasGravityBias)
    {
        // Range of gravityBias is 0.0 to 2.1845.
        float32ScaledTo2UnsignedBeBytes(user->gravityBias, data, &byteindex, 0.0f, 30000.0f);
    }

    // Clock bias estimate (for tightly coupled) in meters
    if(user->hasClockBias)
    {
        // Range of clockBias is -327.67 to 327.67.
        float32ScaledTo2SignedBeBytes(user->clockBias, data, &byteindex, 100.0f);
    }

    // Clock drift estimate (for tightly coupled) in meters per second
    if(user->hasClockBias)
    {
        // Range of clockDrift is -32.767 to 32.767.
        float32ScaledTo2SignedBeBytes(user->clockDrift, data, &byteindex, 1000.0f);
    }

    // Number of satellites that contributed to tightly coupled position updates
    if(user->hasClockBias)
    {
        uint8ToBytes(user->numTightSatPosUpdates, data, &byteindex);
    }

    // Number of satellites that contributed to tightly coupled velocity updates
    if(user->hasClockBias)
    {
        uint8ToBytes(user->numTightSatVelUpdates, data, &byteindex);
    }

    // Number of signals that contributed to tightly coupled position updates
    if(user->hasClockBias)
    {
        uint8ToBytes(user->numTightPosUpdates, data, &byteindex);
    }

    // Number of signals that contributed to tightly coupled velocity updates
    if(user->hasClockBias)
    {
        uint8ToBytes(user->numTightVelUpdates, data, &byteindex);
    }

    // Pan and tilt boresight biases
    if(user->hasPanTiltBias)
    {
        // Range of panTiltBias is -0.1745329251994329 to 0.1745329251994329.
        for(i = 0; i < NUM_GIMBAL_AXES; i++)
            float32ScaledTo2SignedBeBytes(user->panTiltBias[i], data, &byteindex, 187741.0807305168f);
    }

    // Pan and tilt chi-square statistic
    if(user->hasPanTiltBias)
    {
        // Range of panTiltChiSquare is 0.0 to 10.0.
        float32ScaledTo1UnsignedBytes(user->panTiltChiSquare, data, &byteindex, 0.0f, 25.5f);
    }

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getInsQualityPacketID());
}

/*!
 * \brief Decode the InsQuality packet
 *
 * This packet is transmitted once per second by the gimbal to communicate the
 * quality of the inertial navigation system (INS) data. The INS is responsible
 * for fusing the crown board IMU and GPS to determine the position, velocity,
 * attitude, and IMU errors. The quality of the INS data directly impacts the
 * quality of the data in the GeolocateTelemetryCore packet. This data are only
 * sent once per second as the quality data changes slowly.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeInsQualityPacketStructure(const void* pkt, InsQuality_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getInsQualityPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getInsQualityMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Milliseconds since system bootup
    user->systemTime = uint32FromBeBytes(data, &byteindex);

    // The source of GPS data
    user->gpsSource = (gpsSource_t)uint8FromBytes(data, &byteindex);

    // Reserved packet space

    // IMU type
    user->imuType = (imuType_t)((data[byteindex]) & 0x7);
    byteindex += 1; // close bit field

    // The operational mode of the INS
    user->insMode = (insMode_t)uint8FromBytes(data, &byteindex);

    // 1 if the INS is computing and reporting gyro bias states
    user->hasGyroBias = (data[byteindex] >> 7);

    // 1 if the INS is computing and reporting a gravity bias state
    user->hasGravityBias = ((data[byteindex] >> 6) & 0x1);

    // 1 if the INS is computing and reporting accelerometer bias states
    user->hasAccelBias = ((data[byteindex] >> 5) & 0x1);

    // 1 if the INS is computing and reporting clock bias and drift states
    user->hasClockBias = ((data[byteindex] >> 4) & 0x1);

    // 1 if the INS is computing and reporting pan and tilt bias states
    user->hasPanTiltBias = ((data[byteindex] >> 3) & 0x1);

    // 1 if the INS rejected the last position update because the chi-square value was too large.
    user->posRejected = ((data[byteindex] >> 2) & 0x1);

    // 1 if the INS rejected the last velocity update because the chi-square value was too large.
    user->velRejected = ((data[byteindex] >> 1) & 0x1);

    // 1 if the INS rejected the last heading update because the chi-square value was too large.
    user->hdgRejected = ((data[byteindex]) & 0x1);
    byteindex += 1; // close bit field

    // Time in seconds between GPS measurements, 0 if no measurement
    // Range of gpsPeriod is 0.0 to 2.55.
    user->gpsPeriod = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Time in seconds between heading measurements, 0 if no measurement
    // Range of hdgPeriod is 0.0 to 2.55.
    user->hdgPeriod = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Chi-square statistic of the last position observation
    user->posChiSquare = float16FromBeBytes(data, &byteindex, 9);

    // Chi-square statistic of the last velocity observation
    user->velChiSquare = float16FromBeBytes(data, &byteindex, 9);

    // Chi-square statistic of the last heading observation
    user->hdgChiSquare = float16FromBeBytes(data, &byteindex, 9);

    // Attitude confidence in radians as a body Roll, Pitch, Yaw vector
    // Range of attConfidence is 0.0 to 6.5535.
    for(i = 0; i < 3; i++)
        user->attConfidence[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10000.0f);

    // Velocity confidence in meters per second as a North, East, Down vector
    // Range of velConfidence is 0.0 to 655.35.
    for(i = 0; i < 3; i++)
        user->velConfidence[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Position confidence in meters as a North, East, Down vector
    // Range of posConfidence is 0.0 to 655.35.
    for(i = 0; i < 3; i++)
        user->posConfidence[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Rate gyro bias confidence in radians per second as a body Roll, Pitch, Yaw vector
    if(user->hasGyroBias)
    {
        // Range of gyroConfidence is 0.0 to 0.65535.
        for(i = 0; i < 3; i++)
            user->gyroConfidence[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100000.0f);
    }

    // Accelerometer bias confidence in m/s/s as a body X, Y, Z vector
    if(user->hasAccelBias)
    {
        // Range of accelConfidence is 0.0 to 2.1845.
        for(i = 0; i < 3; i++)
            user->accelConfidence[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/30000.0f);
    }

    // Gravity bias confidence in m/s/s
    if(user->hasGravityBias)
    {
        // Range of gravityConfidence is 0.0 to 2.1845.
        user->gravityConfidence = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/30000.0f);
    }

    // Clock bias confidence (for tightly coupled) in meters
    if(user->hasClockBias)
    {
        // Range of clockBiasConfidence is 0.0 to 6.5535.
        user->clockBiasConfidence = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10000.0f);
    }

    // Clock drift confience (for tightly coupled) in meters per second
    if(user->hasClockBias)
    {
        // Range of clockDriftConfidence is 0.0 to 6.5535.
        user->clockDriftConfidence = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10000.0f);
    }

    // Rate gyro bias estimate in radians per second as a body Roll, Pitch, Yaw vector
    if(user->hasGyroBias)
    {
        // Range of gyroBias is -0.32767 to 0.32767.
        for(i = 0; i < 3; i++)
            user->gyroBias[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100000.0f);
    }

    // Accelerometer bias estimate in m/s/s as a body X, Y, Z vector
    if(user->hasAccelBias)
    {
        // Range of accelBias is 0.0 to 2.1845.
        for(i = 0; i < 3; i++)
            user->accelBias[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/30000.0f);
    }

    // Gravity bias estimate in m/s/s
    if(user->hasGravityBias)
    {
        // Range of gravityBias is 0.0 to 2.1845.
        user->gravityBias = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/30000.0f);
    }

    // Clock bias estimate (for tightly coupled) in meters
    if(user->hasClockBias)
    {
        // Range of clockBias is -327.67 to 327.67.
        user->clockBias = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100.0f);
    }

    // Clock drift estimate (for tightly coupled) in meters per second
    if(user->hasClockBias)
    {
        // Range of clockDrift is -32.767 to 32.767.
        user->clockDrift = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);
    }

    // Number of satellites that contributed to tightly coupled position updates
    if(user->hasClockBias)
    {
    user->numTightSatPosUpdates = uint8FromBytes(data, &byteindex);
    }

    // Number of satellites that contributed to tightly coupled velocity updates
    if(user->hasClockBias)
    {
    user->numTightSatVelUpdates = uint8FromBytes(data, &byteindex);
    }

    // Number of signals that contributed to tightly coupled position updates
    if(user->hasClockBias)
    {
    user->numTightPosUpdates = uint8FromBytes(data, &byteindex);
    }

    // Number of signals that contributed to tightly coupled velocity updates
    if(user->hasClockBias)
    {
    user->numTightVelUpdates = uint8FromBytes(data, &byteindex);
    }

    // Pan and tilt boresight biases
    if(user->hasPanTiltBias)
    {
        // Range of panTiltBias is -0.1745329251994329 to 0.1745329251994329.
        for(i = 0; i < NUM_GIMBAL_AXES; i++)
            user->panTiltBias[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/187741.0807305168f);
    }

    // Pan and tilt chi-square statistic
    if(user->hasPanTiltBias)
    {
        // Range of panTiltChiSquare is 0.0 to 10.0.
        user->panTiltChiSquare = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/25.5f);
    }

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionCmd packet
 *
 * Basic commands for control of gimbal pan and tilt. Send this packet to the
 * gimbal to effect basic pan and tilt control. The gimbal will echo the packet
 * as confirmation of receiving it. Note that this packet cannot be used to
 * command the Geopoint or Path modes; those modes need to be commanded through
 * their respective packets. If the gimbal is in Geopoint or Path mode receiving
 * this packet will cancel those modes.
 * \param pkt points to the packet which will be created by this function
 * \param Cmd is Pan/tilt command
 */
void encodeOrionCmdPacket(void* pkt, const OrionCmd_t* Cmd)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Pan/tilt command
    encodeOrionCmd_t(data, &byteindex, Cmd);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionCmdPacketID());
}

/*!
 * \brief Decode the OrionCmd packet
 *
 * Basic commands for control of gimbal pan and tilt. Send this packet to the
 * gimbal to effect basic pan and tilt control. The gimbal will echo the packet
 * as confirmation of receiving it. Note that this packet cannot be used to
 * command the Geopoint or Path modes; those modes need to be commanded through
 * their respective packets. If the gimbal is in Geopoint or Path mode receiving
 * this packet will cancel those modes.
 * \param pkt points to the packet being decoded by this function
 * \param Cmd receives Pan/tilt command
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionCmdPacket(const void* pkt, OrionCmd_t* Cmd)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionCmdPacketID())
        return 0;

    if(numBytes < getOrionCmdMinDataLength())
        return 0;

    // Pan/tilt command
    if(decodeOrionCmd_t(data, &byteindex, Cmd) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionStartupCmd packet
 *
 * Command to run upon motor initialization
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionStartupCmdPacketStructure(void* pkt, const OrionStartupCmd_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Pan/tilt command. Defaults to position mode, pan/tilt of 0
    encodeOrionCmd_t(data, &byteindex, &user->Cmd);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionStartupCmdPacketID());
}

/*!
 * \brief Decode the OrionStartupCmd packet
 *
 * Command to run upon motor initialization
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionStartupCmdPacketStructure(const void* pkt, OrionStartupCmd_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionStartupCmdPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionStartupCmdMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Pan/tilt command. Defaults to position mode, pan/tilt of 0
    if(decodeOrionCmd_t(data, &byteindex, &user->Cmd) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionStartupCmd packet
 *
 * Command to run upon motor initialization
 * \param pkt points to the packet which will be created by this function
 * \param Cmd is Pan/tilt command. Defaults to position mode, pan/tilt of 0
 */
void encodeOrionStartupCmdPacket(void* pkt, const OrionCmd_t* Cmd)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Pan/tilt command. Defaults to position mode, pan/tilt of 0
    encodeOrionCmd_t(data, &byteindex, Cmd);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionStartupCmdPacketID());
}

/*!
 * \brief Decode the OrionStartupCmd packet
 *
 * Command to run upon motor initialization
 * \param pkt points to the packet being decoded by this function
 * \param Cmd receives Pan/tilt command. Defaults to position mode, pan/tilt of 0
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionStartupCmdPacket(const void* pkt, OrionCmd_t* Cmd)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionStartupCmdPacketID())
        return 0;

    if(numBytes < getOrionStartupCmdMinDataLength())
        return 0;

    // Pan/tilt command. Defaults to position mode, pan/tilt of 0
    if(decodeOrionCmd_t(data, &byteindex, Cmd) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the GeopointCmd packet
 *
 * Send this packet to command the gimbal to go to Geopoint mode. In geopoint
 * the gimbal looks at a target as given by a latitude, longitude, altitude
 * position. The geopoint command can include a target velocity, which will
 * cause the gimbal to smoothly move its stare point as it propagates the target
 * position. Geopoint mode is canceled by sending a normal OrionCmd packet.
 * \param pkt points to the packet which will be created by this function
 * \param targetLat is Geodetic latitude of the target in radians, positive North
 * \param targetLon is Longitude of the target in radians, positive East
 * \param targetAlt is Altitude of the target in meters above the WGS-84 ellipsoid
 * \param targetVelNED is Velocity of the target in North, East, Down meters per second
 * \param joystickRange is Estimated range to target in meters. If non-zero *and* if geopoint is already running the position information in this packet is ignored and only the velocity and range information is used to propagate the geopoint command position. This is used for cases where a joystick is being used to drive the geopoint. If the gimbal has its own range estimate then a non-zero joystickRange will be replaced with the gimbal's internal range estimate. If you want the gimbal use the joystick mode but you cannot compute the range, use a range less than 10 meters and the gimbal will not do the range adjustment
 * \param options is Options for the geopoint packet.
 */
void encodeGeopointCmdPacket(void* pkt, double targetLat, double targetLon, double targetAlt, const float targetVelNED[3], float joystickRange, geopointOptions options)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Geodetic latitude of the target in radians, positive North
    // Range of targetLat is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(targetLat, data, &byteindex, 572957795.1308233);

    // Longitude of the target in radians, positive East
    // Range of targetLon is -3.748066027288564 to 3.748066027288564.
    float64ScaledTo4SignedBeBytes(targetLon, data, &byteindex, 572957795.1308233);

    // Altitude of the target in meters above the WGS-84 ellipsoid
    // Range of targetAlt is -214748.3647 to 214748.3647.
    float64ScaledTo4SignedBeBytes(targetAlt, data, &byteindex, 10000.0);

    // Velocity of the target in North, East, Down meters per second
    // Range of targetVelNED is -327.67 to 327.67.
    for(i = 0; i < 3; i++)
        float32ScaledTo2SignedBeBytes(targetVelNED[i], data, &byteindex, 100.0f);

    // Estimated range to target in meters. If non-zero *and* if geopoint is already running the position information in this packet is ignored and only the velocity and range information is used to propagate the geopoint command position. This is used for cases where a joystick is being used to drive the geopoint. If the gimbal has its own range estimate then a non-zero joystickRange will be replaced with the gimbal's internal range estimate. If you want the gimbal use the joystick mode but you cannot compute the range, use a range less than 10 meters and the gimbal will not do the range adjustment
    // Range of joystickRange is 0.0 to 65535.0.
    float32ScaledTo2UnsignedBeBytes(joystickRange, data, &byteindex, 0.0f, 1.0f);

    // Options for the geopoint packet.
    uint8ToBytes(options, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getGeopointCmdPacketID());
}

/*!
 * \brief Decode the GeopointCmd packet
 *
 * Send this packet to command the gimbal to go to Geopoint mode. In geopoint
 * the gimbal looks at a target as given by a latitude, longitude, altitude
 * position. The geopoint command can include a target velocity, which will
 * cause the gimbal to smoothly move its stare point as it propagates the target
 * position. Geopoint mode is canceled by sending a normal OrionCmd packet.
 * \param pkt points to the packet being decoded by this function
 * \param targetLat receives Geodetic latitude of the target in radians, positive North
 * \param targetLon receives Longitude of the target in radians, positive East
 * \param targetAlt receives Altitude of the target in meters above the WGS-84 ellipsoid
 * \param targetVelNED receives Velocity of the target in North, East, Down meters per second
 * \param joystickRange receives Estimated range to target in meters. If non-zero *and* if geopoint is already running the position information in this packet is ignored and only the velocity and range information is used to propagate the geopoint command position. This is used for cases where a joystick is being used to drive the geopoint. If the gimbal has its own range estimate then a non-zero joystickRange will be replaced with the gimbal's internal range estimate. If you want the gimbal use the joystick mode but you cannot compute the range, use a range less than 10 meters and the gimbal will not do the range adjustment
 * \param options receives Options for the geopoint packet.
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeGeopointCmdPacket(const void* pkt, double* targetLat, double* targetLon, double* targetAlt, float targetVelNED[3], float* joystickRange, geopointOptions* options)
{
    int i = 0;
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getGeopointCmdPacketID())
        return 0;

    if(numBytes < getGeopointCmdMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    *joystickRange = 0;
    *options = geopointNone;

    // Geodetic latitude of the target in radians, positive North
    // Range of targetLat is -3.748066027288564 to 3.748066027288564.
    *targetLat = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Longitude of the target in radians, positive East
    // Range of targetLon is -3.748066027288564 to 3.748066027288564.
    *targetLon = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/572957795.1308233);

    // Altitude of the target in meters above the WGS-84 ellipsoid
    // Range of targetAlt is -214748.3647 to 214748.3647.
    *targetAlt = float64ScaledFrom4SignedBeBytes(data, &byteindex, 1.0/10000.0);

    // Velocity of the target in North, East, Down meters per second
    // Range of targetVelNED is -327.67 to 327.67.
    for(i = 0; i < 3; i++)
        targetVelNED[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100.0f);

    // Estimated range to target in meters. If non-zero *and* if geopoint is already running the position information in this packet is ignored and only the velocity and range information is used to propagate the geopoint command position. This is used for cases where a joystick is being used to drive the geopoint. If the gimbal has its own range estimate then a non-zero joystickRange will be replaced with the gimbal's internal range estimate. If you want the gimbal use the joystick mode but you cannot compute the range, use a range less than 10 meters and the gimbal will not do the range adjustment
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of joystickRange is 0.0 to 65535.0.
    *joystickRange = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1.0f);

    // Options for the geopoint packet.
    if(byteindex + 1 > numBytes)
        return 1;

    *options = (geopointOptions)uint8FromBytes(data, &byteindex);

    return 1;
}

//! Encode a Point_t structure into a byte array
void encodePoint_t(uint8_t* data, int* bytecount, const Point_t* user);

/*!
 * \brief Encode a Point_t structure into a byte array
 *
 * List of path points
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodePoint_t(uint8_t* data, int* bytecount, const Point_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // ECEF position in meters
    // Range of posEcef is -8388607.0 to 8388607.0.
    for(i = 0; i < 3; i++)
        float32ScaledTo3SignedBeBytes(user->posEcef[i], data, &byteindex, 1.0f);

    *bytecount = byteindex;

}// encodePoint_t

//! Decode a Point_t structure from a byte array
int decodePoint_t(const uint8_t* data, int* bytecount, Point_t* user);

/*!
 * \brief Decode a Point_t structure from a byte array
 *
 * List of path points
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodePoint_t(const uint8_t* data, int* bytecount, Point_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // ECEF position in meters
    // Range of posEcef is -8388607.0 to 8388607.0.
    for(i = 0; i < 3; i++)
        user->posEcef[i] = float32ScaledFrom3SignedBeBytes(data, &byteindex, 1.0f/1.0f);

    *bytecount = byteindex;

    return 1;

}// decodePoint_t

/*!
 * \brief Create the OrionPath packet
 *
 * The path packet contains a series of waypoints that define a path in 3D
 * space. Sending this packet enables the path track logic, which will cause the
 * gimbal to look at the nearest point on the path; or look directly downward.
 * Path mode is canceled by sending a normal OrionCmd packet.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionPathPacketStructure(void* pkt, const OrionPath_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Number of points in the path
    uint8ToBytes(user->numPoints, data, &byteindex);

    // If numPoints is zero, and this is set, then the gimbal will point downwards
    data[byteindex] = (uint8_t)user->pointDown << 7;

    // Reserved for future expansion

    // Number of steps for across track stepping. Must be more than 1 to enable cross track stepping.
    data[byteindex] |= (uint8_t)user->numCrossTrackSteps;
    byteindex += 1; // close bit field

    // List of path points
    for(i = 0; i < (int)user->numPoints && i < MAX_PATH_POINTS; i++)
        encodePoint_t(data, &byteindex, &user->Point[i]);

    // Angle in radians for step-stare functionality along track. Set to zero for no step-stare. If doing downward pointing the gimbal must be receiving ORION_PKT_RANGE_DATA.
    // Range of alongTrackStepAngle is 0.0 to 3.141592653589793.
    float32ScaledTo2UnsignedBeBytes(user->alongTrackStepAngle, data, &byteindex, 0.0f, 20860.43839105472f);

    // Ratio of cross track step angle to along track step angle. Set to zero for no cross track stepping.
    // Range of crossTrackStepRatio is 0.0 to 2.55.
    float32ScaledTo1UnsignedBytes(user->crossTrackStepRatio, data, &byteindex, 0.0f, 100.0f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionPathPacketID());
}

/*!
 * \brief Decode the OrionPath packet
 *
 * The path packet contains a series of waypoints that define a path in 3D
 * space. Sending this packet enables the path track logic, which will cause the
 * gimbal to look at the nearest point on the path; or look directly downward.
 * Path mode is canceled by sending a normal OrionCmd packet.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionPathPacketStructure(const void* pkt, OrionPath_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionPathPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionPathMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->alongTrackStepAngle = 0;
    user->crossTrackStepRatio = 0;

    // Number of points in the path
    user->numPoints = uint8FromBytes(data, &byteindex);

    // If numPoints is zero, and this is set, then the gimbal will point downwards
    user->pointDown = (data[byteindex] >> 7);

    // Reserved for future expansion

    // Number of steps for across track stepping. Must be more than 1 to enable cross track stepping.
    user->numCrossTrackSteps = ((data[byteindex]) & 0xF);
    byteindex += 1; // close bit field

    // List of path points
    for(i = 0; i < (int)user->numPoints && i < MAX_PATH_POINTS; i++)
    {
        if(decodePoint_t(data, &byteindex, &user->Point[i]) == 0)
            return 0;
    }

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    // Angle in radians for step-stare functionality along track. Set to zero for no step-stare. If doing downward pointing the gimbal must be receiving ORION_PKT_RANGE_DATA.
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of alongTrackStepAngle is 0.0 to 3.141592653589793.
    user->alongTrackStepAngle = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/20860.43839105472f);

    // Ratio of cross track step angle to along track step angle. Set to zero for no cross track stepping.
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of crossTrackStepRatio is 0.0 to 2.55.
    user->crossTrackStepRatio = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    return 1;
}

/*!
 * \brief Create the StareAck packet
 *
 * This packet tells the gimbal that the step-stare image has been acquired and
 * the gimbal can move to the next step stare point.
 * \param pkt points to the packet which will be created by this function
 * \param echoSystemTime is Milliseconds since system bootup received from ORION_PKT_STARE_START. If this value matches the value sent in ORION_PKT_STARE_START then the gimbal will terminate the stare operation early.
 */
void encodeStareAckPacket(void* pkt, uint32_t echoSystemTime)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Milliseconds since system bootup received from ORION_PKT_STARE_START. If this value matches the value sent in ORION_PKT_STARE_START then the gimbal will terminate the stare operation early.
    uint32ToBeBytes(echoSystemTime, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getStareAckPacketID());
}

/*!
 * \brief Decode the StareAck packet
 *
 * This packet tells the gimbal that the step-stare image has been acquired and
 * the gimbal can move to the next step stare point.
 * \param pkt points to the packet being decoded by this function
 * \param echoSystemTime receives Milliseconds since system bootup received from ORION_PKT_STARE_START. If this value matches the value sent in ORION_PKT_STARE_START then the gimbal will terminate the stare operation early.
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeStareAckPacket(const void* pkt, uint32_t* echoSystemTime)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getStareAckPacketID())
        return 0;

    if(numBytes < getStareAckMinDataLength())
        return 0;

    // Milliseconds since system bootup received from ORION_PKT_STARE_START. If this value matches the value sent in ORION_PKT_STARE_START then the gimbal will terminate the stare operation early.
    *echoSystemTime = uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionCameraSwitch packet
 *
 * Command the gimbal to swtich cameras.
 * \param pkt points to the packet which will be created by this function
 * \param Index is The index of the camera to switch to, counting from 0
 */
void encodeOrionCameraSwitchPacket(void* pkt, uint8_t Index)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // The index of the camera to switch to, counting from 0
    uint8ToBytes(Index, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionCameraSwitchPacketID());
}

/*!
 * \brief Decode the OrionCameraSwitch packet
 *
 * Command the gimbal to swtich cameras.
 * \param pkt points to the packet being decoded by this function
 * \param Index receives The index of the camera to switch to, counting from 0
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionCameraSwitchPacket(const void* pkt, uint8_t* Index)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionCameraSwitchPacketID())
        return 0;

    if(numBytes < getOrionCameraSwitchMinDataLength())
        return 0;

    // The index of the camera to switch to, counting from 0
    *Index = uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionCameraState packet
 *
 * Command a camera in the gimbal. Note this packet will eventually be
 * deprecated.
 * \param pkt points to the packet which will be created by this function
 * \param Zoom is Digital zoom ratio
 * \param Focus is Focus command/position
 * \param Index is The index of the camera to command
 */
void encodeOrionCameraStatePacket(void* pkt, float Zoom, float Focus, uint8_t Index)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Digital zoom ratio
    // Range of Zoom is -327.67 to 327.67.
    float32ScaledTo2SignedBeBytes(Zoom, data, &byteindex, 100.0f);

    // Focus command/position
    // Range of Focus is -3.2767 to 3.2767.
    float32ScaledTo2SignedBeBytes(Focus, data, &byteindex, 10000.0f);

    // The index of the camera to command
    uint8ToBytes(Index, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionCameraStatePacketID());
}

/*!
 * \brief Decode the OrionCameraState packet
 *
 * Command a camera in the gimbal. Note this packet will eventually be
 * deprecated.
 * \param pkt points to the packet being decoded by this function
 * \param Zoom receives Digital zoom ratio
 * \param Focus receives Focus command/position
 * \param Index receives The index of the camera to command
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionCameraStatePacket(const void* pkt, float* Zoom, float* Focus, uint8_t* Index)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionCameraStatePacketID())
        return 0;

    if(numBytes < getOrionCameraStateMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    *Focus = -1;
    *Index = 0;

    // Digital zoom ratio
    // Range of Zoom is -327.67 to 327.67.
    *Zoom = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/100.0f);

    // Focus command/position
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of Focus is -3.2767 to 3.2767.
    *Focus = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10000.0f);

    // The index of the camera to command
    if(byteindex + 1 > numBytes)
        return 1;

    *Index = uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionFlirSettings packet
 *
 * FLIR-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionFlirSettingsPacketStructure(void* pkt, const OrionFlirSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    unsigned int tempbitfield = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected FLIR camera.
    uint8ToBytes(user->Index, data, &byteindex);

    data[byteindex] = 0;

    data[byteindex] |= (uint8_t)user->Palette << 4;

    // NUC type setting
    tempbitfield = user->NucType;
    if(tempbitfield > 7)
        tempbitfield = 7;

    data[byteindex] |= (uint8_t)tempbitfield << 1;

    // Image polarity setting - set to 0 for white hot or 1 for black hot. This field is ignored if Palette is non-zero
    data[byteindex] |= (uint8_t)user->BlackHot;
    byteindex += 1; // close bit field

    // Maximum AGC output gain
    uint8ToBytes(user->MaxAgcGain, data, &byteindex);

    // Active Contrast Enhancement (ACE) level
    int8ToBytes(user->AceLevel, data, &byteindex);

    // DDE spatial threshold
    uint8ToBytes(user->DdeThreshold, data, &byteindex);

    // AGC output midpoint, from 0 to 255
    uint8ToBytes(user->AgcMidpoint, data, &byteindex);

    // Integration time, in milliseconds
    // Range of IntegrationTime is 1.0 to 30.0.
    float32ScaledTo1UnsignedBytes(user->IntegrationTime, data, &byteindex, 1.0f, 8.793103448275861f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionFlirSettingsPacketID());
}

/*!
 * \brief Decode the OrionFlirSettings packet
 *
 * FLIR-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionFlirSettingsPacketStructure(const void* pkt, OrionFlirSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionFlirSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionFlirSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->AgcMidpoint = 128;
    user->IntegrationTime = 8;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected FLIR camera.
    user->Index = uint8FromBytes(data, &byteindex);

    user->Palette = ((data[byteindex] >> 4) & 0x7);

    // NUC type setting
    user->NucType = (FlirNucType_t)((data[byteindex] >> 1) & 0x7);

    // Image polarity setting - set to 0 for white hot or 1 for black hot. This field is ignored if Palette is non-zero
    user->BlackHot = ((data[byteindex]) & 0x1);
    byteindex += 1; // close bit field

    // Maximum AGC output gain
    user->MaxAgcGain = uint8FromBytes(data, &byteindex);

    // Active Contrast Enhancement (ACE) level
    user->AceLevel = int8FromBytes(data, &byteindex);

    // DDE spatial threshold
    user->DdeThreshold = uint8FromBytes(data, &byteindex);

    // AGC output midpoint, from 0 to 255
    if(byteindex + 1 > numBytes)
        return 1;

    user->AgcMidpoint = uint8FromBytes(data, &byteindex);

    // Integration time, in milliseconds
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of IntegrationTime is 1.0 to 30.0.
    user->IntegrationTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 1.0f, 1.0f/8.793103448275861f);

    return 1;
}

/*!
 * \brief Create the OrionAptinaSettings packet
 *
 * Aptina-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionAptinaSettingsPacketStructure(void* pkt, const OrionAptinaSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Aptina camera.
    uint8ToBytes(user->Index, data, &byteindex);

    // Minimum exposure time in microseconds
    // Range of MinExposure is 0.05 to 33.0.
    float32ScaledTo2UnsignedBeBytes(user->MinExposure, data, &byteindex, 0.05f, 1988.922610015174f);

    // Maximum exposure time in milliseconds
    // Range of MaxExposure is 0.05 to 33.0.
    float32ScaledTo2UnsignedBeBytes(user->MaxExposure, data, &byteindex, 0.05f, 1988.922610015174f);

    // Minimum sensor luminance gain
    // Range of MinGain is 1.0 to 32.0.
    float32ScaledTo2UnsignedBeBytes(user->MinGain, data, &byteindex, 1.0f, 2114.032258064516f);

    // Maximum sensor luminance gain
    // Range of MaxGain is 1.0 to 32.0.
    float32ScaledTo2UnsignedBeBytes(user->MaxGain, data, &byteindex, 1.0f, 2114.032258064516f);

    // Brightness adjustment
    int8ToBytes(user->Brightness, data, &byteindex);

    // Contrast adjustment
    // Range of Contrast is -1.0 to 1.0.
    float32ScaledTo1SignedBytes(user->Contrast, data, &byteindex, 127.0f);

    // Saturation adjustment
    // Range of Saturation is -1.0 to 1.0.
    float32ScaledTo1SignedBytes(user->Saturation, data, &byteindex, 127.0f);

    // Sharpening filter strength
    // Range of Sharpness is 0.0 to 5.0.
    float32ScaledTo1UnsignedBytes(user->Sharpness, data, &byteindex, 0.0f, 51.0f);

    // Set to 1 to enable AGC debugging information
    data[byteindex] = (uint8_t)user->DebugEnable << 7;
    byteindex += 1; // close bit field

    // Hue adjustment
    int8ToBytes(user->Hue, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionAptinaSettingsPacketID());
}

/*!
 * \brief Decode the OrionAptinaSettings packet
 *
 * Aptina-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionAptinaSettingsPacketStructure(const void* pkt, OrionAptinaSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionAptinaSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionAptinaSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->DebugEnable = 0;
    user->Hue = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Aptina camera.
    user->Index = uint8FromBytes(data, &byteindex);

    // Minimum exposure time in microseconds
    // Range of MinExposure is 0.05 to 33.0.
    user->MinExposure = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.05f, 1.0f/1988.922610015174f);

    // Maximum exposure time in milliseconds
    // Range of MaxExposure is 0.05 to 33.0.
    user->MaxExposure = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.05f, 1.0f/1988.922610015174f);

    // Minimum sensor luminance gain
    // Range of MinGain is 1.0 to 32.0.
    user->MinGain = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 1.0f, 1.0f/2114.032258064516f);

    // Maximum sensor luminance gain
    // Range of MaxGain is 1.0 to 32.0.
    user->MaxGain = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 1.0f, 1.0f/2114.032258064516f);

    // Brightness adjustment
    user->Brightness = int8FromBytes(data, &byteindex);

    // Contrast adjustment
    // Range of Contrast is -1.0 to 1.0.
    user->Contrast = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/127.0f);

    // Saturation adjustment
    // Range of Saturation is -1.0 to 1.0.
    user->Saturation = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/127.0f);

    // Sharpening filter strength
    // Range of Sharpness is 0.0 to 5.0.
    user->Sharpness = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/51.0f);

    if(byteindex + 1 > numBytes)
        return 1;

    // Set to 1 to enable AGC debugging information
    user->DebugEnable = (data[byteindex] >> 7);
    byteindex += 1; // close bit field

    // Hue adjustment
    if(byteindex + 1 > numBytes)
        return 1;

    user->Hue = int8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionZafiroSettings packet
 *
 * Zafiro-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionZafiroSettingsPacketStructure(void* pkt, const OrionZafiroSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Zafiro camera.
    uint8ToBytes(user->Index, data, &byteindex);

    // Image polarity setting - set to 0 for white hot or 1 for black hot
    uint8ToBytes(user->BlackHot, data, &byteindex);

    // Integration time, in milliseconds
    // Range of IntegrationTime is 1.0 to 30.0.
    float32ScaledTo1UnsignedBytes(user->IntegrationTime, data, &byteindex, 1.0f, 8.793103448275861f);

    // Local Area Processing (LAP) enable/disable flag. Set to zero to disable, or non-zero to enable.
    uint8ToBytes(user->LapEnabled, data, &byteindex);

    // LAP Sharpening gain
    // Range of LapGain is 0.5 to 4.0.
    float32ScaledTo1UnsignedBytes(user->LapGain, data, &byteindex, 0.5f, 72.85714285714286f);

    // AGC histogram saturation
    // Range of AgcSaturation is 0.0 to 0.1.
    float32ScaledTo1UnsignedBytes(user->AgcSaturation, data, &byteindex, 0.0f, 2550.0f);

    // Set to 1 to use NUC table presets, default is 0
    uint8ToBytes(user->UseNucTablePresets, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionZafiroSettingsPacketID());
}

/*!
 * \brief Decode the OrionZafiroSettings packet
 *
 * Zafiro-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionZafiroSettingsPacketStructure(const void* pkt, OrionZafiroSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionZafiroSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionZafiroSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->UseNucTablePresets = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Zafiro camera.
    user->Index = uint8FromBytes(data, &byteindex);

    // Image polarity setting - set to 0 for white hot or 1 for black hot
    user->BlackHot = uint8FromBytes(data, &byteindex);

    // Integration time, in milliseconds
    // Range of IntegrationTime is 1.0 to 30.0.
    user->IntegrationTime = float32ScaledFrom1UnsignedBytes(data, &byteindex, 1.0f, 1.0f/8.793103448275861f);

    // Local Area Processing (LAP) enable/disable flag. Set to zero to disable, or non-zero to enable.
    user->LapEnabled = uint8FromBytes(data, &byteindex);

    // LAP Sharpening gain
    // Range of LapGain is 0.5 to 4.0.
    user->LapGain = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.5f, 1.0f/72.85714285714286f);

    // AGC histogram saturation
    // Range of AgcSaturation is 0.0 to 0.1.
    user->AgcSaturation = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/2550.0f);

    // Set to 1 to use NUC table presets, default is 0
    if(byteindex + 1 > numBytes)
        return 1;

    user->UseNucTablePresets = uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionHitachiSettings packet
 *
 * Hitachi-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionHitachiSettingsPacketStructure(void* pkt, const OrionHitachiSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Hitachi camera.
    uint8ToBytes(user->Index, data, &byteindex);

    // Integration time in microseconds, or negative to disable shutter-priority mode
    int16ToBeBytes(user->IntegrationTime, data, &byteindex);

    // Aperture f-number, or negative to disable aperture-priority mode
    // Range of Aperture is -3276.7 to 3276.7.
    float32ScaledTo2SignedBeBytes(user->Aperture, data, &byteindex, 10.0f);

    // Sharpening filter strength
    // Range of Sharpness is 0.0 to 5.0.
    float32ScaledTo1UnsignedBytes(user->Sharpness, data, &byteindex, 0.0f, 51.0f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionHitachiSettingsPacketID());
}

/*!
 * \brief Decode the OrionHitachiSettings packet
 *
 * Hitachi-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionHitachiSettingsPacketStructure(const void* pkt, OrionHitachiSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionHitachiSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionHitachiSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->Sharpness = 1;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Hitachi camera.
    user->Index = uint8FromBytes(data, &byteindex);

    // Integration time in microseconds, or negative to disable shutter-priority mode
    user->IntegrationTime = int16FromBeBytes(data, &byteindex);

    // Aperture f-number, or negative to disable aperture-priority mode
    // Range of Aperture is -3276.7 to 3276.7.
    user->Aperture = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10.0f);

    // Sharpening filter strength
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of Sharpness is 0.0 to 5.0.
    user->Sharpness = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/51.0f);

    return 1;
}

/*!
 * \brief Create the OrionSonySettings packet
 *
 * Sony-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionSonySettingsPacketStructure(void* pkt, const OrionSonySettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Sony camera.
    uint8ToBytes(user->Index, data, &byteindex);

    // Minimum exposure time in milliseconds
    // Range of MinExposure is 0.05 to 33.0.
    float32ScaledTo2UnsignedBeBytes(user->MinExposure, data, &byteindex, 0.05f, 1988.922610015174f);

    // Maximum exposure time in milliseconds
    // Range of MaxExposure is 0.05 to 33.0.
    float32ScaledTo2UnsignedBeBytes(user->MaxExposure, data, &byteindex, 0.05f, 1988.922610015174f);

    // Minimum sensor luminance gain, in dB
    uint8ToBytes(user->MinGain, data, &byteindex);

    // Maximum sensor luminance gain, in dB
    uint8ToBytes(user->MaxGain, data, &byteindex);

    // Brightness target, from 0 to 255
    uint8ToBytes(user->Brightness, data, &byteindex);

    // Contrast adjustment
    // Range of Contrast is -1.0 to 1.0.
    float32ScaledTo1SignedBytes(user->Contrast, data, &byteindex, 127.0f);

    // Saturation adjustment
    // Range of Saturation is -1.0 to 1.0.
    float32ScaledTo1SignedBytes(user->Saturation, data, &byteindex, 127.0f);

    // Sharpening filter strength
    // Range of Sharpness is 0.0 to 5.0.
    float32ScaledTo1UnsignedBytes(user->Sharpness, data, &byteindex, 0.0f, 51.0f);

    // Camera frame rate, in Hertz
    // Range of FrameRate is 0.0 to 30.0.
    float32ScaledTo1UnsignedBytes(user->FrameRate, data, &byteindex, 0.0f, 8.5f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionSonySettingsPacketID());
}

/*!
 * \brief Decode the OrionSonySettings packet
 *
 * Sony-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionSonySettingsPacketStructure(const void* pkt, OrionSonySettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionSonySettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionSonySettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected Sony camera.
    user->Index = uint8FromBytes(data, &byteindex);

    // Minimum exposure time in milliseconds
    // Range of MinExposure is 0.05 to 33.0.
    user->MinExposure = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.05f, 1.0f/1988.922610015174f);

    // Maximum exposure time in milliseconds
    // Range of MaxExposure is 0.05 to 33.0.
    user->MaxExposure = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.05f, 1.0f/1988.922610015174f);

    // Minimum sensor luminance gain, in dB
    user->MinGain = uint8FromBytes(data, &byteindex);

    // Maximum sensor luminance gain, in dB
    user->MaxGain = uint8FromBytes(data, &byteindex);

    // Brightness target, from 0 to 255
    user->Brightness = uint8FromBytes(data, &byteindex);

    // Contrast adjustment
    // Range of Contrast is -1.0 to 1.0.
    user->Contrast = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/127.0f);

    // Saturation adjustment
    // Range of Saturation is -1.0 to 1.0.
    user->Saturation = float32ScaledFrom1SignedBytes(data, &byteindex, 1.0f/127.0f);

    // Sharpening filter strength
    // Range of Sharpness is 0.0 to 5.0.
    user->Sharpness = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/51.0f);

    // Camera frame rate, in Hertz
    // Range of FrameRate is 0.0 to 30.0.
    user->FrameRate = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/8.5f);

    return 1;
}

/*!
 * \brief Create the OrionKtncSettings packet
 *
 * KTnC-specific camera settings.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionKtncSettingsPacketStructure(void* pkt, const OrionKtncSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected KTnC camera.
    uint8ToBytes(user->Index, data, &byteindex);

    // Integration time in microseconds, or negative to disable shutter-priority mode
    int16ToBeBytes(user->IntegrationTime, data, &byteindex);

    // Aperture f-number, or negative to disable aperture-priority mode
    // Range of Aperture is -3276.7 to 3276.7.
    float32ScaledTo2SignedBeBytes(user->Aperture, data, &byteindex, 10.0f);

    // Sharpening adjustment
    // Range of Sharpness is 0.0 to 16.0.
    float32ScaledTo1UnsignedBytes((float)user->Sharpness, data, &byteindex, 0.0f, 15.9375f);

    // Set to non-zero to vertically flip the video
    uint8ToBytes(user->VerticalFlip, data, &byteindex);

    // Exposure compenstation adjustment
    // Range of ExposureComp is 0.0 to 14.0.
    float32ScaledTo1UnsignedBytes((float)user->ExposureComp, data, &byteindex, 0.0f, 18.21428571428572f);

    // Contrast adjustment
    // Range of Contrast is 0.0 to 32.0.
    float32ScaledTo1UnsignedBytes((float)user->Contrast, data, &byteindex, 0.0f, 7.96875f);

    // Saturation adjustment
    // Range of Saturation is 0.0 to 32.0.
    float32ScaledTo1UnsignedBytes((float)user->Saturation, data, &byteindex, 0.0f, 7.96875f);

    // Night mode enable
    data[byteindex] = (uint8_t)user->NightMode << 7;

    // Reset to defaults
    data[byteindex] |= (uint8_t)user->ResetToDefaults << 6;
    byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionKtncSettingsPacketID());
}

/*!
 * \brief Decode the OrionKtncSettings packet
 *
 * KTnC-specific camera settings.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionKtncSettingsPacketStructure(const void* pkt, OrionKtncSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionKtncSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionKtncSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->Sharpness = 8;
    user->VerticalFlip = 0;
    user->ExposureComp = 7;
    user->Contrast = 8;
    user->Saturation = 14;
    user->NightMode = 0;
    user->ResetToDefaults = 0;

    // Index of the camera that these settings should apply to. Use 0xFF to apply to any connected KTnC camera.
    user->Index = uint8FromBytes(data, &byteindex);

    // Integration time in microseconds, or negative to disable shutter-priority mode
    user->IntegrationTime = int16FromBeBytes(data, &byteindex);

    // Aperture f-number, or negative to disable aperture-priority mode
    // Range of Aperture is -3276.7 to 3276.7.
    user->Aperture = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10.0f);

    // Sharpening adjustment
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of Sharpness is 0.0 to 16.0.
    user->Sharpness = (uint8_t)float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/15.9375f);

    // Set to non-zero to vertically flip the video
    if(byteindex + 1 > numBytes)
        return 1;

    user->VerticalFlip = uint8FromBytes(data, &byteindex);

    // Exposure compenstation adjustment
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of ExposureComp is 0.0 to 14.0.
    user->ExposureComp = (uint8_t)float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/18.21428571428572f);

    // Contrast adjustment
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of Contrast is 0.0 to 32.0.
    user->Contrast = (uint8_t)float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/7.96875f);

    // Saturation adjustment
    if(byteindex + 1 > numBytes)
        return 1;

    // Range of Saturation is 0.0 to 32.0.
    user->Saturation = (uint8_t)float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/7.96875f);

    if(byteindex + 1 > numBytes)
        return 1;

    // Night mode enable
    user->NightMode = (data[byteindex] >> 7);

    // Reset to defaults
    user->ResetToDefaults = ((data[byteindex] >> 6) & 0x1);
    byteindex += 1; // close bit field

    return 1;
}

/*!
 * \brief Create the OrionRetractCommand packet
 *
 * Retract or deploy command for a gimbal retraction mechanism.
 * \param pkt points to the packet which will be created by this function
 * \param Cmd is The retraction mechanism command
 */
void encodeOrionRetractCommandPacket(void* pkt, OrionRetractCmd_t Cmd)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // The retraction mechanism command
    uint8ToBytes(Cmd, data, &byteindex);

    // Reserved for future use
    uint8ToBytes((uint8_t)(0), data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionRetractCommandPacketID());
}

/*!
 * \brief Decode the OrionRetractCommand packet
 *
 * Retract or deploy command for a gimbal retraction mechanism.
 * \param pkt points to the packet being decoded by this function
 * \param Cmd receives The retraction mechanism command
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionRetractCommandPacket(const void* pkt, OrionRetractCmd_t* Cmd)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionRetractCommandPacketID())
        return 0;

    if(numBytes < getOrionRetractCommandMinDataLength())
        return 0;

    // The retraction mechanism command
    *Cmd = (OrionRetractCmd_t)uint8FromBytes(data, &byteindex);

    // Reserved for future use
    byteindex += 1;

    return 1;
}

/*!
 * \brief Create the OrionUserData packet
 *
 * This packet can be used to transfer user-defined data payloads between
 * communication ports on the gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionUserDataPacketStructure(void* pkt, const OrionUserData_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Destination crown board communication port identifier
    uint8ToBytes(user->port, data, &byteindex);

    // User data array size in bytes
    uint8ToBytes(user->size, data, &byteindex);

    // User-defined unique identifier or sequence number for this data block
    uint32ToBeBytes(user->id, data, &byteindex);

    // User data byte array
    for(i = 0; i < (int)user->size && i < 128; i++)
        uint8ToBytes(user->data[i], data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionUserDataPacketID());
}

/*!
 * \brief Decode the OrionUserData packet
 *
 * This packet can be used to transfer user-defined data payloads between
 * communication ports on the gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionUserDataPacketStructure(const void* pkt, OrionUserData_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionUserDataPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionUserDataMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Destination crown board communication port identifier
    user->port = (UserDataPort_t)uint8FromBytes(data, &byteindex);

    // User data array size in bytes
    user->size = uint8FromBytes(data, &byteindex);

    // User-defined unique identifier or sequence number for this data block
    user->id = uint32FromBeBytes(data, &byteindex);

    // User data byte array
    for(i = 0; i < (int)user->size && i < 128; i++)
        user->data[i] = uint8FromBytes(data, &byteindex);

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionLaserCommand packet
 *
 * Command to fire the laser (if installed).
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionLaserCommandPacketStructure(void* pkt, const OrionLaserCommand_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Deprecated parameter - set to zero
    uint16ToBeBytes((uint16_t)(0), data, &byteindex);

    // Index of the laser to apply this command to
    uint8ToBytes(user->Index, data, &byteindex);

    // Password, if required by the laser. If a password is required, it must be provided in order to change any aspect of the laser's state (e.g., enable/disable, arm/disarm, fire/deactivate
    stringToBytes(user->Password, data, &byteindex, 16, 0);

    // Set to zero to disable the laser, or non-zero to enable it
    uint8ToBytes(user->Enable, data, &byteindex);

    // Set to zero to disarm the laser, or non-zero to arm
    uint8ToBytes(user->Arm, data, &byteindex);

    // Set to zero to deactivate the laser, or non-zero to activate it
    uint8ToBytes(user->Fire, data, &byteindex);

    // Periodic laser pulse on time, in milliseconds, or zero to fire continuously
    uint16ToBeBytes(user->OnTime, data, &byteindex);

    // Periodic laser pulse off time, in milliseconds, or zero to fire continuously
    uint16ToBeBytes(user->OffTime, data, &byteindex);

    // Laser PRF code, if applicable
    uint16ToBeBytes(user->PrfCode, data, &byteindex);

    // Set to a non-zero value to bypass all laser safety checks
    uint8ToBytes(user->SafetyBypass, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionLaserCommandPacketID());
}

/*!
 * \brief Decode the OrionLaserCommand packet
 *
 * Command to fire the laser (if installed).
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionLaserCommandPacketStructure(const void* pkt, OrionLaserCommand_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionLaserCommandPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionLaserCommandMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->PrfCode = 0;
    user->SafetyBypass = 0;

    // Deprecated parameter - set to zero
    byteindex += 2;

    // Index of the laser to apply this command to
    user->Index = uint8FromBytes(data, &byteindex);

    // Password, if required by the laser. If a password is required, it must be provided in order to change any aspect of the laser's state (e.g., enable/disable, arm/disarm, fire/deactivate
    stringFromBytes(user->Password, data, &byteindex, 16, 0);

    // Set to zero to disable the laser, or non-zero to enable it
    user->Enable = uint8FromBytes(data, &byteindex);

    // Set to zero to disarm the laser, or non-zero to arm
    user->Arm = uint8FromBytes(data, &byteindex);

    // Set to zero to deactivate the laser, or non-zero to activate it
    user->Fire = uint8FromBytes(data, &byteindex);

    // Periodic laser pulse on time, in milliseconds, or zero to fire continuously
    user->OnTime = uint16FromBeBytes(data, &byteindex);

    // Periodic laser pulse off time, in milliseconds, or zero to fire continuously
    user->OffTime = uint16FromBeBytes(data, &byteindex);

    // Laser PRF code, if applicable
    if(byteindex + 2 > numBytes)
        return 1;

    user->PrfCode = uint16FromBeBytes(data, &byteindex);

    // Set to a non-zero value to bypass all laser safety checks
    if(byteindex + 1 > numBytes)
        return 1;

    user->SafetyBypass = uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionLaserStates packet
 *
 * Information about the current state of lasers installed in the gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionLaserStatesPacketStructure(void* pkt, const OrionLaserStates_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Number of installed lasers
    uint8ToBytes(user->NumLasers, data, &byteindex);

    for(i = 0; i < (int)user->NumLasers && i < MAX_LASERS; i++)
        encodeOrionLaserState_t(data, &byteindex, &user->State[i]);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionLaserStatesPacketID());
}

/*!
 * \brief Decode the OrionLaserStates packet
 *
 * Information about the current state of lasers installed in the gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionLaserStatesPacketStructure(const void* pkt, OrionLaserStates_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionLaserStatesPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionLaserStatesMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Number of installed lasers
    user->NumLasers = uint8FromBytes(data, &byteindex);

    for(i = 0; i < (int)user->NumLasers && i < MAX_LASERS; i++)
    {
        if(decodeOrionLaserState_t(data, &byteindex, &user->State[i]) == 0)
            return 0;
    }

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionUartConfig packet
 *
 * This packet is used to change or request the baud rate and protocol of a UART
 * on the crown board. Send this packet with zero bytes to request the
 * configuration of the port that receives the request, or with 1 byte to
 * request the configuration of a specific port. Not all port configuration
 * options are available, the ethernet port must run the PROTOCOL_ORION protocol
 * at either 115200 or 230400 bits per second. In general users should not
 * change the ethernet port setup. In addition the PROTOCOL_UBLOX_GPS is not
 * supported on any user configurable port, it is included in the protocol list
 * only for completeness.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionUartConfigPacketStructure(void* pkt, const OrionUartConfig_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // The port whose configuration should be changed or requested, use USER_DATA_PORT_CURRENT to indicate the port which received this packet
    uint8ToBytes(user->port, data, &byteindex);

    // Baud rate bits per second. Use 0 to select the default baud rate for this port and protocol.
    uint24ToBeBytes((uint32_t)(user->baud), data, &byteindex);

    // The protocol to use for this port. If PROTOCOL_NO_CHANGE or PROTOCOL_DEFAULT are used the reply to this packet will contain the actual protocol in use
    uint8ToBytes(user->protocol, data, &byteindex);

    // A value of 0 indicates that the settings should persist across power cycles. Non-zero values will cause the new setting to be lost after power cycle
    uint8ToBytes(user->temporary, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionUartConfigPacketID());
}

/*!
 * \brief Decode the OrionUartConfig packet
 *
 * This packet is used to change or request the baud rate and protocol of a UART
 * on the crown board. Send this packet with zero bytes to request the
 * configuration of the port that receives the request, or with 1 byte to
 * request the configuration of a specific port. Not all port configuration
 * options are available, the ethernet port must run the PROTOCOL_ORION protocol
 * at either 115200 or 230400 bits per second. In general users should not
 * change the ethernet port setup. In addition the PROTOCOL_UBLOX_GPS is not
 * supported on any user configurable port, it is included in the protocol list
 * only for completeness.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionUartConfigPacketStructure(const void* pkt, OrionUartConfig_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionUartConfigPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionUartConfigMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->temporary = 0;

    // The port whose configuration should be changed or requested, use USER_DATA_PORT_CURRENT to indicate the port which received this packet
    user->port = (UserDataPort_t)uint8FromBytes(data, &byteindex);

    // Baud rate bits per second. Use 0 to select the default baud rate for this port and protocol.
    user->baud = (uint32_t)uint24FromBeBytes(data, &byteindex);

    // The protocol to use for this port. If PROTOCOL_NO_CHANGE or PROTOCOL_DEFAULT are used the reply to this packet will contain the actual protocol in use
    user->protocol = (OrionProtocols_t)uint8FromBytes(data, &byteindex);

    // A value of 0 indicates that the settings should persist across power cycles. Non-zero values will cause the new setting to be lost after power cycle
    if(byteindex + 1 > numBytes)
        return 1;

    user->temporary = uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionLimitsData packet
 *
 * Gimbal limits of operation. This includes the max and min pan and tilt
 * angles, as well as the angular rate and the maximum current consumption.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionLimitsDataPacketStructure(void* pkt, const OrionLimitsData_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Minimum position in radians
    // Range of MinPos is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->MinPos[i], data, &byteindex, 1000.0f);

    // Maximum position in radians
    // Range of MaxPos is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->MaxPos[i], data, &byteindex, 1000.0f);

    // Maximum velocity in radians per second
    // Range of MaxVel is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->MaxVel[i], data, &byteindex, 0.0f, 1000.0f);

    // Maximum acceleration in radians per second per second
    // Range of MaxAccel is 0.0 to 65535.0.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->MaxAccel[i], data, &byteindex, 0.0f, 1.0f);

    // Maximum continuous current in Amps
    // Range of ContCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->ContCur[i], data, &byteindex, 0.0f, 1000.0f);

    // Maximum peak current in Amps
    // Range of PeakCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->PeakCur[i], data, &byteindex, 0.0f, 1000.0f);

    // Peak current time in seconds
    // Range of PeakCurTime is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->PeakCurTime[i], data, &byteindex, 0.0f, 1000.0f);

    // Initialization current in Amps
    // Range of InitCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2UnsignedBeBytes(user->InitCur[i], data, &byteindex, 0.0f, 1000.0f);

    // Maximum motor output power, in watts. Set to zero for no limit
    // Range of MaxPower is 0.0 to 255.0.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo1UnsignedBytes(user->MaxPower[i], data, &byteindex, 0.0f, 1.0f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionLimitsDataPacketID());
}

/*!
 * \brief Decode the OrionLimitsData packet
 *
 * Gimbal limits of operation. This includes the max and min pan and tilt
 * angles, as well as the angular rate and the maximum current consumption.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionLimitsDataPacketStructure(const void* pkt, OrionLimitsData_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionLimitsDataPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionLimitsDataMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MaxPower[i] = 0;

    // Minimum position in radians
    // Range of MinPos is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MinPos[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Maximum position in radians
    // Range of MaxPos is -32.767 to 32.767.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MaxPos[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Maximum velocity in radians per second
    // Range of MaxVel is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MaxVel[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Maximum acceleration in radians per second per second
    // Range of MaxAccel is 0.0 to 65535.0.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MaxAccel[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1.0f);

    // Maximum continuous current in Amps
    // Range of ContCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->ContCur[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Maximum peak current in Amps
    // Range of PeakCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->PeakCur[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Peak current time in seconds
    // Range of PeakCurTime is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->PeakCurTime[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Initialization current in Amps
    // Range of InitCur is 0.0 to 65.535.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->InitCur[i] = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Maximum motor output power, in watts. Set to zero for no limit
    if(byteindex + 1*NUM_GIMBAL_AXES > numBytes)
        return 1;

    // Range of MaxPower is 0.0 to 255.0.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->MaxPower[i] = float32ScaledFrom1UnsignedBytes(data, &byteindex, 0.0f, 1.0f/1.0f);

    return 1;
}

/*!
 * \brief Create the InsOptions packet
 *
 * INS options give configuration options for the inertial navigation system
 * (INS) in the gunbal. Changing the INS options will cause the INS to be
 * restarted if the platform rotation changes. When using platform rotation note
 * the order: First yaw about the gimbal's z-axis to create an intermediate
 * axis. Then pitch about the intermediate y-axis to create a second
 * intermediate axis. Finally roll about the second intermediate x-axis to reach
 * the platform orientation. When using an IMU in the payload ball the
 * enablePlatformRotation can still be used, but will only effect heading
 * observations and the GPS lever arm, it will not rotate the IMU data.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeInsOptionsPacketStructure(void* pkt, const InsOptions_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    unsigned int tempbitfield = 0;
    int i = 0;

    // The INS will be run in the platform reference frame if this is set. The platform reference frame is defined by the rotation from the gimbal reference frame to the platform frame. Set this if the gimbal is installed such that the gimbal reference frame is often near pitch of +/- 90 degrees.
    data[byteindex] = (uint8_t)user->enablePlatformRotation << 7;

    // If set then the INS will use the course of the GPS as a heading input for initialization and heading updates when the heading confidence is poor. This is appropriate for fixed wing aircraft if enablePlatformRotation is set (or if the gimbal native axis is aligned with the aircraft axis).
    data[byteindex] |= (uint8_t)user->enableCourseIsHeading << 6;

    // If set then the INS will ignore any magnetometer measurements.
    data[byteindex] |= (uint8_t)user->disableMagnetometer << 5;

    // If set then the INS will ignore any GPS measurements.
    data[byteindex] |= (uint8_t)user->disableGPS << 4;

    // If set then the INS will be reset, all other fields of this packet are ignored in that case.
    data[byteindex] |= (uint8_t)user->resetINS << 3;

    // Set this to disable clock error estimation for tightly coupled INS.
    data[byteindex] |= (uint8_t)user->disableGpsClockError << 2;

    // Set this to enable accelerometer bias estimation.
    data[byteindex] |= (uint8_t)user->enableAccelBias << 1;

    // Set this to enable the tightly coupled INS.
    data[byteindex] |= (uint8_t)user->enableTightlyCoupled;

    // If set the INS will use the carrier phase rate for tightly coupled velocity observations. Otherwise the tightly coupled velocity observations come from doppler shifts.
    data[byteindex + 1] = (uint8_t)user->usePhaseForVelocity << 7;

    // If set the INS will ignore L1 band for tightly coupled observations.
    data[byteindex + 1] |= (uint8_t)user->disableL1 << 6;

    // If set the INS will ignore the L2 band for tightly coupled observations.
    data[byteindex + 1] |= (uint8_t)user->disableL2 << 5;

    // If set the INS will ignore the L5 band for tightly coupled observations.
    data[byteindex + 1] |= (uint8_t)user->disableL5 << 4;

    // Elevation mask for tightly coupled satellites
    // Range of elevationMask is 0.0 to 0.08726646259971647.
    tempbitfield = float32ScaledToBitfield((float)user->elevationMask, 0.0f, 171.887338539247f);
    if(tempbitfield > 15)
        tempbitfield = 15;

    data[byteindex + 1] |= (uint8_t)tempbitfield;

    // If set the IMU inputs to the INS are coming from the payload ball, not the gimbal crown. Note that enablePlatformRotation is interpreted differently in that case
    data[byteindex + 2] = (uint8_t)user->enablePayloadIns << 7;

    // If set then the INS will attempt to observe the heading use nonlinear methods. This may be helpful for hovering vehicles that do not have any other heading observation.
    data[byteindex + 2] |= (uint8_t)user->enableNonLinearHeading << 6;

    // If set, and if enablePayloadIns is set, the Sensonor IMU inputs to the INS are coming from the payload ball in the HD80MV orientation.
    data[byteindex + 2] |= (uint8_t)user->enableSensonorMV << 5;

    // If set, and if enablePayloadIns is set, the IMU inputs to the INS are coming from the payload ball in the HD25 special orientation.
    data[byteindex + 2] |= (uint8_t)user->enableHD25PayloadINS << 4;

    // Non-zero to enable optical flow.
    data[byteindex + 2] |= (uint8_t)user->opticalFlowSetting;

    // reserved space for future expansion
    data[byteindex + 3] = 0;
    byteindex += 4; // close bit field

    // Roll, Pitch, Yaw angles in radians from -pi to pi. The angles give the Euler rotation (yaw first, then pitch, then roll) from the platform reference frame into the gimbal reference frame.
    // Range of gimbalToPlatformEuler is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->gimbalToPlatformEuler[i], data, &byteindex, 10430.06004058427f);

    // Initial heading angle in radians for the INS
    // Range of initialHeading is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->initialHeading, data, &byteindex, 10430.06004058427f);

    // X, Y, Z meters from first (primary) GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on
    // Range of gpsLeverArm is -32.767 to 32.767.
    for(i = 0; i < 3; i++)
        float32ScaledTo2SignedBeBytes(user->gpsLeverArm[i], data, &byteindex, 1000.0f);

    // For external heading observations (including magnetometer) subtract this angle in radians from the heading observation to get the heading in INS or platform frame
    // Range of headingObservationBiasAngle is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(user->headingObservationBiasAngle, data, &byteindex, 10430.06004058427f);

    // X, Y, Z meters from second GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on. This only applies if Novatel Align data are being received.
    // Range of secondGPSLeverArm is -32.767 to 32.767.
    for(i = 0; i < 3; i++)
        float32ScaledTo2SignedBeBytes(user->secondGPSLeverArm[i], data, &byteindex, 1000.0f);

    // Sensor noise in radians for align heading observation. Use zero for the default sensor noise from the Align hardware.
    // Range of alignHeadingNoise is 0.0 to 3.141592653589793.
    float32ScaledTo2UnsignedBeBytes(user->alignHeadingNoise, data, &byteindex, 0.0f, 20860.43839105472f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getInsOptionsPacketID());
}

/*!
 * \brief Decode the InsOptions packet
 *
 * INS options give configuration options for the inertial navigation system
 * (INS) in the gunbal. Changing the INS options will cause the INS to be
 * restarted if the platform rotation changes. When using platform rotation note
 * the order: First yaw about the gimbal's z-axis to create an intermediate
 * axis. Then pitch about the intermediate y-axis to create a second
 * intermediate axis. Finally roll about the second intermediate x-axis to reach
 * the platform orientation. When using an IMU in the payload ball the
 * enablePlatformRotation can still be used, but will only effect heading
 * observations and the GPS lever arm, it will not rotate the IMU data.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeInsOptionsPacketStructure(const void* pkt, InsOptions_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    unsigned int tempbitfield = 0;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getInsOptionsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getInsOptionsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    for(i = 0; i < 3; i++)
        user->gpsLeverArm[i] = 0;
    user->headingObservationBiasAngle = 0;
    for(i = 0; i < 3; i++)
        user->secondGPSLeverArm[i] = 0;
    user->alignHeadingNoise = 0;

    // The INS will be run in the platform reference frame if this is set. The platform reference frame is defined by the rotation from the gimbal reference frame to the platform frame. Set this if the gimbal is installed such that the gimbal reference frame is often near pitch of +/- 90 degrees.
    user->enablePlatformRotation = (data[byteindex] >> 7);

    // If set then the INS will use the course of the GPS as a heading input for initialization and heading updates when the heading confidence is poor. This is appropriate for fixed wing aircraft if enablePlatformRotation is set (or if the gimbal native axis is aligned with the aircraft axis).
    user->enableCourseIsHeading = ((data[byteindex] >> 6) & 0x1);

    // If set then the INS will ignore any magnetometer measurements.
    user->disableMagnetometer = ((data[byteindex] >> 5) & 0x1);

    // If set then the INS will ignore any GPS measurements.
    user->disableGPS = ((data[byteindex] >> 4) & 0x1);

    // If set then the INS will be reset, all other fields of this packet are ignored in that case.
    user->resetINS = ((data[byteindex] >> 3) & 0x1);

    // Set this to disable clock error estimation for tightly coupled INS.
    user->disableGpsClockError = ((data[byteindex] >> 2) & 0x1);

    // Set this to enable accelerometer bias estimation.
    user->enableAccelBias = ((data[byteindex] >> 1) & 0x1);

    // Set this to enable the tightly coupled INS.
    user->enableTightlyCoupled = ((data[byteindex]) & 0x1);

    // If set the INS will use the carrier phase rate for tightly coupled velocity observations. Otherwise the tightly coupled velocity observations come from doppler shifts.
    user->usePhaseForVelocity = (data[byteindex + 1] >> 7);

    // If set the INS will ignore L1 band for tightly coupled observations.
    user->disableL1 = ((data[byteindex + 1] >> 6) & 0x1);

    // If set the INS will ignore the L2 band for tightly coupled observations.
    user->disableL2 = ((data[byteindex + 1] >> 5) & 0x1);

    // If set the INS will ignore the L5 band for tightly coupled observations.
    user->disableL5 = ((data[byteindex + 1] >> 4) & 0x1);

    // Elevation mask for tightly coupled satellites
    // Range of elevationMask is 0.0 to 0.08726646259971647.
    tempbitfield = ((data[byteindex + 1]) & 0xF);
    user->elevationMask = float32ScaledFromBitfield(tempbitfield, 0.0f, 1.0f/171.887338539247f);

    // If set the IMU inputs to the INS are coming from the payload ball, not the gimbal crown. Note that enablePlatformRotation is interpreted differently in that case
    user->enablePayloadIns = (data[byteindex + 2] >> 7);

    // If set then the INS will attempt to observe the heading use nonlinear methods. This may be helpful for hovering vehicles that do not have any other heading observation.
    user->enableNonLinearHeading = ((data[byteindex + 2] >> 6) & 0x1);

    // If set, and if enablePayloadIns is set, the Sensonor IMU inputs to the INS are coming from the payload ball in the HD80MV orientation.
    user->enableSensonorMV = ((data[byteindex + 2] >> 5) & 0x1);

    // If set, and if enablePayloadIns is set, the IMU inputs to the INS are coming from the payload ball in the HD25 special orientation.
    user->enableHD25PayloadINS = ((data[byteindex + 2] >> 4) & 0x1);

    // Non-zero to enable optical flow.
    user->opticalFlowSetting = ((data[byteindex + 2]) & 0xF);

    // reserved space for future expansion
    byteindex += 4; // close bit field

    // Roll, Pitch, Yaw angles in radians from -pi to pi. The angles give the Euler rotation (yaw first, then pitch, then roll) from the platform reference frame into the gimbal reference frame.
    // Range of gimbalToPlatformEuler is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_AXES; i++)
        user->gimbalToPlatformEuler[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Initial heading angle in radians for the INS
    // Range of initialHeading is -3.141592653589793 to 3.141592653589793.
    user->initialHeading = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // X, Y, Z meters from first (primary) GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on
    if(byteindex + 2*3 > numBytes)
        return 1;

    // Range of gpsLeverArm is -32.767 to 32.767.
    for(i = 0; i < 3; i++)
        user->gpsLeverArm[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // For external heading observations (including magnetometer) subtract this angle in radians from the heading observation to get the heading in INS or platform frame
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of headingObservationBiasAngle is -3.141592653589793 to 3.141592653589793.
    user->headingObservationBiasAngle = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // X, Y, Z meters from second GPS antenna to IMU in the gimbal reference frame, or the platform reference frame if enablePlatformRotation is on. This only applies if Novatel Align data are being received.
    if(byteindex + 2*3 > numBytes)
        return 1;

    // Range of secondGPSLeverArm is -32.767 to 32.767.
    for(i = 0; i < 3; i++)
        user->secondGPSLeverArm[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/1000.0f);

    // Sensor noise in radians for align heading observation. Use zero for the default sensor noise from the Align hardware.
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of alignHeadingNoise is 0.0 to 3.141592653589793.
    user->alignHeadingNoise = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/20860.43839105472f);

    return 1;
}

/*!
 * \brief Create the OrionNetworkSettings packet
 *
 * Change the IP network settings in the gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionNetworkSettingsPacketStructure(void* pkt, const OrionNetworkSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // IPv4 address
    uint32ToBeBytes(user->Ip, data, &byteindex);

    // IPv4 network mask
    uint32ToBeBytes(user->Mask, data, &byteindex);

    // IPv4 gateway address
    uint32ToBeBytes(user->Gateway, data, &byteindex);

    // Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    uint8ToBytes(user->LowDelay, data, &byteindex);

    // Ethernet MTU size, set to zero for hardware default
    uint16ToBeBytes(user->Mtu, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionNetworkSettingsPacketID());
}

/*!
 * \brief Decode the OrionNetworkSettings packet
 *
 * Change the IP network settings in the gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionNetworkSettingsPacketStructure(const void* pkt, OrionNetworkSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionNetworkSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionNetworkSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->LowDelay = 0;
    user->Mtu = 0;

    // IPv4 address
    user->Ip = uint32FromBeBytes(data, &byteindex);

    // IPv4 network mask
    user->Mask = uint32FromBeBytes(data, &byteindex);

    // IPv4 gateway address
    user->Gateway = uint32FromBeBytes(data, &byteindex);

    // Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    if(byteindex + 1 > numBytes)
        return 1;

    user->LowDelay = uint8FromBytes(data, &byteindex);

    // Ethernet MTU size, set to zero for hardware default
    if(byteindex + 2 > numBytes)
        return 1;

    user->Mtu = uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionNetworkByteSettings packet
 *
 * Change the IP network settings in the gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionNetworkByteSettingsPacketStructure(void* pkt, const OrionNetworkByteSettings_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // IPv4 address
    for(i = 0; i < 4; i++)
        uint8ToBytes(user->Ip[i], data, &byteindex);

    // IPv4 network mask
    for(i = 0; i < 4; i++)
        uint8ToBytes(user->Mask[i], data, &byteindex);

    // IPv4 gateway address
    for(i = 0; i < 4; i++)
        uint8ToBytes(user->Gateway[i], data, &byteindex);

    // Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    uint8ToBytes(user->LowDelay, data, &byteindex);

    // Ethernet MTU size, set to zero for hardware default
    uint16ToBeBytes(user->Mtu, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionNetworkByteSettingsPacketID());
}

/*!
 * \brief Decode the OrionNetworkByteSettings packet
 *
 * Change the IP network settings in the gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionNetworkByteSettingsPacketStructure(const void* pkt, OrionNetworkByteSettings_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionNetworkByteSettingsPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionNetworkByteSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->LowDelay = 0;
    user->Mtu = 0;

    // IPv4 address
    for(i = 0; i < 4; i++)
        user->Ip[i] = uint8FromBytes(data, &byteindex);

    // IPv4 network mask
    for(i = 0; i < 4; i++)
        user->Mask[i] = uint8FromBytes(data, &byteindex);

    // IPv4 gateway address
    for(i = 0; i < 4; i++)
        user->Gateway[i] = uint8FromBytes(data, &byteindex);

    // Set to 1 to use low-delay TCP mode (i.e. disable Nagle's Algorithm).
    if(byteindex + 1 > numBytes)
        return 1;

    user->LowDelay = uint8FromBytes(data, &byteindex);

    // Ethernet MTU size, set to zero for hardware default
    if(byteindex + 2 > numBytes)
        return 1;

    user->Mtu = uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionNetworkVideo packet
 *
 * Change the IP settings for video delivery.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionNetworkVideoPacketStructure(void* pkt, const OrionNetworkVideo_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // destination IPv4 address
    uint32ToBeBytes(user->DestIp, data, &byteindex);

    // desitnation port
    uint16ToBeBytes(user->Port, data, &byteindex);

    // Video encoding target bitrate, in bits per second
    uint32ToBeBytes(user->Bitrate, data, &byteindex);

    // TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    int8ToBytes(user->Ttl, data, &byteindex);

    // Output stream format specifier
    uint8ToBytes(user->StreamType, data, &byteindex);

    // MJPEG quality value, from 10 to 95
    uint8ToBytes(user->MjpegQuality, data, &byteindex);

    // Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    data[byteindex] = (uint8_t)user->SaveSettings << 7;

    // Number of TS packets per UDP packet, or 0 for no change
    data[byteindex] |= (uint8_t)user->TsPacketCount << 3;
    byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionNetworkVideoPacketID());
}

/*!
 * \brief Decode the OrionNetworkVideo packet
 *
 * Change the IP settings for video delivery.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionNetworkVideoPacketStructure(const void* pkt, OrionNetworkVideo_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionNetworkVideoPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionNetworkVideoMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->Bitrate = 0;
    user->Ttl = -1;
    user->StreamType = STREAM_TYPE_H264;
    user->MjpegQuality = 30;
    user->SaveSettings = 0;
    user->TsPacketCount = 0;

    // destination IPv4 address
    user->DestIp = uint32FromBeBytes(data, &byteindex);

    // desitnation port
    user->Port = uint16FromBeBytes(data, &byteindex);

    // Video encoding target bitrate, in bits per second
    if(byteindex + 4 > numBytes)
        return 1;

    user->Bitrate = uint32FromBeBytes(data, &byteindex);

    // TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    if(byteindex + 1 > numBytes)
        return 1;

    user->Ttl = int8FromBytes(data, &byteindex);

    // Output stream format specifier
    if(byteindex + 1 > numBytes)
        return 1;

    user->StreamType = (StreamType_t)uint8FromBytes(data, &byteindex);

    // MJPEG quality value, from 10 to 95
    if(byteindex + 1 > numBytes)
        return 1;

    user->MjpegQuality = uint8FromBytes(data, &byteindex);

    if(byteindex + 1 > numBytes)
        return 1;

    // Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    user->SaveSettings = (data[byteindex] >> 7);

    // Number of TS packets per UDP packet, or 0 for no change
    user->TsPacketCount = ((data[byteindex] >> 3) & 0xF);
    byteindex += 1; // close bit field

    return 1;
}

/*!
 * \brief Create the OrionNetworkByteVideo packet
 *
 * Change the IP settings for video delivery.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionNetworkByteVideoPacketStructure(void* pkt, const OrionNetworkByteVideo_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // destination IPv4 address
    for(i = 0; i < 4; i++)
        uint8ToBytes(user->DestIp[i], data, &byteindex);

    // desitnation port
    uint16ToBeBytes(user->Port, data, &byteindex);

    // Video encoding target bitrate, in bits per second
    uint32ToBeBytes(user->Bitrate, data, &byteindex);

    // TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    int8ToBytes(user->Ttl, data, &byteindex);

    // Output stream format specifier
    uint8ToBytes(user->StreamType, data, &byteindex);

    // MJPEG quality value, from 10 to 95
    uint8ToBytes(user->MjpegQuality, data, &byteindex);

    // Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    data[byteindex] = (uint8_t)user->SaveSettings << 7;

    // Number of TS packets per UDP packet, or 0 for no change
    data[byteindex] |= (uint8_t)user->TsPacketCount << 3;
    byteindex += 1; // close bit field

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionNetworkByteVideoPacketID());
}

/*!
 * \brief Decode the OrionNetworkByteVideo packet
 *
 * Change the IP settings for video delivery.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionNetworkByteVideoPacketStructure(const void* pkt, OrionNetworkByteVideo_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionNetworkByteVideoPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionNetworkByteVideoMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->Bitrate = 0;
    user->Ttl = -1;
    user->StreamType = STREAM_TYPE_H264;
    user->MjpegQuality = 30;
    user->SaveSettings = 0;
    user->TsPacketCount = 0;

    // destination IPv4 address
    for(i = 0; i < 4; i++)
        user->DestIp[i] = uint8FromBytes(data, &byteindex);

    // desitnation port
    user->Port = uint16FromBeBytes(data, &byteindex);

    // Video encoding target bitrate, in bits per second
    if(byteindex + 4 > numBytes)
        return 1;

    user->Bitrate = uint32FromBeBytes(data, &byteindex);

    // TTL value for UDP video packets. Values less than or equal to zero will use default values of 64 for unicast and 1 for multicast.
    if(byteindex + 1 > numBytes)
        return 1;

    user->Ttl = int8FromBytes(data, &byteindex);

    // Output stream format specifier
    if(byteindex + 1 > numBytes)
        return 1;

    user->StreamType = (StreamType_t)uint8FromBytes(data, &byteindex);

    // MJPEG quality value, from 10 to 95
    if(byteindex + 1 > numBytes)
        return 1;

    user->MjpegQuality = uint8FromBytes(data, &byteindex);

    if(byteindex + 1 > numBytes)
        return 1;

    // Set to 1 to make h.264 settings non-volatile, or 0 to reset to defaults on startup
    user->SaveSettings = (data[byteindex] >> 7);

    // Number of TS packets per UDP packet, or 0 for no change
    user->TsPacketCount = ((data[byteindex] >> 3) & 0xF);
    byteindex += 1; // close bit field

    return 1;
}

//! Encode a OrionCamSettings_t structure into a byte array
void encodeOrionCamSettings_t(uint8_t* data, int* bytecount, const OrionCamSettings_t* user);

/*!
 * \brief Encode a OrionCamSettings_t structure into a byte array
 *
 * Camera settings information
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeOrionCamSettings_t(uint8_t* data, int* bytecount, const OrionCamSettings_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // The type of camera
    uint8ToBytes(user->Type, data, &byteindex);

    // The communications protocol of the camera
    uint8ToBytes(user->Proto, data, &byteindex);

    // Minimum focal length in millimeters
    // Range of MinFocalLength is 0.0 to 4294967.295.
    float32ScaledTo4UnsignedBeBytes(user->MinFocalLength, data, &byteindex, 0.0f, 1000.0f);

    // Minimum focal length in millimeters
    // Range of MaxFocalLength is 0.0 to 4294967.295.
    float32ScaledTo4UnsignedBeBytes(user->MaxFocalLength, data, &byteindex, 0.0f, 1000.0f);

    // Spacing of pixels in millimeters
    // Range of PixelPitch is 0.0 to 0.065535.
    float32ScaledTo2UnsignedBeBytes(user->PixelPitch, data, &byteindex, 0.0f, 1000000.0f);

    // Number of horizontal pixels in the focal plane array
    uint16ToBeBytes(user->ArrayWidth, data, &byteindex);

    // Number of vertical pixels in the focal plane array
    uint16ToBeBytes(user->ArrayHeight, data, &byteindex);

    // boresight alignment offsets in radians
    // Range of AlignMin is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->AlignMin[i], data, &byteindex, 10430.06004058427f);

    // boresight alignment offsets in radians
    // Range of AlignMax is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        float32ScaledTo2SignedBeBytes(user->AlignMax[i], data, &byteindex, 10430.06004058427f);

    *bytecount = byteindex;

}// encodeOrionCamSettings_t

//! Decode a OrionCamSettings_t structure from a byte array
int decodeOrionCamSettings_t(const uint8_t* data, int* bytecount, OrionCamSettings_t* user);

/*!
 * \brief Decode a OrionCamSettings_t structure from a byte array
 *
 * Camera settings information
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeOrionCamSettings_t(const uint8_t* data, int* bytecount, OrionCamSettings_t* user)
{
    int byteindex = *bytecount;
    int i = 0;

    // The type of camera
    user->Type = (OrionCameraType_t)uint8FromBytes(data, &byteindex);

    // The communications protocol of the camera
    user->Proto = (OrionCameraProtocol_t)uint8FromBytes(data, &byteindex);

    // Minimum focal length in millimeters
    // Range of MinFocalLength is 0.0 to 4294967.295.
    user->MinFocalLength = float32ScaledFrom4UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Minimum focal length in millimeters
    // Range of MaxFocalLength is 0.0 to 4294967.295.
    user->MaxFocalLength = float32ScaledFrom4UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000.0f);

    // Spacing of pixels in millimeters
    // Range of PixelPitch is 0.0 to 0.065535.
    user->PixelPitch = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/1000000.0f);

    // Number of horizontal pixels in the focal plane array
    user->ArrayWidth = uint16FromBeBytes(data, &byteindex);

    // Number of vertical pixels in the focal plane array
    user->ArrayHeight = uint16FromBeBytes(data, &byteindex);

    // boresight alignment offsets in radians
    // Range of AlignMin is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->AlignMin[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // boresight alignment offsets in radians
    // Range of AlignMax is -3.141592653589793 to 3.141592653589793.
    for(i = 0; i < NUM_GIMBAL_AXES; i++)
        user->AlignMax[i] = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    *bytecount = byteindex;

    return 1;

}// decodeOrionCamSettings_t

/*!
 * \brief Create the OrionCameras packet
 *
 * Camera definitions for the Orion gimbal
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionCamerasPacketStructure(void* pkt, const OrionCameras_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // The number of cameras installed
    uint8ToBytes(user->NumCameras, data, &byteindex);

    // Reserved space for future expansion
    for(i = 0; i < 3; i++)
        uint8ToBytes((uint8_t)(0), data, &byteindex);

    // Camera settings information
    for(i = 0; i < (int)user->NumCameras && i < NUM_CAMERAS; i++)
        encodeOrionCamSettings_t(data, &byteindex, &user->OrionCamSettings[i]);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionCamerasPacketID());
}

/*!
 * \brief Decode the OrionCameras packet
 *
 * Camera definitions for the Orion gimbal
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionCamerasPacketStructure(const void* pkt, OrionCameras_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;
    int i = 0;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionCamerasPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionCamerasMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // The number of cameras installed
    user->NumCameras = uint8FromBytes(data, &byteindex);

    // Reserved space for future expansion
    byteindex += 3;

    // Camera settings information
    for(i = 0; i < (int)user->NumCameras && i < NUM_CAMERAS; i++)
    {
        if(decodeOrionCamSettings_t(data, &byteindex, &user->OrionCamSettings[i]) == 0)
            return 0;
    }

    // Used variable length arrays or dependent fields, check actual length
    if(numBytes < byteindex)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionClevisVersion packet
 *
 * Software version for the clevis board in the Orion gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionClevisVersionPacketStructure(void* pkt, const OrionClevisVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the clevis board software
    stringToBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the clevis board
    stringToBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    uint32ToBeBytes(user->OnTime, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionClevisVersionPacketID());
}

/*!
 * \brief Decode the OrionClevisVersion packet
 *
 * Software version for the clevis board in the Orion gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionClevisVersionPacketStructure(const void* pkt, OrionClevisVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionClevisVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionClevisVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->OnTime = 0;

    // Version of the clevis board software
    stringFromBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the clevis board
    stringFromBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    if(byteindex + 4 > numBytes)
        return 1;

    user->OnTime = uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionCrownVersion packet
 *
 * Software version for the crown board in the Orion gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionCrownVersionPacketStructure(void* pkt, const OrionCrownVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the crown board software
    stringToBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the crown board
    stringToBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    uint32ToBeBytes(user->OnTime, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionCrownVersionPacketID());
}

/*!
 * \brief Decode the OrionCrownVersion packet
 *
 * Software version for the crown board in the Orion gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionCrownVersionPacketStructure(const void* pkt, OrionCrownVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionCrownVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionCrownVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->OnTime = 0;

    // Version of the crown board software
    stringFromBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the crown board
    stringFromBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    if(byteindex + 4 > numBytes)
        return 1;

    user->OnTime = uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionPayloadVersion packet
 *
 * Software version for the payload board in the Orion gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionPayloadVersionPacketStructure(void* pkt, const OrionPayloadVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the payload board software
    stringToBytes(user->Version, data, &byteindex, 24, 1);

    // Hardware details of the payload board
    stringToBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    uint32ToBeBytes(user->OnTime, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionPayloadVersionPacketID());
}

/*!
 * \brief Decode the OrionPayloadVersion packet
 *
 * Software version for the payload board in the Orion gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionPayloadVersionPacketStructure(const void* pkt, OrionPayloadVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionPayloadVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionPayloadVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // this packet has default fields, make sure they are set
    user->OnTime = 0;

    // Version of the payload board software
    stringFromBytes(user->Version, data, &byteindex, 24, 1);

    // Hardware details of the payload board
    stringFromBytes(user->PartNumber, data, &byteindex, 16, 1);

    // Board on time in minutes
    if(byteindex + 4 > numBytes)
        return 1;

    user->OnTime = uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionTrackerVersion packet
 *
 * Software version for the tracker board in the Orion Gimbal (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionTrackerVersionPacketStructure(void* pkt, const OrionTrackerVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the tracker board software
    stringToBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the tracker board
    stringToBytes(user->PartNumber, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionTrackerVersionPacketID());
}

/*!
 * \brief Decode the OrionTrackerVersion packet
 *
 * Software version for the tracker board in the Orion Gimbal (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionTrackerVersionPacketStructure(const void* pkt, OrionTrackerVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionTrackerVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionTrackerVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Version of the tracker board software
    stringFromBytes(user->Version, data, &byteindex, 16, 1);

    // Hardware details of the tracker board
    stringFromBytes(user->PartNumber, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionTrackerVersion packet
 *
 * Software version for the tracker board in the Orion Gimbal (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param Version is Version of the tracker board software
 * \param PartNumber is Hardware details of the tracker board
 */
void encodeOrionTrackerVersionPacket(void* pkt, const char Version[16], const char PartNumber[16])
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the tracker board software
    stringToBytes(Version, data, &byteindex, 16, 1);

    // Hardware details of the tracker board
    stringToBytes(PartNumber, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionTrackerVersionPacketID());
}

/*!
 * \brief Decode the OrionTrackerVersion packet
 *
 * Software version for the tracker board in the Orion Gimbal (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param Version receives Version of the tracker board software
 * \param PartNumber receives Hardware details of the tracker board
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionTrackerVersionPacket(const void* pkt, char Version[16], char PartNumber[16])
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionTrackerVersionPacketID())
        return 0;

    if(numBytes < getOrionTrackerVersionMinDataLength())
        return 0;

    // Version of the tracker board software
    stringFromBytes(Version, data, &byteindex, 16, 1);

    // Hardware details of the tracker board
    stringFromBytes(PartNumber, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionRetractVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionRetractVersionPacketStructure(void* pkt, const OrionRetractVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the retract board software
    stringToBytes(user->Version, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionRetractVersionPacketID());
}

/*!
 * \brief Decode the OrionRetractVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionRetractVersionPacketStructure(const void* pkt, OrionRetractVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionRetractVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionRetractVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Version of the retract board software
    stringFromBytes(user->Version, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionRetractVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param Version is Version of the retract board software
 */
void encodeOrionRetractVersionPacket(void* pkt, const char Version[16])
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the retract board software
    stringToBytes(Version, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionRetractVersionPacketID());
}

/*!
 * \brief Decode the OrionRetractVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param Version receives Version of the retract board software
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionRetractVersionPacket(const void* pkt, char Version[16])
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionRetractVersionPacketID())
        return 0;

    if(numBytes < getOrionRetractVersionMinDataLength())
        return 0;

    // Version of the retract board software
    stringFromBytes(Version, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionLensCtlVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionLensCtlVersionPacketStructure(void* pkt, const OrionLensCtlVersion_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the retract board software
    stringToBytes(user->Version, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionLensCtlVersionPacketID());
}

/*!
 * \brief Decode the OrionLensCtlVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionLensCtlVersionPacketStructure(const void* pkt, OrionLensCtlVersion_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionLensCtlVersionPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionLensCtlVersionMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Version of the retract board software
    stringFromBytes(user->Version, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionLensCtlVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet which will be created by this function
 * \param Version is Version of the retract board software
 */
void encodeOrionLensCtlVersionPacket(void* pkt, const char Version[16])
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Version of the retract board software
    stringToBytes(Version, data, &byteindex, 16, 1);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionLensCtlVersionPacketID());
}

/*!
 * \brief Decode the OrionLensCtlVersion packet
 *
 * Software version for the retract board in the Retract Unit (if applicable)
 * \param pkt points to the packet being decoded by this function
 * \param Version receives Version of the retract board software
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionLensCtlVersionPacket(const void* pkt, char Version[16])
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionLensCtlVersionPacketID())
        return 0;

    if(numBytes < getOrionLensCtlVersionMinDataLength())
        return 0;

    // Version of the retract board software
    stringFromBytes(Version, data, &byteindex, 16, 1);

    return 1;
}

/*!
 * \brief Create the OrionBoard packet
 *
 * Information for a specific board in the gimbal.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionBoardPacketStructure(void* pkt, const OrionBoard_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;
    int i = 0;

    // Serial number of this board
    uint32ToBeBytes(user->boardSN, data, &byteindex);

    // Serial number of the whole assembly
    uint32ToBeBytes(user->assemblySN, data, &byteindex);

    // Configuration bits
    uint32ToBeBytes(user->config, data, &byteindex);

    // Reserved space for future things
    for(i = 0; i < 3; i++)
        uint8ToBytes((uint8_t)(0), data, &byteindex);

    // Enumeration defining which board in the gimbal this data applies to
    uint8ToBytes(user->boardEnum, data, &byteindex);

    // Date the board was manufactured
    encodeDate_t(data, &byteindex, &user->manufactureDate);

    // Date the board was calibrated
    encodeDate_t(data, &byteindex, &user->calibrationDate);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionBoardPacketID());
}

/*!
 * \brief Decode the OrionBoard packet
 *
 * Information for a specific board in the gimbal.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionBoardPacketStructure(const void* pkt, OrionBoard_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionBoardPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionBoardMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Serial number of this board
    user->boardSN = uint32FromBeBytes(data, &byteindex);

    // Serial number of the whole assembly
    user->assemblySN = uint32FromBeBytes(data, &byteindex);

    // Configuration bits
    user->config = uint32FromBeBytes(data, &byteindex);

    // Reserved space for future things
    byteindex += 3;

    // Enumeration defining which board in the gimbal this data applies to
    user->boardEnum = (OrionBoardEnumeration_t)uint8FromBytes(data, &byteindex);

    // Date the board was manufactured
    if(decodeDate_t(data, &byteindex, &user->manufactureDate) == 0)
        return 0;

    // Date the board was calibrated
    if(decodeDate_t(data, &byteindex, &user->calibrationDate) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the OrionAutopilotData packet
 *
 * Autopilot state data. The gimbal will use this information to limit certain
 * operations, for example some lasers will not fire unless the autopilot is
 * flying with sufficient altitude above ground.
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeOrionAutopilotDataPacketStructure(void* pkt, const OrionAutopilotData_t* user)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Set to 1 if flying, otherwise 0
    uint8ToBytes(user->IsFlying, data, &byteindex);

    // Set to 1 if AP comms are good, otherwise 0
    uint8ToBytes(user->CommGood, data, &byteindex);

    // Altitude above ground level in meters. Invalid if less than zero
    int16ToBeBytes(user->Agl, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionAutopilotDataPacketID());
}

/*!
 * \brief Decode the OrionAutopilotData packet
 *
 * Autopilot state data. The gimbal will use this information to limit certain
 * operations, for example some lasers will not fire unless the autopilot is
 * flying with sufficient altitude above ground.
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionAutopilotDataPacketStructure(const void* pkt, OrionAutopilotData_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionAutopilotDataPacketID())
        return 0;

    // Verify the packet size
    numBytes = getOrionPublicPacketSize(pkt);
    if(numBytes < getOrionAutopilotDataMinDataLength())
        return 0;

    // The raw data from the packet
    data = getOrionPublicPacketDataConst(pkt);

    // Set to 1 if flying, otherwise 0
    user->IsFlying = uint8FromBytes(data, &byteindex);

    // Set to 1 if AP comms are good, otherwise 0
    user->CommGood = uint8FromBytes(data, &byteindex);

    // Altitude above ground level in meters. Invalid if less than zero
    user->Agl = int16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the OrionExtHeadingData packet
 *
 * Externally supplied heading information. Send this packet to supply a
 * correction to the heading of the inertial navigation system of the gimbal.
 * This packet will be echoed back to the user if INS logging is enabled.
 * \param pkt points to the packet which will be created by this function
 * \param extHeading is External true heading observation in radians from -pi to pi
 * \param noise is Sensor noise of the heading observation in radians. Send 0 to cause the INS to simply shift its heading. Otherwise the extHeading will be fed into the INS kalman filter with this sensor noise.
 * \param headingInGimbalAxis is Set this if the provided heading is in gimbal native axis rather than the platform axis. This will cause the gimbal to rotate the heading reference as needed to the platform axis used by the INS. This will have no effect if the INS options do not specify a platform rotation.
 * \param headingFromAlign is Set this if the provided heading came from an align system.
 * \param pitch is Pitch angle in radians from -pi to pi of the vector used to compute heading.
 */
void encodeOrionExtHeadingDataPacket(void* pkt, float extHeading, float noise, unsigned headingInGimbalAxis, unsigned headingFromAlign, float pitch)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // External true heading observation in radians from -pi to pi
    // Range of extHeading is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(extHeading, data, &byteindex, 10430.06004058427f);

    // Sensor noise of the heading observation in radians. Send 0 to cause the INS to simply shift its heading. Otherwise the extHeading will be fed into the INS kalman filter with this sensor noise.
    // Range of noise is 0.0 to 6.283185307179586.
    float32ScaledTo2UnsignedBeBytes(noise, data, &byteindex, 0.0f, 10430.21919552736f);

    // Set this if the provided heading is in gimbal native axis rather than the platform axis. This will cause the gimbal to rotate the heading reference as needed to the platform axis used by the INS. This will have no effect if the INS options do not specify a platform rotation.
    data[byteindex] = (uint8_t)headingInGimbalAxis << 7;

    // Set this if the provided heading came from an align system.
    data[byteindex] |= (uint8_t)headingFromAlign << 6;

    data[byteindex + 1] = 0;

    byteindex += 2; // close bit field

    // Pitch angle in radians from -pi to pi of the vector used to compute heading.
    // Range of pitch is -3.141592653589793 to 3.141592653589793.
    float32ScaledTo2SignedBeBytes(pitch, data, &byteindex, 10430.06004058427f);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionExtHeadingDataPacketID());
}

/*!
 * \brief Decode the OrionExtHeadingData packet
 *
 * Externally supplied heading information. Send this packet to supply a
 * correction to the heading of the inertial navigation system of the gimbal.
 * This packet will be echoed back to the user if INS logging is enabled.
 * \param pkt points to the packet being decoded by this function
 * \param extHeading receives External true heading observation in radians from -pi to pi
 * \param noise receives Sensor noise of the heading observation in radians. Send 0 to cause the INS to simply shift its heading. Otherwise the extHeading will be fed into the INS kalman filter with this sensor noise.
 * \param headingInGimbalAxis receives Set this if the provided heading is in gimbal native axis rather than the platform axis. This will cause the gimbal to rotate the heading reference as needed to the platform axis used by the INS. This will have no effect if the INS options do not specify a platform rotation.
 * \param headingFromAlign receives Set this if the provided heading came from an align system.
 * \param pitch receives Pitch angle in radians from -pi to pi of the vector used to compute heading.
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionExtHeadingDataPacket(const void* pkt, float* extHeading, float* noise, unsigned* headingInGimbalAxis, unsigned* headingFromAlign, float* pitch)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionExtHeadingDataPacketID())
        return 0;

    if(numBytes < getOrionExtHeadingDataMinDataLength())
        return 0;

    // this packet has default fields, make sure they are set
    *pitch = 0;

    // External true heading observation in radians from -pi to pi
    // Range of extHeading is -3.141592653589793 to 3.141592653589793.
    *extHeading = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    // Sensor noise of the heading observation in radians. Send 0 to cause the INS to simply shift its heading. Otherwise the extHeading will be fed into the INS kalman filter with this sensor noise.
    // Range of noise is 0.0 to 6.283185307179586.
    *noise = float32ScaledFrom2UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/10430.21919552736f);

    // Set this if the provided heading is in gimbal native axis rather than the platform axis. This will cause the gimbal to rotate the heading reference as needed to the platform axis used by the INS. This will have no effect if the INS options do not specify a platform rotation.
    (*headingInGimbalAxis) = (data[byteindex] >> 7);

    // Set this if the provided heading came from an align system.
    (*headingFromAlign) = ((data[byteindex] >> 6) & 0x1);

    byteindex += 2; // close bit field

    // Pitch angle in radians from -pi to pi of the vector used to compute heading.
    if(byteindex + 2 > numBytes)
        return 1;

    // Range of pitch is -3.141592653589793 to 3.141592653589793.
    *pitch = float32ScaledFrom2SignedBeBytes(data, &byteindex, 1.0f/10430.06004058427f);

    return 1;
}

/*!
 * \brief Create the OrionRangeData packet
 *
 * Ranging information from the gimbal to its target. The gimbal will use this
 * information to compute the target location and populate that informtaion in
 * its telemetry output.
 * \param pkt points to the packet which will be created by this function
 * \param range is Range to target in meters
 * \param maxAgeMs is Maximum data age before expiration in milliseconds
 * \param source is Source of range information
 */
void encodeOrionRangeDataPacket(void* pkt, float range, uint16_t maxAgeMs, RangeDataSrc_t source)
{
    uint8_t* data = getOrionPublicPacketData(pkt);
    int byteindex = 0;

    // Range to target in meters
    // Range of range is 0.0 to 42949672.95.
    float32ScaledTo4UnsignedBeBytes(range, data, &byteindex, 0.0f, 100.0f);

    // Maximum data age before expiration in milliseconds
    uint16ToBeBytes(maxAgeMs, data, &byteindex);

    // Source of range information
    uint8ToBytes(source, data, &byteindex);

    // complete the process of creating the packet
    finishOrionPublicPacket(pkt, byteindex, getOrionRangeDataPacketID());
}

/*!
 * \brief Decode the OrionRangeData packet
 *
 * Ranging information from the gimbal to its target. The gimbal will use this
 * information to compute the target location and populate that informtaion in
 * its telemetry output.
 * \param pkt points to the packet being decoded by this function
 * \param range receives Range to target in meters
 * \param maxAgeMs receives Maximum data age before expiration in milliseconds
 * \param source receives Source of range information
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeOrionRangeDataPacket(const void* pkt, float* range, uint16_t* maxAgeMs, RangeDataSrc_t* source)
{
    int byteindex = 0;
    const uint8_t* data = getOrionPublicPacketDataConst(pkt);
    int numBytes = getOrionPublicPacketSize(pkt);

    // Verify the packet identifier
    if(getOrionPublicPacketID(pkt) != getOrionRangeDataPacketID())
        return 0;

    if(numBytes < getOrionRangeDataMinDataLength())
        return 0;

    // Range to target in meters
    // Range of range is 0.0 to 42949672.95.
    *range = float32ScaledFrom4UnsignedBeBytes(data, &byteindex, 0.0f, 1.0f/100.0f);

    // Maximum data age before expiration in milliseconds
    *maxAgeMs = uint16FromBeBytes(data, &byteindex);

    // Source of range information
    *source = (RangeDataSrc_t)uint8FromBytes(data, &byteindex);

    return 1;
}
// end of OrionPublicPacket.c
