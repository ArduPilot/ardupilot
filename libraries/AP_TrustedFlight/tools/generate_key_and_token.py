#!/usr/bin/env python3
'''
script to generate public key and JWT token for Trusted Flight module testing

NOTE:   The key & token generated by this script are for only for demonstration & local testing.
        These are not intended to be used in production systems.

AP_FLAKE8_CLEAN
'''

import os
import sys
import json
from datetime import datetime, timedelta, timezone

from utils.constants import PUBLIC_KEY_FILE, TOKEN_FILE, EXPIRATION_IN_MINS, TOKEN_ISSUER, JWT_TYPE, JWT_ALG
from utils.helpers import base64url_encode

try:
    import monocypher
except ImportError:
    print("Please install monocypher with: python3 -m pip install pymonocypher==3.1.3.2")
    sys.exit(1)


def create_invalid_token(signing_key, token_path, encode=True):
    header = b'header'
    payload = b'payload'

    segments = []
    if encode:
        segments.append(base64url_encode(header))
        segments.append(base64url_encode(payload))
    else:
        segments.append(header)
        segments.append(payload)

    # Segments
    signing_input = b".".join(segments)
    sig = monocypher.signature_sign(signing_key, signing_input)

    segments.append(base64url_encode(sig))

    encoded_token = b".".join(segments)
    with open(token_path, 'wb') as f:
        f.write(encoded_token)
        print(f'Token written to file: {f.name}')


def create_key_pair(public_key_path: str):
    private_key, public_key = monocypher.generate_signing_key_pair()

    with open(public_key_path, 'wb') as f:
        f.write(public_key)
        print(f'Public key written to file: {f.name}')

    return private_key


def create_token(signing_key, token_path, payload=None, header=None, include_payload=True, include_signature=True):
    if payload is None:
        payload = {
            'iss': TOKEN_ISSUER,
            'iat': datetime.now(timezone.utc),
            'nbf': datetime.now(timezone.utc) + timedelta(seconds=5),
            'exp': datetime.now(timezone.utc) + timedelta(minutes=EXPIRATION_IN_MINS),
            'key1': 'value1',
            'key2': 'value2'
        }

    for time_claim in ['iat', 'exp', 'nbf']:
        if isinstance(payload.get(time_claim), datetime):
            payload[time_claim] = int(payload[time_claim].timestamp())

    json_payload = json.dumps(
        payload, separators=(',', ':'), cls=json.JSONEncoder
    ).encode()

    if header is None:
        header = {'typ': JWT_TYPE, 'alg': JWT_ALG}
    json_header = json.dumps(
        header, separators=(',', ':'), cls=json.JSONEncoder
    ).encode()

    segments = []
    segments.append(base64url_encode(json_header))
    if include_payload:
        segments.append(base64url_encode(json_payload))

    # Segments
    signing_input = b".".join(segments)
    sig = monocypher.signature_sign(signing_key, signing_input)

    if include_signature:
        segments.append(base64url_encode(sig))

    encoded_token = b".".join(segments)
    with open(token_path, 'wb') as f:
        f.write(encoded_token)
        print(f'Token written to file: {f.name}')


if __name__ == '__main__':
    if len(sys.argv) != 2:
        print("Usage: generate_key_and_token.py <dir_name>")
        sys.exit(1)

    dir_name = sys.argv[1]
    os.makedirs(f'{dir_name}', exist_ok=True)

    private_key = create_key_pair(f'{dir_name}/{PUBLIC_KEY_FILE}')
    create_token(private_key, f'{dir_name}/{TOKEN_FILE}')
