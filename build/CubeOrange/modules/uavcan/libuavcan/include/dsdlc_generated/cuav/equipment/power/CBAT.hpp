/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/jon305/ardupilot/modules/DroneCAN/DSDL/cuav/equipment/power/20300.CBAT.uavcan
 */

#ifndef CUAV_EQUIPMENT_POWER_CBAT_HPP_INCLUDED
#define CUAV_EQUIPMENT_POWER_CBAT_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

/******************************* Source text **********************************
#
# support for CUAV Smart Battery on UAVCAN
#

float32 temperature                 # The surface temperature of the battery
float32 voltage                     # The total voltage of the battery
float32[<=15] voltage_cell          # Battery individual cell voltages
uint8 cell_count                    # Number of cells
float32 current                     # The current flowing through the sense resistor
float32 average_current             # The average current flowing through the sense resistor
float32 average_power               # The average power of the current discharge
float32 available_energy            # The predicted charge or energy remaining in the battery
float32 remaining_capacity          # The compensated battery capacity remaining
float32 full_charge_capacity        # The compensated capacity of the battery when fully charged
float32 design_capacity             # The design capacity of the battery
uint16 average_time_to_empty        # The predicted remaining battery life at the present rate of discharge, in minutes
uint16 average_time_to_full         # The predicted remaining time until the battery reaches full charge, in minutes
uint7 state_of_health               # Health of the battery
uint7 state_of_charge               # Percent of the full charge [0, 100]
uint7 max_error                     # max error, expected margin of error in % in the state-of-charge calculation with a range of 1 to 100%
uint16 serial_number                # serial number of the battery pack
uint16 manufacture_date             # manufacture date, part of serial number of the battery pack
uint16 cycle_count                  # number of discharge cycles the battery has experienced
uint16 over_discharge_count         # Number of battery overdischarge
float32 passed_charge               # The amount of charge passing through the sense resistor
float32 nominal_voltage             # Nominal voltage of the battery pack
bool is_powering_off                # Power off event imminent indication, false if unknown
uint16 interface_error              # interface error counter

uint11 STATUS_FLAG_IN_USE       = 1     # The battery is currently used as a power supply
uint11 STATUS_FLAG_CHARGING     = 2     # Charger is active
uint11 STATUS_FLAG_CHARGED      = 4     # Charging complete, but the charger is still active
uint11 STATUS_FLAG_TEMP_HOT     = 8     # Battery temperature is above normal
uint11 STATUS_FLAG_TEMP_COLD    = 16    # Battery temperature is below normal
uint11 STATUS_FLAG_OVERLOAD     = 32    # Safe operating area violation
uint11 STATUS_FLAG_BAD_BATTERY  = 64    # This battery should not be used anymore (e.g. low SOH)
uint11 STATUS_FLAG_NEED_SERVICE = 128   # This battery requires maintenance (e.g. balancing, full recharge)
uint11 STATUS_FLAG_BMS_ERROR    = 256   # Battery management system/controller error, smart battery interface error
uint11 STATUS_FLAG_RESERVED_A   = 512   # Keep zero
uint11 STATUS_FLAG_RESERVED_B   = 1024  # Keep zero
uint11 status_flags
******************************************************************************/

/********************* DSDL signature source definition ***********************
cuav.equipment.power.CBAT
saturated float32 temperature
saturated float32 voltage
saturated float32[<=15] voltage_cell
saturated uint8 cell_count
saturated float32 current
saturated float32 average_current
saturated float32 average_power
saturated float32 available_energy
saturated float32 remaining_capacity
saturated float32 full_charge_capacity
saturated float32 design_capacity
saturated uint16 average_time_to_empty
saturated uint16 average_time_to_full
saturated uint7 state_of_health
saturated uint7 state_of_charge
saturated uint7 max_error
saturated uint16 serial_number
saturated uint16 manufacture_date
saturated uint16 cycle_count
saturated uint16 over_discharge_count
saturated float32 passed_charge
saturated float32 nominal_voltage
saturated bool is_powering_off
saturated uint16 interface_error
saturated uint11 status_flags
******************************************************************************/

#undef temperature
#undef voltage
#undef voltage_cell
#undef cell_count
#undef current
#undef average_current
#undef average_power
#undef available_energy
#undef remaining_capacity
#undef full_charge_capacity
#undef design_capacity
#undef average_time_to_empty
#undef average_time_to_full
#undef state_of_health
#undef state_of_charge
#undef max_error
#undef serial_number
#undef manufacture_date
#undef cycle_count
#undef over_discharge_count
#undef passed_charge
#undef nominal_voltage
#undef is_powering_off
#undef interface_error
#undef status_flags
#undef STATUS_FLAG_IN_USE
#undef STATUS_FLAG_CHARGING
#undef STATUS_FLAG_CHARGED
#undef STATUS_FLAG_TEMP_HOT
#undef STATUS_FLAG_TEMP_COLD
#undef STATUS_FLAG_OVERLOAD
#undef STATUS_FLAG_BAD_BATTERY
#undef STATUS_FLAG_NEED_SERVICE
#undef STATUS_FLAG_BMS_ERROR
#undef STATUS_FLAG_RESERVED_A
#undef STATUS_FLAG_RESERVED_B

namespace cuav
{
namespace equipment
{
namespace power
{

template <int _tmpl>
struct UAVCAN_EXPORT CBAT_
{
    typedef const CBAT_<_tmpl>& ParameterType;
    typedef CBAT_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_IN_USE;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_CHARGING;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_CHARGED;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_TEMP_HOT;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_TEMP_COLD;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_OVERLOAD;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_BAD_BATTERY;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_NEED_SERVICE;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_BMS_ERROR;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_RESERVED_A;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATUS_FLAG_RESERVED_B;
    };

    struct FieldTypes
    {
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > temperature;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > voltage;
        typedef ::uavcan::Array< ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeDynamic, 15 > voltage_cell;
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > cell_count;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > current;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > average_current;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > average_power;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > available_energy;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > remaining_capacity;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > full_charge_capacity;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > design_capacity;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > average_time_to_empty;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > average_time_to_full;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > state_of_health;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > state_of_charge;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > max_error;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > serial_number;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > manufacture_date;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > cycle_count;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > over_discharge_count;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > passed_charge;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > nominal_voltage;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > is_powering_off;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > interface_error;
        typedef ::uavcan::IntegerSpec< 11, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > status_flags;
    };

    enum
    {
        MinBitLen
            = FieldTypes::temperature::MinBitLen
            + FieldTypes::voltage::MinBitLen
            + FieldTypes::voltage_cell::MinBitLen
            + FieldTypes::cell_count::MinBitLen
            + FieldTypes::current::MinBitLen
            + FieldTypes::average_current::MinBitLen
            + FieldTypes::average_power::MinBitLen
            + FieldTypes::available_energy::MinBitLen
            + FieldTypes::remaining_capacity::MinBitLen
            + FieldTypes::full_charge_capacity::MinBitLen
            + FieldTypes::design_capacity::MinBitLen
            + FieldTypes::average_time_to_empty::MinBitLen
            + FieldTypes::average_time_to_full::MinBitLen
            + FieldTypes::state_of_health::MinBitLen
            + FieldTypes::state_of_charge::MinBitLen
            + FieldTypes::max_error::MinBitLen
            + FieldTypes::serial_number::MinBitLen
            + FieldTypes::manufacture_date::MinBitLen
            + FieldTypes::cycle_count::MinBitLen
            + FieldTypes::over_discharge_count::MinBitLen
            + FieldTypes::passed_charge::MinBitLen
            + FieldTypes::nominal_voltage::MinBitLen
            + FieldTypes::is_powering_off::MinBitLen
            + FieldTypes::interface_error::MinBitLen
            + FieldTypes::status_flags::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::temperature::MaxBitLen
            + FieldTypes::voltage::MaxBitLen
            + FieldTypes::voltage_cell::MaxBitLen
            + FieldTypes::cell_count::MaxBitLen
            + FieldTypes::current::MaxBitLen
            + FieldTypes::average_current::MaxBitLen
            + FieldTypes::average_power::MaxBitLen
            + FieldTypes::available_energy::MaxBitLen
            + FieldTypes::remaining_capacity::MaxBitLen
            + FieldTypes::full_charge_capacity::MaxBitLen
            + FieldTypes::design_capacity::MaxBitLen
            + FieldTypes::average_time_to_empty::MaxBitLen
            + FieldTypes::average_time_to_full::MaxBitLen
            + FieldTypes::state_of_health::MaxBitLen
            + FieldTypes::state_of_charge::MaxBitLen
            + FieldTypes::max_error::MaxBitLen
            + FieldTypes::serial_number::MaxBitLen
            + FieldTypes::manufacture_date::MaxBitLen
            + FieldTypes::cycle_count::MaxBitLen
            + FieldTypes::over_discharge_count::MaxBitLen
            + FieldTypes::passed_charge::MaxBitLen
            + FieldTypes::nominal_voltage::MaxBitLen
            + FieldTypes::is_powering_off::MaxBitLen
            + FieldTypes::interface_error::MaxBitLen
            + FieldTypes::status_flags::MaxBitLen
    };

    // Constants
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_IN_USE >::Type STATUS_FLAG_IN_USE; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_CHARGING >::Type STATUS_FLAG_CHARGING; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_CHARGED >::Type STATUS_FLAG_CHARGED; // 4
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_TEMP_HOT >::Type STATUS_FLAG_TEMP_HOT; // 8
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_TEMP_COLD >::Type STATUS_FLAG_TEMP_COLD; // 16
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_OVERLOAD >::Type STATUS_FLAG_OVERLOAD; // 32
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_BAD_BATTERY >::Type STATUS_FLAG_BAD_BATTERY; // 64
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_NEED_SERVICE >::Type STATUS_FLAG_NEED_SERVICE; // 128
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_BMS_ERROR >::Type STATUS_FLAG_BMS_ERROR; // 256
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_RESERVED_A >::Type STATUS_FLAG_RESERVED_A; // 512
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATUS_FLAG_RESERVED_B >::Type STATUS_FLAG_RESERVED_B; // 1024

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::temperature >::Type temperature;
    typename ::uavcan::StorageType< typename FieldTypes::voltage >::Type voltage;
    typename ::uavcan::StorageType< typename FieldTypes::voltage_cell >::Type voltage_cell;
    typename ::uavcan::StorageType< typename FieldTypes::cell_count >::Type cell_count;
    typename ::uavcan::StorageType< typename FieldTypes::current >::Type current;
    typename ::uavcan::StorageType< typename FieldTypes::average_current >::Type average_current;
    typename ::uavcan::StorageType< typename FieldTypes::average_power >::Type average_power;
    typename ::uavcan::StorageType< typename FieldTypes::available_energy >::Type available_energy;
    typename ::uavcan::StorageType< typename FieldTypes::remaining_capacity >::Type remaining_capacity;
    typename ::uavcan::StorageType< typename FieldTypes::full_charge_capacity >::Type full_charge_capacity;
    typename ::uavcan::StorageType< typename FieldTypes::design_capacity >::Type design_capacity;
    typename ::uavcan::StorageType< typename FieldTypes::average_time_to_empty >::Type average_time_to_empty;
    typename ::uavcan::StorageType< typename FieldTypes::average_time_to_full >::Type average_time_to_full;
    typename ::uavcan::StorageType< typename FieldTypes::state_of_health >::Type state_of_health;
    typename ::uavcan::StorageType< typename FieldTypes::state_of_charge >::Type state_of_charge;
    typename ::uavcan::StorageType< typename FieldTypes::max_error >::Type max_error;
    typename ::uavcan::StorageType< typename FieldTypes::serial_number >::Type serial_number;
    typename ::uavcan::StorageType< typename FieldTypes::manufacture_date >::Type manufacture_date;
    typename ::uavcan::StorageType< typename FieldTypes::cycle_count >::Type cycle_count;
    typename ::uavcan::StorageType< typename FieldTypes::over_discharge_count >::Type over_discharge_count;
    typename ::uavcan::StorageType< typename FieldTypes::passed_charge >::Type passed_charge;
    typename ::uavcan::StorageType< typename FieldTypes::nominal_voltage >::Type nominal_voltage;
    typename ::uavcan::StorageType< typename FieldTypes::is_powering_off >::Type is_powering_off;
    typename ::uavcan::StorageType< typename FieldTypes::interface_error >::Type interface_error;
    typename ::uavcan::StorageType< typename FieldTypes::status_flags >::Type status_flags;

    CBAT_()
        : temperature()
        , voltage()
        , voltage_cell()
        , cell_count()
        , current()
        , average_current()
        , average_power()
        , available_energy()
        , remaining_capacity()
        , full_charge_capacity()
        , design_capacity()
        , average_time_to_empty()
        , average_time_to_full()
        , state_of_health()
        , state_of_charge()
        , max_error()
        , serial_number()
        , manufacture_date()
        , cycle_count()
        , over_discharge_count()
        , passed_charge()
        , nominal_voltage()
        , is_powering_off()
        , interface_error()
        , status_flags()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<989 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 20300 };

    static const char* getDataTypeFullName()
    {
        return "cuav.equipment.power.CBAT";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool CBAT_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        temperature == rhs.temperature &&
        voltage == rhs.voltage &&
        voltage_cell == rhs.voltage_cell &&
        cell_count == rhs.cell_count &&
        current == rhs.current &&
        average_current == rhs.average_current &&
        average_power == rhs.average_power &&
        available_energy == rhs.available_energy &&
        remaining_capacity == rhs.remaining_capacity &&
        full_charge_capacity == rhs.full_charge_capacity &&
        design_capacity == rhs.design_capacity &&
        average_time_to_empty == rhs.average_time_to_empty &&
        average_time_to_full == rhs.average_time_to_full &&
        state_of_health == rhs.state_of_health &&
        state_of_charge == rhs.state_of_charge &&
        max_error == rhs.max_error &&
        serial_number == rhs.serial_number &&
        manufacture_date == rhs.manufacture_date &&
        cycle_count == rhs.cycle_count &&
        over_discharge_count == rhs.over_discharge_count &&
        passed_charge == rhs.passed_charge &&
        nominal_voltage == rhs.nominal_voltage &&
        is_powering_off == rhs.is_powering_off &&
        interface_error == rhs.interface_error &&
        status_flags == rhs.status_flags;
}

template <int _tmpl>
bool CBAT_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(temperature, rhs.temperature) &&
        ::uavcan::areClose(voltage, rhs.voltage) &&
        ::uavcan::areClose(voltage_cell, rhs.voltage_cell) &&
        ::uavcan::areClose(cell_count, rhs.cell_count) &&
        ::uavcan::areClose(current, rhs.current) &&
        ::uavcan::areClose(average_current, rhs.average_current) &&
        ::uavcan::areClose(average_power, rhs.average_power) &&
        ::uavcan::areClose(available_energy, rhs.available_energy) &&
        ::uavcan::areClose(remaining_capacity, rhs.remaining_capacity) &&
        ::uavcan::areClose(full_charge_capacity, rhs.full_charge_capacity) &&
        ::uavcan::areClose(design_capacity, rhs.design_capacity) &&
        ::uavcan::areClose(average_time_to_empty, rhs.average_time_to_empty) &&
        ::uavcan::areClose(average_time_to_full, rhs.average_time_to_full) &&
        ::uavcan::areClose(state_of_health, rhs.state_of_health) &&
        ::uavcan::areClose(state_of_charge, rhs.state_of_charge) &&
        ::uavcan::areClose(max_error, rhs.max_error) &&
        ::uavcan::areClose(serial_number, rhs.serial_number) &&
        ::uavcan::areClose(manufacture_date, rhs.manufacture_date) &&
        ::uavcan::areClose(cycle_count, rhs.cycle_count) &&
        ::uavcan::areClose(over_discharge_count, rhs.over_discharge_count) &&
        ::uavcan::areClose(passed_charge, rhs.passed_charge) &&
        ::uavcan::areClose(nominal_voltage, rhs.nominal_voltage) &&
        ::uavcan::areClose(is_powering_off, rhs.is_powering_off) &&
        ::uavcan::areClose(interface_error, rhs.interface_error) &&
        ::uavcan::areClose(status_flags, rhs.status_flags);
}

template <int _tmpl>
int CBAT_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::temperature::encode(self.temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::voltage::encode(self.voltage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::voltage_cell::encode(self.voltage_cell, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cell_count::encode(self.cell_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::current::encode(self.current, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_current::encode(self.average_current, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_power::encode(self.average_power, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::available_energy::encode(self.available_energy, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::remaining_capacity::encode(self.remaining_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::full_charge_capacity::encode(self.full_charge_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::design_capacity::encode(self.design_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_time_to_empty::encode(self.average_time_to_empty, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_time_to_full::encode(self.average_time_to_full, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::state_of_health::encode(self.state_of_health, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::state_of_charge::encode(self.state_of_charge, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::max_error::encode(self.max_error, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::serial_number::encode(self.serial_number, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::manufacture_date::encode(self.manufacture_date, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cycle_count::encode(self.cycle_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::over_discharge_count::encode(self.over_discharge_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::passed_charge::encode(self.passed_charge, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::nominal_voltage::encode(self.nominal_voltage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::is_powering_off::encode(self.is_powering_off, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::interface_error::encode(self.interface_error, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::status_flags::encode(self.status_flags, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int CBAT_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::temperature::decode(self.temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::voltage::decode(self.voltage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::voltage_cell::decode(self.voltage_cell, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cell_count::decode(self.cell_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::current::decode(self.current, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_current::decode(self.average_current, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_power::decode(self.average_power, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::available_energy::decode(self.available_energy, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::remaining_capacity::decode(self.remaining_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::full_charge_capacity::decode(self.full_charge_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::design_capacity::decode(self.design_capacity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_time_to_empty::decode(self.average_time_to_empty, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::average_time_to_full::decode(self.average_time_to_full, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::state_of_health::decode(self.state_of_health, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::state_of_charge::decode(self.state_of_charge, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::max_error::decode(self.max_error, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::serial_number::decode(self.serial_number, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::manufacture_date::decode(self.manufacture_date, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cycle_count::decode(self.cycle_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::over_discharge_count::decode(self.over_discharge_count, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::passed_charge::decode(self.passed_charge, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::nominal_voltage::decode(self.nominal_voltage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::is_powering_off::decode(self.is_powering_off, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::interface_error::decode(self.interface_error, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::status_flags::decode(self.status_flags, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature CBAT_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0xB4DACE3A38E09A74ULL);

    FieldTypes::temperature::extendDataTypeSignature(signature);
    FieldTypes::voltage::extendDataTypeSignature(signature);
    FieldTypes::voltage_cell::extendDataTypeSignature(signature);
    FieldTypes::cell_count::extendDataTypeSignature(signature);
    FieldTypes::current::extendDataTypeSignature(signature);
    FieldTypes::average_current::extendDataTypeSignature(signature);
    FieldTypes::average_power::extendDataTypeSignature(signature);
    FieldTypes::available_energy::extendDataTypeSignature(signature);
    FieldTypes::remaining_capacity::extendDataTypeSignature(signature);
    FieldTypes::full_charge_capacity::extendDataTypeSignature(signature);
    FieldTypes::design_capacity::extendDataTypeSignature(signature);
    FieldTypes::average_time_to_empty::extendDataTypeSignature(signature);
    FieldTypes::average_time_to_full::extendDataTypeSignature(signature);
    FieldTypes::state_of_health::extendDataTypeSignature(signature);
    FieldTypes::state_of_charge::extendDataTypeSignature(signature);
    FieldTypes::max_error::extendDataTypeSignature(signature);
    FieldTypes::serial_number::extendDataTypeSignature(signature);
    FieldTypes::manufacture_date::extendDataTypeSignature(signature);
    FieldTypes::cycle_count::extendDataTypeSignature(signature);
    FieldTypes::over_discharge_count::extendDataTypeSignature(signature);
    FieldTypes::passed_charge::extendDataTypeSignature(signature);
    FieldTypes::nominal_voltage::extendDataTypeSignature(signature);
    FieldTypes::is_powering_off::extendDataTypeSignature(signature);
    FieldTypes::interface_error::extendDataTypeSignature(signature);
    FieldTypes::status_flags::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_IN_USE >::Type
    CBAT_<_tmpl>::STATUS_FLAG_IN_USE = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_CHARGING >::Type
    CBAT_<_tmpl>::STATUS_FLAG_CHARGING = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_CHARGED >::Type
    CBAT_<_tmpl>::STATUS_FLAG_CHARGED = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_TEMP_HOT >::Type
    CBAT_<_tmpl>::STATUS_FLAG_TEMP_HOT = 8U; // 8

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_TEMP_COLD >::Type
    CBAT_<_tmpl>::STATUS_FLAG_TEMP_COLD = 16U; // 16

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_OVERLOAD >::Type
    CBAT_<_tmpl>::STATUS_FLAG_OVERLOAD = 32U; // 32

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_BAD_BATTERY >::Type
    CBAT_<_tmpl>::STATUS_FLAG_BAD_BATTERY = 64U; // 64

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_NEED_SERVICE >::Type
    CBAT_<_tmpl>::STATUS_FLAG_NEED_SERVICE = 128U; // 128

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_BMS_ERROR >::Type
    CBAT_<_tmpl>::STATUS_FLAG_BMS_ERROR = 256U; // 256

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_RESERVED_A >::Type
    CBAT_<_tmpl>::STATUS_FLAG_RESERVED_A = 512U; // 512

template <int _tmpl>
const typename ::uavcan::StorageType< typename CBAT_<_tmpl>::ConstantTypes::STATUS_FLAG_RESERVED_B >::Type
    CBAT_<_tmpl>::STATUS_FLAG_RESERVED_B = 1024U; // 1024

/*
 * Final typedef
 */
typedef CBAT_<0> CBAT;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::cuav::equipment::power::CBAT > _uavcan_gdtr_registrator_CBAT;

}

} // Namespace power
} // Namespace equipment
} // Namespace cuav

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::cuav::equipment::power::CBAT >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::cuav::equipment::power::CBAT::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::cuav::equipment::power::CBAT >::stream(Stream& s, ::cuav::equipment::power::CBAT::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "temperature: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::temperature >::stream(s, obj.temperature, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "voltage: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::voltage >::stream(s, obj.voltage, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "voltage_cell: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::voltage_cell >::stream(s, obj.voltage_cell, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "cell_count: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::cell_count >::stream(s, obj.cell_count, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "current: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::current >::stream(s, obj.current, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "average_current: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::average_current >::stream(s, obj.average_current, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "average_power: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::average_power >::stream(s, obj.average_power, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "available_energy: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::available_energy >::stream(s, obj.available_energy, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "remaining_capacity: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::remaining_capacity >::stream(s, obj.remaining_capacity, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "full_charge_capacity: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::full_charge_capacity >::stream(s, obj.full_charge_capacity, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "design_capacity: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::design_capacity >::stream(s, obj.design_capacity, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "average_time_to_empty: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::average_time_to_empty >::stream(s, obj.average_time_to_empty, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "average_time_to_full: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::average_time_to_full >::stream(s, obj.average_time_to_full, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "state_of_health: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::state_of_health >::stream(s, obj.state_of_health, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "state_of_charge: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::state_of_charge >::stream(s, obj.state_of_charge, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "max_error: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::max_error >::stream(s, obj.max_error, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "serial_number: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::serial_number >::stream(s, obj.serial_number, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "manufacture_date: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::manufacture_date >::stream(s, obj.manufacture_date, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "cycle_count: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::cycle_count >::stream(s, obj.cycle_count, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "over_discharge_count: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::over_discharge_count >::stream(s, obj.over_discharge_count, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "passed_charge: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::passed_charge >::stream(s, obj.passed_charge, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "nominal_voltage: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::nominal_voltage >::stream(s, obj.nominal_voltage, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "is_powering_off: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::is_powering_off >::stream(s, obj.is_powering_off, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "interface_error: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::interface_error >::stream(s, obj.interface_error, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "status_flags: ";
    YamlStreamer< ::cuav::equipment::power::CBAT::FieldTypes::status_flags >::stream(s, obj.status_flags, level + 1);
}

}

namespace cuav
{
namespace equipment
{
namespace power
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::cuav::equipment::power::CBAT::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::cuav::equipment::power::CBAT >::stream(s, obj, 0);
    return s;
}

} // Namespace power
} // Namespace equipment
} // Namespace cuav

#endif // CUAV_EQUIPMENT_POWER_CBAT_HPP_INCLUDED