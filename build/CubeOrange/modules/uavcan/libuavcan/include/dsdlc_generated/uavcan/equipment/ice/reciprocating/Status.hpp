/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/jon305/ardupilot/modules/DroneCAN/DSDL/uavcan/equipment/ice/reciprocating/1120.Status.uavcan
 */

#ifndef UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_HPP_INCLUDED
#define UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

#include <uavcan/equipment/ice/reciprocating/CylinderStatus.hpp>

/******************************* Source text **********************************
#
# Generic status message of a piston engine control system.
#
# All integer fields are required unless stated otherwise.
# All floating point fields are optional unless stated otherwise; unknown/unapplicable fields should be set to NaN.
#

#
# Abstract engine state. The flags defined below can provide further elaboration.
# This is a required field.
#
uint2 state
#
# The engine is not running. This is the default state.
# Next states: STARTING, FAULT
#
uint2 STATE_STOPPED = 0
#
# The engine is starting. This is a transient state.
# Next states: STOPPED, RUNNING, FAULT
#
uint2 STATE_STARTING = 1
#
# The engine is running normally.
# Some error flags may be set to indicate non-fatal issues, e.g. overheating.
# Next states: STOPPED, FAULT
#
uint2 STATE_RUNNING = 2
#
# The engine can no longer function.
# The error flags may contain additional information about the nature of the fault.
# Next states: STOPPED.
#
uint2 STATE_FAULT = 3

#
# General status flags.
# Note that not all flags are required. Those that aren't are prepended with a validity flag, which is, obviously,
# always required; when the validity flag is set, it is assumed that the relevant flags are set correctly.
# If the validity flag is cleared, then the state of the relevant flags should be ignored.
# All unused bits must be cleared.
#
uint30 flags
#
# General error. This flag is required, and it can be used to indicate an error condition
# that does not fit any of the other flags.
# Note that the vendor may also report additional status information via the vendor specific status code
# field of the NodeStatus message.
#
uint30 FLAG_GENERAL_ERROR                       = 1
#
# Error of the crankshaft sensor. This flag is optional.
#
uint30 FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED   = 2
uint30 FLAG_CRANKSHAFT_SENSOR_ERROR             = 4
#
# Temperature levels. These flags are optional; either none of them or all of them are supported.
#
uint30 FLAG_TEMPERATURE_SUPPORTED               = 8
uint30 FLAG_TEMPERATURE_BELOW_NOMINAL           = 16      # Under-temperature warning
uint30 FLAG_TEMPERATURE_ABOVE_NOMINAL           = 32      # Over-temperature warning
uint30 FLAG_TEMPERATURE_OVERHEATING             = 64      # Critical overheating
uint30 FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL       = 128     # Exhaust gas over-temperature warning
#
# Fuel pressure. These flags are optional; either none of them or all of them are supported.
#
uint30 FLAG_FUEL_PRESSURE_SUPPORTED             = 256
uint30 FLAG_FUEL_PRESSURE_BELOW_NOMINAL         = 512     # Under-pressure warning
uint30 FLAG_FUEL_PRESSURE_ABOVE_NOMINAL         = 1024    # Over-pressure warning
#
# Detonation warning. This flag is optional.
# This warning is cleared immediately after broadcasting is done if detonation is no longer happening.
#
uint30 FLAG_DETONATION_SUPPORTED                = 2048
uint30 FLAG_DETONATION_OBSERVED                 = 4096    # Detonation condition observed warning
#
# Misfire warning. This flag is optional.
# This warning is cleared immediately after broadcasting is done if misfire is no longer happening.
#
uint30 FLAG_MISFIRE_SUPPORTED                   = 8192
uint30 FLAG_MISFIRE_OBSERVED                    = 16384   # Misfire condition observed warning
#
# Oil pressure. These flags are optional; either none of them or all of them are supported.
#
uint30 FLAG_OIL_PRESSURE_SUPPORTED              = 32768
uint30 FLAG_OIL_PRESSURE_BELOW_NOMINAL          = 65536   # Under-pressure warning
uint30 FLAG_OIL_PRESSURE_ABOVE_NOMINAL          = 131072  # Over-pressure warning
#
# Debris warning. This flag is optional.
#
uint30 FLAG_DEBRIS_SUPPORTED                    = 262144
uint30 FLAG_DEBRIS_DETECTED                     = 524288  # Detection of debris warning

#
# Reserved space
#
void16

#
# Engine load estimate.
# Unit: percent.
# Range: [0, 127].
#
uint7 engine_load_percent

#
# Engine speed.
# Unit: revolutions per minute.
#
uint17 engine_speed_rpm

#
# Spark dwell time.
# Unit: millisecond.
#
float16 spark_dwell_time_ms

#
# Atmospheric (barometric) pressure.
# Unit: kilopascal.
#
float16 atmospheric_pressure_kpa

#
# Engine intake manifold pressure.
# Unit: kilopascal.
#
float16 intake_manifold_pressure_kpa

#
# Engine intake manifold temperature.
# Unit: kelvin.
#
float16 intake_manifold_temperature

#
# Engine coolant temperature.
# Unit: kelvin.
#
float16 coolant_temperature

#
# Oil pressure.
# Unit: kilopascal.
#
float16 oil_pressure

#
# Oil temperature.
# Unit: kelvin.
#
float16 oil_temperature

#
# Fuel pressure.
# Unit: kilopascal.
#
float16 fuel_pressure

#
# Instant fuel consumption estimate.
# The estimated value should be low-pass filtered in order to prevent aliasing effects.
# Unit: (centimeter^3)/minute.
#
float32 fuel_consumption_rate_cm3pm

#
# Estimate of the consumed fuel since the start of the engine.
# This variable MUST be reset when the engine is stopped.
# Unit: centimeter^3.
#
float32 estimated_consumed_fuel_volume_cm3

#
# Throttle position.
# Unit: percent.
#
uint7 throttle_position_percent

#
# The index of the publishing ECU.
#
uint6 ecu_index

#
# Spark plug activity report.
# Can be used during pre-flight tests of the spark subsystem.
#
uint3 spark_plug_usage
#
uint3 SPARK_PLUG_SINGLE         = 0
uint3 SPARK_PLUG_FIRST_ACTIVE   = 1
uint3 SPARK_PLUG_SECOND_ACTIVE  = 2
uint3 SPARK_PLUG_BOTH_ACTIVE    = 3

#
# Per-cylinder status information.
#
CylinderStatus[<=16] cylinder_status
******************************************************************************/

/********************* DSDL signature source definition ***********************
uavcan.equipment.ice.reciprocating.Status
saturated uint2 state
saturated uint30 flags
void16
saturated uint7 engine_load_percent
saturated uint17 engine_speed_rpm
saturated float16 spark_dwell_time_ms
saturated float16 atmospheric_pressure_kpa
saturated float16 intake_manifold_pressure_kpa
saturated float16 intake_manifold_temperature
saturated float16 coolant_temperature
saturated float16 oil_pressure
saturated float16 oil_temperature
saturated float16 fuel_pressure
saturated float32 fuel_consumption_rate_cm3pm
saturated float32 estimated_consumed_fuel_volume_cm3
saturated uint7 throttle_position_percent
saturated uint6 ecu_index
saturated uint3 spark_plug_usage
uavcan.equipment.ice.reciprocating.CylinderStatus[<=16] cylinder_status
******************************************************************************/

#undef state
#undef flags
#undef _void_0
#undef engine_load_percent
#undef engine_speed_rpm
#undef spark_dwell_time_ms
#undef atmospheric_pressure_kpa
#undef intake_manifold_pressure_kpa
#undef intake_manifold_temperature
#undef coolant_temperature
#undef oil_pressure
#undef oil_temperature
#undef fuel_pressure
#undef fuel_consumption_rate_cm3pm
#undef estimated_consumed_fuel_volume_cm3
#undef throttle_position_percent
#undef ecu_index
#undef spark_plug_usage
#undef cylinder_status
#undef STATE_STOPPED
#undef STATE_STARTING
#undef STATE_RUNNING
#undef STATE_FAULT
#undef FLAG_GENERAL_ERROR
#undef FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED
#undef FLAG_CRANKSHAFT_SENSOR_ERROR
#undef FLAG_TEMPERATURE_SUPPORTED
#undef FLAG_TEMPERATURE_BELOW_NOMINAL
#undef FLAG_TEMPERATURE_ABOVE_NOMINAL
#undef FLAG_TEMPERATURE_OVERHEATING
#undef FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL
#undef FLAG_FUEL_PRESSURE_SUPPORTED
#undef FLAG_FUEL_PRESSURE_BELOW_NOMINAL
#undef FLAG_FUEL_PRESSURE_ABOVE_NOMINAL
#undef FLAG_DETONATION_SUPPORTED
#undef FLAG_DETONATION_OBSERVED
#undef FLAG_MISFIRE_SUPPORTED
#undef FLAG_MISFIRE_OBSERVED
#undef FLAG_OIL_PRESSURE_SUPPORTED
#undef FLAG_OIL_PRESSURE_BELOW_NOMINAL
#undef FLAG_OIL_PRESSURE_ABOVE_NOMINAL
#undef FLAG_DEBRIS_SUPPORTED
#undef FLAG_DEBRIS_DETECTED
#undef SPARK_PLUG_SINGLE
#undef SPARK_PLUG_FIRST_ACTIVE
#undef SPARK_PLUG_SECOND_ACTIVE
#undef SPARK_PLUG_BOTH_ACTIVE

namespace uavcan
{
namespace equipment
{
namespace ice
{
namespace reciprocating
{

template <int _tmpl>
struct UAVCAN_EXPORT Status_
{
    typedef const Status_<_tmpl>& ParameterType;
    typedef Status_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATE_STOPPED;
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATE_STARTING;
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATE_RUNNING;
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > STATE_FAULT;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_GENERAL_ERROR;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_CRANKSHAFT_SENSOR_ERROR;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_TEMPERATURE_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_TEMPERATURE_BELOW_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_TEMPERATURE_ABOVE_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_TEMPERATURE_OVERHEATING;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_FUEL_PRESSURE_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_FUEL_PRESSURE_BELOW_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_FUEL_PRESSURE_ABOVE_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_DETONATION_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_DETONATION_OBSERVED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_MISFIRE_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_MISFIRE_OBSERVED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_OIL_PRESSURE_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_OIL_PRESSURE_BELOW_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_OIL_PRESSURE_ABOVE_NOMINAL;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_DEBRIS_SUPPORTED;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_DEBRIS_DETECTED;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SPARK_PLUG_SINGLE;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SPARK_PLUG_FIRST_ACTIVE;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SPARK_PLUG_SECOND_ACTIVE;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SPARK_PLUG_BOTH_ACTIVE;
    };

    struct FieldTypes
    {
        typedef ::uavcan::IntegerSpec< 2, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > state;
        typedef ::uavcan::IntegerSpec< 30, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > flags;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > _void_0;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > engine_load_percent;
        typedef ::uavcan::IntegerSpec< 17, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > engine_speed_rpm;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > spark_dwell_time_ms;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > atmospheric_pressure_kpa;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > intake_manifold_pressure_kpa;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > intake_manifold_temperature;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > coolant_temperature;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > oil_pressure;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > oil_temperature;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > fuel_pressure;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > fuel_consumption_rate_cm3pm;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > estimated_consumed_fuel_volume_cm3;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > throttle_position_percent;
        typedef ::uavcan::IntegerSpec< 6, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ecu_index;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > spark_plug_usage;
        typedef ::uavcan::Array< ::uavcan::equipment::ice::reciprocating::CylinderStatus, ::uavcan::ArrayModeDynamic, 16 > cylinder_status;
    };

    enum
    {
        MinBitLen
            = FieldTypes::state::MinBitLen
            + FieldTypes::flags::MinBitLen
            + FieldTypes::_void_0::MinBitLen
            + FieldTypes::engine_load_percent::MinBitLen
            + FieldTypes::engine_speed_rpm::MinBitLen
            + FieldTypes::spark_dwell_time_ms::MinBitLen
            + FieldTypes::atmospheric_pressure_kpa::MinBitLen
            + FieldTypes::intake_manifold_pressure_kpa::MinBitLen
            + FieldTypes::intake_manifold_temperature::MinBitLen
            + FieldTypes::coolant_temperature::MinBitLen
            + FieldTypes::oil_pressure::MinBitLen
            + FieldTypes::oil_temperature::MinBitLen
            + FieldTypes::fuel_pressure::MinBitLen
            + FieldTypes::fuel_consumption_rate_cm3pm::MinBitLen
            + FieldTypes::estimated_consumed_fuel_volume_cm3::MinBitLen
            + FieldTypes::throttle_position_percent::MinBitLen
            + FieldTypes::ecu_index::MinBitLen
            + FieldTypes::spark_plug_usage::MinBitLen
            + FieldTypes::cylinder_status::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::state::MaxBitLen
            + FieldTypes::flags::MaxBitLen
            + FieldTypes::_void_0::MaxBitLen
            + FieldTypes::engine_load_percent::MaxBitLen
            + FieldTypes::engine_speed_rpm::MaxBitLen
            + FieldTypes::spark_dwell_time_ms::MaxBitLen
            + FieldTypes::atmospheric_pressure_kpa::MaxBitLen
            + FieldTypes::intake_manifold_pressure_kpa::MaxBitLen
            + FieldTypes::intake_manifold_temperature::MaxBitLen
            + FieldTypes::coolant_temperature::MaxBitLen
            + FieldTypes::oil_pressure::MaxBitLen
            + FieldTypes::oil_temperature::MaxBitLen
            + FieldTypes::fuel_pressure::MaxBitLen
            + FieldTypes::fuel_consumption_rate_cm3pm::MaxBitLen
            + FieldTypes::estimated_consumed_fuel_volume_cm3::MaxBitLen
            + FieldTypes::throttle_position_percent::MaxBitLen
            + FieldTypes::ecu_index::MaxBitLen
            + FieldTypes::spark_plug_usage::MaxBitLen
            + FieldTypes::cylinder_status::MaxBitLen
    };

    // Constants
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATE_STOPPED >::Type STATE_STOPPED; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATE_STARTING >::Type STATE_STARTING; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATE_RUNNING >::Type STATE_RUNNING; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::STATE_FAULT >::Type STATE_FAULT; // 3
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_GENERAL_ERROR >::Type FLAG_GENERAL_ERROR; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED >::Type FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_CRANKSHAFT_SENSOR_ERROR >::Type FLAG_CRANKSHAFT_SENSOR_ERROR; // 4
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_TEMPERATURE_SUPPORTED >::Type FLAG_TEMPERATURE_SUPPORTED; // 8
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_TEMPERATURE_BELOW_NOMINAL >::Type FLAG_TEMPERATURE_BELOW_NOMINAL; // 16
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_TEMPERATURE_ABOVE_NOMINAL >::Type FLAG_TEMPERATURE_ABOVE_NOMINAL; // 32
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_TEMPERATURE_OVERHEATING >::Type FLAG_TEMPERATURE_OVERHEATING; // 64
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL >::Type FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL; // 128
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_FUEL_PRESSURE_SUPPORTED >::Type FLAG_FUEL_PRESSURE_SUPPORTED; // 256
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_FUEL_PRESSURE_BELOW_NOMINAL >::Type FLAG_FUEL_PRESSURE_BELOW_NOMINAL; // 512
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_FUEL_PRESSURE_ABOVE_NOMINAL >::Type FLAG_FUEL_PRESSURE_ABOVE_NOMINAL; // 1024
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_DETONATION_SUPPORTED >::Type FLAG_DETONATION_SUPPORTED; // 2048
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_DETONATION_OBSERVED >::Type FLAG_DETONATION_OBSERVED; // 4096
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_MISFIRE_SUPPORTED >::Type FLAG_MISFIRE_SUPPORTED; // 8192
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_MISFIRE_OBSERVED >::Type FLAG_MISFIRE_OBSERVED; // 16384
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_OIL_PRESSURE_SUPPORTED >::Type FLAG_OIL_PRESSURE_SUPPORTED; // 32768
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_OIL_PRESSURE_BELOW_NOMINAL >::Type FLAG_OIL_PRESSURE_BELOW_NOMINAL; // 65536
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_OIL_PRESSURE_ABOVE_NOMINAL >::Type FLAG_OIL_PRESSURE_ABOVE_NOMINAL; // 131072
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_DEBRIS_SUPPORTED >::Type FLAG_DEBRIS_SUPPORTED; // 262144
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_DEBRIS_DETECTED >::Type FLAG_DEBRIS_DETECTED; // 524288
    static const typename ::uavcan::StorageType< typename ConstantTypes::SPARK_PLUG_SINGLE >::Type SPARK_PLUG_SINGLE; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::SPARK_PLUG_FIRST_ACTIVE >::Type SPARK_PLUG_FIRST_ACTIVE; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::SPARK_PLUG_SECOND_ACTIVE >::Type SPARK_PLUG_SECOND_ACTIVE; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::SPARK_PLUG_BOTH_ACTIVE >::Type SPARK_PLUG_BOTH_ACTIVE; // 3

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::state >::Type state;
    typename ::uavcan::StorageType< typename FieldTypes::flags >::Type flags;
    typename ::uavcan::StorageType< typename FieldTypes::engine_load_percent >::Type engine_load_percent;
    typename ::uavcan::StorageType< typename FieldTypes::engine_speed_rpm >::Type engine_speed_rpm;
    typename ::uavcan::StorageType< typename FieldTypes::spark_dwell_time_ms >::Type spark_dwell_time_ms;
    typename ::uavcan::StorageType< typename FieldTypes::atmospheric_pressure_kpa >::Type atmospheric_pressure_kpa;
    typename ::uavcan::StorageType< typename FieldTypes::intake_manifold_pressure_kpa >::Type intake_manifold_pressure_kpa;
    typename ::uavcan::StorageType< typename FieldTypes::intake_manifold_temperature >::Type intake_manifold_temperature;
    typename ::uavcan::StorageType< typename FieldTypes::coolant_temperature >::Type coolant_temperature;
    typename ::uavcan::StorageType< typename FieldTypes::oil_pressure >::Type oil_pressure;
    typename ::uavcan::StorageType< typename FieldTypes::oil_temperature >::Type oil_temperature;
    typename ::uavcan::StorageType< typename FieldTypes::fuel_pressure >::Type fuel_pressure;
    typename ::uavcan::StorageType< typename FieldTypes::fuel_consumption_rate_cm3pm >::Type fuel_consumption_rate_cm3pm;
    typename ::uavcan::StorageType< typename FieldTypes::estimated_consumed_fuel_volume_cm3 >::Type estimated_consumed_fuel_volume_cm3;
    typename ::uavcan::StorageType< typename FieldTypes::throttle_position_percent >::Type throttle_position_percent;
    typename ::uavcan::StorageType< typename FieldTypes::ecu_index >::Type ecu_index;
    typename ::uavcan::StorageType< typename FieldTypes::spark_plug_usage >::Type spark_plug_usage;
    typename ::uavcan::StorageType< typename FieldTypes::cylinder_status >::Type cylinder_status;

    Status_()
        : state()
        , flags()
        , engine_load_percent()
        , engine_speed_rpm()
        , spark_dwell_time_ms()
        , atmospheric_pressure_kpa()
        , intake_manifold_pressure_kpa()
        , intake_manifold_temperature()
        , coolant_temperature()
        , oil_pressure()
        , oil_temperature()
        , fuel_pressure()
        , fuel_consumption_rate_cm3pm()
        , estimated_consumed_fuel_volume_cm3()
        , throttle_position_percent()
        , ecu_index()
        , spark_plug_usage()
        , cylinder_status()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<1565 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 1120 };

    static const char* getDataTypeFullName()
    {
        return "uavcan.equipment.ice.reciprocating.Status";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool Status_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        state == rhs.state &&
        flags == rhs.flags &&
        engine_load_percent == rhs.engine_load_percent &&
        engine_speed_rpm == rhs.engine_speed_rpm &&
        spark_dwell_time_ms == rhs.spark_dwell_time_ms &&
        atmospheric_pressure_kpa == rhs.atmospheric_pressure_kpa &&
        intake_manifold_pressure_kpa == rhs.intake_manifold_pressure_kpa &&
        intake_manifold_temperature == rhs.intake_manifold_temperature &&
        coolant_temperature == rhs.coolant_temperature &&
        oil_pressure == rhs.oil_pressure &&
        oil_temperature == rhs.oil_temperature &&
        fuel_pressure == rhs.fuel_pressure &&
        fuel_consumption_rate_cm3pm == rhs.fuel_consumption_rate_cm3pm &&
        estimated_consumed_fuel_volume_cm3 == rhs.estimated_consumed_fuel_volume_cm3 &&
        throttle_position_percent == rhs.throttle_position_percent &&
        ecu_index == rhs.ecu_index &&
        spark_plug_usage == rhs.spark_plug_usage &&
        cylinder_status == rhs.cylinder_status;
}

template <int _tmpl>
bool Status_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(state, rhs.state) &&
        ::uavcan::areClose(flags, rhs.flags) &&
        ::uavcan::areClose(engine_load_percent, rhs.engine_load_percent) &&
        ::uavcan::areClose(engine_speed_rpm, rhs.engine_speed_rpm) &&
        ::uavcan::areClose(spark_dwell_time_ms, rhs.spark_dwell_time_ms) &&
        ::uavcan::areClose(atmospheric_pressure_kpa, rhs.atmospheric_pressure_kpa) &&
        ::uavcan::areClose(intake_manifold_pressure_kpa, rhs.intake_manifold_pressure_kpa) &&
        ::uavcan::areClose(intake_manifold_temperature, rhs.intake_manifold_temperature) &&
        ::uavcan::areClose(coolant_temperature, rhs.coolant_temperature) &&
        ::uavcan::areClose(oil_pressure, rhs.oil_pressure) &&
        ::uavcan::areClose(oil_temperature, rhs.oil_temperature) &&
        ::uavcan::areClose(fuel_pressure, rhs.fuel_pressure) &&
        ::uavcan::areClose(fuel_consumption_rate_cm3pm, rhs.fuel_consumption_rate_cm3pm) &&
        ::uavcan::areClose(estimated_consumed_fuel_volume_cm3, rhs.estimated_consumed_fuel_volume_cm3) &&
        ::uavcan::areClose(throttle_position_percent, rhs.throttle_position_percent) &&
        ::uavcan::areClose(ecu_index, rhs.ecu_index) &&
        ::uavcan::areClose(spark_plug_usage, rhs.spark_plug_usage) &&
        ::uavcan::areClose(cylinder_status, rhs.cylinder_status);
}

template <int _tmpl>
int Status_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    typename ::uavcan::StorageType< typename FieldTypes::_void_0 >::Type _void_0 = 0;
    int res = 1;
    res = FieldTypes::state::encode(self.state, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::flags::encode(self.flags, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::_void_0::encode(_void_0, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::engine_load_percent::encode(self.engine_load_percent, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::engine_speed_rpm::encode(self.engine_speed_rpm, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::spark_dwell_time_ms::encode(self.spark_dwell_time_ms, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::atmospheric_pressure_kpa::encode(self.atmospheric_pressure_kpa, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::intake_manifold_pressure_kpa::encode(self.intake_manifold_pressure_kpa, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::intake_manifold_temperature::encode(self.intake_manifold_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::coolant_temperature::encode(self.coolant_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::oil_pressure::encode(self.oil_pressure, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::oil_temperature::encode(self.oil_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::fuel_pressure::encode(self.fuel_pressure, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::fuel_consumption_rate_cm3pm::encode(self.fuel_consumption_rate_cm3pm, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::estimated_consumed_fuel_volume_cm3::encode(self.estimated_consumed_fuel_volume_cm3, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::throttle_position_percent::encode(self.throttle_position_percent, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::ecu_index::encode(self.ecu_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::spark_plug_usage::encode(self.spark_plug_usage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cylinder_status::encode(self.cylinder_status, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int Status_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    typename ::uavcan::StorageType< typename FieldTypes::_void_0 >::Type _void_0 = 0;
    int res = 1;
    res = FieldTypes::state::decode(self.state, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::flags::decode(self.flags, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::_void_0::decode(_void_0, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::engine_load_percent::decode(self.engine_load_percent, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::engine_speed_rpm::decode(self.engine_speed_rpm, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::spark_dwell_time_ms::decode(self.spark_dwell_time_ms, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::atmospheric_pressure_kpa::decode(self.atmospheric_pressure_kpa, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::intake_manifold_pressure_kpa::decode(self.intake_manifold_pressure_kpa, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::intake_manifold_temperature::decode(self.intake_manifold_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::coolant_temperature::decode(self.coolant_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::oil_pressure::decode(self.oil_pressure, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::oil_temperature::decode(self.oil_temperature, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::fuel_pressure::decode(self.fuel_pressure, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::fuel_consumption_rate_cm3pm::decode(self.fuel_consumption_rate_cm3pm, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::estimated_consumed_fuel_volume_cm3::decode(self.estimated_consumed_fuel_volume_cm3, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::throttle_position_percent::decode(self.throttle_position_percent, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::ecu_index::decode(self.ecu_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::spark_plug_usage::decode(self.spark_plug_usage, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::cylinder_status::decode(self.cylinder_status, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature Status_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x5465C0CF37619F32ULL);

    FieldTypes::state::extendDataTypeSignature(signature);
    FieldTypes::flags::extendDataTypeSignature(signature);
    FieldTypes::_void_0::extendDataTypeSignature(signature);
    FieldTypes::engine_load_percent::extendDataTypeSignature(signature);
    FieldTypes::engine_speed_rpm::extendDataTypeSignature(signature);
    FieldTypes::spark_dwell_time_ms::extendDataTypeSignature(signature);
    FieldTypes::atmospheric_pressure_kpa::extendDataTypeSignature(signature);
    FieldTypes::intake_manifold_pressure_kpa::extendDataTypeSignature(signature);
    FieldTypes::intake_manifold_temperature::extendDataTypeSignature(signature);
    FieldTypes::coolant_temperature::extendDataTypeSignature(signature);
    FieldTypes::oil_pressure::extendDataTypeSignature(signature);
    FieldTypes::oil_temperature::extendDataTypeSignature(signature);
    FieldTypes::fuel_pressure::extendDataTypeSignature(signature);
    FieldTypes::fuel_consumption_rate_cm3pm::extendDataTypeSignature(signature);
    FieldTypes::estimated_consumed_fuel_volume_cm3::extendDataTypeSignature(signature);
    FieldTypes::throttle_position_percent::extendDataTypeSignature(signature);
    FieldTypes::ecu_index::extendDataTypeSignature(signature);
    FieldTypes::spark_plug_usage::extendDataTypeSignature(signature);
    FieldTypes::cylinder_status::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::STATE_STOPPED >::Type
    Status_<_tmpl>::STATE_STOPPED = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::STATE_STARTING >::Type
    Status_<_tmpl>::STATE_STARTING = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::STATE_RUNNING >::Type
    Status_<_tmpl>::STATE_RUNNING = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::STATE_FAULT >::Type
    Status_<_tmpl>::STATE_FAULT = 3U; // 3

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_GENERAL_ERROR >::Type
    Status_<_tmpl>::FLAG_GENERAL_ERROR = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_CRANKSHAFT_SENSOR_ERROR_SUPPORTED = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_CRANKSHAFT_SENSOR_ERROR >::Type
    Status_<_tmpl>::FLAG_CRANKSHAFT_SENSOR_ERROR = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_TEMPERATURE_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_TEMPERATURE_SUPPORTED = 8U; // 8

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_TEMPERATURE_BELOW_NOMINAL >::Type
    Status_<_tmpl>::FLAG_TEMPERATURE_BELOW_NOMINAL = 16U; // 16

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_TEMPERATURE_ABOVE_NOMINAL >::Type
    Status_<_tmpl>::FLAG_TEMPERATURE_ABOVE_NOMINAL = 32U; // 32

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_TEMPERATURE_OVERHEATING >::Type
    Status_<_tmpl>::FLAG_TEMPERATURE_OVERHEATING = 64U; // 64

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL >::Type
    Status_<_tmpl>::FLAG_TEMPERATURE_EGT_ABOVE_NOMINAL = 128U; // 128

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_FUEL_PRESSURE_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_FUEL_PRESSURE_SUPPORTED = 256U; // 256

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_FUEL_PRESSURE_BELOW_NOMINAL >::Type
    Status_<_tmpl>::FLAG_FUEL_PRESSURE_BELOW_NOMINAL = 512U; // 512

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_FUEL_PRESSURE_ABOVE_NOMINAL >::Type
    Status_<_tmpl>::FLAG_FUEL_PRESSURE_ABOVE_NOMINAL = 1024U; // 1024

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_DETONATION_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_DETONATION_SUPPORTED = 2048U; // 2048

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_DETONATION_OBSERVED >::Type
    Status_<_tmpl>::FLAG_DETONATION_OBSERVED = 4096U; // 4096

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_MISFIRE_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_MISFIRE_SUPPORTED = 8192U; // 8192

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_MISFIRE_OBSERVED >::Type
    Status_<_tmpl>::FLAG_MISFIRE_OBSERVED = 16384U; // 16384

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_OIL_PRESSURE_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_OIL_PRESSURE_SUPPORTED = 32768U; // 32768

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_OIL_PRESSURE_BELOW_NOMINAL >::Type
    Status_<_tmpl>::FLAG_OIL_PRESSURE_BELOW_NOMINAL = 65536U; // 65536

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_OIL_PRESSURE_ABOVE_NOMINAL >::Type
    Status_<_tmpl>::FLAG_OIL_PRESSURE_ABOVE_NOMINAL = 131072U; // 131072

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_DEBRIS_SUPPORTED >::Type
    Status_<_tmpl>::FLAG_DEBRIS_SUPPORTED = 262144U; // 262144

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::FLAG_DEBRIS_DETECTED >::Type
    Status_<_tmpl>::FLAG_DEBRIS_DETECTED = 524288U; // 524288

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::SPARK_PLUG_SINGLE >::Type
    Status_<_tmpl>::SPARK_PLUG_SINGLE = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::SPARK_PLUG_FIRST_ACTIVE >::Type
    Status_<_tmpl>::SPARK_PLUG_FIRST_ACTIVE = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::SPARK_PLUG_SECOND_ACTIVE >::Type
    Status_<_tmpl>::SPARK_PLUG_SECOND_ACTIVE = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename Status_<_tmpl>::ConstantTypes::SPARK_PLUG_BOTH_ACTIVE >::Type
    Status_<_tmpl>::SPARK_PLUG_BOTH_ACTIVE = 3U; // 3

/*
 * Final typedef
 */
typedef Status_<0> Status;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::uavcan::equipment::ice::reciprocating::Status > _uavcan_gdtr_registrator_Status;

}

} // Namespace reciprocating
} // Namespace ice
} // Namespace equipment
} // Namespace uavcan

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::uavcan::equipment::ice::reciprocating::Status::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status >::stream(Stream& s, ::uavcan::equipment::ice::reciprocating::Status::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "state: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::state >::stream(s, obj.state, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "flags: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::flags >::stream(s, obj.flags, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "engine_load_percent: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::engine_load_percent >::stream(s, obj.engine_load_percent, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "engine_speed_rpm: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::engine_speed_rpm >::stream(s, obj.engine_speed_rpm, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "spark_dwell_time_ms: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::spark_dwell_time_ms >::stream(s, obj.spark_dwell_time_ms, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "atmospheric_pressure_kpa: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::atmospheric_pressure_kpa >::stream(s, obj.atmospheric_pressure_kpa, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "intake_manifold_pressure_kpa: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::intake_manifold_pressure_kpa >::stream(s, obj.intake_manifold_pressure_kpa, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "intake_manifold_temperature: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::intake_manifold_temperature >::stream(s, obj.intake_manifold_temperature, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "coolant_temperature: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::coolant_temperature >::stream(s, obj.coolant_temperature, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "oil_pressure: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::oil_pressure >::stream(s, obj.oil_pressure, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "oil_temperature: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::oil_temperature >::stream(s, obj.oil_temperature, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "fuel_pressure: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::fuel_pressure >::stream(s, obj.fuel_pressure, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "fuel_consumption_rate_cm3pm: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::fuel_consumption_rate_cm3pm >::stream(s, obj.fuel_consumption_rate_cm3pm, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "estimated_consumed_fuel_volume_cm3: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::estimated_consumed_fuel_volume_cm3 >::stream(s, obj.estimated_consumed_fuel_volume_cm3, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "throttle_position_percent: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::throttle_position_percent >::stream(s, obj.throttle_position_percent, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "ecu_index: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::ecu_index >::stream(s, obj.ecu_index, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "spark_plug_usage: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::spark_plug_usage >::stream(s, obj.spark_plug_usage, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "cylinder_status: ";
    YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status::FieldTypes::cylinder_status >::stream(s, obj.cylinder_status, level + 1);
}

}

namespace uavcan
{
namespace equipment
{
namespace ice
{
namespace reciprocating
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::uavcan::equipment::ice::reciprocating::Status::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::uavcan::equipment::ice::reciprocating::Status >::stream(s, obj, 0);
    return s;
}

} // Namespace reciprocating
} // Namespace ice
} // Namespace equipment
} // Namespace uavcan

#endif // UAVCAN_EQUIPMENT_ICE_RECIPROCATING_STATUS_HPP_INCLUDED