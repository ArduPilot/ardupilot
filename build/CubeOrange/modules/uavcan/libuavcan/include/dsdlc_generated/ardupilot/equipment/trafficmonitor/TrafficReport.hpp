/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/jon305/ardupilot/modules/DroneCAN/DSDL/ardupilot/equipment/trafficmonitor/20790.TrafficReport.uavcan
 */

#ifndef ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_HPP_INCLUDED
#define ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

#include <uavcan/Timestamp.hpp>

/******************************* Source text **********************************
# Network-synchronized timestamp, 0 if not available. Note: not necessarily a UTC time.
uavcan.Timestamp timestamp

# icao address
uint32 icao_address

# Time since last communication in seconds
uint16 tslc

# Traffic position in lat-lon-alt. Check alt_type for altitude datum
int32 latitude_deg_1e7
int32 longitude_deg_1e7
float32 alt_m

# Traffic heading in radians.
# Course over ground if heading is unavailable. 0 if neither are available.
float16 heading

# Traffic velocity in m/s
float16[3] velocity

# Traffic squawk code
uint16 squawk

# Traffic callsign
uint8[9] callsign

# Traffic source
uint3 SOURCE_ADSB = 0
uint3 SOURCE_ADSB_UAT = 1
uint3 SOURCE_FLARM = 2
uint3 source

# Traffic type
uint5 TRAFFIC_TYPE_UNKNOWN = 0
uint5 TRAFFIC_TYPE_LIGHT = 1
uint5 TRAFFIC_TYPE_SMALL = 2
uint5 TRAFFIC_TYPE_LARGE = 3
uint5 TRAFFIC_TYPE_HIGH_VORTEX_LARGE = 4
uint5 TRAFFIC_TYPE_HEAVY = 5
uint5 TRAFFIC_TYPE_HIGHLY_MANUV = 6
uint5 TRAFFIC_TYPE_ROTOCRAFT = 7
uint5 TRAFFIC_TYPE_GLIDER = 9
uint5 TRAFFIC_TYPE_LIGHTER_THAN_AIR = 10
uint5 TRAFFIC_TYPE_PARACHUTE = 11
uint5 TRAFFIC_TYPE_ULTRA_LIGHT = 12
uint5 TRAFFIC_TYPE_UAV = 14
uint5 TRAFFIC_TYPE_SPACE = 15
uint5 TRAFFIC_TYPE_EMERGENCY_SURFACE = 17
uint5 TRAFFIC_TYPE_SERVICE_SURFACE = 18
uint5 TRAFFIC_TYPE_POINT_OBSTACLE = 19
uint5 traffic_type

# Altitude type
uint7 ALT_TYPE_ALT_UNKNOWN = 0
uint7 ALT_TYPE_PRESSURE_AMSL = 1
uint7 ALT_TYPE_WGS84 = 2
uint7 alt_type

# Validity flags
bool lat_lon_valid
bool heading_valid
bool velocity_valid
bool callsign_valid
bool ident_valid
bool simulated_report
bool vertical_velocity_valid
bool baro_valid
******************************************************************************/

/********************* DSDL signature source definition ***********************
ardupilot.equipment.trafficmonitor.TrafficReport
uavcan.Timestamp timestamp
saturated uint32 icao_address
saturated uint16 tslc
saturated int32 latitude_deg_1e7
saturated int32 longitude_deg_1e7
saturated float32 alt_m
saturated float16 heading
saturated float16[3] velocity
saturated uint16 squawk
saturated uint8[9] callsign
saturated uint3 source
saturated uint5 traffic_type
saturated uint7 alt_type
saturated bool lat_lon_valid
saturated bool heading_valid
saturated bool velocity_valid
saturated bool callsign_valid
saturated bool ident_valid
saturated bool simulated_report
saturated bool vertical_velocity_valid
saturated bool baro_valid
******************************************************************************/

#undef timestamp
#undef icao_address
#undef tslc
#undef latitude_deg_1e7
#undef longitude_deg_1e7
#undef alt_m
#undef heading
#undef velocity
#undef squawk
#undef callsign
#undef source
#undef traffic_type
#undef alt_type
#undef lat_lon_valid
#undef heading_valid
#undef velocity_valid
#undef callsign_valid
#undef ident_valid
#undef simulated_report
#undef vertical_velocity_valid
#undef baro_valid
#undef SOURCE_ADSB
#undef SOURCE_ADSB_UAT
#undef SOURCE_FLARM
#undef TRAFFIC_TYPE_UNKNOWN
#undef TRAFFIC_TYPE_LIGHT
#undef TRAFFIC_TYPE_SMALL
#undef TRAFFIC_TYPE_LARGE
#undef TRAFFIC_TYPE_HIGH_VORTEX_LARGE
#undef TRAFFIC_TYPE_HEAVY
#undef TRAFFIC_TYPE_HIGHLY_MANUV
#undef TRAFFIC_TYPE_ROTOCRAFT
#undef TRAFFIC_TYPE_GLIDER
#undef TRAFFIC_TYPE_LIGHTER_THAN_AIR
#undef TRAFFIC_TYPE_PARACHUTE
#undef TRAFFIC_TYPE_ULTRA_LIGHT
#undef TRAFFIC_TYPE_UAV
#undef TRAFFIC_TYPE_SPACE
#undef TRAFFIC_TYPE_EMERGENCY_SURFACE
#undef TRAFFIC_TYPE_SERVICE_SURFACE
#undef TRAFFIC_TYPE_POINT_OBSTACLE
#undef ALT_TYPE_ALT_UNKNOWN
#undef ALT_TYPE_PRESSURE_AMSL
#undef ALT_TYPE_WGS84

namespace ardupilot
{
namespace equipment
{
namespace trafficmonitor
{

template <int _tmpl>
struct UAVCAN_EXPORT TrafficReport_
{
    typedef const TrafficReport_<_tmpl>& ParameterType;
    typedef TrafficReport_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SOURCE_ADSB;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SOURCE_ADSB_UAT;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > SOURCE_FLARM;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_UNKNOWN;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_LIGHT;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_SMALL;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_LARGE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_HIGH_VORTEX_LARGE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_HEAVY;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_HIGHLY_MANUV;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_ROTOCRAFT;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_GLIDER;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_LIGHTER_THAN_AIR;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_PARACHUTE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_ULTRA_LIGHT;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_UAV;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_SPACE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_EMERGENCY_SURFACE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_SERVICE_SURFACE;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > TRAFFIC_TYPE_POINT_OBSTACLE;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ALT_TYPE_ALT_UNKNOWN;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ALT_TYPE_PRESSURE_AMSL;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ALT_TYPE_WGS84;
    };

    struct FieldTypes
    {
        typedef ::uavcan::Timestamp timestamp;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > icao_address;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > tslc;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > latitude_deg_1e7;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessSigned, ::uavcan::CastModeSaturate > longitude_deg_1e7;
        typedef ::uavcan::FloatSpec< 32, ::uavcan::CastModeSaturate > alt_m;
        typedef ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate > heading;
        typedef ::uavcan::Array< ::uavcan::FloatSpec< 16, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeStatic, 3 > velocity;
        typedef ::uavcan::IntegerSpec< 16, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > squawk;
        typedef ::uavcan::Array< ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate >, ::uavcan::ArrayModeStatic, 9 > callsign;
        typedef ::uavcan::IntegerSpec< 3, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > source;
        typedef ::uavcan::IntegerSpec< 5, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > traffic_type;
        typedef ::uavcan::IntegerSpec< 7, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > alt_type;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > lat_lon_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > heading_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > velocity_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > callsign_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > ident_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > simulated_report;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > vertical_velocity_valid;
        typedef ::uavcan::IntegerSpec< 1, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > baro_valid;
    };

    enum
    {
        MinBitLen
            = FieldTypes::timestamp::MinBitLen
            + FieldTypes::icao_address::MinBitLen
            + FieldTypes::tslc::MinBitLen
            + FieldTypes::latitude_deg_1e7::MinBitLen
            + FieldTypes::longitude_deg_1e7::MinBitLen
            + FieldTypes::alt_m::MinBitLen
            + FieldTypes::heading::MinBitLen
            + FieldTypes::velocity::MinBitLen
            + FieldTypes::squawk::MinBitLen
            + FieldTypes::callsign::MinBitLen
            + FieldTypes::source::MinBitLen
            + FieldTypes::traffic_type::MinBitLen
            + FieldTypes::alt_type::MinBitLen
            + FieldTypes::lat_lon_valid::MinBitLen
            + FieldTypes::heading_valid::MinBitLen
            + FieldTypes::velocity_valid::MinBitLen
            + FieldTypes::callsign_valid::MinBitLen
            + FieldTypes::ident_valid::MinBitLen
            + FieldTypes::simulated_report::MinBitLen
            + FieldTypes::vertical_velocity_valid::MinBitLen
            + FieldTypes::baro_valid::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::timestamp::MaxBitLen
            + FieldTypes::icao_address::MaxBitLen
            + FieldTypes::tslc::MaxBitLen
            + FieldTypes::latitude_deg_1e7::MaxBitLen
            + FieldTypes::longitude_deg_1e7::MaxBitLen
            + FieldTypes::alt_m::MaxBitLen
            + FieldTypes::heading::MaxBitLen
            + FieldTypes::velocity::MaxBitLen
            + FieldTypes::squawk::MaxBitLen
            + FieldTypes::callsign::MaxBitLen
            + FieldTypes::source::MaxBitLen
            + FieldTypes::traffic_type::MaxBitLen
            + FieldTypes::alt_type::MaxBitLen
            + FieldTypes::lat_lon_valid::MaxBitLen
            + FieldTypes::heading_valid::MaxBitLen
            + FieldTypes::velocity_valid::MaxBitLen
            + FieldTypes::callsign_valid::MaxBitLen
            + FieldTypes::ident_valid::MaxBitLen
            + FieldTypes::simulated_report::MaxBitLen
            + FieldTypes::vertical_velocity_valid::MaxBitLen
            + FieldTypes::baro_valid::MaxBitLen
    };

    // Constants
    static const typename ::uavcan::StorageType< typename ConstantTypes::SOURCE_ADSB >::Type SOURCE_ADSB; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::SOURCE_ADSB_UAT >::Type SOURCE_ADSB_UAT; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::SOURCE_FLARM >::Type SOURCE_FLARM; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_UNKNOWN >::Type TRAFFIC_TYPE_UNKNOWN; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_LIGHT >::Type TRAFFIC_TYPE_LIGHT; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_SMALL >::Type TRAFFIC_TYPE_SMALL; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_LARGE >::Type TRAFFIC_TYPE_LARGE; // 3
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_HIGH_VORTEX_LARGE >::Type TRAFFIC_TYPE_HIGH_VORTEX_LARGE; // 4
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_HEAVY >::Type TRAFFIC_TYPE_HEAVY; // 5
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_HIGHLY_MANUV >::Type TRAFFIC_TYPE_HIGHLY_MANUV; // 6
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_ROTOCRAFT >::Type TRAFFIC_TYPE_ROTOCRAFT; // 7
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_GLIDER >::Type TRAFFIC_TYPE_GLIDER; // 9
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_LIGHTER_THAN_AIR >::Type TRAFFIC_TYPE_LIGHTER_THAN_AIR; // 10
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_PARACHUTE >::Type TRAFFIC_TYPE_PARACHUTE; // 11
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_ULTRA_LIGHT >::Type TRAFFIC_TYPE_ULTRA_LIGHT; // 12
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_UAV >::Type TRAFFIC_TYPE_UAV; // 14
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_SPACE >::Type TRAFFIC_TYPE_SPACE; // 15
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_EMERGENCY_SURFACE >::Type TRAFFIC_TYPE_EMERGENCY_SURFACE; // 17
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_SERVICE_SURFACE >::Type TRAFFIC_TYPE_SERVICE_SURFACE; // 18
    static const typename ::uavcan::StorageType< typename ConstantTypes::TRAFFIC_TYPE_POINT_OBSTACLE >::Type TRAFFIC_TYPE_POINT_OBSTACLE; // 19
    static const typename ::uavcan::StorageType< typename ConstantTypes::ALT_TYPE_ALT_UNKNOWN >::Type ALT_TYPE_ALT_UNKNOWN; // 0
    static const typename ::uavcan::StorageType< typename ConstantTypes::ALT_TYPE_PRESSURE_AMSL >::Type ALT_TYPE_PRESSURE_AMSL; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::ALT_TYPE_WGS84 >::Type ALT_TYPE_WGS84; // 2

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::timestamp >::Type timestamp;
    typename ::uavcan::StorageType< typename FieldTypes::icao_address >::Type icao_address;
    typename ::uavcan::StorageType< typename FieldTypes::tslc >::Type tslc;
    typename ::uavcan::StorageType< typename FieldTypes::latitude_deg_1e7 >::Type latitude_deg_1e7;
    typename ::uavcan::StorageType< typename FieldTypes::longitude_deg_1e7 >::Type longitude_deg_1e7;
    typename ::uavcan::StorageType< typename FieldTypes::alt_m >::Type alt_m;
    typename ::uavcan::StorageType< typename FieldTypes::heading >::Type heading;
    typename ::uavcan::StorageType< typename FieldTypes::velocity >::Type velocity;
    typename ::uavcan::StorageType< typename FieldTypes::squawk >::Type squawk;
    typename ::uavcan::StorageType< typename FieldTypes::callsign >::Type callsign;
    typename ::uavcan::StorageType< typename FieldTypes::source >::Type source;
    typename ::uavcan::StorageType< typename FieldTypes::traffic_type >::Type traffic_type;
    typename ::uavcan::StorageType< typename FieldTypes::alt_type >::Type alt_type;
    typename ::uavcan::StorageType< typename FieldTypes::lat_lon_valid >::Type lat_lon_valid;
    typename ::uavcan::StorageType< typename FieldTypes::heading_valid >::Type heading_valid;
    typename ::uavcan::StorageType< typename FieldTypes::velocity_valid >::Type velocity_valid;
    typename ::uavcan::StorageType< typename FieldTypes::callsign_valid >::Type callsign_valid;
    typename ::uavcan::StorageType< typename FieldTypes::ident_valid >::Type ident_valid;
    typename ::uavcan::StorageType< typename FieldTypes::simulated_report >::Type simulated_report;
    typename ::uavcan::StorageType< typename FieldTypes::vertical_velocity_valid >::Type vertical_velocity_valid;
    typename ::uavcan::StorageType< typename FieldTypes::baro_valid >::Type baro_valid;

    TrafficReport_()
        : timestamp()
        , icao_address()
        , tslc()
        , latitude_deg_1e7()
        , longitude_deg_1e7()
        , alt_m()
        , heading()
        , velocity()
        , squawk()
        , callsign()
        , source()
        , traffic_type()
        , alt_type()
        , lat_lon_valid()
        , heading_valid()
        , velocity_valid()
        , callsign_valid()
        , ident_valid()
        , simulated_report()
        , vertical_velocity_valid()
        , baro_valid()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<375 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 20790 };

    static const char* getDataTypeFullName()
    {
        return "ardupilot.equipment.trafficmonitor.TrafficReport";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool TrafficReport_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        timestamp == rhs.timestamp &&
        icao_address == rhs.icao_address &&
        tslc == rhs.tslc &&
        latitude_deg_1e7 == rhs.latitude_deg_1e7 &&
        longitude_deg_1e7 == rhs.longitude_deg_1e7 &&
        alt_m == rhs.alt_m &&
        heading == rhs.heading &&
        velocity == rhs.velocity &&
        squawk == rhs.squawk &&
        callsign == rhs.callsign &&
        source == rhs.source &&
        traffic_type == rhs.traffic_type &&
        alt_type == rhs.alt_type &&
        lat_lon_valid == rhs.lat_lon_valid &&
        heading_valid == rhs.heading_valid &&
        velocity_valid == rhs.velocity_valid &&
        callsign_valid == rhs.callsign_valid &&
        ident_valid == rhs.ident_valid &&
        simulated_report == rhs.simulated_report &&
        vertical_velocity_valid == rhs.vertical_velocity_valid &&
        baro_valid == rhs.baro_valid;
}

template <int _tmpl>
bool TrafficReport_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(timestamp, rhs.timestamp) &&
        ::uavcan::areClose(icao_address, rhs.icao_address) &&
        ::uavcan::areClose(tslc, rhs.tslc) &&
        ::uavcan::areClose(latitude_deg_1e7, rhs.latitude_deg_1e7) &&
        ::uavcan::areClose(longitude_deg_1e7, rhs.longitude_deg_1e7) &&
        ::uavcan::areClose(alt_m, rhs.alt_m) &&
        ::uavcan::areClose(heading, rhs.heading) &&
        ::uavcan::areClose(velocity, rhs.velocity) &&
        ::uavcan::areClose(squawk, rhs.squawk) &&
        ::uavcan::areClose(callsign, rhs.callsign) &&
        ::uavcan::areClose(source, rhs.source) &&
        ::uavcan::areClose(traffic_type, rhs.traffic_type) &&
        ::uavcan::areClose(alt_type, rhs.alt_type) &&
        ::uavcan::areClose(lat_lon_valid, rhs.lat_lon_valid) &&
        ::uavcan::areClose(heading_valid, rhs.heading_valid) &&
        ::uavcan::areClose(velocity_valid, rhs.velocity_valid) &&
        ::uavcan::areClose(callsign_valid, rhs.callsign_valid) &&
        ::uavcan::areClose(ident_valid, rhs.ident_valid) &&
        ::uavcan::areClose(simulated_report, rhs.simulated_report) &&
        ::uavcan::areClose(vertical_velocity_valid, rhs.vertical_velocity_valid) &&
        ::uavcan::areClose(baro_valid, rhs.baro_valid);
}

template <int _tmpl>
int TrafficReport_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::timestamp::encode(self.timestamp, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::icao_address::encode(self.icao_address, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::tslc::encode(self.tslc, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::latitude_deg_1e7::encode(self.latitude_deg_1e7, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::longitude_deg_1e7::encode(self.longitude_deg_1e7, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::alt_m::encode(self.alt_m, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::heading::encode(self.heading, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity::encode(self.velocity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::squawk::encode(self.squawk, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::callsign::encode(self.callsign, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::source::encode(self.source, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::traffic_type::encode(self.traffic_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::alt_type::encode(self.alt_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::lat_lon_valid::encode(self.lat_lon_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::heading_valid::encode(self.heading_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_valid::encode(self.velocity_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::callsign_valid::encode(self.callsign_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::ident_valid::encode(self.ident_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::simulated_report::encode(self.simulated_report, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::vertical_velocity_valid::encode(self.vertical_velocity_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::baro_valid::encode(self.baro_valid, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int TrafficReport_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::timestamp::decode(self.timestamp, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::icao_address::decode(self.icao_address, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::tslc::decode(self.tslc, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::latitude_deg_1e7::decode(self.latitude_deg_1e7, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::longitude_deg_1e7::decode(self.longitude_deg_1e7, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::alt_m::decode(self.alt_m, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::heading::decode(self.heading, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity::decode(self.velocity, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::squawk::decode(self.squawk, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::callsign::decode(self.callsign, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::source::decode(self.source, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::traffic_type::decode(self.traffic_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::alt_type::decode(self.alt_type, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::lat_lon_valid::decode(self.lat_lon_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::heading_valid::decode(self.heading_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::velocity_valid::decode(self.velocity_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::callsign_valid::decode(self.callsign_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::ident_valid::decode(self.ident_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::simulated_report::decode(self.simulated_report, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::vertical_velocity_valid::decode(self.vertical_velocity_valid, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::baro_valid::decode(self.baro_valid, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature TrafficReport_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0xC8D1484864BB8949ULL);

    FieldTypes::timestamp::extendDataTypeSignature(signature);
    FieldTypes::icao_address::extendDataTypeSignature(signature);
    FieldTypes::tslc::extendDataTypeSignature(signature);
    FieldTypes::latitude_deg_1e7::extendDataTypeSignature(signature);
    FieldTypes::longitude_deg_1e7::extendDataTypeSignature(signature);
    FieldTypes::alt_m::extendDataTypeSignature(signature);
    FieldTypes::heading::extendDataTypeSignature(signature);
    FieldTypes::velocity::extendDataTypeSignature(signature);
    FieldTypes::squawk::extendDataTypeSignature(signature);
    FieldTypes::callsign::extendDataTypeSignature(signature);
    FieldTypes::source::extendDataTypeSignature(signature);
    FieldTypes::traffic_type::extendDataTypeSignature(signature);
    FieldTypes::alt_type::extendDataTypeSignature(signature);
    FieldTypes::lat_lon_valid::extendDataTypeSignature(signature);
    FieldTypes::heading_valid::extendDataTypeSignature(signature);
    FieldTypes::velocity_valid::extendDataTypeSignature(signature);
    FieldTypes::callsign_valid::extendDataTypeSignature(signature);
    FieldTypes::ident_valid::extendDataTypeSignature(signature);
    FieldTypes::simulated_report::extendDataTypeSignature(signature);
    FieldTypes::vertical_velocity_valid::extendDataTypeSignature(signature);
    FieldTypes::baro_valid::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::SOURCE_ADSB >::Type
    TrafficReport_<_tmpl>::SOURCE_ADSB = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::SOURCE_ADSB_UAT >::Type
    TrafficReport_<_tmpl>::SOURCE_ADSB_UAT = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::SOURCE_FLARM >::Type
    TrafficReport_<_tmpl>::SOURCE_FLARM = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_UNKNOWN >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_UNKNOWN = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_LIGHT >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_LIGHT = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_SMALL >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_SMALL = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_LARGE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_LARGE = 3U; // 3

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_HIGH_VORTEX_LARGE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_HIGH_VORTEX_LARGE = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_HEAVY >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_HEAVY = 5U; // 5

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_HIGHLY_MANUV >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_HIGHLY_MANUV = 6U; // 6

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_ROTOCRAFT >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_ROTOCRAFT = 7U; // 7

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_GLIDER >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_GLIDER = 9U; // 9

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_LIGHTER_THAN_AIR >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_LIGHTER_THAN_AIR = 10U; // 10

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_PARACHUTE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_PARACHUTE = 11U; // 11

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_ULTRA_LIGHT >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_ULTRA_LIGHT = 12U; // 12

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_UAV >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_UAV = 14U; // 14

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_SPACE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_SPACE = 15U; // 15

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_EMERGENCY_SURFACE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_EMERGENCY_SURFACE = 17U; // 17

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_SERVICE_SURFACE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_SERVICE_SURFACE = 18U; // 18

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::TRAFFIC_TYPE_POINT_OBSTACLE >::Type
    TrafficReport_<_tmpl>::TRAFFIC_TYPE_POINT_OBSTACLE = 19U; // 19

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::ALT_TYPE_ALT_UNKNOWN >::Type
    TrafficReport_<_tmpl>::ALT_TYPE_ALT_UNKNOWN = 0U; // 0

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::ALT_TYPE_PRESSURE_AMSL >::Type
    TrafficReport_<_tmpl>::ALT_TYPE_PRESSURE_AMSL = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename TrafficReport_<_tmpl>::ConstantTypes::ALT_TYPE_WGS84 >::Type
    TrafficReport_<_tmpl>::ALT_TYPE_WGS84 = 2U; // 2

/*
 * Final typedef
 */
typedef TrafficReport_<0> TrafficReport;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::ardupilot::equipment::trafficmonitor::TrafficReport > _uavcan_gdtr_registrator_TrafficReport;

}

} // Namespace trafficmonitor
} // Namespace equipment
} // Namespace ardupilot

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::ardupilot::equipment::trafficmonitor::TrafficReport::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport >::stream(Stream& s, ::ardupilot::equipment::trafficmonitor::TrafficReport::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "timestamp: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::timestamp >::stream(s, obj.timestamp, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "icao_address: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::icao_address >::stream(s, obj.icao_address, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "tslc: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::tslc >::stream(s, obj.tslc, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "latitude_deg_1e7: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::latitude_deg_1e7 >::stream(s, obj.latitude_deg_1e7, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "longitude_deg_1e7: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::longitude_deg_1e7 >::stream(s, obj.longitude_deg_1e7, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "alt_m: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::alt_m >::stream(s, obj.alt_m, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "heading: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::heading >::stream(s, obj.heading, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "velocity: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::velocity >::stream(s, obj.velocity, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "squawk: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::squawk >::stream(s, obj.squawk, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "callsign: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::callsign >::stream(s, obj.callsign, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "source: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::source >::stream(s, obj.source, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "traffic_type: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::traffic_type >::stream(s, obj.traffic_type, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "alt_type: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::alt_type >::stream(s, obj.alt_type, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "lat_lon_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::lat_lon_valid >::stream(s, obj.lat_lon_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "heading_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::heading_valid >::stream(s, obj.heading_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "velocity_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::velocity_valid >::stream(s, obj.velocity_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "callsign_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::callsign_valid >::stream(s, obj.callsign_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "ident_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::ident_valid >::stream(s, obj.ident_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "simulated_report: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::simulated_report >::stream(s, obj.simulated_report, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "vertical_velocity_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::vertical_velocity_valid >::stream(s, obj.vertical_velocity_valid, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "baro_valid: ";
    YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport::FieldTypes::baro_valid >::stream(s, obj.baro_valid, level + 1);
}

}

namespace ardupilot
{
namespace equipment
{
namespace trafficmonitor
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::ardupilot::equipment::trafficmonitor::TrafficReport::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::ardupilot::equipment::trafficmonitor::TrafficReport >::stream(s, obj, 0);
    return s;
}

} // Namespace trafficmonitor
} // Namespace equipment
} // Namespace ardupilot

#endif // ARDUPILOT_EQUIPMENT_TRAFFICMONITOR_TRAFFICREPORT_HPP_INCLUDED